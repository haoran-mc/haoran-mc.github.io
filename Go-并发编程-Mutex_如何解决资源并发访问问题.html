<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-05-10 Tue 20:56 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Mutex 如何解决资源并发访问问题</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">Mutex 如何解决资源并发访问问题</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org55f8c4c">引言</a></li>
<li><a href="#orga1d1d96">互斥锁的实现机制</a></li>
<li><a href="#org0b4d18c">Locker 接口</a></li>
<li><a href="#orgcf90da4">Lock 与 Unlock</a></li>
<li><a href="#org80d181b">不使用锁可能会出现什么状况</a></li>
<li><a href="#org1986838">race detector</a></li>
<li><a href="#orgac5c135">使用 Mutex 加锁保护</a></li>
<li><a href="#orgf6bb703">Mutex 的其他用法</a>
<ul>
<li><a href="#org32547b4">Mutex 嵌入到 struct 中使用</a></li>
<li><a href="#orgab3556b">Mutex 作为结构体的匿名字段</a></li>
<li><a href="#orged02acd">封装成方法</a></li>
</ul>
</li>
<li><a href="#org7bf821c">总结</a></li>
</ul>
</div>
</div>

<div id="outline-container-org55f8c4c" class="outline-2">
<h2 id="org55f8c4c">引言</h2>
<div class="outline-text-2" id="text-org55f8c4c">
<p>
直接从解决并发访问这个棘手问题入手。<br>
</p>

<p>
说起并发访问问题，真是太常见了，比如 <span class="underline">多个 goroutine 并发更新同一个资源</span> ，像计数器；同时更新用户的账户信息；秒杀系统；往同一个 buffer 中并发写入数据等等。如果没有互斥控制，就会出现一些异常情况，比如计数器的计数不准确、用户的账户可能出现透支、秒杀系统出现超卖、buffer 中的数据混乱，等等，后果都很严重。<br>
</p>

<p>
这些问题怎么解决呢？对，用互斥锁，那在 Go 语言里，就是 <code>Mutex</code> 。<br>
</p>

<p>
这里，我们先详细了解互斥锁的实现机制，以及 Go 标准库的互斥锁 Mutex 的基本使用方法。在后面会讲解 Mutex 的具体实现原理、易错场景和一些拓展用法。<br>
</p>

<p>
好了，我们先来看看互斥锁的实现机制。<br>
</p>
</div>
</div>
<div id="outline-container-orga1d1d96" class="outline-2">
<h2 id="orga1d1d96">互斥锁的实现机制</h2>
<div class="outline-text-2" id="text-orga1d1d96">
<p>
互斥锁是并发控制的一个基本手段，是为了避免竞争而建立的一种并发控制机制。在学习它的具体实现原理前，我们要先搞懂一个概念，就是 <b>临界区</b> 。<br>
</p>

<p>
<span class="underline">在并发编程中，如果程序中的一部分会被并发访问或修改，那么，为了避免并发访问导致的意想不到的结果，这部分程序需要被保护起来，这部分被保护起来的程序，就叫做临界区。</span><br>
</p>

<p>
可以说，临界区就是一个被共享的资源，或者说是一个整体的一组共享资源，比如对数据库的访问、对某一个共享数据结构的操作、对一个 I/O 设备的使用、对一个连接池中的连接的调用，等等。<br>
</p>

<p>
如果很多线程同步访问临界区，就会造成访问或操作错误，这当然不是我们希望看到的结果。所以，我们可以 <b>使用互斥锁，限定临界区只能同时由一个线程持有</b> 。<br>
</p>

<p>
当临界区由一个线程持有的时候，其它线程如果想进入这个临界区，就会返回失败，或者是等待。直到持有的线程退出临界区，这些等待线程中的某一个才有机会接着持有这个临界区。<br>
</p>

<div class="div-center">
	<img src="./images/Go并发编程-互斥锁、临界区.webp" width="720px" />
</div>

<p>
互斥锁就很好地解决了资源竞争问题，有人也把互斥锁叫做排它锁。那在 Go 标准库中，它提供了 Mutex 来实现互斥锁这个功能。<br>
</p>

<p>
根据 2019 年第一篇全面分析 Go 并发 Bug 的论文 <a href="https://songlh.github.io/paper/go-study.pdf">Understanding Real-World Concurrency Bugs in Go</a> ， <b>Mutex 是使用最广泛的同步原语</b> （Synchronization primitives，有人也叫做 <b>并发原语</b> 。我们在这个课程中根据英文直译优先用同步原语，但是并发原语的指代范围更大，还可以包括任务编排的类型，所以后面我们讲 Channel 或者扩展类型时也会用并发原语）。关于同步原语，并没有一个严格的定义，你可以把它看作解决并发问题的一个基础的数据结构。<br>
</p>

<p>
同步原语的适用场景：<br>
</p>

<ul class="org-ul">
<li><b>共享资源</b> ，并发地读写共享资源，会出现数据竞争（data race）的问题，所以需要 <code>Mutex、RWMutex</code> 这样的并发原语来保护。<br></li>
<li><b>任务编排</b> ，需要 goroutine 按照一定的规律执行，而 goroutine 之间有相互等待或者依赖的顺序关系，我们常常使用 <code>WaitGroup</code> 或者 <code>Channel</code> 来实现。<br></li>
<li><b>消息传递</b> ，信息交流以及不同的 goroutine 之间的线程安全的数据交流，常常使用 <code>Channel</code> 来实现。<br></li>
</ul>

<p>
先介绍 <code>Mutex</code> ，可以怎么使用 <code>Mutex</code> ？<br>
</p>
</div>
</div>
<div id="outline-container-org0b4d18c" class="outline-2">
<h2 id="org0b4d18c">Locker 接口</h2>
<div class="outline-text-2" id="text-org0b4d18c">
<p>
在正式看 Mutex 用法之前呢，我想先给你交代一件事：Locker 接口。<br>
在 Go 的标准库中， package <code>sync</code> 提供了锁相关的一系列同步原语，这个 package 还定义了一个 <code>Locker</code> 的接口， <code>Mutex</code> 就实现了这个接口。<br>
</p>

<p>
<code>Locker</code> 的接口定义了锁同步原语的方法集：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Locker</span> <span style="color: #268bd2; font-weight: bold;">interface</span> {
    <span style="color: #d75fd7; font-weight: bold;">Lock</span>()
    <span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
}
</pre>
</div>

<p>
可以看到，Go 定义的锁接口的方法集很简单，就是请求锁（Lock）和释放锁（Unlock）这两个方法，秉承了 Go 语言一贯的简洁风格。<br>
</p>

<p>
但是，这个接口在实际项目应用得不多，因为我们一般会直接使用具体的同步原语，而不是通过接口。<br>
</p>

<p>
我们这一讲介绍的 <code>Mutex</code> 以及后面会介绍的读写锁 <code>RWMutex</code> 都实现了 <code>Locker</code> 接口，所以首先我把这个接口介绍了，让你做到心中有数。<br>
</p>
</div>
</div>
<div id="outline-container-orgcf90da4" class="outline-2">
<h2 id="orgcf90da4">Lock 与 Unlock</h2>
<div class="outline-text-2" id="text-orgcf90da4">
<p>
下面我们直接看 <code>Mutex</code> 。<br>
</p>

<p>
简单来说， <b>互斥锁 Mutex 就提供两个方法 Lock 和 Unlock：进入临界区之前调用 Lock 方法，退出临界区的时候调用 Unlock 方法</b> ：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span>(<span style="color: #8787d7;">m</span> *<span style="color: #df005f; font-weight: bold;">Mutex</span>)<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
<span style="color: #268bd2; font-weight: bold;">func</span>(<span style="color: #8787d7;">m</span> *<span style="color: #df005f; font-weight: bold;">Mutex</span>)<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
</pre>
</div>

<p>
当一个 goroutine 通过调用 <code>Lock</code> 方法获得了这个锁的拥有权后， 其它请求锁的 goroutine 就会阻塞在 <code>Lock</code> 方法的调用上，直到锁被释放并且自己获取到了这个锁的拥有权。<br>
</p>
</div>
</div>
<div id="outline-container-org80d181b" class="outline-2">
<h2 id="org80d181b">不使用锁可能会出现什么状况</h2>
<div class="outline-text-2" id="text-org80d181b">
<p>
看到这儿，你可能会问，为啥一定要加锁呢？别急，我带你来看一个并发访问场景中不使用锁的例子，看看实现起来会出现什么状况。<br>
</p>

<p>
在这个例子中，我们创建了 10 个 goroutine，同时不断地对一个变量（count）进行加 1 操作，每个 goroutine 负责执行 10 万次的加 1 操作，我们期望的最后计数的结果是 10 * 100000 = 1000000 (一百万)。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">import</span> (
    <span style="color: #2aa198;">"fmt"</span>
    <span style="color: #2aa198;">"sync"</span>
)

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">count</span> = 0
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20351;&#29992; WaitGroup &#31561;&#24453; 10 &#20010; goroutine &#23436;&#25104;</span>
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">wg</span> <span style="color: #df005f; font-weight: bold;">sync.WaitGroup</span>
    wg.<span style="color: #d75fd7; font-weight: bold;">Add</span>(10)
    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := 0; i &lt; 10; i++ {
        <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
            <span style="color: #268bd2; font-weight: bold;">defer</span> wg.<span style="color: #d75fd7; font-weight: bold;">Done</span>()
            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#23545;&#21464;&#37327; count &#25191;&#34892; 10 &#27425;&#21152; 1</span>
            <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">j</span> := 0; j &lt; 100000; j++ {
                count++
            }
        }()
    }
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#31561;&#24453; 10 &#20010; goroutine &#23436;&#25104;</span>
    wg.<span style="color: #d75fd7; font-weight: bold;">Wait</span>()
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(count)
}
</pre>
</div>

<p>
在这段代码中，我们使用 <code>sync.WaitGroup</code> 来等待所有的 goroutine 执行完毕后，再输出最终的结果。 <code>sync.WaitGroup</code> 这个同步原语我会在后面的课程中具体介绍，现在你只需要知道，我们使用它来控制等待一组 goroutine 全部做完任务。<br>
</p>

<p>
但是，每次运行，你都可能得到不同的结果，基本上不会得到理想中的一百万的结果。<br>
</p>

<p>
这是为什么呢？<br>
</p>

<p>
其实， <span class="underline">这是因为， <code>count++</code> 不是一个原子操作</span> ，它至少包含几个步骤，比如读取变量 <code>count</code> 的当前值，对这个值加 1，把结果再保存到 <code>count</code> 中。因为不是原子操作，就可能有并发的问题。<br>
</p>

<p>
比如，10 个 goroutine 同时读取到 <code>count</code> 的值为 9527，接着各自按照自己的逻辑加 1，值变成了 9528，然后把这个结果再写回到 <code>count</code> 变量。但是，实际上，此时我们增加的总数应该是 10 才对，这里却只增加了 1，好多计数都被“吞”掉了。这是并发访问共享数据的常见错误。<br>
</p>

<div class="org-src-container">
<pre class="src src-assembly">// count++ 操作的汇编代码
MOVQ    "".count(SB), AX
LEAQ    1(AX), CX
MOVQ    CX, "".count(SB)	
</pre>
</div>

<p>
这个问题，有经验的开发人员还是比较容易发现的，但是，很多时候，并发问题隐藏得非常深，即使是有经验的人，也不太容易发现或者 Debug 出来。<br>
</p>
</div>
</div>
<div id="outline-container-org1986838" class="outline-2">
<h2 id="org1986838">race detector</h2>
<div class="outline-text-2" id="text-org1986838">
<p>
针对这个问题，Go 提供了一个检测并发访问共享资源是否有问题的工具：<a href="https://blog.golang.org/race-detector">race detector</a> ，它可以帮助我们自动发现程序有没有 data race 的问题。<br>
</p>

<p>
Go race detector 是基于 Google 的 C/C++ <a href="https://github.com/google/sanitizers">sanitizers</a>  技术实现的，编译器通过探测所有的内存访问，加入代码能监视对这些内存地址的访问（读还是写）。在代码运行的时候，race detector 就能监控到对共享变量的非同步访问，出现 race 的时候，就会打印出警告信息。<br>
</p>

<p>
这个技术在 Google 内部帮了大忙，探测出了 Chromium 等代码的大量并发问题。Go 1.1 中就引入了这种技术，并且一下子就发现了标准库中的 42 个并发问题。现在，race detector 已经成了 Go 持续集成过程中的一部分。<br>
</p>

<p>
我们来看看这个工具怎么用。<br>
</p>

<p>
在编译（compile）、测试（test）或者运行（run）Go 代码的时候，加上 <b>race</b> 参数，就有可能发现并发问题。比如在上面的例子中，我们可以加上 race 参数运行，检测一下是不是有并发问题。如果你 <code>go run -race counter.go</code> ，就会输出警告信息。<br>
</p>

<div class="div-center">
	<img src="./images/Go-并发编程-race.png" />
</div>

<p>
这个警告不但会告诉你有并发问题，而且还会告诉你哪个 goroutine 在哪一行对哪个变量有写操作，同时，哪个 goroutine 在哪一行对哪个变量有读操作，就是这些并发的读写访问，引起了 data race。<br>
</p>

<p>
例子中的 goroutine 7 对内存地址 0x00c420014098 有读的操作（counter.go 文件第 16 行），同时，goroutine 6 对内存地址 0x00c420014098 有写的操作（counter.go 文件第 16 行）。而且还有可能有多个 goroutine 在同时进行读写，所以警告信息可能会很长。<br>
</p>

<p>
虽然这个工具使用起来很方便，但是，因为它的实现方式，只能通过真正对实际地址进行读写访问的时候才能探测，所以它并不能在编译的时候发现 data race 的问题。而且，在运行的时候，只有在触发了 data race 之后，才能检测到，如果碰巧没有触发（比如一个 data race 问题只能在 2 月 14 号零点或者 11 月 11 号零点才出现），是检测不出来的。<br>
</p>

<p>
而且，把开启了 race 的程序部署在线上，还是比较影响性能的。运行 <code>go tool compile -race -S counter.go</code> ，可以查看计数器例子的代码，重点关注一下 <code>count++</code> 前后的编译后的代码：<br>
</p>

<pre class="example">
0x002a 00042 (counter.go:14)    CALL    runtime.racefuncenter(SB)
......
0x0057 00087 (counter.go:17)    JMP     154
0x0059 00089 (counter.go:17)    MOVQ    AX, "".j+24(SP)
0x005e 00094 (counter.go:17)    MOVQ    "".&amp;count+64(SP), AX
0x0063 00099 (counter.go:18)    MOVQ    AX, (SP)
0x0067 00103 (counter.go:18)    PCDATA  $0, $1
0x0067 00103 (counter.go:18)    CALL    runtime.raceread(SB)
0x006c 00108 (counter.go:18)    MOVQ    "".&amp;count+64(SP), AX
0x0071 00113 (counter.go:18)    MOVQ    (AX), CX
0x0074 00116 (counter.go:18)    MOVQ    CX, ""..autotmp_6+32(SP)
0x0079 00121 (counter.go:18)    MOVQ    AX, (SP)
0x007d 00125 (counter.go:18)    PCDATA  $0, $1
0x007d 00125 (counter.go:18)    CALL    runtime.racewrite(SB)
0x0082 00130 (counter.go:18)    MOVQ    ""..autotmp_6+32(SP), AX
0x0087 00135 (counter.go:18)    INCQ    AX
0x008a 00138 (counter.go:18)    MOVQ    "".&amp;count+64(SP), CX
0x008f 00143 (counter.go:18)    MOVQ    AX, (CX)
0x0092 00146 (counter.go:18)    MOVQ    "".j+24(SP), AX
0x0097 00151 (counter.go:17)    INCQ    AX
0x009a 00154 (counter.go:17)    CMPQ    AX, $100000
0x00a0 00160 (counter.go:17)    JLT     89
0x00a2 00162 (counter.go:20)    PCDATA  $0, $2
0x00a2 00162 (counter.go:20)    XCHGL   AX, AX
0x00a3 00163 (counter.go:20)    CALL    runtime.deferreturn(SB)
0x00a8 00168 (counter.go:20)    PCDATA  $0, $2
0x00a8 00168 (counter.go:20)    CALL    runtime.racefuncexit(SB)
0x00ad 00173 (counter.go:20)    MOVQ    40(SP), BP
0x00b2 00178 (counter.go:20)    ADDQ    $48, SP
0x00b6 00182 (counter.go:20)    RET
</pre>

<p>
在编译的代码中，增加了 <code>runtime.racefuncenter</code> 、 <code>runtime.raceread</code> 、 <code>runtime.racewrite</code> 、 <code>runtime.racefuncexit</code> 等检测 data race 的方法。通过这些插入的指令，Go race detector 工具就能够成功地检测出 data race 问题了。<br>
</p>

<p>
总结一下，通过在编译的时候插入一些指令，在运行时通过这些插入的指令检测并发读写从而发现 data race 问题，就是这个工具的实现机制。<br>
</p>
</div>
</div>
<div id="outline-container-orgac5c135" class="outline-2">
<h2 id="orgac5c135">使用 Mutex 加锁保护</h2>
<div class="outline-text-2" id="text-orgac5c135">
<p>
既然这个例子存在 data race 问题，我们就要想办法来解决它。这个时候，我们的主角 Mutex 就要登场了，它可以轻松地消除掉 data race。<br>
</p>

<p>
具体怎么做呢？<br>
</p>

<p>
我们知道，这里的共享资源是 <code>count</code> 变量，临界区是 <code>count++</code> ， <span class="underline">只要在临界区前面获取锁，在离开临界区的时候释放锁，就能完美地解决 data race 的问题了</span> 。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> main

<span style="color: #268bd2; font-weight: bold;">import</span> (
    <span style="color: #2aa198;">"fmt"</span>
    <span style="color: #2aa198;">"sync"</span>
)

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20114;&#26021;&#38145;&#20445;&#25252;&#35745;&#25968;&#22120;</span>
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">mu</span> <span style="color: #df005f; font-weight: bold;">sync.Mutex</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35745;&#25968;&#22120;&#30340;&#20540;</span>
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">count</span> = 0

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36741;&#21161;&#21464;&#37327;&#65292;&#29992;&#26469;&#30830;&#35748;&#25152;&#26377;&#30340;goroutine&#37117;&#23436;&#25104;</span>
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">wg</span> <span style="color: #df005f; font-weight: bold;">sync.WaitGroup</span>
    wg.<span style="color: #d75fd7; font-weight: bold;">Add</span>(10)

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21551;&#21160;10&#20010;gourontine</span>
    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := 0; i &lt; 10; i++ {
        <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
            <span style="color: #268bd2; font-weight: bold;">defer</span> wg.<span style="color: #d75fd7; font-weight: bold;">Done</span>()
            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#32047;&#21152;10&#19975;&#27425;</span>
            <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">j</span> := 0; j &lt; 100000; j++ {
                mu.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
                count++
                mu.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
            }
        }()
    }
    wg.<span style="color: #d75fd7; font-weight: bold;">Wait</span>()
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(count)
}
</pre>
</div>

<p>
如果你再运行一下程序，就会发现，data race 警告没有了，系统干脆地输出了 1000000。<br>
</p>

<p>
这里有一点需要注意： <code>Mutex</code> 的零值是还没有 goroutine 等待的未加锁的状态，所以你不需要额外的初始化，直接声明变量（如 <code>var mu sync.Mutex</code> ）即可。<br>
</p>

<p>
那 Mutex 还有哪些用法呢？<br>
</p>
</div>
</div>
<div id="outline-container-orgf6bb703" class="outline-2">
<h2 id="orgf6bb703">Mutex 的其他用法</h2>
<div class="outline-text-2" id="text-orgf6bb703">
</div>
<div id="outline-container-org32547b4" class="outline-3">
<h3 id="org32547b4">Mutex 嵌入到 struct 中使用</h3>
<div class="outline-text-3" id="text-org32547b4">
<p>
很多情况下， <code>Mutex</code> 会嵌入到其它 <code>struct</code> 中使用，比如下面的方式：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Counter</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    mu    <span style="color: #df005f; font-weight: bold;">sync.Mutex</span>
    Count <span style="color: #df005f; font-weight: bold;">uint64</span>
}
</pre>
</div>

<p>
在初始化嵌入的 struct 时，也不必初始化这个 Mutex 字段，不会因为没有初始化出现空指针或者是无法获取到锁的情况。<br>
</p>
</div>
</div>
<div id="outline-container-orgab3556b" class="outline-3">
<h3 id="orgab3556b">Mutex 作为结构体的匿名字段</h3>
<div class="outline-text-3" id="text-orgab3556b">
<p>
有时候，我们还可以采用嵌入字段的方式。通过嵌入字段，你可以在这个 <code>struct</code> 上直接调用 <code>Lock/Unlock</code> 方法。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">counter</span> <span style="color: #df005f; font-weight: bold;">Counter</span>
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">wg</span> <span style="color: #df005f; font-weight: bold;">sync.WaitGroup</span>
    wg.<span style="color: #d75fd7; font-weight: bold;">Add</span>(10)
    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := 0; i &lt; 10; i++ {
        <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
            <span style="color: #268bd2; font-weight: bold;">defer</span> wg.<span style="color: #d75fd7; font-weight: bold;">Done</span>()
            <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">j</span> := 0; j &lt; 100000; j++ {
                counter.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
                counter.Count++
                counter.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
            }
        }()
    }
    wg.<span style="color: #d75fd7; font-weight: bold;">Wait</span>()
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(counter.Count)
}


<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Counter</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    sync.Mutex
    Count <span style="color: #df005f; font-weight: bold;">uint64</span>
} 
</pre>
</div>
</div>
</div>
<div id="outline-container-orged02acd" class="outline-3">
<h3 id="orged02acd">封装成方法</h3>
<div class="outline-text-3" id="text-orged02acd">
<p>
如果嵌入的 <code>struct</code> 有多个字段，我们一般会把 <code>Mutex</code> 放在要控制的字段上面，然后使用空格把字段分隔开来。即使你不这样做，代码也可以正常编译，只不过，用这种风格去写的话，逻辑会更清晰，也更易于维护。<br>
</p>

<p>
甚至，你还可以把获取锁、释放锁、计数加一的逻辑封装成一个方法，对外不需要暴露锁等逻辑：<br>
</p>

<div class="org-src-container">
<pre class="src src-go">
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#23553;&#35013;&#22909;&#30340;&#35745;&#25968;&#22120;</span>
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">counter</span> <span style="color: #df005f; font-weight: bold;">Counter</span>

    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">wg</span> <span style="color: #df005f; font-weight: bold;">sync.WaitGroup</span>
    wg.<span style="color: #d75fd7; font-weight: bold;">Add</span>(10)

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21551;&#21160;10&#20010;goroutine</span>
    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := 0; i &lt; 10; i++ {
        <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
            <span style="color: #268bd2; font-weight: bold;">defer</span> wg.<span style="color: #d75fd7; font-weight: bold;">Done</span>()
            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#25191;&#34892;10&#19975;&#27425;&#32047;&#21152;</span>
            <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">j</span> := 0; j &lt; 100000; j++ {
                counter.<span style="color: #d75fd7; font-weight: bold;">Incr</span>() <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21463;&#21040;&#38145;&#20445;&#25252;&#30340;&#26041;&#27861;</span>
            }
        }()
    }
    wg.<span style="color: #d75fd7; font-weight: bold;">Wait</span>()
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(counter.<span style="color: #d75fd7; font-weight: bold;">Count</span>())
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#32447;&#31243;&#23433;&#20840;&#30340;&#35745;&#25968;&#22120;&#31867;&#22411;</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Counter</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    CounterType <span style="color: #df005f; font-weight: bold;">int</span>
    Name        <span style="color: #df005f; font-weight: bold;">string</span>

    mu    <span style="color: #df005f; font-weight: bold;">sync.Mutex</span>   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#38548;&#19968;&#20010;&#31354;&#34892;&#65292;&#34920;&#31034;&#36825;&#20010;&#38145;&#29992;&#26469;&#20445;&#25252; count</span>
    count <span style="color: #df005f; font-weight: bold;">uint64</span>
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21152;1&#30340;&#26041;&#27861;&#65292;&#20869;&#37096;&#20351;&#29992;&#20114;&#26021;&#38145;&#20445;&#25252;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">Counter</span>) <span style="color: #d75fd7; font-weight: bold;">Incr</span>() {
    c.mu.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
    c.count++
    c.mu.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#24471;&#21040;&#35745;&#25968;&#22120;&#30340;&#20540;&#65292;&#20063;&#38656;&#35201;&#38145;&#20445;&#25252;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">Counter</span>) <span style="color: #d75fd7; font-weight: bold;">Count</span>() <span style="color: #df005f; font-weight: bold;">uint64</span> {
    c.mu.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
    <span style="color: #268bd2; font-weight: bold;">defer</span> c.mu.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
    <span style="color: #268bd2; font-weight: bold;">return</span> c.count
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org7bf821c" class="outline-2">
<h2 id="org7bf821c">总结</h2>
<div class="outline-text-2" id="text-org7bf821c">
<p>
<code>Mutex</code> 的使用很简单，它只有简简单单的两个方法， <code>Lock()</code> 和 <code>Unlock()</code> ，进入临界区之前调用 <code>Lock()</code> 方法，退出临界区调用 <code>Unlock()</code> 方法。<br>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-05-09 22:05 Mon</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-05-10 Tue 20:56</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
