<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-10-02 六 11:35 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>GO-MAKE</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran &lt;haoran.mc@outlook.com&gt;">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">GO-MAKE</h1>
<p>
golang 分配内存主要有内置函数new和make，今天我们来探究一下make有哪些玩法。
</p>

<p>
map只能为slice, map, channel分配内存，并返回一个初始化的值。首先来看下make有以下三种不同的用法：
</p>

<ol class="org-ol">
<li>make(map[string]string)</li>

<li>make([]int, 2)</li>

<li>make([]int, 2, 4)</li>
</ol>



<ol class="org-ol">
<li>第一种用法，即缺少长度的参数，只传类型，这种用法只能用在类型为map或chan的场景，例如make([]int)是会报错的。这样返回的空间长度都是默认为0的。</li>

<li>第二种用法，指定了长度，例如make([]int, 2)返回的是一个长度为2的slice</li>

<li>第三种用法，第二参数指定的是切片的长度，第三个参数是用来指定预留的空间长度，例如a := make([]int, 2, 4), 这里值得注意的是返回的切片a的总长度是4，预留的意思并不是另外多出来4的长度，其实是包含了前面2个已经切片的个数的。所以举个例子当你这样用的时候 a := make([]int, 4, 2)，就会报语法错误。</li>
</ol>

<p>
因此，当我们为slice分配内存的时候，应当尽量预估到slice可能的最大长度，通过给make传第三个参数的方式来给slice预留好内存空间，这样可以避免二次分配内存带来的开销，大大提高程序的性能。
</p>

<p>
而事实上，我们其实是很难预估切片的可能的最大长度的，这种情况下，当我们调用append为slice追加元素时，golang为了尽可能的减少二次分配内存，并不是每一次都只增加一个单位的内存空间，而且遵循这样一种扩容机制：
</p>

<p>
当有预留的未使用的空间时，直接对未使用的空间进行切片追加，当预留的空间全部使用完毕的时候，扩容的空间将会是当前的slice长度的一倍，例如当前slice的长度为4，进行一次append操作之后，cap(a)返回的长度将会是8.
</p>
</div>
</body>
</html>
