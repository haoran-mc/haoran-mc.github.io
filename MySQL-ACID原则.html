<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-10-07 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>数据库 ACID 原则</title>
<meta name="author" content="L.M.haoran" />
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved." />
<meta name="generator" content="Org Mode" />
<link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
           <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
           <script type="module" src="static/js/main.js" defer></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">数据库 ACID 原则</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgaeb62e5">事务</a></li>
<li><a href="#orgf17a99c">事务控制语句</a></li>
<li><a href="#org0914cf7">MySQL 事务处理只要有两种方法</a></li>
<li><a href="#orgdc4325f">ACID</a>
<ul>
<li><a href="#org2bc3023">Atomicity 原子性</a></li>
<li><a href="#orgd3eadb0">Consistency 一致性</a></li>
<li><a href="#orge7b194c">Isolation 隔离性</a>
<ul>
<li><a href="#orgb240c55">事务之间的相互影响</a>
<ul>
<li><a href="#org5b24f62">脏读</a></li>
<li><a href="#orge611074">不可重复读</a></li>
<li><a href="#org37a7a6d">幻读</a></li>
<li><a href="#orgabd606f">丢失更新（脏写）</a>
<ul>
<li><a href="#orgb66e191">丢失更新分类</a></li>
<li><a href="#orgda33572">解决丢失更新问题</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7c8549a">理解 SQL SERVER 中的隔离级别</a></li>
</ul>
</li>
<li><a href="#org0708292">Durability 持久性</a></li>
<li><a href="#org4693106">总结</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgaeb62e5" class="outline-2">
<h2 id="orgaeb62e5">事务</h2>
<div class="outline-text-2" id="text-orgaeb62e5">
<blockquote>
<p>
事务是一个操作序列，这些操作要么都执行，要么都不执行，他是一个不可分割的工作单位。<br>
</p>
</blockquote>

<ul class="org-ul">
<li>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。<br></li>
<li>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。<br></li>
<li><p>
事务用来管理 insert, update, delete 语句<br>
</p>

<p>
一般来说，事务必须满足 4 个条件（ACID）：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。<br>
</p>

<dl class="org-dl">
<dt>原子性</dt><dd>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。<br></dd>
<dt>一致性</dt><dd>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。<br></dd>
<dt>隔离性</dt><dd>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。<br></dd>
<dt>持久性</dt><dd><p>
事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。<br>
</p>

<pre class="example" id="org13255a9">
在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。
</pre></dd>
</dl></li>
</ul>
</div>
</div>
<div id="outline-container-orgf17a99c" class="outline-2">
<h2 id="orgf17a99c">事务控制语句</h2>
<div class="outline-text-2" id="text-orgf17a99c">
<ul class="org-ul">
<li><code>SET autocommit = 0</code> 关闭默认的事务自动提交<br></li>
<li><code>BEGIN</code> 或 <code>START TRANSACTION</code> 显式地开启一个事务；<br></li>
<li><code>COMMIT</code> 也可以使用 <code>COMMIT WORK</code> ，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；<br></li>
<li><code>ROLLBACK</code> 也可以使用 <code>ROLLBACK WORK</code> ，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；<br></li>
<li><code>SAVEPOINT identifier</code> ，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；<br></li>
<li><code>RELEASE SAVEPOINT identifier</code> 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；<br></li>
<li><code>ROLLBACK TO identifier</code> 把事务回滚到标记点；<br></li>
<li><code>SET TRANSACTION</code> 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有 <code>READ UNCOMMITTED</code> 、 <code>READ COMMITTED</code> 、 <code>REPEATABLE READ</code> 和 <code>SERIALIZABLE</code> 。<br></li>
</ul>
</div>
</div>
<div id="outline-container-org0914cf7" class="outline-2">
<h2 id="org0914cf7">MySQL 事务处理只要有两种方法</h2>
<div class="outline-text-2" id="text-org0914cf7">
<ol class="org-ol">
<li>用 BEGIN, ROLLBACK, COMMIT 来实现<br>
<ul class="org-ul">
<li><code>BEGIN</code> 开始一个事务<br></li>
<li><code>ROLLBACK</code> 事务回滚<br></li>
<li><code>COMMIT</code> 事务确认<br></li>
</ul></li>
<li>直接用 SET 来改变 MySQL 的自动提交模式<br>
<ul class="org-ul">
<li><code>SET AUTOCOMMIT=0</code> 禁止自动提交<br></li>
<li><code>SET AUTOCOMMIT=1</code> 开启自动提交<br></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-orgdc4325f" class="outline-2">
<h2 id="orgdc4325f">ACID</h2>
<div class="outline-text-2" id="text-orgdc4325f">
</div>
<div id="outline-container-org2bc3023" class="outline-3">
<h3 id="org2bc3023">Atomicity 原子性</h3>
<div class="outline-text-3" id="text-org2bc3023">
<blockquote>
<p>
默认情况下一条SQL就是一个单独事务，事务是自动提交的。只有显式的使用start transaction开启一个事务，才能将一个代码块放在事务中执行。保障事务的原子性是数据库管理系统的责任，为此许多数据源采用日志机制。例如，SQL Server使用一个预写事务日志，在将数据提交到实际数据页面前，先写在事务日志上。<br>
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-sql"><span style="color: #ea3d54;">begin</span> <span style="color: #ea3d54;">transaction</span>
<span style="color: #ea3d54;">update</span> account <span style="color: #ea3d54;">set</span> money= money - 100where <span style="color: #ea3d54;">name</span>=<span style="color: #4fb3d8;">'A'</span>;
<span style="color: #ea3d54;">update</span> account <span style="color: #ea3d54;">set</span> money= money +100where <span style="color: #ea3d54;">name</span>=<span style="color: #4fb3d8;">'B'</span>;
if Error <span style="color: #ea3d54;">then</span>
<span style="color: #ea3d54;">rollback</span>
<span style="color: #ea3d54;">else</span>
<span style="color: #ea3d54;">commit</span>
</pre>
</div>

<p>
在事务中的扣款和加款两条语句，要么都执行，要么就都不执行。否则如果只执行了扣款语句就提交了，此时如果突然断电，A 账号已经发生了扣款，B 账号却没有收款，在生活中就会引起纠纷。<br>
</p>

<p>
解决方法：在数据库管理系统（DBMS）中，默认情况下一条 SQL 就是一个单独事务，事务是自动提交的。只有显式的使用 <code>start transaction</code> 开启一个事务，才能将一个代码块放在事务中执行。保障事务的原子性是数据库管理系统的责任，为此许多数据源采用日志机制。例如，SQL Server 使用一个预写事务日志，在将数据提交到实际数据页面前，先写在事务日志上。<br>
</p>
</div>
</div>
<div id="outline-container-orgd3eadb0" class="outline-3">
<h3 id="orgd3eadb0">Consistency 一致性</h3>
<div class="outline-text-3" id="text-orgd3eadb0">
<blockquote>
<p>
在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。<br>
</p>
</blockquote>

<p>
案例：对银行转帐事务，不管事务成功还是失败，应该保证事务结束后 ACCOUNT 表中 aaa 和 bbb 的存款总额为 2000 元。<br>
</p>

<p style="margin: 0.145rem 0 0 0;"><b>解决方法：</b></p>

<ol class="org-ol">
<li>数据库机制层面：<br>
数据库层面的一致性是，在一个事务执行之前和之后，数据会符合你设置的约束（唯一约束，外键约束，Check 约束等）和触发器设置。这一点是由 SQL SERVER 进行保证的。比如转账，则可以使用 CHECK 约束两个账户之和等于 2000 来达到一致性目的。<br></li>
<li>业务层面：<br>
对于业务层面来说，一致性是保持业务的一致性。这个业务一致性需要由开发人员进行保证。当然，很多业务方面的一致性，也可以通过转移到数据库机制层面进行保证。<br></li>
</ol>
</div>
</div>
<div id="outline-container-orge7b194c" class="outline-3">
<h3 id="orge7b194c">Isolation 隔离性</h3>
<div class="outline-text-3" id="text-orge7b194c">
<blockquote>
<p>
数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。<br>
</p>
</blockquote>

<p>
这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。<br>
</p>

<p>
企业开发中，事务最复杂问题都是由事务隔离性引起的。当多个事务并发时，SQL Server利用加锁和阻塞来保证事务之间不同等级的隔离性。一般情况下，完全的隔离性是不现实的，完全的隔离性要求数据库同一时间只执行一条事务，这样会严重影响性能。想要理解SQL Server中对于隔离性的保障，首先要了解并发事务之间是如何干扰的。<br>
</p>
</div>
<div id="outline-container-orgb240c55" class="outline-4">
<h4 id="orgb240c55">事务之间的相互影响</h4>
<div class="outline-text-4" id="text-orgb240c55">
<p>
事务之间的相互影响分为几种，分别为：脏读，不可重复读，幻读，丢失更新。<br>
</p>
</div>
<div id="outline-container-org5b24f62" class="outline-5">
<h5 id="org5b24f62">脏读</h5>
<div class="outline-text-5" id="text-org5b24f62">
<p>
脏读意味着一个事务读取了另一个事务未提交的数据，而这个数据是有可能回滚的；如下案例，此时如果事务 1 回滚，则 B 账户必将有损失。<br>
</p>

<div class="div-center">
    <img src="./images/MySQL-脏读.png" />
</div>
</div>
</div>
<div id="outline-container-orge611074" class="outline-5">
<h5 id="orge611074">不可重复读</h5>
<div class="outline-text-5" id="text-orge611074">
<p>
不可重复读意味着，在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。如下案例，事务 1 必然会变得糊涂，不知道发生了什么。<br>
</p>

<div class="div-center">
    <img src="./images/MySQL-不可重复读.png" />
</div>
</div>
</div>
<div id="outline-container-org37a7a6d" class="outline-5">
<h5 id="org37a7a6d">幻读</h5>
<div class="outline-text-5" id="text-org37a7a6d">
<p>
幻读，是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。<br>
</p>

<div class="div-center">
    <img src="./images/MySQL-幻读.png" />
</div>
</div>
</div>
<div id="outline-container-orgabd606f" class="outline-5">
<h5 id="orgabd606f">丢失更新（脏写）</h5>
<div class="outline-text-5" id="text-orgabd606f">
<p>
丢失更新就是两个事务在并发下同时进行更新，后一个事务的更新覆盖了前一个事务更新的情况，丢失更新是数据没有保证一致性导致的。比如，事务 A 修改了一条记录，事务 B 在 事务 A 提交的同时也进行了一次修改并且提交。当事务 A 查询的时候，会发现刚才修改的内容没有被修改，好像丢失了更新。<br>
</p>

<div class="div-center">
    <img src="./images/MySQL-丢失更新.png" />
</div>
</div>

<div id="outline-container-orgb66e191" class="outline-6">
<h6 id="orgb66e191">丢失更新分类</h6>
<div class="outline-text-6" id="text-orgb66e191">
<p>
上图中，事务二最后一步进行提交，造成事务一的更新没有了，这样的丢失叫做 <b>覆盖丢失</b> ；如果上图中的事务二最后一步进行的是回滚，事务一的更新还是会丢失，这样的丢失叫做 <b>回滚丢失</b> 。<br>
</p>
</div>
</div>
<div id="outline-container-orgda33572" class="outline-6">
<h6 id="orgda33572">解决丢失更新问题</h6>
<div class="outline-text-6" id="text-orgda33572">
<p>
两种思路，一种是悲观锁，另一种是乐观锁，详细了解请看：<a href="MySQL-锁机制.html">MySQL锁机制</a><br>
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org7c8549a" class="outline-4">
<h4 id="org7c8549a">理解 SQL SERVER 中的隔离级别</h4>
<div class="outline-text-4" id="text-org7c8549a">
<p>
数据库的事务隔离级别（TRANSACTION ISOLATION LEVEL）是一个数据库上很基本的一个概念。为什么会有事务隔离级别，SQL Server上实现了哪些事务隔离级别？事务隔离级别的前提是一个多用户、多进程、多线程的并发系统，在这个系统中为了保证数据的一致性和完整性，我们引入了事务隔离级别这个概念，对一个单用户、单线程的应用来说则不存在这个问题。<br>
</p>

<p>
为了避免上述几种事务之间的影响，SQL Server 通过设置不同的隔离级别来进行不同程度的避免。因为高的隔离等级意味着更多的锁，从而牺牲性能。所以这个选项开放给了用户根据具体的需求进行设置。不过默认的隔离级别 Read Commited 符合了多数的实际需求：<br>
</p>

<p>
通过 ~show variables like '%%'<br>
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">隔离级别</th>
<th scope="col" class="org-left">解决脏写</th>
<th scope="col" class="org-left">解决脏读</th>
<th scope="col" class="org-left">解决不可重复读</th>
<th scope="col" class="org-left">解决幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">读未提交 READ UNCOMMITTED</td>
<td class="org-left">是</td>
<td class="org-left">否</td>
<td class="org-left">否</td>
<td class="org-left">否</td>
</tr>

<tr>
<td class="org-left">读已提交 READ COMMITTED</td>
<td class="org-left">是</td>
<td class="org-left">是</td>
<td class="org-left">否</td>
<td class="org-left">否</td>
</tr>

<tr>
<td class="org-left">可重复读 REPEATABLE READ</td>
<td class="org-left">是</td>
<td class="org-left">是</td>
<td class="org-left">是</td>
<td class="org-left">否</td>
</tr>

<tr>
<td class="org-left">串行化 SERIALIZABLE</td>
<td class="org-left">是</td>
<td class="org-left">是</td>
<td class="org-left">是</td>
<td class="org-left">是</td>
</tr>
</tbody>
</table>



<p>
四个隔离级别解决问题程度的递增，是用牺牲数据库的并发性能来得到的，如串行化级别，解决了所有的并发问题，但却没有任何并发能力。所以需要根据实际业务情况选择合适的隔离级别。<br>
</p>

<p>
还需要清楚，四个隔离级别只是 SQL 给出的规范，包括前面所讲的 ACID 事务的实现，每个数据库存储引擎对这些的实现技术都是不同的，所有引擎都在追求更高的隔离级别下的更高的并发能力。比如 MySQL 默认使用的 InnoDB 引擎，使用 MVCC 技术在可重复读级别下，不用阻塞事务 B 的写操作就可以解决不可重复读甚至是幻读问题。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org0708292" class="outline-3">
<h3 id="org0708292">Durability 持久性</h3>
<div class="outline-text-3" id="text-org0708292">
<blockquote>
<p>
事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。<br>
</p>
</blockquote>

<p>
SQL SERVER通过write-ahead transaction log来保证持久性。write-ahead transaction log的意思是，事务中对数据库的改变在写入到数据库之前，首先写入到事务日志中。而事务日志是按照顺序排号的（LSN）。当数据库崩溃或者服务器断点时，重启动SQL SERVER，SQLSERVER首先会检查日志顺序号，将本应对数据库做更改而未做的部分持久化到数据库，从而保证了持久性。<br>
</p>
</div>
</div>
<div id="outline-container-org4693106" class="outline-3">
<h3 id="org4693106">总结</h3>
<div class="outline-text-3" id="text-org4693106">
<p>
事务的（ACID）特性是由关系数据库管理系统（RDBMS，数据库系统）来实现的。数据库管理系统采用日志来保证事务的原子性、一致性和持久性。日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。<br>
</p>

<p>
数据库管理系统采用锁机制来实现事务的隔离性。当多个事务同时更新数据库中相同的数据时，只允许持有锁的事务能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。<br>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-03-14 20:03 Mon</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-10-07</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
