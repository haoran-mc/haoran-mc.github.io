<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-10-08 Fri 14:46 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>GO-基本类型和运算符</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">GO-基本类型和运算符</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org2f83d09">布尔类型 bool</a></li>
<li><a href="#org0d4b702">数字类型</a>
<ul>
<li><a href="#orgba251c6">格式化说明符</a></li>
<li><a href="#orgcc35aea">数字值转换</a></li>
<li><a href="#org0dd3294">复数</a></li>
<li><a href="#org709b943">位运算</a></li>
<li><a href="#orgfe69c99">逻辑运算符</a></li>
<li><a href="#org250e58a">算术运算符</a></li>
<li><a href="#org4920fa0">随机数</a></li>
<li><a href="#orgc3e2a16">运算符与优先级</a></li>
<li><a href="#org18d012f">类型别名</a></li>
<li><a href="#orgcfcbac8">字符类型</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org2f83d09" class="outline-2">
<h2 id="org2f83d09">布尔类型 bool</h2>
<div class="outline-text-2" id="text-org2f83d09">
<p>
一个简单的例子：var b bool = true。<br>
布尔型的值只可以是常量 true 或者 false。<br>
两个类型相同的值可以使用相等 <code>= 或者不等 !</code> 运算符来进行比较并获得一个布尔型的值。<br>
当相等运算符两边的值是完全相同的值的时候会返回 true，否则返回 false，并且只有在两个的值的类型相同的情况下才可以使用。<br>
</p>

<p>
Go 对于值之间的比较有非常严格的限制，只有两个类型相同的值才可以进行比较，如果值的类型是接口（interface，第 11 章），它们也必须都实现了相同的接口。如果其中一个值是常量，那么另外一个值的类型必须和该常量类型相兼容的。如果以上条件都不满足，则其中一个值的类型必须在被转换为和另外一个值的类型相同之后才可以进行比较。<br>
</p>

<p>
对于布尔值而言，好的命名能够很好地提升代码的可读性。例如以 is 或者 Is 开头的 isSorted、isFinished、isVisible，使用这样的命名能够在阅读代码的获得阅读正常语句一样的良好体验，例如标准库中的 unicode.IsDigit(ch)<br>
</p>
</div>
</div>
<div id="outline-container-org0d4b702" class="outline-2">
<h2 id="org0d4b702">数字类型</h2>
<div class="outline-text-2" id="text-org0d4b702">
<p>
Go 语言支持整型和浮点型数字，并且原生支持复数，其中位的运算采用补码。<br>
Go 也有基于架构的类型，例如：int、uint 和 uintptr。<br>
这些类型的长度都是根据运行程序所在的操作系统类型所决定的：<br>
int 和 uint 在 32 位操作系统上，它们均使用 32 位（4 个字节），在 64 位操作系统上，它们均使用 64 位（8 个字节）。<br>
uintptr 的长度被设定为足够存放一个指针即可。<br>
</p>

<p>
Go 语言中没有 float 类型。（Go 语言中只有 float32 和 float64）没有 double 类型。<br>
与操作系统架构无关的类型都有固定的大小，并在类型的名称中就可以看出来：<br>
</p>

<p>
整数：<br>
</p>
<ul class="org-ul">
<li>int8（-128 -&gt; 127）<br></li>
<li>int16（-32768 -&gt; 32767）<br></li>
<li>int32（-2,147,483,648 -&gt; 2,147,483,647）<br></li>
<li>int64（-9,223,372,036,854,775,808 -&gt; 9,223,372,036,854,775,807）<br></li>
</ul>

<p>
无符号整数：<br>
</p>
<ul class="org-ul">
<li>uint8（0 -&gt; 255）<br></li>
<li>uint16（0 -&gt; 65,535）<br></li>
<li>uint32（0 -&gt; 4,294,967,295）<br></li>
<li>uint64（0 -&gt; 18,446,744,073,709,551,615）<br></li>
</ul>

<p>
浮点型（IEEE-754 标准）：<br>
</p>
<ul class="org-ul">
<li>float32（+- 1e-45 -&gt; +- 3.4 * 1e38）<br></li>
<li>float64（+- 5  1e-324 -&gt; 107  1e308）<br></li>
</ul>

<p>
int 型是计算最快的一种类型。<br>
整型的零值为 0，浮点型的零值为 0.0。<br>
</p>

<p>
float32 精确到小数点后 7 位，float64 精确到小数点后 15 位。由于精确度的缘故，你在使用 <code>= 或者 !</code> 来比较浮点数时应当非常小心。你最好在正式使用前测试对于精确度要求较高的运算。<br>
你应该尽可能地使用 float64，因为 math 包中所有有关数学运算的函数都会要求接收这个类型。<br>
你可以通过增加前缀 0 来表示 8 进制数（如：077），增加前缀 0x 来表示 16 进制数（如：0xFF），以及使用 e 来表示 10 的连乘（如： 1e3 = 1000，或者 6.022e23 = 6.022 x 1e23）。<br>
你可以使用 a := uint64(0) 来同时完成类型转换和赋值操作，这样 a 的类型就是 uint64。<br>
Go 中不允许不同类型之间的混合使用，但是对于常量的类型限制非常少，因此允许常量之间的混合使用。<br>
</p>
</div>
<div id="outline-container-orgba251c6" class="outline-3">
<h3 id="orgba251c6">格式化说明符</h3>
<div class="outline-text-3" id="text-orgba251c6">
<p>
在格式化字符串里，%d 用于格式化整数（%x 和 %X 用于格式化 16 进制表示的数字），%g 用于格式化浮点型（%f 输出浮点数，%e 输出科学计数表示法），%0d 用于规定输出定长的整数，其中开头的数字 0 是必须的。<br>
%n.mg 用于表示数字 n 并精确到小数点后 m 位，除了使用 g 之外，还可以使用 e 或者 f，例如：使用格式化字符串 %5.2e 来输出 3.4 的结果为 3.40e+00<br>
</p>
</div>
</div>
<div id="outline-container-orgcc35aea" class="outline-3">
<h3 id="orgcc35aea">数字值转换</h3>
<div class="outline-text-3" id="text-orgcc35aea">
<p>
当进行类似 a32bitInt = int32(a32Float) 的转换时，小数点后的数字将被丢弃。这种情况一般发生当从取值范围较大的类型转换为取值范围较小的类型时，或者你可以写一个专门用于处理类型转换的函数来确保没有发生精度的丢失。下面这个例子展示如何安全地从<br>
</p>

<p>
int 型转换为 int8：<br>
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #BD93F9;">func</span> <span style="color: #AFAFAF;">Uint8FromInt</span>(<span style="color: #AFAFAF;">n</span> <span style="color: #AFAFAF;">int</span>) (<span style="color: #AFAFAF;">uint8</span>, <span style="color: #AFAFAF;">error</span>) {
    <span style="color: #BD93F9;">if</span> <span style="color: #009F9F;">0</span> &lt;= n &amp;&amp; n &lt;= math.MaxUint8 { <span style="color: #7c7c7c; font-style: italic;">// </span><span style="color: #7c7c7c; font-style: italic;">conversion is safe</span>
        <span style="color: #BD93F9;">return</span> <span style="color: #AFAFAF;">uint8</span>(n), <span style="color: #009F9F;">nil</span>
    }
    <span style="color: #BD93F9;">return</span> <span style="color: #009F9F;">0</span>, fmt.<span style="color: #AFAFAF;">Errorf</span>(<span style="color: #FC9F4E;">"%d is out of the uint8 range"</span>, n)
}
</pre>
</div>

<p>
或者安全地从 float64 转换为 int：<br>
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #BD93F9;">func</span> <span style="color: #AFAFAF;">IntFromFloat64</span>(<span style="color: #AFAFAF;">x</span> <span style="color: #AFAFAF;">float64</span>) <span style="color: #AFAFAF;">int</span> {
    <span style="color: #BD93F9;">if</span> math.MinInt32 &lt;= x &amp;&amp; x &lt;= math.MaxInt32 { <span style="color: #7c7c7c; font-style: italic;">// </span><span style="color: #7c7c7c; font-style: italic;">x lies in the integer range</span>
        <span style="color: #AFAFAF;">whole</span>, <span style="color: #AFAFAF;">fraction</span> := math.<span style="color: #AFAFAF;">Modf</span>(x)
        <span style="color: #BD93F9;">if</span> fraction &gt;= <span style="color: #009F9F;">0</span>.<span style="color: #009F9F;">5</span> {
            whole++
        }
        <span style="color: #BD93F9;">return</span> <span style="color: #AFAFAF;">int</span>(whole)
    }
    <span style="color: #AFAFAF;">panic</span>(fmt.<span style="color: #AFAFAF;">Sprintf</span>(<span style="color: #FC9F4E;">"%g is out of the int32 range"</span>, x))
}
</pre>
</div>

<p>
不过如果你实际存的数字超出你要转换到的类型的取值范围的话，则会引发 panic<br>
</p>
</div>
</div>
<div id="outline-container-org0dd3294" class="outline-3">
<h3 id="org0dd3294">复数</h3>
<div class="outline-text-3" id="text-org0dd3294">
<p>
Go 拥有以下复数类型：<br>
complex64 (32 位实数和虚数)<br>
complex128 (64 位实数和虚数)Copy<br>
复数使用 re+imI 来表示，其中 re 代表实数部分，im 代表虚数部分，I 代表根号负 1。<br>
</p>

<p>
函数 real(c) 和 imag(c) 可以分别获得相应的实数和虚数部分。<br>
在使用格式化说明符时，可以使用 %v 来表示复数，但当你希望只表示其中的一个部分的时候需要使用 %f。<br>
复数支持和其它数字类型一样的运算。当你使用等号 <code>= 或者不等号 !</code> 对复数进行比较运算时，注意对精确度的把握。cmath 包中包含了一些操作复数的公共方法。如果你对内存的要求不是特别高，最好使用 complex128 作为计算类型，因为相关函数都使用这个类型的参数。<br>
</p>
</div>
</div>
<div id="outline-container-org709b943" class="outline-3">
<h3 id="org709b943">位运算</h3>
</div>
<div id="outline-container-orgfe69c99" class="outline-3">
<h3 id="orgfe69c99">逻辑运算符</h3>
</div>
<div id="outline-container-org250e58a" class="outline-3">
<h3 id="org250e58a">算术运算符</h3>
<div class="outline-text-3" id="text-org250e58a">
<ul class="org-ul">
<li>相对于一般规则而言，Go 在进行字符串拼接时允许使用对运算符 + 的重载，但 Go 本身不允许开发者进行自定义的运算符重载<br></li>
<li>整数除以 0 可能导致程序崩溃，将会导致运行时的恐慌状态<br></li>
<li>浮点数除以 0.0 会返回一个无穷尽的结果，使用 +Inf 表示。<br></li>
<li>对于整数和浮点数，你可以使用一元运算符 ++（递增）和 &#x2013;（递减），但只能用于后缀<br></li>
<li>同时，带有 <del>+ 和 &#x2013; 的只能作为语句，而非表达式，因此 n = i+</del> 这种写法是无效的，其它像 f(i++) 或者 a[i]=b[i++] 这些可以用于 C、C++ 和 Java 中的写法在 Go 中也是不允许的。<br></li>
<li>在运算时 溢出 不会产生错误，Go 会简单地将超出位数抛弃。如果你需要范围无限大的整数或者有理数（意味着只被限制于计算机内存），你可以使用标准库中的 big 包，该包提供了类似 big.Int 和 big.Rat 这样的类型（第 9.4 节）。<br></li>
</ul>
</div>
</div>
<div id="outline-container-org4920fa0" class="outline-3">
<h3 id="org4920fa0">随机数</h3>
<div class="outline-text-3" id="text-org4920fa0">
<p>
一些像游戏或者统计学类的应用需要用到随机数。rand 包实现了伪随机数的生成。<br>
</p>

<p>
示例 4.10 random.go 演示了如何生成 10 个非负随机数：<br>
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #BD93F9;">package</span> main
<span style="color: #BD93F9;">import</span> (
    <span style="color: #FC9F4E;">"fmt"</span>
    <span style="color: #FC9F4E;">"math/rand"</span>
    <span style="color: #FC9F4E;">"time"</span>
)

<span style="color: #BD93F9;">func</span> <span style="color: #AFAFAF;">main</span>() {
    <span style="color: #BD93F9;">for</span> <span style="color: #AFAFAF;">i</span> := <span style="color: #009F9F;">0</span>; i &lt; <span style="color: #009F9F;">10</span>; i++ {
        <span style="color: #AFAFAF;">a</span> := rand.<span style="color: #AFAFAF;">Int</span>()
        fmt.<span style="color: #AFAFAF;">Printf</span>(<span style="color: #FC9F4E;">"%d / "</span>, a)
    }
    <span style="color: #BD93F9;">for</span> <span style="color: #AFAFAF;">i</span> := <span style="color: #009F9F;">0</span>; i &lt; <span style="color: #009F9F;">5</span>; i++ {
        <span style="color: #AFAFAF;">r</span> := rand.<span style="color: #AFAFAF;">Intn</span>(<span style="color: #009F9F;">8</span>)
        fmt.<span style="color: #AFAFAF;">Printf</span>(<span style="color: #FC9F4E;">"%d / "</span>, r)
    }
    fmt.<span style="color: #AFAFAF;">Println</span>()
    <span style="color: #AFAFAF;">timens</span> := <span style="color: #AFAFAF;">int64</span>(time.<span style="color: #AFAFAF;">Now</span>().<span style="color: #AFAFAF;">Nanosecond</span>())
    rand.<span style="color: #AFAFAF;">Seed</span>(timens)
    <span style="color: #BD93F9;">for</span> <span style="color: #AFAFAF;">i</span> := <span style="color: #009F9F;">0</span>; i &lt; <span style="color: #009F9F;">10</span>; i++ {
        fmt.<span style="color: #AFAFAF;">Printf</span>(<span style="color: #FC9F4E;">"%2.2f / "</span>, <span style="color: #009F9F;">100</span>*rand.<span style="color: #AFAFAF;">Float32</span>())
    }
}
</pre>
</div>

<p>
函数 rand.Float32 和 rand.Float64 返回介于 [0.0, 1.0) 之间的伪随机数，其中包括 0.0 但不包括 1.0。函数 rand.Intn 返回介于 [0, n) 之间的伪随机数。<br>
</p>

<p>
你可以使用 Seed(value) 函数来提供伪随机数的生成种子，一般情况下都会使用当前时间的纳秒级数字（第 4.8 节）。<br>
</p>
</div>
</div>

<div id="outline-container-orgc3e2a16" class="outline-3">
<h3 id="orgc3e2a16">运算符与优先级</h3>
<div class="outline-text-3" id="text-orgc3e2a16">
<p>
有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：<br>
</p>
<pre class="example" id="org2d0cdfb">
优先级     运算符
 7      ^ !
 6      * / % &lt;&lt; &gt;&gt; &amp; &amp;^
 5      + - | ^
 4      == != &lt; &lt;= &gt;= &gt;
 3      &lt;-
 2      &amp;&amp;
 1      ||
</pre>
</div>
</div>
<div id="outline-container-org18d012f" class="outline-3">
<h3 id="org18d012f">类型别名</h3>
<div class="outline-text-3" id="text-org18d012f">
<p>
当你在使用某个类型时，你可以给它起另一个名字，然后你就可以在你的代码中使用新的名字（用于简化名称或解决名称冲突）。<br>
在 type TZ int 中，TZ 就是 int 类型的新名称（用于表示程序中的时区），然后就可以使用 TZ 来操作 int 类型的数据。<br>
</p>

<p>
实际上，类型别名得到的新类型并非和原类型完全相同，新类型不会拥有原类型所附带的方法（第 10 章）；TZ 可以自定义一个方法用来输出更加人性化的时区信息。<br>
</p>
</div>
</div>
<div id="outline-container-orgcfcbac8" class="outline-3">
<h3 id="orgcfcbac8">字符类型</h3>
<div class="outline-text-3" id="text-orgcfcbac8">
<p>
严格来说，这并不是 Go 语言的一个类型，字符只是整数的特殊用例。byte 类型是 uint8 的别名，对于只占用 1 个字节的传统 ASCII 编码的字符来说，完全没有问题。例如：var ch byte = 'A'；字符使用单引号括起来。<br>
在 ASCII 码表中，A 的值是 65，而使用 16 进制表示则为 41，所以下面的写法是等效的：<br>
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #BD93F9;">var</span> <span style="color: #AFAFAF;">ch</span> <span style="color: #AFAFAF;">byte</span> = <span style="color: #009F9F;">65</span> <span style="color: #AFAFAF;">&#25110;</span> <span style="color: #BD93F9;">var</span> ch <span style="color: #AFAFAF;">byte</span> = <span style="color: #FC9F4E;">'\x41'</span>
</pre>
</div>
<p>
（\x 总是紧跟着长度为 2 的 16 进制数）<br>
另外一种可能的写法是 \ 后面紧跟着长度为 3 的八进制数，例如：\377。<br>
不过 Go 同样支持 Unicode（UTF-8），因此字符同样称为 Unicode 代码点或者 runes，并在内存中使用 int 来表示。在文档中，一般使用格式 U+hhhh 来表示，其中 h 表示一个 16 进制数。其实 rune 也是 Go 当中的一个类型，并且是 int32 的别名。<br>
在书写 Unicode 字符时，需要在 16 进制数之前加上前缀 \u 或者 \U。<br>
因为 Unicode 至少占用 2 个字节，所以我们使用 int16 或者 int 类型来表示。如果需要使用到 4 字节，则会加上 \U 前缀；前缀 \u 则总是紧跟着长度为 4 的 16 进制数，前缀 \U 紧跟着长度为 8 的 16 进制数。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #BD93F9;">var</span> <span style="color: #AFAFAF;">ch</span> <span style="color: #AFAFAF;">int</span> = <span style="color: #FC9F4E;">'\u0041'</span>
<span style="color: #BD93F9;">var</span> <span style="color: #AFAFAF;">ch2</span> <span style="color: #AFAFAF;">int</span> = <span style="color: #FC9F4E;">'\u03B2'</span>
<span style="color: #BD93F9;">var</span> <span style="color: #AFAFAF;">ch3</span> <span style="color: #AFAFAF;">int</span> = <span style="color: #FC9F4E;">'\U00101234'</span>
fmt.<span style="color: #AFAFAF;">Printf</span>(<span style="color: #FC9F4E;">"%d - %d - %d\n"</span>, ch, ch2, ch3) <span style="color: #7c7c7c; font-style: italic;">// </span><span style="color: #7c7c7c; font-style: italic;">integer</span>
fmt.<span style="color: #AFAFAF;">Printf</span>(<span style="color: #FC9F4E;">"%c - %c - %c\n"</span>, ch, ch2, ch3) <span style="color: #7c7c7c; font-style: italic;">// </span><span style="color: #7c7c7c; font-style: italic;">character</span>
fmt.<span style="color: #AFAFAF;">Printf</span>(<span style="color: #FC9F4E;">"%X - %X - %X\n"</span>, ch, ch2, ch3) <span style="color: #7c7c7c; font-style: italic;">// </span><span style="color: #7c7c7c; font-style: italic;">UTF-8 bytes</span>
fmt.<span style="color: #AFAFAF;">Printf</span>(<span style="color: #FC9F4E;">"%U - %U - %U"</span>, ch, ch2, ch3) <span style="color: #7c7c7c; font-style: italic;">// </span><span style="color: #7c7c7c; font-style: italic;">UTF-8 code point</span>
</pre>
</div>

<p>
输出：<br>
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #009F9F;">65</span> - <span style="color: #009F9F;">946</span> - <span style="color: #009F9F;">1053236</span>
A - &#946; - r
<span style="color: #009F9F;">41</span> - <span style="color: #009F9F;">3B2</span> - <span style="color: #009F9F;">101234</span>
U+<span style="color: #009F9F;">0041</span> - U+<span style="color: #009F9F;">03B2</span> - U+<span style="color: #009F9F;">101234</span>
</pre>
</div>

<p>
格式化说明符 %c 用于表示字符；当和字符配合使用时，%v 或 %d 会输出用于表示该字符的整数；%U 输出格式为 U+hhhh 的字符串（另一个示例见第 5.4.4 节）。<br>
</p>

<p>
包 unicode 包含了一些针对测试字符的非常有用的函数（其中 ch 代表字符）：<br>
</p>

<p>
判断是否为字母：unicode.IsLetter(ch)<br>
判断是否为数字：unicode.IsDigit(ch)<br>
判断是否为空白符号：unicode.IsSpace(ch)<br>
这些函数返回一个布尔值。包 utf8 拥有更多与 rune 相关的函数。<br>
</p>
</div>
</div>
</div>
</div>
</body>
</html>
