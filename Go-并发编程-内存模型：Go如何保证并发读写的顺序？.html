<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-07-03 Sun 22:53 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Go 并发编程 - 内存模型：GO如何保证并发读写的顺序？</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">Go 并发编程 - 内存模型：GO如何保证并发读写的顺序？</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orga19a29a">引言</a></li>
<li><a href="#orgd2fc05e">重排和可见性的问题</a></li>
<li><a href="#org4a5650c">happens-before</a></li>
<li><a href="#orgb56318d">Go 语言中保证的 happens-before 关系</a>
<ul>
<li><a href="#orgcd4f4df">init 函数</a></li>
<li><a href="#org13f9cd7">goroutine</a></li>
<li><a href="#org206cc14">Channel</a></li>
<li><a href="#orgf2c397c">Mutex/RWMutex</a></li>
<li><a href="#orgbf16ef3">WaitGroup</a></li>
<li><a href="#orgd8babac">Once</a></li>
<li><a href="#org6986760">atomic</a></li>
</ul>
</li>
<li><a href="#orgf9e9aaa">总结</a></li>
</ul>
</div>
</div>

<div id="outline-container-orga19a29a" class="outline-2">
<h2 id="orga19a29a">引言</h2>
<div class="outline-text-2" id="text-orga19a29a">
<p>
Go 官方文档里专门介绍了 Go 的<a href="https://go.dev/ref/mem">内存模型</a>，你不要误解这里的内存模型的含义，它并不是指 Go 对象的内存分配、内存回收和内存整理的规范，它描述的是并发环境中多 goroutine 读相同变量的时候，变量的可见性条件。具体点说，就是指，在什么条件下，goroutine 在读取一个变量的值的时候，能够看到其它 goroutine 对这个变量进行的写的结果。<br>
</p>

<p>
由于 CPU 指令重排和多级 Cache 的存在，保证多核访问同一个变量这件事儿变得非常复杂。毕竟，不同 CPU 架构（x86/amd64、ARM、Power 等）的处理方式也不一样，再加上编译器的优化也可能对指令进行重排，所以编程语言需要一个规范，来明确多线程同时访问同一个变量的可见性和顺序（ Russ Cox 在麻省理工学院 <a href="https://pdos.csail.mit.edu/6.824/">6.824 分布式系统 Distributed Systems</a> 课程 的一课，专门介绍了相关的<a href="http://nil.csail.mit.edu/6.824/2016/notes/gomem.pdf">知识</a>）。在编程语言中，这个规范被叫做内存模型。<br>
</p>

<p>
除了 Go，Java、C++、C、C#、Rust 等编程语言也有内存模型。为什么这些编程语言都要定义内存模型呢？在我看来，主要是两个目的。<br>
</p>

<ul class="org-ul">
<li>向广大的程序员提供一种保证，以便他们在做设计和开发程序时，面对同一个数据同时被多个 goroutine 访问的情况，可以做一些串行化访问的控制，比如使用 Channel 或者 sync 包和 sync/atomic 包中的并发原语。<br></li>
<li>允许编译器和硬件对程序做一些优化。这一点其实主要是为编译器开发者提供的保证，这样可以方便他们对 Go 的编译器做优化。<br></li>
</ul>

<p>
首先，我们要先弄明白重排和可见性的问题，因为它们影响着程序实际执行的顺序关系。<br>
</p>
</div>
</div>
<div id="outline-container-orgd2fc05e" class="outline-2">
<h2 id="orgd2fc05e">重排和可见性的问题</h2>
<div class="outline-text-2" id="text-orgd2fc05e">
<p>
<span class="underline">由于指令重排，代码并不一定会按照你写的顺序执行。</span><br>
</p>

<p>
举个例子，当两个 goroutine 同时对一个数据进行读写时，假设 goroutine g1 对这个变量进行写操作 w，goroutine g2 同时对这个变量进行读操作 r，那么，如果 g2 在执行读操作 r 的时候，已经看到了 g1 写操作 w 的结果，那么，也不意味着 g2 能看到在 w 之前的其它的写操作。这是一个反直观的结果，不过的确可能会存在。<br>
</p>

<p>
接下来，我再举几个具体的例子，带你来感受一下，重排以及多核 CPU 并发执行导致程序的运行和代码的书写顺序不一样的情况。<br>
</p>

<p>
先看第一个例子，代码如下：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">a</span>, <span style="color: #8787d7;">b</span> <span style="color: #df005f; font-weight: bold;">int</span>

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">f</span>() {
    a = 1 <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">w&#20043;&#21069;&#30340;&#20889;&#25805;&#20316;</span>
    b = 2 <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20889;&#25805;&#20316;w</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">g</span>() {
    <span style="color: #268bd2;">print</span>(b) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35835;&#25805;&#20316;r</span>
    <span style="color: #268bd2;">print</span>(a) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">???</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #d75fd7; font-weight: bold;">f</span>() <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">g1</span>
    <span style="color: #d75fd7; font-weight: bold;">g</span>() <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">g2</span>
}
</pre>
</div>

<p>
可以看到，第 9 行是要打印 b 的值。需要注意的是，即使这里打印出的值是 2，但是依然可能在打印 a 的值时，打印出初始值 0，而不是 1。这是因为，程序运行的时候，不能保证 g2 看到的 a 和 b 的赋值有先后关系。<br>
</p>

<p>
再来看一个类似的例子。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">a</span> <span style="color: #df005f; font-weight: bold;">string</span>
<span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">done</span> <span style="color: #df005f; font-weight: bold;">bool</span>

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">setup</span>() {
    a = <span style="color: #2aa198;">"hello, world"</span>
    done = <span style="color: #d75fd7;">true</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #d75fd7; font-weight: bold;">setup</span>()
    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #d75fd7;">!</span>done {
    }
    <span style="color: #268bd2;">print</span>(a)
}
</pre>
</div>

<p>
在这段代码中，主 goroutine main 即使观察到 done 变成 true 了，最后读取到的 a 的值仍然可能为空。<br>
</p>

<p>
更糟糕的情况是，main 根本就观察不到另一个 goroutine 对 done 的写操作，这就会导致 main 程序一直被 hang 住。甚至可能还会出现半初始化的情况，比如：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">T</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    msg <span style="color: #df005f; font-weight: bold;">string</span>
}

<span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">g</span> *<span style="color: #df005f; font-weight: bold;">T</span>

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">setup</span>() {
    <span style="color: #8787d7;">t</span> := <span style="color: #268bd2;">new</span>(<span style="color: #df005f; font-weight: bold;">T</span>)
    t.msg = <span style="color: #2aa198;">"hello, world"</span>
    g = t
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #d75fd7; font-weight: bold;">setup</span>()
    <span style="color: #268bd2; font-weight: bold;">for</span> g == <span style="color: #d75fd7;">nil</span> {
    }
    <span style="color: #268bd2;">print</span>(g.msg)
}
</pre>
</div>

<p>
即使 main goroutine 观察到 g 不为 nil，也可能打印出空的 msg（第 17 行）。<br>
</p>

<p>
看到这里，你可能要说了，我都运行这个程序几百万次了，怎么也没有观察到这种现象？我可以这么告诉你，能不能观察到和提供保证（guarantee）是两码事儿。由于 CPU 架构和 Go 编译器的不同，即使你运行程序时没有遇到这些现象，也不代表 Go 可以 100% 保证不会出现这些问题。<br>
</p>

<p>
刚刚说了，程序在运行的时候，两个操作的顺序可能不会得到保证，那该怎么办呢？接下来，我要带你了解一下 Go 内存模型中很重要的一个概念：happens-before，这是用来描述两个时间的顺序关系的。如果某些操作能提供 happens-before 关系，那么，我们就可以 100% 保证它们之间的顺序。<br>
</p>
</div>
</div>
<div id="outline-container-org4a5650c" class="outline-2">
<h2 id="org4a5650c">happens-before</h2>
<div class="outline-text-2" id="text-org4a5650c">
<p>
<span class="underline">在一个 goroutine 内部，程序的执行顺序和它们的代码指定的顺序是一样的，即使编译器或者 CPU 重排了读写顺序，从行为上来看，也和代码指定的顺序一样。</span><br>
</p>

<p>
这是一个非常重要的保证，我们一定要记住。<br>
</p>

<p>
我们来看一个例子。在下面的代码中，即使编译器或者 CPU 对 a、b、c 的初始化进行了重排，但是打印结果依然能保证是 1、2、3，而不会出现 1、0、0 或 1、0、1 等情况。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">foo</span>() {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">a</span> = 1
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">b</span> = 2
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">c</span> = 3

    <span style="color: #268bd2;">println</span>(a)
    <span style="color: #268bd2;">println</span>(b)
    <span style="color: #268bd2;">println</span>(c)
}
</pre>
</div>

<p>
但是，对于另一个 goroutine 来说，重排却会产生非常大的影响。 <span class="underline">因为 Go 只保证 goroutine 内部重排对读写的顺序没有影响</span> ，比如刚刚我们在讲“可见性”问题时提到的三个例子，那该怎么办呢？这就要用到 happens-before 关系了。<br>
</p>

<p>
如果两个 action（read 或者 write）有明确的 happens-before 关系，你就可以确定它们之间的执行顺序（或者是行为表现上的顺序）。<br>
</p>

<p>
Go 内存模型通过 happens-before 定义两个事件（读、写 action）的顺序：如果事件 e1  happens before 事件 e2，那么，我们就可以说事件 e2 在事件 e1 之后发生（happens after）。如果 e1 不是 happens before e2， 同时也不 happens after e2，那么，我们就可以说事件 e1 和 e2 是同时发生的。<br>
</p>

<p>
如果要保证对“变量 v 的读操作 r”能够观察到一个对“变量 v 的写操作 w”，并且 r 只能观察到 w 对变量 v 的写，没有其它对 v 的写操作，也就是说，我们要保证 r 绝对能观察到 w 操作的结果，那么就需要同时满足两个条件：<br>
</p>

<ol class="org-ol">
<li>w happens before r；<br></li>
<li>其它对 v 的写操作（w2、w3、w4, &#x2026;&#x2026;） 要么 happens before w，要么 happens after r，绝对不会和 w、r 同时发生，或者是在它们之间发生；<br></li>
</ol>

<p>
你可能会说，这是很显然的事情啊，但我要和你说的是，这是一个非常严格、严谨的数学定义。<br>
</p>

<p>
对于单个的 goroutine 来说，它有一个特殊的 happens-before 关系，Go 内存模型中是这么讲的：<br>
</p>

<blockquote>
<p>
Within a single goroutine, the happens-before order is the order expressed by the program.<br>
</p>
</blockquote>

<p>
它的意思是，在单个的 goroutine 内部， happens-before 的关系和代码编写的顺序是一致的。<br>
</p>

<p>
在 goroutine 内部对一个局部变量 v 的读，一定能观察到最近一次对这个局部变量 v 的写。如果要保证多个 goroutine 之间对一个共享变量的读写顺序，在 Go 语言中，可以使用并发原语为读写操作建立 happens-before 关系，这样就可以保证顺序了。<br>
</p>

<p>
说到这儿，我想先给你补充三个 Go 语言中和内存模型有关的小知识，掌握了这些，你就能更好地理解下面的内容。<br>
</p>

<ol class="org-ol">
<li>在 Go 语言中，对变量进行零值的初始化就是一个写操作。<br></li>
<li>如果对超过机器 word（64bit、32bit 或者其它）大小的值进行读写，那么，就可以看作是对拆成 word 大小的几个读写无序进行。<br></li>
<li>Go 并不提供直接的 CPU 屏障（CPU fence）来提示编译器或者 CPU 保证顺序性，而是使用不同架构的内存屏障指令来实现统一的并发原语。<br></li>
</ol>
</div>
</div>
<div id="outline-container-orgb56318d" class="outline-2">
<h2 id="orgb56318d">Go 语言中保证的 happens-before 关系</h2>
<div class="outline-text-2" id="text-orgb56318d">
<p>
除了单个 goroutine 内部提供的 happens-before 保证，Go 语言中还提供了一些其它的 happens-before 关系的保证，下面我来一个一个介绍下。<br>
</p>
</div>
<div id="outline-container-orgcd4f4df" class="outline-3">
<h3 id="orgcd4f4df">init 函数</h3>
<div class="outline-text-3" id="text-orgcd4f4df">
<p>
应用程序的初始化是在单一的 goroutine 执行的。如果包 p 导入了包 q，那么，q 的 init 函数的执行一定 happens before p 的任何初始化代码。<br>
</p>

<p>
这里有一个特殊情况需要你记住： <span class="underline">main 函数一定在导入的包的 init 函数之后执行。</span><br>
</p>

<p>
包级别的变量在同一个文件中是按照声明顺序逐个初始化的，除非初始化它的时候依赖其它的变量。同一个包下的多个文件，会按照文件名的排列顺序进行初始化。这个顺序被定义在<a href="https://golang.org/ref/spec#Program_initialization_and_execution">Go语言规范中</a>，而不是 Go 的内存模型规范中。你可以看看下面的例子中各个变量的值：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">var</span> (
    <span style="color: #8787d7;">a</span> = c + b  <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">== 9</span>
    <span style="color: #8787d7;">b</span> = <span style="color: #d75fd7; font-weight: bold;">f</span>()    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">== 4</span>
    <span style="color: #8787d7;">c</span> = <span style="color: #d75fd7; font-weight: bold;">f</span>()    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">== 5</span>
    <span style="color: #8787d7;">d</span> = 3      <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">== 5 &#20840;&#37096;&#21021;&#22987;&#21270;&#23436;&#25104;&#21518;</span>
)

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">f</span>() <span style="color: #df005f; font-weight: bold;">int</span> {
    d++
    <span style="color: #268bd2; font-weight: bold;">return</span> d
} 
</pre>
</div>

<p>
具体怎么对这些变量进行初始化呢？Go 采用的是依赖分析技术。不过，依赖分析技术保证的顺序只是针对同一包下的变量，而且，只有引用关系是本包变量、函数和非接口的方法，才能保证它们的顺序性。<br>
</p>

<p>
同一个包下可以有多个 init 函数，甚至一个文件中也可以包含多个相同签名的 init 函数。<br>
</p>

<p>
刚刚讲的这些都是不同包的 init 函数执行顺序，下面我举一个具体的例子，把这些内容串起来，你一看就明白了。<br>
</p>

<p>
这个例子是一个 main 程序，它依赖包 p1，包 p1 依赖包 p2，包 p2 依赖 p3。<br>
</p>

<div class="div-center">
<img src="./images/Go-并发编程-init初始化.webp" width="620px" />
</div>

<p>
包 p3 包含两个文件，分别定义了一个 init 函数。第一个文件中定义了两个变量，这两个变量的值还会在 init 函数中进行修改。<br>
</p>

<p>
我们来分别看下包 p3 的这两个文件：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">lib1.go in p3</span>

<span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">V1_p3</span> = trace.<span style="color: #d75fd7; font-weight: bold;">Trace</span>(<span style="color: #2aa198;">"init v1_p3"</span>, 3)
<span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">V2_p3</span> = trace.<span style="color: #d75fd7; font-weight: bold;">Trace</span>(<span style="color: #2aa198;">"init v2_p3"</span>, 3)


<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">init</span>() {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"init func in p3"</span>)
    V1_p3 = 300
    V2_p3 = 300
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">lib2.go in p3</span>

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">init</span>() {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"another init func in p3"</span>)
} 
</pre>
</div>

<p>
下面再来看看包 p2。包 p2 定义了变量和 init 函数。第一个变量初始化为 2，并在 init 函数中更改为 200。第二个变量是复制的 p3.V2_p3。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">V1_p2</span> = trace.<span style="color: #d75fd7; font-weight: bold;">Trace</span>(<span style="color: #2aa198;">"init v1_p2"</span>, 2)
<span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">V2_p2</span> = trace.<span style="color: #d75fd7; font-weight: bold;">Trace</span>(<span style="color: #2aa198;">"init v2_p2"</span>, p3.V2_p3)

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">init</span>() {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"init func in p2"</span>)
    V1_p2 = 200
}
</pre>
</div>

<p>
包 p1 定义了变量和 init 函数。它的两个变量的值是复制的 p2 对应的两个变量值。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">V1_p1</span> = trace.<span style="color: #d75fd7; font-weight: bold;">Trace</span>(<span style="color: #2aa198;">"init v1_p1"</span>, p2.V1_p2)
<span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">V2_p1</span> = trace.<span style="color: #d75fd7; font-weight: bold;">Trace</span>(<span style="color: #2aa198;">"init v2_p1"</span>, p2.V2_p2)

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">init</span>() {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"init func in p1"</span>)
}
</pre>
</div>

<p>
main 定义了 init 函数和 main 函数。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">init</span>() {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"init func in main"</span>)
}


<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"V1_p1:"</span>, p1.V1_p1)
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"V2_p1:"</span>, p1.V2_p1)
}
</pre>
</div>

<p>
运行 main 函数会依次输出 p3、p2、p1、main 的初始化变量时的日志（变量初始化时的日志和 init 函数调用时的日志）：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21253;p3&#30340;&#21464;&#37327;&#21021;&#22987;&#21270;</span>
init <span style="color: #df005f; font-weight: bold;">v1_p3</span> : 3
init <span style="color: #df005f; font-weight: bold;">v2_p3</span> : 3
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">p3&#30340;init&#20989;&#25968;</span>
init <span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">in</span> <span style="color: #df005f; font-weight: bold;">p3</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">p3&#30340;&#21478;&#19968;&#20010;init&#20989;&#25968; </span>
another <span style="color: #df005f; font-weight: bold;">init</span> <span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">in</span> <span style="color: #df005f; font-weight: bold;">p3</span>

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21253;p2&#30340;&#21464;&#37327;&#21021;&#22987;&#21270;</span>
init <span style="color: #df005f; font-weight: bold;">v1_p2</span> : 2
init <span style="color: #df005f; font-weight: bold;">v2_p2</span> : 300
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21253;p2&#30340;init&#20989;&#25968;</span>
init <span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">in</span> <span style="color: #df005f; font-weight: bold;">p2</span>

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21253;p1&#30340;&#21464;&#37327;&#21021;&#22987;&#21270;</span>
init <span style="color: #df005f; font-weight: bold;">v1_p1</span> : 200
init <span style="color: #df005f; font-weight: bold;">v2_p1</span> : 300
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21253;p1&#30340;init&#20989;&#25968;</span>
init <span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">in</span> <span style="color: #df005f; font-weight: bold;">p1</span>

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21253;main&#30340;init&#20989;&#25968;</span>
init <span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">in</span> <span style="color: #df005f; font-weight: bold;">main</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">main&#20989;&#25968;</span>
<span style="color: #d75fd7;">V1_p1</span>: 200
<span style="color: #d75fd7;">V2_p1</span>: 300
</pre>
</div>

<p>
下面，我们再来看看 goroutine 对 happens-before 关系的保证情况。<br>
</p>
</div>
</div>
<div id="outline-container-org13f9cd7" class="outline-3">
<h3 id="org13f9cd7">goroutine</h3>
<div class="outline-text-3" id="text-org13f9cd7">
<p>
首先，我们需要明确一个规则：启动 goroutine 的 go 语句的执行，一定 happens before 此 goroutine 内的代码执行。<br>
</p>

<p>
根据这个规则，我们就可以知道，如果 go 语句传入的参数是一个函数执行的结果，那么，这个函数一定先于 goroutine 内部的代码被执行。<br>
</p>

<p>
我们来看一个例子。在下面的代码中，第 8 行 a 的赋值和第 9 行的 go 语句是在同一个 goroutine 中执行的，所以，在主 goroutine 看来，第 8 行肯定 happens before 第 9 行，又由于刚才的保证，第 9 行子 goroutine 的启动 happens before 第 4 行的变量输出，那么，我们就可以推断出，第 8 行 happens before 第 4 行。也就是说，在第 4 行打印 a 的值的时候，肯定会打印出“hello world”。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">a</span> <span style="color: #df005f; font-weight: bold;">string</span>

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">f</span>() {
    <span style="color: #268bd2;">print</span>(a)
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">hello</span>() {
    a = <span style="color: #2aa198;">"hello, world"</span>
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #d75fd7; font-weight: bold;">f</span>()
}
</pre>
</div>

<p>
刚刚说的是启动 goroutine 的情况，goroutine 退出的时候，是没有任何 happens-before 保证的。所以，如果你想观察某个 goroutine 的执行效果，你需要使用同步机制建立 happens-before 关系，比如 Mutex 或者 Channel。接下来，我会讲 Channel 的 happens-before 的关系保证。<br>
</p>
</div>
</div>
<div id="outline-container-org206cc14" class="outline-3">
<h3 id="org206cc14">Channel</h3>
<div class="outline-text-3" id="text-org206cc14">
<p>
Channel 是 goroutine 同步交流的主要方法。往一个 Channel 中发送一条数据，通常对应着另一个 goroutine 从这个 Channel 中接收一条数据。<br>
</p>

<p>
通用的 Channel happens-before 关系保证有 4 条规则，我分别来介绍下。<br>
</p>

<p>
<b>第 1 条规则是</b> ，往 Channel 中的发送操作，happens before 从该 Channel 接收相应数据的动作完成之前，即第 n 个 send 一定 happens before 第 n 个 receive 的完成。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">ch</span> = <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}, 10) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">buffered&#25110;&#32773;unbuffered</span>
<span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">s</span> <span style="color: #df005f; font-weight: bold;">string</span>

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">f</span>() {
    s = <span style="color: #2aa198;">"hello, world"</span>
    ch &lt;- <span style="color: #268bd2; font-weight: bold;">struct</span>{}{}
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #d75fd7; font-weight: bold;">f</span>()
    &lt;-ch
    <span style="color: #268bd2;">print</span>(s)
}
</pre>
</div>

<p>
在这个例子中，s 的初始化（第 5 行）happens before 往 ch 中发送数据， 往 ch 发送数据 happens before 从 ch 中读取出一条数据（第 11 行），第 12 行打印 s 的值 happens after 第 11 行，所以，打印的结果肯定是初始化后的 s 的值“hello world”。<br>
</p>

<p>
<b>第 2 条规则是</b> ，close 一个 Channel 的调用，肯定 happens before 从关闭的 Channel 中读取出一个零值。<br>
</p>

<p>
还是拿刚刚的这个例子来说，如果你把第 6 行替换成 close(ch)，也能保证同样的执行顺序。因为第 11 行从关闭的 ch 中读取出零值后，第 6 行肯定被调用了。<br>
</p>

<p>
<b>第 3 条规则是</b> ，对于 unbuffered 的 Channel，也就是容量是 0 的 Channel，从此 Channel 中读取数据的调用一定 happens before 往此 Channel 发送数据的调用完成。<br>
</p>

<p>
所以，在上面的这个例子中呢，如果想保持同样的执行顺序，也可以写成这样：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">ch</span> = <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">int</span>)
<span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">s</span> <span style="color: #df005f; font-weight: bold;">string</span>

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">f</span>() {
    s = <span style="color: #2aa198;">"hello, world"</span>
    &lt;-ch
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #d75fd7; font-weight: bold;">f</span>()
    ch &lt;- <span style="color: #268bd2; font-weight: bold;">struct</span>{}{}
    <span style="color: #268bd2;">print</span>(s)
}
</pre>
</div>

<p>
如果第 11 行发送语句执行成功（完毕），那么根据这个规则，第 6 行（接收）的调用肯定发生了（执行完成不完成不重要，重要的是这一句“肯定执行了”），那么 s 也肯定初始化了，所以一定会打印出“hello world”。<br>
</p>

<p>
这一条比较晦涩，但是，因为 Channel 是 unbuffered 的 Channel，所以这个规则也成立。<br>
</p>

<p>
<b>第 4 条规则是</b> ，如果 Channel 的容量是 m（m&gt;0），那么，第 n 个 receive 一定 happens before 第 n+m 个 send 的完成。<br>
</p>

<p>
前一条规则是针对 unbuffered channel 的，这里给出了更广泛的针对 buffered channel 的保证。利用这个规则，我们可以实现信号量（Semaphore）的并发原语。Channel 的容量相当于可用的资源，发送一条数据相当于请求信号量，接收一条数据相当于释放信号。<br>
</p>
</div>
</div>
<div id="outline-container-orgf2c397c" class="outline-3">
<h3 id="orgf2c397c">Mutex/RWMutex</h3>
<div class="outline-text-3" id="text-orgf2c397c">
<p>
对于互斥锁 Mutex m 或者读写锁 RWMutex m，有 3 条 happens-before 关系的保证。<br>
</p>

<ol class="org-ol">
<li>第 n 次的 m.Unlock 一定 happens before 第 n+1 m.Lock 方法的返回；<br></li>
<li>对于读写锁 RWMutex m，如果它的第 n 个 m.Lock 方法的调用已返回，那么它的第 n 个 m.Unlock 的方法调用一定 happens before 任何一个 m.RLock 方法调用的返回，只要这些 m.RLock 方法调用 happens after 第 n 次 m.Lock 的调用的返回。这就可以保证，只有释放了持有的写锁，那些等待的读请求才能请求到读锁。<br></li>
<li>对于读写锁 RWMutex m，如果它的第 n 个 m.RLock 方法的调用已返回，那么它的第 k （k&lt;=n）个成功的 m.RUnlock 方法的返回一定 happens before 任意的 m.RUnlockLock 方法调用，只要这些 m.Lock 方法调用 happens after 第 n 次 m.RLock。<br></li>
</ol>

<p>
读写锁的保证有点绕，来看看官方的描述：<br>
</p>

<blockquote>
<p>
对于读写锁 l 的 l.RLock 方法调用，如果存在一个 n，这次的 l.RLock 调用 happens after 第 n 次的 l.Unlock，那么，和这个 RLock 相对应的 l.RUnlock 一定 happens before 第 n+1 次 l.Lock。意思是，读写锁的 Lock 必须等待既有的读锁释放后才能获取到。<br>
</p>
</blockquote>

<p>
再举个例子。在下面的代码中，第 6 行第一次的 Unlock 一定 happens before 第二次的 Lock（第 12 行），所以这也能保证正确地打印出“hello world”。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">mu</span> <span style="color: #df005f; font-weight: bold;">sync.Mutex</span>
<span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">s</span> <span style="color: #df005f; font-weight: bold;">string</span>

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">foo</span>() {
    s = <span style="color: #2aa198;">"hello, world"</span>
    mu.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    mu.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #d75fd7; font-weight: bold;">foo</span>()
    mu.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
    <span style="color: #268bd2;">print</span>(s)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbf16ef3" class="outline-3">
<h3 id="orgbf16ef3">WaitGroup</h3>
<div class="outline-text-3" id="text-orgbf16ef3">
<p>
接下来是 WaitGroup 的保证。<br>
</p>

<p>
对于一个 WaitGroup 实例 wg，在某个时刻 t0 时，它的计数值已经不是零了，假如 t0 时刻之后调用了一系列的 wg.Add(n) 或者 wg.Done()，并且只有最后一次调用 wg 的计数值变为了 0，那么，可以保证这些 wg.Add 或者 wg.Done() 一定 happens before t0 时刻之后调用的 wg.Wait 方法的返回。<br>
</p>

<p>
这个保证的通俗说法，就是 Wait 方法等到计数值归零之后才返回。<br>
</p>
</div>
</div>
<div id="outline-container-orgd8babac" class="outline-3">
<h3 id="orgd8babac">Once</h3>
<div class="outline-text-3" id="text-orgd8babac">
<p>
Once 提供的保证是：对于 once.Do(f) 调用，f 函数的那个单次调用一定 happens before 任何 once.Do(f) 调用的返回。换句话说，就是函数 f 一定会在 Do 方法返回之前执行。<br>
</p>

<p>
还是以 hello world 的例子为例，这次我们使用 Once 并发原语实现，可以看下下面的代码：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">s</span> <span style="color: #df005f; font-weight: bold;">string</span>
<span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">once</span> <span style="color: #df005f; font-weight: bold;">sync.Once</span>

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">foo</span>() {
    s = <span style="color: #2aa198;">"hello, world"</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">twoprint</span>() {
    once.<span style="color: #d75fd7; font-weight: bold;">Do</span>(foo)
    <span style="color: #268bd2;">print</span>(s)
}
</pre>
</div>

<p>
第 5 行的执行一定 happens before 第 9 行的返回，所以执行到第 10 行的时候，sd 已经初始化了，所以会正确地打印“hello world”。<br>
</p>
</div>
</div>
<div id="outline-container-org6986760" class="outline-3">
<h3 id="org6986760">atomic</h3>
<div class="outline-text-3" id="text-org6986760">
<p>
其实，Go 内存模型的官方文档并没有明确给出 atomic 的保证，有一个相关的 issue <a href="https://github.com/golang/go/issues/5045">go# 5045</a> 记录了相关的讨论。光看 issue 号，就知道这个讨论由来已久了。Russ Cox 想让 atomic 有一个弱保证，这样可以为以后留下充足的可扩展空间，所以，Go 内存模型规范上并没有严格的定义。<br>
</p>

<p>
对于 Go 1.15 的官方实现来说，可以保证使用 atomic 的 Load/Store 的变量之间的顺序性。<br>
</p>

<p>
在下面的例子中，打印出的 a 的结果总是 1，但是官方并没有做任何文档上的说明和保证。<br>
</p>

<p>
依照 Ian Lance Taylor 的说法，Go 核心开发组的成员几乎没有关注这个方向上的研究，因为这个问题太复杂，有很多问题需要去研究，所以，现阶段还是不要使用 atomic 来保证顺序性。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">a</span>, <span style="color: #8787d7;">b</span> <span style="color: #df005f; font-weight: bold;">int32</span> = 0, 0

    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
        atomic.<span style="color: #d75fd7; font-weight: bold;">StoreInt32</span>(&amp;a, 1)
        atomic.<span style="color: #d75fd7; font-weight: bold;">StoreInt32</span>(&amp;b, 1)
    }()

    <span style="color: #268bd2; font-weight: bold;">for</span> atomic.<span style="color: #d75fd7; font-weight: bold;">LoadInt32</span>(&amp;b) == <span style="color: #df005f; font-weight: bold;">0</span>{
        runtime.<span style="color: #d75fd7; font-weight: bold;">Gosched</span>()
    }
        fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(atomic.<span style="color: #d75fd7; font-weight: bold;">LoadInt32</span>(&amp;a))
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf9e9aaa" class="outline-2">
<h2 id="orgf9e9aaa">总结</h2>
<div class="outline-text-2" id="text-orgf9e9aaa">
<p>
Go 的内存模型规范中，一开始有这么一段话：<br>
</p>

<blockquote>
<p>
If you must read the rest of this document to understand the behavior of your program, you are being too clever.<br>
</p>

<p>
Don't be clever.<br>
</p>
</blockquote>

<p>
我来说说我对这句话的理解：你通过学习这节课来理解你的程序的行为是聪明的，但是，不要自作聪明。<br>
</p>

<p>
谨慎地使用这些保证，能够让你的程序按照设想的 happens-before 关系执行，但是不要以为完全理解这些概念和保证，就可以随意地制造所谓的各种技巧，否则就很容易掉进“坑”里，而且会给代码埋下了很多的“定时炸弹”。<br>
</p>

<p>
比如，Go 里面已经有值得信赖的互斥锁了，如果没有额外的需求，就不要使用 Channel 创造出自己的互斥锁。<br>
</p>

<p>
当然，我也不希望你畏手畏脚地把思想局限住，我还是建议你去做一些有意义的尝试，比如使用 Channel 实现信号量等扩展并发原语。<br>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-07-03 Sun 22:53</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
