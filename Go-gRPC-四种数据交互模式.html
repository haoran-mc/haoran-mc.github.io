<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-07-18 Mon 15:54 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>GRPC四种数据交互模式</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">GRPC四种数据交互模式</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgece3ab7">一、简单模式</a></li>
<li><a href="#org2554e39">二、服务端流模式</a>
<ul>
<li><a href="#orgf98a92d">服务接口定义</a></li>
<li><a href="#org1905cb2">编译.proto文件，生成pb.go文件</a></li>
<li><a href="#org4c2c7e6">自动生成文件的变化</a>
<ul>
<li><a href="#orgcc5cd19">服务端自动生成</a></li>
<li><a href="#orge45d3d4">客户端自动生成</a></li>
</ul>
</li>
<li><a href="#org9cad6f9">服务编码实现</a></li>
<li><a href="#org81cde17">服务的注册和监听的处理</a></li>
<li><a href="#org3934711">客户端数据接收</a></li>
</ul>
</li>
<li><a href="#org1490fa1">三、客户端流模式</a></li>
<li><a href="#org0fcf84b">四、双向流模式</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgece3ab7" class="outline-2">
<h2 id="orgece3ab7">一、简单模式</h2>
<div class="outline-text-2" id="text-orgece3ab7">
<p>
在上面客户端与服务端之间通过消息结构体定义的方式来传递数据，我们称之为“单项RPC”，也称之为简单模式。除此之外，gRPC中还有数据流模式的RPC调用实现。<br>
</p>
</div>
</div>
<div id="outline-container-org2554e39" class="outline-2">
<h2 id="org2554e39">二、服务端流模式</h2>
<div class="outline-text-2" id="text-org2554e39">
<p>
在服务端流模式的RPC实现中，服务端得到客户端请求后，处理结束返回一个数据应答流。在发送完所有的客户端请求的应答数据后，服务端的状态详情和可选的跟踪元数据发送给客户端。服务端流RPC实现案例如下：<br>
</p>
</div>
<div id="outline-container-orgf98a92d" class="outline-3">
<h3 id="orgf98a92d">服务接口定义</h3>
<div class="outline-text-3" id="text-orgf98a92d">
<p>
在.proto文件中定义服务接口,使用服务端流模式定义服务接口,如下所示：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">...</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35746;&#21333;&#26381;&#21153;service&#23450;&#20041;</span>
service <span style="color: #df005f; font-weight: bold;">OrderService</span> {
    rpc <span style="color: #df005f; font-weight: bold;">GetOrderInfos</span> (OrderRequest) <span style="color: #df005f; font-weight: bold;">returns</span> (stream <span style="color: #df005f; font-weight: bold;">OrderInfo</span>) {};   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#26381;&#21153;&#31471;&#27969;&#27169;&#24335;</span>
}
</pre>
</div>

<p>
我们可以看到与之前简单模式下的数据作为服务接口的参数和返回值不同的是，此处服务接口的返回值使用了stream进行修饰。通过stream修饰的方式表示该接口调用时，服务端会以数据流的形式将数据返回给客户端。<br>
</p>
</div>
</div>
<div id="outline-container-org1905cb2" class="outline-3">
<h3 id="org1905cb2">编译.proto文件，生成pb.go文件</h3>
<div class="outline-text-3" id="text-org1905cb2">
<p>
使用gRPC插件编译命令编译.proto文件，编译命令如下:<br>
</p>

<div class="org-src-container">
<pre class="src src-go">protoc --go_out=plugins=grpc:. message.proto
</pre>
</div>
</div>
</div>
<div id="outline-container-org4c2c7e6" class="outline-3">
<h3 id="org4c2c7e6">自动生成文件的变化</h3>
<div class="outline-text-3" id="text-org4c2c7e6">
<p>
与数据结构体发送携带数据实现不同的时，流模式下的数据发送和接收使用新的功能方法完成。在自动生成的go代码程序当中，每一个流模式对应的服务接口，都会自动生成对应的单独的client和server程序，以及对应的结构体实现。具体编程如下图所示：<br>
</p>
</div>
<div id="outline-container-orgcc5cd19" class="outline-4">
<h4 id="orgcc5cd19">服务端自动生成</h4>
<div class="outline-text-4" id="text-orgcc5cd19">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">OrderService_GetOrderInfosServer</span> <span style="color: #268bd2; font-weight: bold;">interface</span> {
    <span style="color: #d75fd7; font-weight: bold;">Send</span>(*<span style="color: #df005f; font-weight: bold;">OrderInfo</span>) <span style="color: #df005f; font-weight: bold;">error</span>
    grpc.ServerStream
}

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">orderServiceGetOrderInfosServer</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    grpc.ServerStream
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">x</span> *<span style="color: #df005f; font-weight: bold;">orderServiceGetOrderInfosServer</span>) <span style="color: #d75fd7; font-weight: bold;">Send</span>(<span style="color: #8787d7;">m</span> *<span style="color: #df005f; font-weight: bold;">OrderInfo</span>) <span style="color: #df005f; font-weight: bold;">error</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> x.ServerStream.<span style="color: #d75fd7; font-weight: bold;">SendMsg</span>(m)
}
</pre>
</div>

<p>
流模式下，服务接口的服务端提供Send方法，将数据以流的形式进行发送。<br>
</p>
</div>
</div>
<div id="outline-container-orge45d3d4" class="outline-4">
<h4 id="orge45d3d4">客户端自动生成</h4>
<div class="outline-text-4" id="text-orge45d3d4">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">OrderService_GetOrderInfosClient</span> <span style="color: #268bd2; font-weight: bold;">interface</span> {
    <span style="color: #d75fd7; font-weight: bold;">Recv</span>() (*<span style="color: #df005f; font-weight: bold;">OrderInfo</span>, <span style="color: #df005f; font-weight: bold;">error</span>)
    grpc.ClientStream
}

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">orderServiceGetOrderInfosClient</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    grpc.ClientStream
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">x</span> *<span style="color: #df005f; font-weight: bold;">orderServiceGetOrderInfosClient</span>) <span style="color: #d75fd7; font-weight: bold;">Recv</span>() (*<span style="color: #df005f; font-weight: bold;">OrderInfo</span>, <span style="color: #df005f; font-weight: bold;">error</span>) {
    <span style="color: #8787d7;">m</span> := <span style="color: #268bd2;">new</span>(<span style="color: #df005f; font-weight: bold;">OrderInfo</span>)
    <span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #8787d7;">err</span> := x.ClientStream.<span style="color: #d75fd7; font-weight: bold;">RecvMsg</span>(m); err != <span style="color: #d75fd7;">nil</span> {
        <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">nil</span>, err
    }
    <span style="color: #268bd2; font-weight: bold;">return</span> m, <span style="color: #d75fd7;">nil</span>
}
</pre>
</div>

<p>
流模式下，服务接口的客户端提供Recv()方法接收服务端发送的流数据。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org9cad6f9" class="outline-3">
<h3 id="org9cad6f9">服务编码实现</h3>
<div class="outline-text-3" id="text-org9cad6f9">
<p>
定义好服务接口并编译生成代码文件后，即可根据规则对定义的服务进行编码实现。具体的服务编码实现如下所示：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#35746;&#21333;&#26381;&#21153;&#23454;&#29616;</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">OrderServiceImpl</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
}

<span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#33719;&#21462;&#35746;&#21333;&#20449;&#24687;s</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">os</span> *<span style="color: #df005f; font-weight: bold;">OrderServiceImpl</span>) <span style="color: #d75fd7; font-weight: bold;">GetOrderInfos</span>(<span style="color: #8787d7;">request</span> *<span style="color: #df005f; font-weight: bold;">message.OrderRequest</span>, <span style="color: #8787d7;">stream</span> <span style="color: #df005f; font-weight: bold;">message.OrderService_GetOrderInfosServer</span>) <span style="color: #df005f; font-weight: bold;">error</span> {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">" &#26381;&#21153;&#31471;&#27969; RPC &#27169;&#24335;"</span>)

    <span style="color: #8787d7;">orderMap</span> := <span style="color: #268bd2; font-weight: bold;">map</span>[<span style="color: #df005f; font-weight: bold;">string</span>]<span style="color: #df005f; font-weight: bold;">message.OrderInfo</span>{
        <span style="color: #2aa198;">"202111080001"</span>: <span style="color: #df005f; font-weight: bold;">message.OrderInfo</span>{<span style="color: #d75fd7;">OrderId</span>: <span style="color: #2aa198;">"202111080001"</span>, <span style="color: #d75fd7;">OrderName</span>: <span style="color: #2aa198;">"&#34915;&#26381;"</span>, <span style="color: #d75fd7;">OrderStatus</span>: <span style="color: #2aa198;">"&#24050;&#20184;&#27454;"</span>},
        <span style="color: #2aa198;">"202111080002"</span>: <span style="color: #df005f; font-weight: bold;">message.OrderInfo</span>{<span style="color: #d75fd7;">OrderId</span>: <span style="color: #2aa198;">"202111080002"</span>, <span style="color: #d75fd7;">OrderName</span>: <span style="color: #2aa198;">"&#38646;&#39135;"</span>, <span style="color: #d75fd7;">OrderStatus</span>: <span style="color: #2aa198;">"&#24050;&#20184;&#27454;"</span>},
        <span style="color: #2aa198;">"202111080003"</span>: <span style="color: #df005f; font-weight: bold;">message.OrderInfo</span>{<span style="color: #d75fd7;">OrderId</span>: <span style="color: #2aa198;">"202111080003"</span>, <span style="color: #d75fd7;">OrderName</span>: <span style="color: #2aa198;">"&#39135;&#21697;"</span>, <span style="color: #d75fd7;">OrderStatus</span>: <span style="color: #2aa198;">"&#26410;&#20184;&#27454;"</span>},
    }
    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">id</span>, <span style="color: #8787d7;">info</span> := <span style="color: #268bd2; font-weight: bold;">range</span> orderMap {
        <span style="color: #268bd2; font-weight: bold;">if</span> (time.<span style="color: #d75fd7; font-weight: bold;">Now</span>().<span style="color: #d75fd7; font-weight: bold;">Unix</span>() &gt;= request.TimeStamp) {
            fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"&#35746;&#21333;&#24207;&#21015;&#21495;ID&#65306;"</span>, id)
            fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"&#35746;&#21333;&#35814;&#24773;&#65306;"</span>, info)
            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36890;&#36807;&#27969;&#27169;&#24335;&#21457;&#36865;&#32473;&#23458;&#25143;&#31471;</span>
            stream.<span style="color: #d75fd7; font-weight: bold;">Send</span>(&amp;info)
        }
    }
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">nil</span>
}
</pre>
</div>

<p>
GetOrderInfos方法就是服务接口的具体实现，因为是流模式开发，服务端将数据以流的形式进行发送,因此，该方法的第二个参数类型为OrderService_GetOrderInfosServer，该参数类型是一个接口，其中包含Send方法，允许发送流数据。Send方法的具体实现在编译好的pb.go文件中，进一步调用grpc.SeverStream.SendMsg方法。<br>
</p>
</div>
</div>
<div id="outline-container-org81cde17" class="outline-3">
<h3 id="org81cde17">服务的注册和监听的处理</h3>
<div class="outline-text-3" id="text-org81cde17">
<p>
服务的监听与处理与前文所学内容没有区别，依然是相同的步骤:<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">server</span> := grpc.<span style="color: #d75fd7; font-weight: bold;">NewServer</span>()
    <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#27880;&#20876;</span>
    message.<span style="color: #d75fd7; font-weight: bold;">RegisterOrderServiceServer</span>(server, <span style="color: #268bd2;">new</span>(<span style="color: #df005f; font-weight: bold;">OrderServiceImpl</span>))
    <span style="color: #8787d7;">lis</span>, <span style="color: #8787d7;">err</span> := net.<span style="color: #d75fd7; font-weight: bold;">Listen</span>(<span style="color: #2aa198;">"tcp"</span>, <span style="color: #2aa198;">":8090"</span>)
    <span style="color: #268bd2; font-weight: bold;">if</span> err != <span style="color: #d75fd7;">nil</span> {
        <span style="color: #268bd2;">panic</span>(err.<span style="color: #d75fd7; font-weight: bold;">Error</span>())
    }
    server.<span style="color: #d75fd7; font-weight: bold;">Serve</span>(lis)
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org3934711" class="outline-3">
<h3 id="org3934711">客户端数据接收</h3>
<div class="outline-text-3" id="text-org3934711">
<p>
服务端使用Send方法将数据以流的形式进行发送，客户端可以使用Recv()方法接收流数据,因为数据流失源源不断的，因此使用for无限循环实现数据流的读取，当读取到io.EOF时，表示流数据结束。客户端数据读取实现如下：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">...</span>
<span style="color: #268bd2; font-weight: bold;">for</span> {
    <span style="color: #8787d7;">orderInfo</span>, <span style="color: #8787d7;">err</span> := orderInfoClient.<span style="color: #d75fd7; font-weight: bold;">Recv</span>()
    <span style="color: #268bd2; font-weight: bold;">if</span> err == io.EOF {
        fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"&#35835;&#21462;&#32467;&#26463;"</span>)
        <span style="color: #268bd2; font-weight: bold;">return</span>
    }
    <span style="color: #268bd2; font-weight: bold;">if</span> err != <span style="color: #d75fd7;">nil</span> {
        <span style="color: #268bd2;">panic</span>(err.<span style="color: #d75fd7; font-weight: bold;">Error</span>())
    }
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"&#35835;&#21462;&#21040;&#30340;&#20449;&#24687;&#65306;"</span>, orderInfo)
}
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">...</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org1490fa1" class="outline-2">
<h2 id="org1490fa1">三、客户端流模式</h2>
</div>
<div id="outline-container-org0fcf84b" class="outline-2">
<h2 id="org0fcf84b">四、双向流模式</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2021-11-08 08:11 Mon</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-07-18 Mon 15:54</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
