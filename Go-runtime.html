<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-02-14 Mon 23:41 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>RUNTIME</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">RUNTIME</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org2075b6f">Introduction</a></li>
<li><a href="#orgba1b328">Environment Variables</a></li>
<li><a href="#orgb88fbb6">Constants</a></li>
<li><a href="#orgdf65f92">Variables</a></li>
<li><a href="#org52161e7">type Error</a></li>
<li><a href="#orgacb7462">type TypeAssertionError</a>
<ul>
<li><a href="#org260111d">func (*TypeAssertionError) Error</a></li>
<li><a href="#orgc5cc69d">func (*TypeAssertionError) RuntimeError</a></li>
</ul>
</li>
<li><a href="#org91cfca3">func GOROOT</a></li>
<li><a href="#org0bd13e4">func Version</a></li>
<li><a href="#orgcb9d60b">func NumCPU</a></li>
<li><a href="#org5b6b9a1">func GOMAXPROCS</a></li>
<li><a href="#orgbdbda59">func SetCPUProfileRate</a></li>
<li><a href="#org58d3688">func CPUProfile</a></li>
<li><a href="#org37d85ce">func GC</a></li>
<li><a href="#orgbfc8027">func SetFinalizer</a></li>
<li><a href="#org7e28848">type MemStats</a></li>
<li><a href="#org97421bf">func ReadMemStats</a></li>
<li><a href="#org99c809c">type MemProfileRecord</a>
<ul>
<li><a href="#org1d61b39">func (*MemProfileRecord) InUseBytes</a></li>
<li><a href="#org25a66ef">func (*MemProfileRecord) InUseObjects</a></li>
<li><a href="#org2829929">func (*MemProfileRecord) Stack</a></li>
</ul>
</li>
<li><a href="#org64c443c">func MemProfile</a></li>
<li><a href="#org1d45596">func Breakpoint</a></li>
<li><a href="#orgc9cb069">func Stack</a></li>
<li><a href="#org772771b">func Caller</a></li>
<li><a href="#orga6f5977">func Callers</a></li>
<li><a href="#org7de0909">type StackRecord</a>
<ul>
<li><a href="#orgaf501f2">func (*StackRecord) Stack</a></li>
</ul>
</li>
<li><a href="#org6a8c033">type Func</a>
<ul>
<li><a href="#org9c57b3d">func FuncForPC</a></li>
<li><a href="#org387be5e">func (*Func) Name</a></li>
<li><a href="#org719a301">func (*Func) FileLine</a></li>
<li><a href="#orgb405960">func (*Func) Entry</a></li>
</ul>
</li>
<li><a href="#org448a65d">func NumCgoCall</a></li>
<li><a href="#org37a43ab">func NumGoroutine</a></li>
<li><a href="#org7cb9275">func Goexit</a></li>
<li><a href="#org6e14fce">func Gosched</a></li>
<li><a href="#orgc63b9a4">func GoroutineProfile</a></li>
<li><a href="#orge418fcd">func LockOSThread</a></li>
<li><a href="#org3e67aa3">func UnlockOSThread</a></li>
<li><a href="#orgf7a16df">func ThreadCreateProfile</a></li>
<li><a href="#orga0b3b1d">type BlockProfileRecord</a></li>
<li><a href="#org036bef4">func SetBlockProfileRate</a></li>
<li><a href="#org40132e4">func BlockProfile</a></li>
</ul>
</div>
</div>

<div id="outline-container-org2075b6f" class="outline-2">
<h2 id="org2075b6f">Introduction</h2>
<div class="outline-text-2" id="text-org2075b6f">
<p>
runtime包提供和go运行时环境的互操作，如控制go程的函数。它也包括用于reflect包的低层次类型信息；参见reflect报的文档获取运行时类型系统的可编程接口。<br>
</p>
</div>
</div>

<div id="outline-container-orgba1b328" class="outline-2">
<h2 id="orgba1b328">Environment Variables</h2>
<div class="outline-text-2" id="text-orgba1b328">
<p>
下面的环境变量（$name或%name%，这依赖于主机的操作系统）控制go程序的运行时行为。它们的含义和用法可能在各发行版之间改变。<br>
</p>

<p>
环境变量GOGC设置最初的垃圾收集目标百分比。当新申请的数据和前次垃圾收集剩下的存活数据的比率达到该百分比时，就会触发垃圾收集。默认GOGC=100。设置GOGC=off 会完全关闭垃圾收集。runtime/debug包的SetGCPercent函数允许在运行时修改该百分比。参见<a href="http://golang.org/pkg/runtime/debug/#SetGCPercent">http://golang.org/pkg/runtime/debug/#SetGCPercent</a><br>
</p>

<p>
环境变量GODEBUG控制运行时的debug输出。GODEBUG的值是逗号分隔的name=val对。支持的name如下：<br>
</p>

<p>
allocfreetrace: 设置其为1，会导致每次分配都会被记录剖面，会记录每一个对象的分配、释放<br>
及其堆栈踪迹。<br>
efence: 设置其为1，会导致分配器运行模式为：每个对象申请在独立的页和地址，且永不循环利用。<br>
gctrace: 设置其为1，会导致垃圾收集器每次收集都向标准错误输出写入单行的数据，概述收集的总<br>
内存的大小和暂停的总时间长度。设置其为2，会写入同样的概述，但也会写入每次收集的两个数据。<br>
gcdead: 设置其为1，会导致垃圾收集器摧毁任何它认为已经死掉的执行堆栈。<br>
schedtrace: 设置其为X，会导致调度程序每隔X毫秒输出单行信息到标准错误输出，概述调度状态。<br>
scheddetail: 设置schedtrace为X并设置其为1，会导致调度程序每隔X毫秒输出详细的多行信息，<br>
描述调度、进程、线程和go程的状态。<br>
环境变量GOMAXPROCS限制可以同时运行用户层次的go代码的操作系统进程数。没有对代表go代码的、可以在系统调用中阻塞的go程数的限制；那些阻塞的go程不与GOMAXPROCS限制冲突。本包的GOMAXPROCS函数可以查询和修改该限制。<br>
</p>

<p>
环境变量GOTRACEBACK控制当go程序因为不能恢复的panic或不期望的运行时情况失败时的输出。失败的程序默认会打印所有现存go程的堆栈踪迹（省略运行时系统中的函数），然后以状态码2退出。如果GOTRACEBACK为0，会完全忽略所有go程的堆栈踪迹。如果GOTRACEBACK为1，会采用默认行为。如果GOTRACEBACK为2，会打印所有现存go程包括运行时函数的堆栈踪迹。如果GOTRACEBACK为crash，会打印所有现存go程包括运行时函数的堆栈踪迹，并且如果可能会采用操作系统特定的方式崩溃，而不是退出。例如，在Unix系统里，程序会释放SIGABRT信号以触发核心信息转储。<br>
</p>

<p>
环境变量GOARCH、GOOS、GOPATH和GOROOT构成完整的go环境变量集合。它们影响go程序的构建（参见<a href="http://golang.org/cmd/go">http://golang.org/cmd/go</a> andhttp://golang.org/pkg/go/build）。<br>
</p>

<p>
GOARCH、GOOS和GOROOT在编译时被记录并可用本包的常量和函数获取，但它们不会影响运行时环境。<br>
</p>
</div>
</div>
<div id="outline-container-orgb88fbb6" class="outline-2">
<h2 id="orgb88fbb6">Constants</h2>
<div class="outline-text-2" id="text-orgb88fbb6">
<div class="org-src-container">
<pre class="src src-og">const Compiler = "gc"
</pre>
</div>

<p>
Compiler是编译工具链的名字，工具链会构建可执行的二进制文件。已知的工具链是：<br>
</p>

<pre class="example" id="org0149697">
gc      The 5g/6g/8g compiler suite at code.google.com/p/go.
gccgo   The gccgo front end, part of the GCC compiler suite.
</pre>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">const</span> <span style="color: #d75fd7;">GOARCH</span> <span style="color: #df005f; font-weight: bold;">string</span> = theGoarch
</pre>
</div>

<p>
GOARCH是可执行程序的目标处理器架构（将要在该架构的机器上执行）：386、amd64或arm。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">const</span> <span style="color: #d75fd7;">GOOS</span> <span style="color: #df005f; font-weight: bold;">string</span> = theGoos
</pre>
</div>

<p>
GOOS是可执行程序的目标操作系统（将要在该操作系统的机器上执行）：darwin、freebsd、linux等。<br>
</p>
</div>
</div>
<div id="outline-container-orgdf65f92" class="outline-2">
<h2 id="orgdf65f92">Variables</h2>
<div class="outline-text-2" id="text-orgdf65f92">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">MemProfileRate</span> <span style="color: #df005f; font-weight: bold;">int</span> = <span style="color: #d75fd7;">512</span> * <span style="color: #d75fd7;">1024</span>
</pre>
</div>

<p>
MemProfileRate控制会在内存profile里记录和报告的内存分配采样频率。内存profile记录器平均每分配MemProfileRate字节进行一次分配采样。<br>
</p>

<p>
要在profile里包含每一个申请的块，可以将MemProfileRate设为1。要完全关闭profile的记录，设置本变量为0。<br>
</p>

<p>
处理内存profile的工具假设profile记录速度在整个程序的生命期是固定的，并等于当前值。修改内存profile的程序应该只进行一次，且尽可能早的修改（例如，在main函数的开始处）。<br>
</p>
</div>
</div>
<div id="outline-container-org52161e7" class="outline-2">
<h2 id="org52161e7">type Error</h2>
<div class="outline-text-2" id="text-org52161e7">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Error</span> <span style="color: #268bd2; font-weight: bold;">interface</span> {
    error
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">RuntimeError&#26159;&#19968;&#20010;&#26080;&#25805;&#20316;&#30340;&#20989;&#25968;&#65292;&#20165;&#29992;&#20110;&#21306;&#21035;&#36816;&#34892;&#26102;&#38169;&#35823;&#21644;&#26222;&#36890;&#38169;&#35823;&#12290;</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20855;&#26377;RuntimeError&#26041;&#27861;&#30340;&#38169;&#35823;&#31867;&#22411;&#23601;&#26159;&#36816;&#34892;&#26102;&#38169;&#35823;&#31867;&#22411;&#12290;</span>
    <span style="color: #d75fd7; font-weight: bold;">RuntimeError</span>()
}
</pre>
</div>

<p>
Error接口用来识别运行时错误。<br>
</p>
</div>
</div>
<div id="outline-container-orgacb7462" class="outline-2">
<h2 id="orgacb7462">type TypeAssertionError</h2>
<div class="outline-text-2" id="text-orgacb7462">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">TypeAssertionError</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20869;&#21547;&#38544;&#34255;&#25110;&#38750;&#23548;&#20986;&#23383;&#27573;</span>
}
</pre>
</div>

<p>
TypeAssertionError表示一次失败的类型断言。<br>
</p>
</div>
<div id="outline-container-org260111d" class="outline-3">
<h3 id="org260111d">func (*TypeAssertionError) Error</h3>
<div class="outline-text-3" id="text-org260111d">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">e</span> *<span style="color: #df005f; font-weight: bold;">TypeAssertionError</span>) <span style="color: #d75fd7; font-weight: bold;">Error</span>() <span style="color: #df005f; font-weight: bold;">string</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc5cc69d" class="outline-3">
<h3 id="orgc5cc69d">func (*TypeAssertionError) RuntimeError</h3>
<div class="outline-text-3" id="text-orgc5cc69d">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (*<span style="color: #df005f; font-weight: bold;">TypeAssertionError</span>) <span style="color: #d75fd7; font-weight: bold;">RuntimeError</span>()
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org91cfca3" class="outline-2">
<h2 id="org91cfca3">func GOROOT</h2>
<div class="outline-text-2" id="text-org91cfca3">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">GOROOT</span>() <span style="color: #df005f; font-weight: bold;">string</span>
</pre>
</div>

<p>
GOROOT返回Go的根目录。如果存在GOROOT环境变量，返回该变量的值；否则，返回创建Go时的根目录。<br>
</p>
</div>
</div>
<div id="outline-container-org0bd13e4" class="outline-2">
<h2 id="org0bd13e4">func Version</h2>
<div class="outline-text-2" id="text-org0bd13e4">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">Version</span>() <span style="color: #df005f; font-weight: bold;">string</span>
</pre>
</div>

<p>
返回Go的版本字符串。它要么是递交的hash和创建时的日期；要么是发行标签如"go1.3"。<br>
</p>
</div>
</div>
<div id="outline-container-orgcb9d60b" class="outline-2">
<h2 id="orgcb9d60b">func NumCPU</h2>
<div class="outline-text-2" id="text-orgcb9d60b">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">NumCPU</span>() <span style="color: #df005f; font-weight: bold;">int</span>
</pre>
</div>

<p>
NumCPU返回本地机器的逻辑CPU个数。<br>
</p>
</div>
</div>
<div id="outline-container-org5b6b9a1" class="outline-2">
<h2 id="org5b6b9a1">func GOMAXPROCS</h2>
<div class="outline-text-2" id="text-org5b6b9a1">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">GOMAXPROCS</span>(<span style="color: #8787d7;">n</span> <span style="color: #df005f; font-weight: bold;">int</span>) <span style="color: #df005f; font-weight: bold;">int</span>
</pre>
</div>

<p>
GOMAXPROCS 设置可同时执行的最大 CPU 数，并返回先前的设置。 若 n &lt; 1，它就不会更改当前设置。本地机器的逻辑 CPU 数可通过 NumCPU 查询。本函数在调度程序优化后会去掉。<br>
</p>
</div>
</div>
<div id="outline-container-orgbdbda59" class="outline-2">
<h2 id="orgbdbda59">func SetCPUProfileRate</h2>
<div class="outline-text-2" id="text-orgbdbda59">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">SetCPUProfileRate</span>(<span style="color: #8787d7;">hz</span> <span style="color: #df005f; font-weight: bold;">int</span>)
</pre>
</div>

<p>
SetCPUProfileRate设置CPU profile记录的速率为平均每秒hz次。如果hz&lt;=0，SetCPUProfileRate会关闭profile的记录。如果记录器在执行，该速率必须在关闭之后才能修改。<br>
</p>

<p>
绝大多数使用者应使用runtime/pprof包或testing包的-test.cpuprofile选项而非直接使用SetCPUProfileRate。<br>
</p>
</div>
</div>
<div id="outline-container-org58d3688" class="outline-2">
<h2 id="org58d3688">func CPUProfile</h2>
<div class="outline-text-2" id="text-org58d3688">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">CPUProfile</span>() []<span style="color: #df005f; font-weight: bold;">byte</span>
</pre>
</div>

<p>
CPUProfile返回二进制CPU profile堆栈跟踪数据的下一个chunk，函数会阻塞直到该数据可用。 如果profile的记录被关闭，且在记录器开着的时候积累的profile数据都被返回了，CPUProfile会返回nil。调用者在再次调用本函数之前应先保存返回的数据。<br>
</p>

<p>
绝大多数使用者应使用 runtime/pprof包或testing包的-test.cpuprofile选项而非直接使用 CPUProfile。<br>
</p>
</div>
</div>
<div id="outline-container-org37d85ce" class="outline-2">
<h2 id="org37d85ce">func GC</h2>
<div class="outline-text-2" id="text-org37d85ce">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">GC</span>()
</pre>
</div>

<p>
GC 执行一次垃圾回收。<br>
</p>
</div>
</div>
<div id="outline-container-orgbfc8027" class="outline-2">
<h2 id="orgbfc8027">func SetFinalizer</h2>
<div class="outline-text-2" id="text-orgbfc8027">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">SetFinalizer</span>(<span style="color: #8787d7;">x</span>, <span style="color: #8787d7;">f</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{})
</pre>
</div>

<p>
SetFinalizer将x的终止器设置为f。当垃圾收集器发现一个不能接触的（即引用计数为零，程序中不能再直接或间接访问该对象）具有终止器的块时，它会清理该关联（对象到终止器）并在独立go程调用f(x)。这使x再次可以接触，但没有了绑定的终止器。如果SetFinalizer没有被再次调用，下一次垃圾收集器将视x为不可接触的，并释放x。<br>
</p>

<p>
SetFinalizer(x, nil)会清理任何绑定到x的终止器。<br>
</p>

<p>
参数x必须是一个指向通过new申请的对象的指针，或者通过对复合字面值取址得到的指针。参数f必须是一个函数，它接受单个可以直接用x类型值赋值的参数，也可以有任意个被忽略的返回值。如果这两条任一条不被满足，本函数就会中断程序。<br>
</p>

<p>
终止器会按依赖顺序执行：如果A指向B，两者都有终止器，且它们无法从其它方面接触，只有A的终止器执行；A被释放后，B的终止器就可以执行。如果一个循环结构包含一个具有终止器的块，该循环不能保证会被当垃圾收集，终止器也不能保证会执行；因为没有尊重依赖关系的顺序。<br>
</p>

<p>
x的终止器会在x变为不可接触之后的任意时间被调度执行。不保证终止器会在程序退出前执行，因此一般终止器只用于在长期运行的程序中释放关联到某对象的非内存资源。例如，当一个程序丢弃一个os.File对象时没有调用其Close方法，该os.File对象可以使用终止器去关闭对应的操作系统文件描述符。但依靠终止器去刷新内存中的I/O缓冲如bufio.Writer是错误的，因为缓冲不会在程序退出时被刷新。<br>
</p>

<p>
如果*x的大小为0字节，不保证终止器会执行。<br>
</p>

<p>
一个程序会有单独一个go程顺序执行所有的终止器。如果一个终止器必须运行较长时间，它应该在内部另开go程执行该任务。<br>
</p>
</div>
</div>
<div id="outline-container-org7e28848" class="outline-2">
<h2 id="org7e28848">type MemStats</h2>
<div class="outline-text-2" id="text-org7e28848">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">MemStats</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#19968;&#33324;&#32479;&#35745;</span>
    Alloc      <span style="color: #df005f; font-weight: bold;">uint64</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#24050;&#30003;&#35831;&#19988;&#20173;&#22312;&#20351;&#29992;&#30340;&#23383;&#33410;&#25968;</span>
    TotalAlloc <span style="color: #df005f; font-weight: bold;">uint64</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#24050;&#30003;&#35831;&#30340;&#24635;&#23383;&#33410;&#25968;&#65288;&#24050;&#37322;&#25918;&#30340;&#37096;&#20998;&#20063;&#31639;&#22312;&#20869;&#65289;</span>
    Sys        <span style="color: #df005f; font-weight: bold;">uint64</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20174;&#31995;&#32479;&#20013;&#33719;&#21462;&#30340;&#23383;&#33410;&#25968;&#65288;&#19979;&#38754;XxxSys&#20043;&#21644;&#65289;</span>
    Lookups    <span style="color: #df005f; font-weight: bold;">uint64</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#25351;&#38024;&#26597;&#25214;&#30340;&#27425;&#25968;</span>
    Mallocs    <span style="color: #df005f; font-weight: bold;">uint64</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#30003;&#35831;&#20869;&#23384;&#30340;&#27425;&#25968;</span>
    Frees      <span style="color: #df005f; font-weight: bold;">uint64</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#37322;&#25918;&#20869;&#23384;&#30340;&#27425;&#25968;</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20027;&#20998;&#37197;&#22534;&#32479;&#35745;</span>
    HeapAlloc    <span style="color: #df005f; font-weight: bold;">uint64</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#24050;&#30003;&#35831;&#19988;&#20173;&#22312;&#20351;&#29992;&#30340;&#23383;&#33410;&#25968;</span>
    HeapSys      <span style="color: #df005f; font-weight: bold;">uint64</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20174;&#31995;&#32479;&#20013;&#33719;&#21462;&#30340;&#23383;&#33410;&#25968;</span>
    HeapIdle     <span style="color: #df005f; font-weight: bold;">uint64</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#38386;&#32622;span&#20013;&#30340;&#23383;&#33410;&#25968;</span>
    HeapInuse    <span style="color: #df005f; font-weight: bold;">uint64</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#38750;&#38386;&#32622;span&#20013;&#30340;&#23383;&#33410;&#25968;</span>
    HeapReleased <span style="color: #df005f; font-weight: bold;">uint64</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#37322;&#25918;&#21040;&#31995;&#32479;&#30340;&#23383;&#33410;&#25968;</span>
    HeapObjects  <span style="color: #df005f; font-weight: bold;">uint64</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#24050;&#20998;&#37197;&#23545;&#35937;&#30340;&#24635;&#20010;&#25968;</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">L&#20302;&#23618;&#27425;&#12289;&#22823;&#23567;&#22266;&#23450;&#30340;&#32467;&#26500;&#20307;&#20998;&#37197;&#22120;&#32479;&#35745;&#65292;Inuse&#20026;&#27491;&#22312;&#20351;&#29992;&#30340;&#23383;&#33410;&#25968;&#65292;Sys&#20026;&#20174;&#31995;&#32479;&#33719;&#21462;&#30340;&#23383;&#33410;&#25968;</span>
    StackInuse  <span style="color: #df005f; font-weight: bold;">uint64</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#24341;&#23548;&#31243;&#24207;&#30340;&#22534;&#26632;</span>
    StackSys    <span style="color: #df005f; font-weight: bold;">uint64</span>
    MSpanInuse  <span style="color: #df005f; font-weight: bold;">uint64</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">mspan&#32467;&#26500;&#20307;</span>
    MSpanSys    <span style="color: #df005f; font-weight: bold;">uint64</span>
    MCacheInuse <span style="color: #df005f; font-weight: bold;">uint64</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">mcache&#32467;&#26500;&#20307;</span>
    MCacheSys   <span style="color: #df005f; font-weight: bold;">uint64</span>
    BuckHashSys <span style="color: #df005f; font-weight: bold;">uint64</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">profile&#26742;&#25955;&#21015;&#34920;</span>
    GCSys       <span style="color: #df005f; font-weight: bold;">uint64</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">GC&#20803;&#25968;&#25454;</span>
    OtherSys    <span style="color: #df005f; font-weight: bold;">uint64</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20854;&#20182;&#31995;&#32479;&#30003;&#35831;</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22403;&#22334;&#25910;&#38598;&#22120;&#32479;&#35745;</span>
    NextGC       <span style="color: #df005f; font-weight: bold;">uint64</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20250;&#22312;HeapAlloc&#23383;&#27573;&#21040;&#36798;&#35813;&#20540;&#65288;&#23383;&#33410;&#25968;&#65289;&#26102;&#36816;&#34892;&#19979;&#27425;GC</span>
    LastGC       <span style="color: #df005f; font-weight: bold;">uint64</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#19978;&#27425;&#36816;&#34892;&#30340;&#32477;&#23545;&#26102;&#38388;&#65288;&#32435;&#31186;&#65289;</span>
    PauseTotalNs <span style="color: #df005f; font-weight: bold;">uint64</span>
    PauseNs      [<span style="color: #d75fd7;">256</span>]<span style="color: #df005f; font-weight: bold;">uint64</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36817;&#26399;GC&#26242;&#20572;&#26102;&#38388;&#30340;&#24490;&#29615;&#32531;&#20914;&#65292;&#26368;&#36817;&#19968;&#27425;&#22312;[(NumGC+255)%256]</span>
    NumGC        <span style="color: #df005f; font-weight: bold;">uint32</span>
    EnableGC     <span style="color: #df005f; font-weight: bold;">bool</span>
    DebugGC      <span style="color: #df005f; font-weight: bold;">bool</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#27599;&#27425;&#30003;&#35831;&#30340;&#23383;&#33410;&#25968;&#30340;&#32479;&#35745;&#65292;61&#26159;C&#20195;&#30721;&#20013;&#30340;&#23610;&#23544;&#20998;&#32423;&#25968;</span>
    BySize [<span style="color: #d75fd7;">61</span>]<span style="color: #268bd2; font-weight: bold;">struct</span> {
        Size    <span style="color: #df005f; font-weight: bold;">uint32</span>
        Mallocs <span style="color: #df005f; font-weight: bold;">uint64</span>
        Frees   <span style="color: #df005f; font-weight: bold;">uint64</span>
    }
}
</pre>
</div>

<p>
MemStats 记录内存申请和分配的统计信息。<br>
</p>
</div>
</div>
<div id="outline-container-org97421bf" class="outline-2">
<h2 id="org97421bf">func ReadMemStats</h2>
<div class="outline-text-2" id="text-org97421bf">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">ReadMemStats</span>(<span style="color: #8787d7;">m</span> *<span style="color: #df005f; font-weight: bold;">MemStats</span>)
</pre>
</div>

<p>
ReadMemStats 将内存申请和分配的统计信息填写进 m。<br>
</p>
</div>
</div>
<div id="outline-container-org99c809c" class="outline-2">
<h2 id="org99c809c">type MemProfileRecord</h2>
<div class="outline-text-2" id="text-org99c809c">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">MemProfileRecord</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    AllocBytes, FreeBytes     <span style="color: #df005f; font-weight: bold;">int64</span>       <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#30003;&#35831;&#21644;&#37322;&#25918;&#30340;&#23383;&#33410;&#25968;</span>
    AllocObjects, FreeObjects <span style="color: #df005f; font-weight: bold;">int64</span>       <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#30003;&#35831;&#21644;&#37322;&#25918;&#30340;&#23545;&#35937;&#25968;</span>
    Stack0                    [<span style="color: #d75fd7;">32</span>]<span style="color: #df005f; font-weight: bold;">uintptr</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35813;&#35760;&#24405;&#30340;&#35843;&#29992;&#26632;&#36394;&#36857;&#65292;&#20197;&#31532;&#19968;&#20010;&#38646;&#20540;&#25104;&#21592;&#25130;&#27490;</span>
}
</pre>
</div>

<p>
MemProfileRecord用于描述某个调用栈序列申请和释放的活动对象等信息。<br>
</p>
</div>
<div id="outline-container-org1d61b39" class="outline-3">
<h3 id="org1d61b39">func (*MemProfileRecord) InUseBytes</h3>
<div class="outline-text-3" id="text-org1d61b39">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">r</span> *<span style="color: #df005f; font-weight: bold;">MemProfileRecord</span>) <span style="color: #d75fd7; font-weight: bold;">InUseBytes</span>() <span style="color: #df005f; font-weight: bold;">int64</span>
</pre>
</div>

<p>
InUseBytes返回正在使用的字节数（AllocBytes – FreeBytes）<br>
</p>
</div>
</div>
<div id="outline-container-org25a66ef" class="outline-3">
<h3 id="org25a66ef">func (*MemProfileRecord) InUseObjects</h3>
<div class="outline-text-3" id="text-org25a66ef">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">r</span> *<span style="color: #df005f; font-weight: bold;">MemProfileRecord</span>) <span style="color: #d75fd7; font-weight: bold;">InUseObjects</span>() <span style="color: #df005f; font-weight: bold;">int64</span>
</pre>
</div>

<p>
InUseObjects返回正在使用的对象数（AllocObjects - FreeObjects）<br>
</p>
</div>
</div>
<div id="outline-container-org2829929" class="outline-3">
<h3 id="org2829929">func (*MemProfileRecord) Stack</h3>
<div class="outline-text-3" id="text-org2829929">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">r</span> *<span style="color: #df005f; font-weight: bold;">MemProfileRecord</span>) <span style="color: #d75fd7; font-weight: bold;">Stack</span>() []<span style="color: #df005f; font-weight: bold;">uintptr</span>
</pre>
</div>

<p>
Stack返回关联至此记录的调用栈踪迹，即r.Stack0的前缀。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org64c443c" class="outline-2">
<h2 id="org64c443c">func MemProfile</h2>
<div class="outline-text-2" id="text-org64c443c">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">MemProfile</span>(<span style="color: #8787d7;">p</span> []<span style="color: #df005f; font-weight: bold;">MemProfileRecord</span>, <span style="color: #8787d7;">inuseZero</span> <span style="color: #df005f; font-weight: bold;">bool</span>) (<span style="color: #8787d7;">n</span> <span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #8787d7;">ok</span> <span style="color: #df005f; font-weight: bold;">bool</span>)
</pre>
</div>

<p>
MemProfile返回当前内存profile中的记录数n。若len(p)&gt;=n，MemProfile会将此分析报告复制到p中并返回(n, true)；如果len(p)&lt;n，MemProfile则不会更改p，而只返回(n, false)。<br>
</p>

<p>
如果inuseZero为真，该profile就会包含无效分配记录（其中r.AllocBytes&gt;0，而r.AllocBytes==r.FreeBytes。这些内存都是被申请后又释放回运行时环境的）。<br>
</p>

<p>
大多数调用者应当使用runtime/pprof包或testing包的-test.memprofile标记，而非直接调用MemProfile。<br>
</p>
</div>
</div>
<div id="outline-container-org1d45596" class="outline-2">
<h2 id="org1d45596">func Breakpoint</h2>
<div class="outline-text-2" id="text-org1d45596">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">Breakpoint</span>()
</pre>
</div>

<p>
Breakpoint执行一个断点陷阱。<br>
</p>
</div>
</div>
<div id="outline-container-orgc9cb069" class="outline-2">
<h2 id="orgc9cb069">func Stack</h2>
<div class="outline-text-2" id="text-orgc9cb069">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">Stack</span>(<span style="color: #8787d7;">buf</span> []<span style="color: #df005f; font-weight: bold;">byte</span>, <span style="color: #8787d7;">all</span> <span style="color: #df005f; font-weight: bold;">bool</span>) <span style="color: #df005f; font-weight: bold;">int</span>
</pre>
</div>

<p>
Stack将调用其的go程的调用栈踪迹格式化后写入到buf中并返回写入的字节数。若all为true，函数会在写入当前go程的踪迹信息后，将其它所有go程的调用栈踪迹都格式化写入到buf中。<br>
</p>
</div>
</div>
<div id="outline-container-org772771b" class="outline-2">
<h2 id="org772771b">func Caller</h2>
<div class="outline-text-2" id="text-org772771b">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">Caller</span>(<span style="color: #8787d7;">skip</span> <span style="color: #df005f; font-weight: bold;">int</span>) (<span style="color: #8787d7;">pc</span> <span style="color: #df005f; font-weight: bold;">uintptr</span>, <span style="color: #8787d7;">file</span> <span style="color: #df005f; font-weight: bold;">string</span>, <span style="color: #8787d7;">line</span> <span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #8787d7;">ok</span> <span style="color: #df005f; font-weight: bold;">bool</span>)
</pre>
</div>

<p>
Caller报告当前go程调用栈所执行的函数的文件和行号信息。实参skip为上溯的栈帧数，0表示Caller的调用者（Caller所在的调用栈）。（由于历史原因，skip的意思在Caller和Callers中并不相同。）函数的返回值为调用栈标识符、文件名、该调用在文件中的行号。如果无法获得信息，ok会被设为false。<br>
</p>
</div>
</div>
<div id="outline-container-orga6f5977" class="outline-2">
<h2 id="orga6f5977">func Callers</h2>
<div class="outline-text-2" id="text-orga6f5977">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">Callers</span>(<span style="color: #8787d7;">skip</span> <span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #8787d7;">pc</span> []<span style="color: #df005f; font-weight: bold;">uintptr</span>) <span style="color: #df005f; font-weight: bold;">int</span>
</pre>
</div>

<p>
函数把当前go程调用栈上的调用栈标识符填入切片pc中，返回写入到pc中的项数。实参skip为开始在pc中记录之前所要跳过的栈帧数，0表示Callers自身的调用栈，1表示Callers所在的调用栈。返回写入p的项数。<br>
</p>
</div>
</div>
<div id="outline-container-org7de0909" class="outline-2">
<h2 id="org7de0909">type StackRecord</h2>
<div class="outline-text-2" id="text-org7de0909">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">StackRecord</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    Stack0 [<span style="color: #d75fd7;">32</span>]<span style="color: #df005f; font-weight: bold;">uintptr</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35813;&#35760;&#24405;&#30340;&#35843;&#29992;&#26632;&#36394;&#36857;&#65292;&#20197;&#31532;&#19968;&#20010;&#38646;&#20540;&#25104;&#21592;&#25130;&#27490;</span>
}
</pre>
</div>

<p>
StackRecord描述单条调用栈。<br>
</p>
</div>
<div id="outline-container-orgaf501f2" class="outline-3">
<h3 id="orgaf501f2">func (*StackRecord) Stack</h3>
<div class="outline-text-3" id="text-orgaf501f2">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">r</span> *<span style="color: #df005f; font-weight: bold;">StackRecord</span>) <span style="color: #d75fd7; font-weight: bold;">Stack</span>() []<span style="color: #df005f; font-weight: bold;">uintptr</span>
</pre>
</div>

<p>
Stack返回与记录相关联的调用栈踪迹，即r.Stack0的前缀。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org6a8c033" class="outline-2">
<h2 id="org6a8c033">type Func</h2>
<div class="outline-text-2" id="text-org6a8c033">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Func</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20869;&#21547;&#38544;&#34255;&#25110;&#38750;&#23548;&#20986;&#23383;&#27573;</span>
}
</pre>
</div>
</div>
<div id="outline-container-org9c57b3d" class="outline-3">
<h3 id="org9c57b3d">func FuncForPC</h3>
<div class="outline-text-3" id="text-org9c57b3d">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">FuncForPC</span>(<span style="color: #8787d7;">pc</span> <span style="color: #df005f; font-weight: bold;">uintptr</span>) *<span style="color: #df005f; font-weight: bold;">Func</span>
</pre>
</div>

<p>
FuncForPC返回一个表示调用栈标识符pc对应的调用栈的*Func；如果该调用栈标识符没有对应的调用栈，函数会返回nil。每一个调用栈必然是对某个函数的调用。<br>
</p>
</div>
</div>
<div id="outline-container-org387be5e" class="outline-3">
<h3 id="org387be5e">func (*Func) Name</h3>
<div class="outline-text-3" id="text-org387be5e">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">f</span> *<span style="color: #df005f; font-weight: bold;">Func</span>) <span style="color: #d75fd7; font-weight: bold;">Name</span>() <span style="color: #df005f; font-weight: bold;">string</span>
</pre>
</div>

<p>
Name返回该调用栈所调用的函数的名字。<br>
</p>
</div>
</div>
<div id="outline-container-org719a301" class="outline-3">
<h3 id="org719a301">func (*Func) FileLine</h3>
<div class="outline-text-3" id="text-org719a301">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">f</span> *<span style="color: #df005f; font-weight: bold;">Func</span>) <span style="color: #d75fd7; font-weight: bold;">FileLine</span>(<span style="color: #8787d7;">pc</span> <span style="color: #df005f; font-weight: bold;">uintptr</span>) (<span style="color: #8787d7;">file</span> <span style="color: #df005f; font-weight: bold;">string</span>, <span style="color: #8787d7;">line</span> <span style="color: #df005f; font-weight: bold;">int</span>)
</pre>
</div>

<p>
FileLine返回该调用栈所调用的函数的源代码文件名和行号。如果pc不是f内的调用栈标识符，结果是不精确的。<br>
</p>
</div>
</div>
<div id="outline-container-orgb405960" class="outline-3">
<h3 id="orgb405960">func (*Func) Entry</h3>
<div class="outline-text-3" id="text-orgb405960">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">f</span> *<span style="color: #df005f; font-weight: bold;">Func</span>) <span style="color: #d75fd7; font-weight: bold;">Entry</span>() <span style="color: #df005f; font-weight: bold;">uintptr</span>
</pre>
</div>

<p>
Entry返回该调用栈的调用栈标识符。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org448a65d" class="outline-2">
<h2 id="org448a65d">func NumCgoCall</h2>
<div class="outline-text-2" id="text-org448a65d">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">NumCgoCall</span>() <span style="color: #df005f; font-weight: bold;">int64</span>
</pre>
</div>

<p>
NumCgoCall返回当前进程执行的cgo调用次数。<br>
</p>
</div>
</div>
<div id="outline-container-org37a43ab" class="outline-2">
<h2 id="org37a43ab">func NumGoroutine</h2>
<div class="outline-text-2" id="text-org37a43ab">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">NumGoroutine</span>() <span style="color: #df005f; font-weight: bold;">int</span>
</pre>
</div>

<p>
NumGoroutine 返回当前存在的 Go 程数。<br>
</p>
</div>
</div>
<div id="outline-container-org7cb9275" class="outline-2">
<h2 id="org7cb9275">func Goexit</h2>
<div class="outline-text-2" id="text-org7cb9275">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">Goexit</span>()
</pre>
</div>

<p>
Goexit终止调用它的go程。其它go程不会受影响。Goexit会在终止该go程前执行所有defer的函数。<br>
</p>

<p>
在程序的main go程调用本函数，会终结该go程，而不会让main返回。因为main函数没有返回，程序会继续执行其它的go程。如果所有其它go程都退出了，程序就会崩溃。<br>
</p>
</div>
</div>
<div id="outline-container-org6e14fce" class="outline-2">
<h2 id="org6e14fce">func Gosched</h2>
<div class="outline-text-2" id="text-org6e14fce">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">Gosched</span>()
</pre>
</div>

<p>
Gosched使当前go程放弃处理器，以让其它go程运行。它不会挂起当前go程，因此当前go程未来会恢复执行。<br>
</p>
</div>
</div>
<div id="outline-container-orgc63b9a4" class="outline-2">
<h2 id="orgc63b9a4">func GoroutineProfile</h2>
<div class="outline-text-2" id="text-orgc63b9a4">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">GoroutineProfile</span>(<span style="color: #8787d7;">p</span> []<span style="color: #df005f; font-weight: bold;">StackRecord</span>) (<span style="color: #8787d7;">n</span> <span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #8787d7;">ok</span> <span style="color: #df005f; font-weight: bold;">bool</span>)
</pre>
</div>

<p>
GoroutineProfile返回活跃go程的堆栈profile中的记录个数。若len(p) &gt;= n，函数就会将profile中的记录复制到p中并返回(n, true)。若len(p) &lt; n，则不会修改p，而只返回(n, false)。<br>
</p>

<p>
绝大多数调用者应当使用runtime/pprof包，而非直接调用GoroutineProfile。<br>
</p>
</div>
</div>
<div id="outline-container-orge418fcd" class="outline-2">
<h2 id="orge418fcd">func LockOSThread</h2>
<div class="outline-text-2" id="text-orge418fcd">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">LockOSThread</span>()
</pre>
</div>

<p>
将调用的go程绑定到它当前所在的操作系统线程。除非调用的go程退出或调用UnlockOSThread，否则它将总是在该线程中执行，而其它go程则不能进入该线程。<br>
</p>
</div>
</div>
<div id="outline-container-org3e67aa3" class="outline-2">
<h2 id="org3e67aa3">func UnlockOSThread</h2>
<div class="outline-text-2" id="text-org3e67aa3">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">UnlockOSThread</span>()
</pre>
</div>

<p>
将调用的go程解除和它绑定的操作系统线程。若调用的go程未调用LockOSThread，UnlockOSThread不做操作。<br>
</p>
</div>
</div>
<div id="outline-container-orgf7a16df" class="outline-2">
<h2 id="orgf7a16df">func ThreadCreateProfile</h2>
<div class="outline-text-2" id="text-orgf7a16df">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">ThreadCreateProfile</span>(<span style="color: #8787d7;">p</span> []<span style="color: #df005f; font-weight: bold;">StackRecord</span>) (<span style="color: #8787d7;">n</span> <span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #8787d7;">ok</span> <span style="color: #df005f; font-weight: bold;">bool</span>)
</pre>
</div>

<p>
返回线程创建profile中的记录个数。如果len(p)&gt;=n，本函数就会将profile中的记录复制到p中并返回(n, true)。若len(p)&lt;n，则不会更改p，而只返回(n, false)。<br>
</p>

<p>
绝大多数使用者应当使用runtime/pprof包，而非直接调用ThreadCreateProfile。<br>
</p>
</div>
</div>
<div id="outline-container-orga0b3b1d" class="outline-2">
<h2 id="orga0b3b1d">type BlockProfileRecord</h2>
<div class="outline-text-2" id="text-orga0b3b1d">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">BlockProfileRecord</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    Count  <span style="color: #df005f; font-weight: bold;">int64</span>
    Cycles <span style="color: #df005f; font-weight: bold;">int64</span>
    StackRecord
}
</pre>
</div>

<p>
BlockProfileRecord用于描述某个调用栈序列发生的阻塞事件的信息。<br>
</p>
</div>
</div>
<div id="outline-container-org036bef4" class="outline-2">
<h2 id="org036bef4">func SetBlockProfileRate</h2>
<div class="outline-text-2" id="text-org036bef4">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">SetBlockProfileRate</span>(<span style="color: #8787d7;">rate</span> <span style="color: #df005f; font-weight: bold;">int</span>)
</pre>
</div>

<p>
SetBlockProfileRate控制阻塞profile记录go程阻塞事件的采样频率。对于一个阻塞事件，平均每阻塞rate纳秒，阻塞profile记录器就采集一份样本。<br>
</p>

<p>
要在profile中包括每一个阻塞事件，需传入rate=1；要完全关闭阻塞profile的记录，需传入rate&lt;=0。<br>
</p>
</div>
</div>
<div id="outline-container-org40132e4" class="outline-2">
<h2 id="org40132e4">func BlockProfile</h2>
<div class="outline-text-2" id="text-org40132e4">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">BlockProfile</span>(<span style="color: #8787d7;">p</span> []<span style="color: #df005f; font-weight: bold;">BlockProfileRecord</span>) (<span style="color: #8787d7;">n</span> <span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #8787d7;">ok</span> <span style="color: #df005f; font-weight: bold;">bool</span>)
</pre>
</div>

<p>
BlockProfile返回当前阻塞profile中的记录个数。如果len(p)&gt;=n，本函数就会将此profile中的记录复制到p中并返回(n, true)。如果len(p)&lt;n，本函数则不会修改p，而只返回(n, false)。<br>
</p>

<p>
绝大多数使用者应当使用runtime/pprof包或testing包的-test.blockprofile标记， 而非直接调用 BlockProfile。<br>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-02-11 22:02 Fri</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-02-14 Mon 23:41</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
