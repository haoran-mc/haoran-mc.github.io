<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-09-30 四 16:12 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>K-D</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran &lt;haoran.mc@outlook.com&gt;">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">K-D</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org5dc65c0">引入问题</a>
<ul>
<li><a href="#orgc9f12fe">低维</a>
<ul>
<li><a href="#org56f476c">最近邻问题</a></li>
<li><a href="#org26f4c04">区间搜索问题</a></li>
</ul>
</li>
<li><a href="#orgd4f12a7">高维</a>
<ul>
<li><a href="#org9f69a2c">最近邻问题</a></li>
<li><a href="#org2e2bd95">区间搜索问题</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgcc7a620">K-D Tree的基本结构</a></li>
<li><a href="#orgb413251">解决上述问题</a>
<ul>
<li><a href="#org7fe4296">区间搜索问题</a></li>
<li><a href="#org50d4272">最近邻问题</a></li>
</ul>
</li>
<li><a href="#org950af1e">技巧</a>
<ul>
<li><a href="#org56f18e3">优化分割维度</a></li>
<li><a href="#org1f049d4">随机转换坐标系</a></li>
</ul>
</li>
<li><a href="#org0a05007">构建</a>
<ul>
<li><a href="#org8934373">建树</a></li>
<li><a href="#org64c8977">k=2的例子</a></li>
<li><a href="#org0d59bae">插入</a></li>
<li><a href="#org63bf083">删除</a></li>
</ul>
</li>
<li><a href="#orgf3d6269">习题</a>
<ul>
<li><a href="#orgb82d468">邻域查询</a></li>
<li><a href="#orgefc80c5">高维空间上的操作</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
k-D Tree(KDT , k-Dimension Tree) 是一种可以高效处理k维空间信息的数据结构在结点数n远大于2^k时，应用k-D Tree的时间效率很好，在算法竞赛的题目中，一般有k = 2
</p>
<div id="outline-container-org5dc65c0" class="outline-2">
<h2 id="org5dc65c0">引入问题</h2>
<div class="outline-text-2" id="text-org5dc65c0">
</div>
<div id="outline-container-orgc9f12fe" class="outline-3">
<h3 id="orgc9f12fe">低维</h3>
<div class="outline-text-3" id="text-orgc9f12fe">
</div>
<div id="outline-container-org56f476c" class="outline-4">
<h4 id="org56f476c">最近邻问题</h4>
<div class="outline-text-4" id="text-org56f476c">
<p>
给定数轴上的n个点，每次询问输入一个新的点p，要求输出距离p最近的点解决方案：平衡树(Balanced BST)
</p>
</div>
</div>
<div id="outline-container-org26f4c04" class="outline-4">
<h4 id="org26f4c04">区间搜索问题</h4>
<div class="outline-text-4" id="text-org26f4c04">
<p>
给定数轴上的n个点，每次询问一个区间[l, r]，要求输出区间内的所有点解决方案：线段树(Segment Tree)
</p>
</div>
</div>
</div>
<div id="outline-container-orgd4f12a7" class="outline-3">
<h3 id="orgd4f12a7">高维</h3>
<div class="outline-text-3" id="text-orgd4f12a7">
<p>
高维上最近邻问题就不能用平衡树解决，因为平衡树是二叉搜索树，它的中序遍历是升序的，而对于多维的数据，平衡树无法定义一种排序的方法建立平衡树
</p>
</div>
<div id="outline-container-org9f69a2c" class="outline-4">
<h4 id="org9f69a2c">最近邻问题</h4>
<div class="outline-text-4" id="text-org9f69a2c">
<p>
给定k维空间中的n个点，每次询问输入一个新的点p，要求输出距离p最近的点
</p>
</div>
</div>
<div id="outline-container-org2e2bd95" class="outline-4">
<h4 id="org2e2bd95">区间搜索问题</h4>
<div class="outline-text-4" id="text-org2e2bd95">
<p>
给定k维空间中的n个点，每次询问一个范围(range)(超长方体)，要求输出范围内的所有点
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgcc7a620" class="outline-2">
<h2 id="orgcc7a620">K-D Tree的基本结构</h2>
<div class="outline-text-2" id="text-orgcc7a620">
<p>
K-D Tree是一个类似BST的数据结构，树上每个结点均代表着输入数据中的一个点对于K-D Tree上的任意一个非叶子结点n，均存在一个维度dn，使得：
</p>
<ul class="org-ul">
<li>n左子树中的每个结点在dn维度上均比n小</li>
<li>n右子树中的每个结点在dn维度上均比n大
dn由结点的深度决定(dn = depn mod d)</li>
</ul>
</div>
</div>
<div id="outline-container-orgb413251" class="outline-2">
<h2 id="orgb413251">解决上述问题</h2>
<div class="outline-text-2" id="text-orgb413251">
</div>
<div id="outline-container-org7fe4296" class="outline-3">
<h3 id="org7fe4296">区间搜索问题</h3>
<div class="outline-text-3" id="text-org7fe4296">
<p>
给定k维空间中的n个点，每次询问一个范围(range)，要求输出范围内的所有点
</p>

<p>
query(r, range);
</p>
<ul class="org-ul">
<li>定义K-D Tree 上一个结点的region为覆盖其子树内所有结点的最小矩形区域(二维上是矩形)</li>
<li>如果range完全覆盖了r的region，则遍历输出r的子树</li>
<li><p>
否则
</p>
<ul class="org-ul">
<li>如果r左子树的region与range有交，则执行query(r-&gt;lson, region);</li>
<li>如果r右子树的region与range有交，则执行query(r-&gt;rson, region);</li>
</ul>

\begin{equation}
Q(n) = \begin{cases}
    O(1),        & n = 1 \notag \\
    2 + 2Q(n/4), & n > 1
\end{cases}
\end{equation}

<p>
根据主定理，K-D tree解决二维区间搜索问题的时间复杂度为\(O(\sqrt{n} + k)\)
扩展至d维时，K-D tree解决区间搜索问题的时间复杂度为\(O(d \times n^{1-\frac1d} + k)\)
</p>

<p>
区间搜索问题可以做到更优复杂度 &#x2014; Layered Range Tree
时间复杂度：\(O(log^{d-1}n)\)
时间复杂度：\(O(n \times log^dn)\)
</p></li>
</ul>
</div>
</div>
<div id="outline-container-org50d4272" class="outline-3">
<h3 id="org50d4272">最近邻问题</h3>
<div class="outline-text-3" id="text-org50d4272">
<p>
给定k维空间中的n个点，每次询问输入一个新的点p，要求输出距离p最近的点
</p>

<p>
query(r, p);
</p>
<ul class="org-ul">
<li>全程维护当前答案min_dis</li>
<li>定义dis(r, p)为点p到r的region的最近距离</li>
<li>update(r, p)</li>
<li>当dis(r-&gt;lson, p) &lt; dis(r-&gt;rson, p)时:
<ul class="org-ul">
<li>if dis(r-&gt;lson, p) &lt; min_dis then query(r-&gt;lson, p)</li>
<li>if dis(r-&gt;rson, p) &lt; min_dis then query(r-&gt;rson, p)</li>
</ul></li>
<li><p>
当dis(r-&gt;lson, p) &gt; dis(r-&gt;rson, p)时:
</p>
<ul class="org-ul">
<li>if dis(r-&gt;rson, p) &lt; min_dis then query(r-&gt;rson, p)</li>
<li>if dis(r-&gt;lson, p) &lt; min_dis then query(r-&gt;lson, p)</li>
</ul>

<p>
对于随机数据，查询的平均时间复杂度为O(logn)
对于最坏情况，查询的时间复杂度为\(O(\sqrt{n})\)
</p>

<p>
K-D Tree在最近邻问题上达到了最优时间复杂度通过一些技巧，可以消除"随机询问"的条件限制
</p></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org950af1e" class="outline-2">
<h2 id="org950af1e">技巧</h2>
<div class="outline-text-2" id="text-org950af1e">
</div>
<div id="outline-container-org56f18e3" class="outline-3">
<h3 id="org56f18e3">优化分割维度</h3>
<div class="outline-text-3" id="text-org56f18e3">
<p>
解决最近邻一类问题时，可以切割rgion中极差最大的那一维
</p>
</div>
</div>
<div id="outline-container-org1f049d4" class="outline-3">
<h3 id="org1f049d4">随机转换坐标系</h3>
<div class="outline-text-3" id="text-org1f049d4">
<p>
将坐标轴旋转随机角度，不改变最近邻问题答案
</p>
</div>
</div>
</div>
<div id="outline-container-org0a05007" class="outline-2">
<h2 id="org0a05007">构建</h2>
<div class="outline-text-2" id="text-org0a05007">
</div>
<div id="outline-container-org8934373" class="outline-3">
<h3 id="org8934373">建树</h3>
<div class="outline-text-3" id="text-org8934373">
<p>
k-D Tree 具有二叉搜索树的形态，二叉搜索树上的每个结点都对应k维空间内的一个点。其每个子树中的点都在一个k维的超长方体内，这个超长方体内的所有点也都在这个子树中假设我们已经知道了k维空间内的n个不同的点的坐标，要将其构建成一棵 k-D Tree，步骤如下：
</p>
<ol class="org-ol">
<li>若当前超长方体中只有一个点，返回这个点</li>
<li>选择一个维度，将当前超长方体按照这个维度分成两个超长方体</li>
<li>选择切割点：在选择的维度上选择一个点，这一维度上的值小于这个点的归入一个超长方体(左子树)，其余的归入另一个超长方体(右子树)</li>
<li>将选择的点作为这棵子树的根节点，递归对分出的两个超长方体构建左右子树，维护子树的信息</li>
</ol>
</div>
</div>
<div id="outline-container-org64c8977" class="outline-3">
<h3 id="org64c8977">k=2的例子</h3>
<div class="outline-text-3" id="text-org64c8977">
<pre class="example" id="orga95e5c7">
   ^
10 |             |
 9 |             |
 8 |       B     |
 7 |       *     |   E
 6 |             |---*-----
 5 |         C   |
 4 |---------*---|
 3 |   *         | 
 2 |   A       D * 
 1 |             | * F
   |------------------------&gt;
 0   1 2 3 4 5 6 7 8 9 10


其构建出的K-D Tree的形态可能是这样的:

              (7, 2) x
              /    \
             /      \
      y (5, 4)      (9, 6) y
        /    \      /
       /      \    /
  (2, 3)  (4, 7)  (8, 1)
</pre>
<p>
其中树上每个结点上的坐标是选择的分割点的坐标，非叶子结点旁的x或y是选择的切割维度这样的复杂度无法保证。对于2, 3两步，我们提出两个优化：
</p>
<ol class="org-ol">
<li>选择的维度要满足其内部点的分布的差异度最大，即每次选择的切割维度是方差最大的维度。</li>
<li><p>
每次在维度上选择切割点时选择该维度上的 中位数，这样可以保证每次分成的左右子树大小尽量相等。
</p>

<p>
可以发现，使用优化2后，构建出的 k-D Tree 的树高最多为O(logn)
</p>

<p>
现在，构建 k-D Tree 时间复杂度的瓶颈在于快速选出一个维度上的中位数，并将在该维度上的值小于该中位数的置于中位数的左边，其余置于右边。如果每次都使用 sort 函数对该维度进行排序，时间复杂度是O(n(logn)^2)的。事实上，单次找出n个元素中的中位数并将中位数置于排序后正确的位置的复杂度可以达到O(n)
</p>

<p>
我们来回顾一下快速排序的思想。每次我们选出一个数，将小于该数的置于该数的左边，大于该数的置于该数的右边，保证该数在排好序后正确的位置上，然后递归排序左侧和右侧的值。这样的期望复杂度是O(nlogn)的。但是由于 k-D Tree 只要求要中位数在排序后正确的位置上，所以我们只需要递归排序包含中位数的一侧。可以证明，这样的期望复杂度是O(n)的。在 algorithm 库中，有一个实现相同功能的函数 nth_element()，要找到 s[l] 和 s[r] 之间的值按照排序规则 cmp 排序后在 s[mid] 位置上的值，并保证 s[mid] 左边的值小于 s[mid]，右边的值大于 s[mid]，只需写 nth_element(s+l,s+mid,s+r+1,cmp)
</p>

<p>
借助这种思想，构建 k-D Tree 时间复杂度是O(nlogn)的
</p></li>
</ol>
</div>
</div>
<div id="outline-container-org0d59bae" class="outline-3">
<h3 id="org0d59bae">插入</h3>
<div class="outline-text-3" id="text-org0d59bae">
<p>
如果维护的这个k维点集是可变的，即可能会插入或删除一些点，此时k-D Tree的平衡性无法保证。由于k-D Tree的构造，不能支持旋转，类似与 FHQ Treap 的随机优先级也不能保证其复杂度，可以保证平衡性的手段只有类似于替罪羊树的重构思想
</p>

<p>
我们引入一个重构常数 \(\alpha\) ，对于k-D Tree上的一个结点，若其有一个子树的结点数在以x为根的子树的结点数中的占比大于 \(\alpha\) ，则认为以x为根的子树是不平衡的，需要重构。重构时，先遍历子树求出一个序列，然后用以上描述的方法建出一棵k-D Tree，代替原来不平衡的子树
</p>

<p>
在插入一个k维点时，先根据记录的分割维度和分割点判断应该继续插入到左子树还是右子树，如果到达了空结点，新建一个结点代替这个空结点。成功插入结点后回溯插入的过程，维护结点的信息，如果发现当前的子树不平衡，则重构当前子树
</p>
</div>
</div>
<div id="outline-container-org63bf083" class="outline-3">
<h3 id="org63bf083">删除</h3>
<div class="outline-text-3" id="text-org63bf083">
<p>
如果还有删除操作，则使用 <b>惰性删除</b> ，即删除一个结点时打上删除标记，而保留其在k-D Tree上的位置。如果这样写，当未删除的结点数在以x为根的子树中的占比小于 \(\alpha\) 时，同样认为这个子树是不平衡的，需要重构
</p>

<p>
类似于替罪羊树，带重构的k-D Tree的树高仍然是O(logn)的
</p>
</div>
</div>
</div>
<div id="outline-container-orgf3d6269" class="outline-2">
<h2 id="orgf3d6269">习题</h2>
<div class="outline-text-2" id="text-orgf3d6269">
</div>
<div id="outline-container-orgb82d468" class="outline-3">
<h3 id="orgb82d468">邻域查询</h3>
<div class="outline-text-3" id="text-orgb82d468">
<p>
例题：luogu P1429 平面最近点对(加强版)
给定平面上的n个点(xi, yi), 找出平面上最近两个点对之间的欧几里得距离，2 &lt;= n &lt;= 2e5，0 &lt;= xi, yi &lt;= 1e9
</p>

<p>
首先建出关于这n个点的2-D Tree
</p>

<p>
枚举每个结点，对于每个结点找到不等于该结点且距离最小的点，即可求出答案。每次暴力遍历 2-D Tree 上的每个结点的时间复杂度是O(n)的，需要剪枝。我们可以维护一个子树中的所有结点在每一维上的坐标的最小值和最大值。假设当前已经找到的最近点对的距离是res，如果查询点到子树内所有点都包含在内的长方形的 最近距离大于等于res，则在这个子树内一定没有答案，搜索时不进入这个子树
</p>

<p>
此外，还可以使用一种启发式搜索的方法，即若一个结点的两个子树都有可能包含答案，先在与查询点距离最近的一个子树中搜索答案。可以认为，查询点到子树对应的长方形的最近距离就是此题的估价函数
</p>

<p>
注意：虽然以上使用的种种优化，但是使用 k-D Tree 单次查询最近点的时间复杂度最坏还是O(n)的，但不失为一种优秀的骗分算法，使用时请注意。在这里对邻域查询的讲解仅限于加强对 k-D Tree 结构的认识
</p>
</div>
</div>
<div id="outline-container-orgefc80c5" class="outline-3">
<h3 id="orgefc80c5">高维空间上的操作</h3>
</div>
</div>
</div>
</body>
</html>
