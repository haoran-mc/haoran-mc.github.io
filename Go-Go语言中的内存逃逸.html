<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-02-16 Wed 00:21 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>GO语言中的内存逃逸</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">GO语言中的内存逃逸</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org3c18216">什么是内存逃逸</a></li>
<li><a href="#org184aa05">内存逃逸的危害</a></li>
<li><a href="#orgb92288b">什么是逃逸分析</a></li>
<li><a href="#org3560388">Go 语言中的逃逸分析</a></li>
<li><a href="#org8a2cbe5">一些内存逃逸的例子</a>
<ul>
<li><a href="#orgc0a6982">1. 函数返回局部指针变量</a></li>
<li><a href="#org1986c11">2. interface 类型逃逸</a></li>
<li><a href="#orgf0b9bed">3. 闭包产生的逃逸</a></li>
<li><a href="#org563c6a7">4. 变量大小不确定及栈空间不足引发逃逸</a></li>
<li><a href="#org639ba30">小结</a></li>
</ul>
</li>
<li><a href="#orgd030d11">避免内存逃逸的办法</a></li>
</ul>
</div>
</div>

<div id="outline-container-org3c18216" class="outline-2">
<h2 id="org3c18216">什么是内存逃逸</h2>
<div class="outline-text-2" id="text-org3c18216">
<p>
内存空间包含两个最重要的区域：堆区（Heap）和栈区（Stack）。在 C 语言中，栈区域会专门存放函数的参数、局部变量等，栈的地址从内存高地址往低地址增长；而堆内存正好相反，堆地址从内存低地址往高地址增长。如果想要在堆区域分配内存，需要我们手动调用 <code>malloc</code> 函数去堆区域申请内存分配，使用完还需要手动释放，如果没有释放就会导致内存泄漏。<br>
</p>

<p>
写过 C 语言的朋友应该都知道 C 语言函数是不能返回局部变量地址的（特指存放于栈区局部变量地址），除非是局部静态变量地址、字符串常量地址、动态分配地址。其原因是一般局部变量的作用域只在函数内，其存储位置在栈区中，当程序调用完函数后，局部变量会随此函数一起被释放。其地址指向的内容不明（原先的数值可能不变，也可能改变）。而局部静态变量地址和字符串常量地址存放在数据区，动态分配地址存放在堆区，函数运行结束后只会释放栈区的内容，而不会改变数据区和堆区。<br>
</p>

<p>
所以在 C 语言中我们想在一个函数中返回局部变量地址时，有三个正确的方式：返回静态局部变量地址、返回字符串常量地址，返回动态分配在堆上的地址，因为他们都不在栈区，即使释放函数，其内容也不会受影响，我们以在返回堆上内存地址为例看一段代码：<br>
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #d75fd7;">#include</span> <span style="color: #2aa198;">"stdio.h"</span>
<span style="color: #d75fd7;">#include</span> <span style="color: #2aa198;">"stdlib.h"</span>

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36820;&#22238;&#21160;&#24577;&#20998;&#37197;&#30340;&#22320;&#22336;</span>
<span style="color: #df005f; font-weight: bold;">int</span> *<span style="color: #d75fd7; font-weight: bold;">f1</span>() {
    <span style="color: #df005f; font-weight: bold;">int</span> <span style="color: #8787d7;">a</span> = <span style="color: #d75fd7;">9</span>;
    <span style="color: #df005f; font-weight: bold;">int</span> *<span style="color: #8787d7;">pa</span> = (<span style="color: #df005f; font-weight: bold;">int</span> *)malloc(<span style="color: #d75fd7;">8</span>);
    *pa = a;
    <span style="color: #268bd2; font-weight: bold;">return</span> pa;
}

<span style="color: #df005f; font-weight: bold;">int</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #df005f; font-weight: bold;">int</span> *<span style="color: #8787d7;">pb</span>;
    pb = f1();
    printf(<span style="color: #2aa198;">"after : *pb = %d\tpb = %p\n"</span>, *pb, pb);
    free(pb);
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">1</span>;
}
</pre>
</div>

<p>
通过上面的例子我们知道在C语言中动态内存的分配与释放完全交与程序员的手中，这样就会导致我们在写程序时如履薄冰，好处是我们可以完全掌控内存，缺点是我们一不小心就会导致内存泄漏，所以很多现代语言都有GC机制，Go就是一门带垃圾回收的语言，真正解放了我们程序员的双手，我们不需要在像写C语言那样考虑是否能返回局部变量地址了，内存管理交与给编译器，编译器会经过逃逸分析把变量合理的分配到"正确"的地方。<br>
</p>

<p>
说到这里，可以简单总结一下什么是内存逃逸了：<br>
</p>

<blockquote>
<p>
在一段程序中，每一个函数都会有自己的内存区域存放自己的局部变量、返回地址等，这些内存会由编译器在栈中进行分配，每一个函数都会分配一个栈桢，在函数运行结束后进行销毁，但是有些变量我们想在函数运行结束后仍然使用它，那么就需要把这个变量在堆上分配，这种从"栈"上逃逸到"堆"上的现象就成为内存逃逸。<br>
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org184aa05" class="outline-2">
<h2 id="org184aa05">内存逃逸的危害</h2>
<div class="outline-text-2" id="text-org184aa05">
<p>
堆是一块没有特定结构，也没有固定大小的内存区域，可以根据需要进行调整。全局变量，内存占用较大的局部变量，函数调用结束后不能立刻回收的局部变量都会存在堆里面。变量在堆上的分配和回收都比在栈上开销大的多。对于 go 这种带 GC 的语言来说，会增加 gc 压力，同时也容易造成内存碎片。<br>
</p>
</div>
</div>
<div id="outline-container-orgb92288b" class="outline-2">
<h2 id="orgb92288b">什么是逃逸分析</h2>
<div class="outline-text-2" id="text-orgb92288b">
<p>
上面我们知道了什么是内存逃逸，下面我们就来看一看什么是逃逸分析？<br>
</p>

<p>
上文我们说到 C 语言使用 <code>malloc</code> 在堆上动态分配内存后，还需要手动调用 <code>free</code> 释放内存，如果不释放就会造成内存泄漏的风险。在 Go 语言中堆内存的分配与释放完全不需要我们去管了，Go 语言引入了GC 机制，GC 机制会对位于堆上的对象进行自动管理，当某个对象不可达时(即没有其对象引用它时)，他将会被回收并被重用。虽然引入 GC 可以让开发人员降低对内存管理的心智负担，但是 GC 也会给程序带来性能损耗，当堆内存中有大量待扫描的堆内存对象时，将会给 GC 带来过大的压力，虽然 Go 语言使用的是标记清除算法，并且在此基础上使用了三色标记法和写屏障技术，提高了效率，但是如果我们的程序仍在堆上分配了大量内存，依赖会对 GC 造成不可忽视的压力。因此为了减少 GC 造成的压力，Go 语言引入了逃逸分析，也就是想法设法尽量减少在堆上的内存分配，可以在栈中分配的变量尽量留在栈中。<br>
</p>

<p>
小结逃逸分析：<br>
</p>

<blockquote>
<p>
逃逸分析就是指程序在编译阶段根据代码中的数据流，对代码中哪些变量需要在栈中分配，哪些变量需要在堆上分配进行静态分析的方法。堆和栈相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。栈内存分配则会非常快。栈分配内存只需要两个 CPU 指令："PUSH"和"RELEASE"，分配和释放；而堆分配内存首先需要去找到一块大小合适的内存块，之后要通过垃圾回收才能释放。所以逃逸分析更做到更好内存分配，提高程序的运行速度。<br>
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org3560388" class="outline-2">
<h2 id="org3560388">Go 语言中的逃逸分析</h2>
<div class="outline-text-2" id="text-org3560388">
<p>
通过 <code>go build -gcflags '-m -m 'l'</code> 命令查看到逃逸分析的结果，分析内联优化时使用的 <code>-gcflags '-m -m'</code> 能看到所有的编译器优化，这里使用 <code>-l</code> 禁用掉内联优化，只关注逃逸优化就好。<br>
</p>
</div>
</div>
<div id="outline-container-org8a2cbe5" class="outline-2">
<h2 id="org8a2cbe5">一些内存逃逸的例子</h2>
<div class="outline-text-2" id="text-org8a2cbe5">
</div>
<div id="outline-container-orgc0a6982" class="outline-3">
<h3 id="orgc0a6982">1. 函数返回局部指针变量</h3>
<div class="outline-text-3" id="text-orgc0a6982">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">Add</span>(<span style="color: #8787d7;">x</span>,<span style="color: #8787d7;">y</span> <span style="color: #df005f; font-weight: bold;">int</span>) *<span style="color: #df005f; font-weight: bold;">int</span> {
    <span style="color: #8787d7;">res</span> := <span style="color: #d75fd7;">0</span>
    res = x + y
    <span style="color: #268bd2; font-weight: bold;">return</span> &amp;res
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>()  {
    <span style="color: #d75fd7; font-weight: bold;">Add</span>(<span style="color: #d75fd7;">1</span>, <span style="color: #d75fd7;">2</span>)
}
</pre>
</div>

<p>
函数返回的局部变量是一个指针变量，当函数 <code>Add</code> 执行结束后，对应的栈桢就会被销毁，但是引用已经返回到函数之外，如果我们在外部解引用地址，就会导致程序访问非法内存，就像上面的C语言的例子一样，所以编译器经过逃逸分析后将其在堆上分配内存。<br>
</p>
</div>
</div>
<div id="outline-container-org1986c11" class="outline-3">
<h3 id="org1986c11">2. interface 类型逃逸</h3>
<div class="outline-text-3" id="text-org1986c11">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">str</span> := <span style="color: #2aa198;">"hello world"</span>
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"%v"</span>, str)
}
</pre>
</div>

<p>
<code>str</code> 是 <code>main</code> 函数中的一个局部变量，传递给 <code>fmt.Println()</code> 函数后发生了逃逸，这是因为 <code>fmt.Println()</code> 函数的入参是一个 <code>interface{}</code> 类型，如果函数参数为 <code>interface{}</code> ，那么在编译期间就很难确定其参数的具体类型，也会发送逃逸。<br>
</p>

<p>
但是 <code>str</code> 这个变量没有在堆上进行分配，只是它存储的值逃逸到堆上了，也就说任何被 <code>str</code> 引用的对象必须分配在堆上。<br>
</p>

<p>
如果把代码改成这样：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">str</span> := <span style="color: #2aa198;">"hello world"</span>
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"%p"</span>, &amp;str)
}
</pre>
</div>

<p>
这回 <code>str</code> 逃逸到了堆上，在堆上进行内存分配，这是因为我们访问 <code>str</code> 的地址，因为入参是 <code>interface</code> 类型，所以变量 <code>str</code> 的地址以实参的形式传入 <code>fmt.Printf</code> 后被装箱到一个 <code>interface{}</code> 形参变量中，装箱的形参变量的值要在堆上分配，但是还要存储一个栈上的地址，也就是 <code>str</code> 的地址，堆上的对象不能存储一个栈上的地址，所以 <code>str</code> 也逃逸到堆上，在堆上分配内存。 <b>（这里注意一个知识点：Go语言的参数传递只有值传递）</b><br>
</p>
</div>
</div>
<div id="outline-container-orgf0b9bed" class="outline-3">
<h3 id="orgf0b9bed">3. 闭包产生的逃逸</h3>
<div class="outline-text-3" id="text-orgf0b9bed">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">Increase</span>() <span style="color: #268bd2; font-weight: bold;">func</span>() <span style="color: #df005f; font-weight: bold;">int</span> {
    <span style="color: #8787d7;">n</span> := <span style="color: #d75fd7;">0</span>
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">func</span>() <span style="color: #df005f; font-weight: bold;">int</span> {
        n++
        <span style="color: #268bd2; font-weight: bold;">return</span> n
    }
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">in</span> := <span style="color: #d75fd7; font-weight: bold;">Increase</span>()
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #d75fd7; font-weight: bold;">in</span>())
}
</pre>
</div>

<p>
因为函数也是一个指针类型，所以匿名函数当作返回值时也发生了逃逸，在匿名函数中使用外部变量 <code>n</code> ，这个变量 <code>n</code> 会一直存在直到 <code>in</code> 被销毁，所以 <code>n</code> 变量逃逸到了堆上。<br>
</p>
</div>
</div>
<div id="outline-container-org563c6a7" class="outline-3">
<h3 id="org563c6a7">4. 变量大小不确定及栈空间不足引发逃逸</h3>
<div class="outline-text-3" id="text-org563c6a7">
<p>
我们先使用 <code>ulimit -a</code> 查看操作系统的栈空间。<br>
</p>

<pre class="example" id="org32aeae7">
$ ulimit -a
-t: cpu time (seconds)              unlimited
-f: file size (blocks)              unlimited
-d: data seg size (kbytes)          unlimited
-s: stack size (kbytes)             8192
-c: core file size (blocks)         unlimited
-m: resident set size (kbytes)      unlimited
-u: processes                       30753
-n: file descriptors                8192
-l: locked-in-memory size (kbytes)  64
-v: address space (kbytes)          unlimited
-x: file locks                      unlimited
-i: pending signals                 30753
-q: bytes in POSIX msg queues       819200
-e: max nice                        0
-r: max rt priority                 0
-N 15:                              unlimited
</pre>

<p>
我的电脑的栈空间大小是 8192，所以根据这个我们写一个测试用例：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> main

<span style="color: #268bd2; font-weight: bold;">import</span> (
    <span style="color: #2aa198;">"math/rand"</span>
)

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">LessThan8192</span>() {
    <span style="color: #8787d7;">nums</span> := <span style="color: #268bd2;">make</span>([]<span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #d75fd7;">100</span>) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">= 64KB</span>
    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := <span style="color: #d75fd7;">0</span>; i &lt; <span style="color: #268bd2;">len</span>(nums); i++ {
        nums[i] = rand.<span style="color: #d75fd7; font-weight: bold;">Int</span>()
    }
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">MoreThan8192</span>() {
    <span style="color: #8787d7;">nums</span> := <span style="color: #268bd2;">make</span>([]<span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #d75fd7;">1000000</span>) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">= 64KB</span>
    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := <span style="color: #d75fd7;">0</span>; i &lt; <span style="color: #268bd2;">len</span>(nums); i++ {
        nums[i] = rand.<span style="color: #d75fd7; font-weight: bold;">Int</span>()
    }
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">NonConstant</span>() {
    <span style="color: #8787d7;">number</span> := <span style="color: #d75fd7;">10</span>
    <span style="color: #8787d7;">s</span> := <span style="color: #268bd2;">make</span>([]<span style="color: #df005f; font-weight: bold;">int</span>, number)
    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := <span style="color: #d75fd7;">0</span>; i &lt; <span style="color: #268bd2;">len</span>(s); i++ {
        s[i] = i
    }
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #d75fd7; font-weight: bold;">NonConstant</span>()
    <span style="color: #d75fd7; font-weight: bold;">LessThan8192</span>()
    <span style="color: #d75fd7; font-weight: bold;">MoreThan8192</span>()
}
</pre>
</div>

<p>
当栈空间足够时，不会发生逃逸，但是当变量过大时，已经完全超过栈空间的大小时，将会发生逃逸到堆上分配内存。<br>
</p>

<p>
同样当我们初始化切片时，没有直接指定大小，而是填入的变量，这种情况为了保证内存的安全，编译器也会触发逃逸，在堆上进行分配内存。<br>
</p>
</div>
</div>
<div id="outline-container-org639ba30" class="outline-3">
<h3 id="org639ba30">小结</h3>
<div class="outline-text-3" id="text-org639ba30">
<p>
能引起变量逃逸到堆上的典型情况：<br>
</p>

<dl class="org-dl">
<dt>在方法内把局部变量指针返回</dt><dd>局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。<br></dd>
<dt>发送指针或带有指针的值到 channel 中</dt><dd>在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。<br></dd>
<dt>在一个切片上存储指针或带指针的值</dt><dd>一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。<br></dd>
<dt>slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )</dt><dd>slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。<br></dd>
<dt>在 interface 类型上调用方法</dt><dd>在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。<br></dd>
</dl>
</div>
</div>
</div>
<div id="outline-container-orgd030d11" class="outline-2">
<h2 id="orgd030d11">避免内存逃逸的办法</h2>
<div class="outline-text-2" id="text-orgd030d11">
<ul class="org-ul">
<li>对于小型的数据，使用传值而不是传指针，避免内存逃逸。<br></li>
<li>避免使用长度不固定的slice切片，在编译期无法确定切片长度，只能将切片使用堆分配。<br></li>
<li>interface 调用方法会发生内存逃逸，在热点代码片段，谨慎使用。<br></li>
</ul>



<div class="reference">
	<ul style="list-style: none;">
		<li><a href="https://segmentfault.com/a/1190000040450335" target="_blank">详解Go语言中的内存逃逸</a></li>
		<li><a href="https://segmentfault.com/a/1190000039843497" target="_blank">简单聊聊内存逃逸 ｜ 剑指 offer - golang</a></li>
	</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-02-15 16:02 Tue</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-02-16 Wed 00:21</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
