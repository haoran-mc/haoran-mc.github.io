<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-02-03 Thu 14:57 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>GO-MAKE和NEW</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">GO-MAKE和NEW</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org7a90654">简介</a></li>
<li><a href="#org8250cfc">make</a></li>
<li><a href="#org455de47">new</a></li>
<li><a href="#orga71d05b">小结</a></li>
</ul>
</div>
</div>

<div id="outline-container-org7a90654" class="outline-2">
<h2 id="org7a90654">简介</h2>
<div class="outline-text-2" id="text-org7a90654">
<p>
当我们想要在 Go 语言中初始化一个结构时，可能会用到两个不同的关键字 — <code>make</code> 和 <code>new</code> 。因为它们的功能相似，所以初学者可能会对这两个关键字的作用感到困惑，但是它们两者能够初始化的变量却有较大的不同。<br>
</p>

<ul class="org-ul">
<li><code>make</code> 的作用是初始化内置的数据结构，也就是我们在前面提到的切片、哈希表和 Channel；<br></li>
<li><code>new</code> 的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针；<br></li>
</ul>

<p>
我们在代码中往往都会使用如下所示的语句初始化这三类基本类型，这三个语句分别返回了不同类型的数据结构：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">slice</span> := <span style="color: #268bd2;">make</span>([]<span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #d75fd7;">0</span>, <span style="color: #d75fd7;">100</span>)
<span style="color: #8787d7;">hash</span> := <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">map</span>[<span style="color: #df005f; font-weight: bold;">int</span>]<span style="color: #df005f; font-weight: bold;">bool</span>, <span style="color: #d75fd7;">10</span>)
<span style="color: #8787d7;">ch</span> := <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #d75fd7;">5</span>)
</pre>
</div>

<ul class="org-ul">
<li><code>slice</code> 是一个包含 <code>data</code> 、 <code>cap</code> 和 <code>len</code> 的结构体 <a href="https://draveness.me/golang/tree/reflect.SliceHeader">reflect.SliceHeader</a> ；<br></li>
<li><code>hash</code> 是一个指向 <a href="https://draveness.me/golang/tree/runtime.hmap">runtime.hmap</a>  结构体的指针；<br></li>
<li><code>ch</code> 是一个指向 <a href="https://draveness.me/golang/tree/runtime.hchan">runtime.hchan</a>  结构体的指针；<br></li>
</ul>

<p>
相比与复杂的 <code>make</code> 关键字， <code>new</code> 的功能就简单多了，它只能接收类型作为参数然后返回一个指向该类型的指针：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">i</span> := <span style="color: #268bd2;">new</span>(<span style="color: #df005f; font-weight: bold;">int</span>)

<span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">v</span> <span style="color: #df005f; font-weight: bold;">int</span>
<span style="color: #8787d7;">i</span> := &amp;v
</pre>
</div>

<p>
上述代码片段中的两种不同初始化方法是等价的，它们都会创建一个指向 <code>int</code> 零值的指针。<br>
</p>

<img src="./images/Go语言设计与实现-make与new初始化的类型.png" width=650px/>

<p>
图 5-14 make 和 new 初始化的类型<br>
</p>

<p>
接下来我们将分别介绍 <code>make</code> 和 <code>new</code> 初始化不同数据结构的过程，我们会从编译期间和运行时两个不同阶段理解这两个关键字的原理，不过由于前面的章节已经详细地分析过 <code>make</code> 的原理，所以这里会将重点放在另一个关键字 <code>new</code> 上。<br>
</p>
</div>
</div>
<div id="outline-container-org8250cfc" class="outline-2">
<h2 id="org8250cfc">make</h2>
<div class="outline-text-2" id="text-org8250cfc">
<p>
在前面的章节中我们已经谈到过 make 在创建切片、哈希表和 Channel 的具体过程，所以在这一小节，我们只是会简单提及 make 相关的数据结构的初始化原理。<br>
</p>

<img src="./images/Go语言设计与实现-make关键字的类型检查.png" width=650px />

<p>
图 5-15 make 关键字的类型检查<br>
</p>

<p>
在编译期间的类型检查阶段，Go 语言会将代表 <code>make</code> 关键字的 <code>OMAKE</code> 节点根据参数类型的不同转换成了 <code>OMAKESLICE</code> 、 <code>OMAKEMAP</code> 和 <code>OMAKECHAN</code> 三种不同类型的节点，这些节点会调用不同的运行时函数来初始化相应的数据结构。<br>
</p>
</div>
</div>
<div id="outline-container-org455de47" class="outline-2">
<h2 id="org455de47">new</h2>
<div class="outline-text-2" id="text-org455de47">
<p>
编译器会在中间代码生成阶段通过以下两个函数处理该关键字：<br>
</p>

<ol class="org-ol">
<li><a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.callnew">cmd/compile/internal/gc.callnew</a>  会将关键字转换成 <code>ONEWOBJ</code> 类型的节点；<br></li>
<li><a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.state.expr">cmd/compile/internal/gc.state.expr</a>  会根据申请空间的大小分两种情况处理：<br>
<ol class="org-ol">
<li>如果申请的空间为 0，就会返回一个表示空指针的 <code>zerobase</code> 变量；<br></li>
<li>在遇到其他情况时会将关键字转换成 <a href="https://draveness.me/golang/tree/runtime.newobject">runtime.newobject</a>  函数：<br></li>
</ol></li>
</ol>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">callnew</span>(<span style="color: #8787d7;">t</span> *<span style="color: #df005f; font-weight: bold;">types.Type</span>) *<span style="color: #df005f; font-weight: bold;">Node</span> {
    ...
        <span style="color: #8787d7;">n</span> := <span style="color: #d75fd7; font-weight: bold;">nod</span>(ONEWOBJ, <span style="color: #d75fd7; font-weight: bold;">typename</span>(t), <span style="color: #d75fd7;">nil</span>)
    ...
        <span style="color: #268bd2; font-weight: bold;">return</span> n
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">s</span> *<span style="color: #df005f; font-weight: bold;">state</span>) <span style="color: #d75fd7; font-weight: bold;">expr</span>(<span style="color: #8787d7;">n</span> *<span style="color: #df005f; font-weight: bold;">Node</span>) *<span style="color: #df005f; font-weight: bold;">ssa.Value</span> {
    <span style="color: #268bd2; font-weight: bold;">switch</span> n.Op {
    <span style="color: #268bd2; font-weight: bold;">case</span> ONEWOBJ:
        <span style="color: #268bd2; font-weight: bold;">if</span> n.Type.<span style="color: #d75fd7; font-weight: bold;">Elem</span>().<span style="color: #d75fd7; font-weight: bold;">Size</span>() == <span style="color: #d75fd7;">0</span> {
            <span style="color: #268bd2; font-weight: bold;">return</span> s.<span style="color: #d75fd7; font-weight: bold;">newValue1A</span>(ssa.OpAddr, n.Type, zerobaseSym, s.sb)
        }
        <span style="color: #8787d7;">typ</span> := s.<span style="color: #d75fd7; font-weight: bold;">expr</span>(n.Left)
        <span style="color: #8787d7;">vv</span> := s.<span style="color: #d75fd7; font-weight: bold;">rtcall</span>(newobject, <span style="color: #d75fd7;">true</span>, []*<span style="color: #df005f; font-weight: bold;">types.Type</span>{n.Type}, typ)
        <span style="color: #268bd2; font-weight: bold;">return</span> vv[<span style="color: #d75fd7;">0</span>]
    }
}
</pre>
</div>

<p>
需要注意的是，无论是直接使用 <code>new</code> ，还是使用 <code>var</code> 初始化变量，它们在编译器看来都是 <code>ONEW</code> 和 <code>ODCL</code> 节点。如果变量会逃逸到堆上，这些节点在这一阶段都会被 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.walkstmt">cmd/compile/internal/gc.walkstmt</a>  转换成通过 <a href="https://draveness.me/golang/tree/runtime.newobject">runtime.newobject</a> 函数并在堆上申请内存：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">walkstmt</span>(<span style="color: #8787d7;">n</span> *<span style="color: #df005f; font-weight: bold;">Node</span>) *<span style="color: #df005f; font-weight: bold;">Node</span> {
    <span style="color: #268bd2; font-weight: bold;">switch</span> n.Op {
    <span style="color: #268bd2; font-weight: bold;">case</span> ODCL:
        <span style="color: #8787d7;">v</span> := n.Left
        <span style="color: #268bd2; font-weight: bold;">if</span> v.<span style="color: #d75fd7; font-weight: bold;">Class</span>() == PAUTOHEAP {
            <span style="color: #268bd2; font-weight: bold;">if</span> prealloc[v] == <span style="color: #d75fd7;">nil</span> {
                prealloc[v] = <span style="color: #d75fd7; font-weight: bold;">callnew</span>(v.Type)
            }
            <span style="color: #8787d7;">nn</span> := <span style="color: #d75fd7; font-weight: bold;">nod</span>(OAS, v.Name.Param.Heapaddr, prealloc[v])
            nn.<span style="color: #d75fd7; font-weight: bold;">SetColas</span>(<span style="color: #d75fd7;">true</span>)
            nn = <span style="color: #d75fd7; font-weight: bold;">typecheck</span>(nn, ctxStmt)
            <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7; font-weight: bold;">walkstmt</span>(nn)
        }
    <span style="color: #268bd2; font-weight: bold;">case</span> ONEW:
        <span style="color: #268bd2; font-weight: bold;">if</span> n.Esc == EscNone {
            <span style="color: #8787d7;">r</span> := <span style="color: #d75fd7; font-weight: bold;">temp</span>(n.Type.<span style="color: #d75fd7; font-weight: bold;">Elem</span>())
            r = <span style="color: #d75fd7; font-weight: bold;">nod</span>(OAS, r, <span style="color: #d75fd7;">nil</span>)
            r = <span style="color: #d75fd7; font-weight: bold;">typecheck</span>(r, ctxStmt)
            init.<span style="color: #d75fd7; font-weight: bold;">Append</span>(r)
            r = <span style="color: #d75fd7; font-weight: bold;">nod</span>(OADDR, r.Left, <span style="color: #d75fd7;">nil</span>)
            r = <span style="color: #d75fd7; font-weight: bold;">typecheck</span>(r, ctxExpr)
            n = r
        } <span style="color: #268bd2; font-weight: bold;">else</span> {
            n = <span style="color: #d75fd7; font-weight: bold;">callnew</span>(n.Type.<span style="color: #d75fd7; font-weight: bold;">Elem</span>())
        }
    }
}
</pre>
</div>

<p>
不过这也不是绝对的，如果通过 <code>var</code> 或者 <code>new</code> 创建的变量不需要在当前作用域外生存，例如不用作为返回值返回给调用方，那么就不需要初始化在堆上。<br>
</p>

<p>
<a href="https://draveness.me/golang/tree/runtime.newobject">runtime.newobject</a>  函数会获取传入类型占用空间的大小，调用 <a href="https://draveness.me/golang/tree/runtime.mallocgc">runtime.mallocgc</a>  在堆上申请一片内存空间并返回指向这片内存空间的指针：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">newobject</span>(<span style="color: #8787d7;">typ</span> *<span style="color: #df005f; font-weight: bold;">_type</span>) <span style="color: #df005f; font-weight: bold;">unsafe.Pointer</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7; font-weight: bold;">mallocgc</span>(typ.size, typ, <span style="color: #d75fd7;">true</span>)
}
</pre>
</div>

<p>
<a href="https://draveness.me/golang/tree/runtime.mallocgc">runtime.mallocgc</a> 函数的实现大概有 200 多行代码，我们会在后面的章节中详细分析 Go 语言的内存管理机制。<br>
</p>
</div>
</div>
<div id="outline-container-orga71d05b" class="outline-2">
<h2 id="orga71d05b">小结</h2>
<div class="outline-text-2" id="text-orga71d05b">
<p>
这里我们简单总结一下 Go 语言中 <code>make</code> 和 <code>new</code> 关键字的实现原理， <code>make</code> 关键字的作用是创建切片、哈希表和 Channel 等内置的数据结构，而 <code>new</code> 的作用是为类型申请一片内存空间，并返回指向这片内存的指针。<br>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-02-02 19:02 Wed</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-02-03 Thu 14:57</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
