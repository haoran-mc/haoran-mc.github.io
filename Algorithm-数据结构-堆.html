<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-09-30 四 10:37 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>堆</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran &lt;haoran.mc@outlook.com&gt;">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">堆</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgf5d3cf5">堆</a></li>
<li><a href="#orgf7734f3">二叉堆</a>
<ul>
<li><a href="#org710254c">插入操作</a></li>
<li><a href="#org4153062">建堆</a>
<ul>
<li><a href="#org3b2f0d9">向上建堆</a></li>
<li><a href="#org3354145">向下建堆</a></li>
</ul>
</li>
<li><a href="#orgc013ff3">删除操作</a></li>
</ul>
</li>
<li><a href="#org36edf71">对顶堆</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgf5d3cf5" class="outline-2">
<h2 id="orgf5d3cf5">堆</h2>
<div class="outline-text-2" id="text-orgf5d3cf5">
<ul class="org-ul">
<li><p>
堆是一棵 <b>完全二叉树</b> ,树中每个结点都不小于(或不大于)其左右孩子结点的值
</p>
<ul class="org-ul">
<li>如果父亲结点的值小于或等于孩子结点的值，那么称这样的堆为 <b>小顶堆</b></li>
<li>如果父亲结点的值大于或等于孩子结点的值，那么称这样的堆为 <b>大顶堆</b></li>
</ul>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">数据结构</td>
<td class="org-left">配对堆</td>
<td class="org-left">二叉堆</td>
<td class="org-left">左偏树</td>
<td class="org-left">二项堆</td>
<td class="org-left">斐波那契数列</td>
</tr>

<tr>
<td class="org-left">插入</td>
<td class="org-left">O(1)</td>
<td class="org-left">O(logn)</td>
<td class="org-left">O(logn)</td>
<td class="org-left">O(1)</td>
<td class="org-left">O(1)</td>
</tr>

<tr>
<td class="org-left">查询最小值</td>
<td class="org-left">O(1)</td>
<td class="org-left">O(1)</td>
<td class="org-left">O(1)</td>
<td class="org-left">O(logn)</td>
<td class="org-left">O(1)</td>
</tr>

<tr>
<td class="org-left">删除最小值</td>
<td class="org-left">O(logn)</td>
<td class="org-left">O(logn)</td>
<td class="org-left">O(logn)</td>
<td class="org-left">O(logn)</td>
<td class="org-left">O(logn)</td>
</tr>

<tr>
<td class="org-left">合并</td>
<td class="org-left">O(1)</td>
<td class="org-left">O(n)</td>
<td class="org-left">O(logn)</td>
<td class="org-left">O(logn)</td>
<td class="org-left">O(1)</td>
</tr>

<tr>
<td class="org-left">减小一个元素的值</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">O(logn)</td>
<td class="org-left">O(logn)</td>
<td class="org-left">O(logn)</td>
<td class="org-left">O(1)</td>
</tr>

<tr>
<td class="org-left">是否支持可持久化</td>
<td class="org-left">×</td>
<td class="org-left">1</td>
<td class="org-left">1</td>
<td class="org-left">1</td>
<td class="org-left">×</td>
</tr>
</tbody>
</table></li>
</ul>
</div>
</div>
<div id="outline-container-orgf7734f3" class="outline-2">
<h2 id="orgf7734f3">二叉堆</h2>
<div class="outline-text-2" id="text-orgf7734f3">
<p>
二叉堆是一棵完全二叉树，这棵树父亲的权值不小于儿子的权值(大根堆)
</p>
</div>
<div id="outline-container-org710254c" class="outline-3">
<h3 id="org710254c">插入操作</h3>
<div class="outline-text-3" id="text-org710254c">
<ol class="org-ol">
<li>将新的元素插入到最下一层最右的叶子之后，如果最下一层已满，就新增一层</li>
<li><b>向上调整</b> ：如果这个结点的权值大，就与父亲交换，重复此过程</li>
</ol>
</div>
</div>
<div id="outline-container-org4153062" class="outline-3">
<h3 id="org4153062">建堆</h3>
<div class="outline-text-3" id="text-org4153062">
</div>
<div id="outline-container-org3b2f0d9" class="outline-4">
<h4 id="org3b2f0d9">向上建堆</h4>
<div class="outline-text-4" id="text-org3b2f0d9">
<ol class="org-ol">
<li>for (int i = 1; i &lt;= n; ++i) 从第一位到最后一位输入</li>
<li>每输入一位，就向上调整，如果当前结点比父亲结点大，就交换</li>
<li>直到当前结点不再大于父亲结点</li>
</ol>
</div>
</div>
<div id="outline-container-org3354145" class="outline-4">
<h4 id="org3354145">向下建堆</h4>
<div class="outline-text-4" id="text-org3354145">
<ol class="org-ol">
<li>for (int i = n; i &lt;= 1; &#x2013;i) 从最后一位到第一位输入</li>
<li>每输入一位，就向下调整，如果当前结点不比两个子结点大，就与子结点中最大的那个交换</li>
<li>直到当前结点比两个子结点都大</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgc013ff3" class="outline-3">
<h3 id="orgc013ff3">删除操作</h3>
<div class="outline-text-3" id="text-orgc013ff3">
<ol class="org-ol">
<li>交换根结点与最后一个结点，然后删掉</li>
<li><b>向下调整</b> ：交换后，跟结点可能不满足堆性质，在该结点的儿子中找到一个最大的交换，重复此过程</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org36edf71" class="outline-2">
<h2 id="org36edf71">对顶堆</h2>
<div class="outline-text-2" id="text-org36edf71">
<p>
<b>维护一个序列上第k大的数</b>
对顶堆由一个大根堆和一个小根堆组成小根堆维护大于等于第k大的值 &amp;&amp; 大根堆维护小于第k大的值 &amp;&amp; 大根堆与小根堆存储全部的值
</p>

<pre class="example" id="org1f48752">
..\        /
.5 \      / 15    大根堆
....\    /
......25

......36 (第36大的值)
..../    \
64 /      \ 72    小根堆
../        \
</pre>

<ul class="org-ul">
<li>维护
<ol class="org-ol">
<li>当小根堆堆顶大小大于k时，不断将大根堆堆顶取出并插入小根堆，直到小根堆堆顶是第k大的值</li>
<li>当小根堆堆顶大小小于第k大的值，不断将小根堆堆顶取出并插入到大根堆，直到小根堆堆顶是第k大的值</li>
</ol></li>
<li><b>插入元素</b> : 若插入的元素大于等于小根堆堆顶元素，则插入小根堆，否则插入大根堆</li>
<li><b>查询第k大的数</b> : 小根堆堆顶元素即是第k大的数</li>
<li><b>删除第k大的数</b> : 删除小根堆堆顶元素，然后维护对顶堆</li>
<li><b>第k大的数数值发生变化</b> : 根据新的值维护对顶堆</li>
</ul>

<p>
查询操作时间复杂度为O(1)，其余时间复杂度为O(logn)
</p>
</div>
</div>
</div>
</body>
</html>
