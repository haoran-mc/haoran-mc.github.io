<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-10-14 Thu 09:43 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>卡特兰数</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">卡特兰数</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org1b7d295">Catalan 数列</a></li>
<li><a href="#orgf99a201">递推式</a></li>
<li><a href="#org2a8fd45">出栈次序</a>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#orgdc09b51">常规分析</a></li>
<li><a href="#orgd10f1a2">非常规分析</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org13d3680">路径计数问题</a></li>
<li><a href="#orgb39d171">排身高</a></li>
</ul>
</div>
</div>

<div id="outline-container-org1b7d295" class="outline-2">
<h2 id="org1b7d295">Catalan 数列</h2>
<div class="outline-text-2" id="text-org1b7d295">
<p>
以下问题属于 \(Catalan\) 数列：<br>
</p>

<ol class="org-ol">
<li>有 \(2n\) 个人排成一行进入剧场。入场费 \(5\) 元。其中只有 \(n\) 个人有一张 \(5\) 元钞票，另外 \(n\) 人只有 \(10\) 元钞票，剧院无其它钞票，问有多少中方法使得只要有 \(10\) 元的人买票，售票处就有 \(5\) 元的钞票找零？<br></li>
<li>一位大城市的律师在她住所以北 \(n\) 个街区和以东 \(n\) 个街区处工作。每天她走 \(2n\) 个街区去上班。如果他从不穿越（但可以碰到）从家到办公室的对角线，那么有多少条可能的道路？<br></li>
<li>在圆上选择 \(2n\) 个点，将这些点成对连接起来使得所得到的 \(n\) 条线段不相交的方法数？<br></li>
<li>对角线不相交的情况下，将一个凸多边形区域分成三角形区域的方法数？<br></li>
<li>一个栈（无穷大）的进栈序列为 \(1, 2, 3, ...， n\) 有多少个不同的出栈序列？<br></li>
<li>\(n\) 个结点可构造多少个不同的二叉树？<br></li>
<li>\(n\) 个 \(+1\) 和 \(n\) 个 \(-1\) 构成 \(2n\) 项 \(a_1, a_2, a_3, \dots，a_{2n}\)，其部分和满足 \(a_1 + a_2 + a_3 + \dots + a_k \geq 0 (k = 1, 2, 3, \dots, 2n) \) 对与 \(n\) 该数列为？<br></li>
<li>矩阵连乘： \(P = a_1 \times a_2 \times a_3 \times \dots \times a_n\)，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案<br></li>

<li>给定 \(n\) 个 \(0\) 和 \(n\) 个 \(1\)，它们按照某种顺序排成长度为 \(2n\) 的序列，满足前缀中 \(0\) 的个数都不少与 \(1\) 的个数的序列的数量为 \(cnt = \frac{C_{2n}^n}{n+1}\)<br></li>
<li>给定 \(m\) 个 \(0\) 和 \(n-m\) 个 \(1\)，它们按照某种顺序排成长度为 \(n\) 的序列，满足前缀中 \(0\) 的个数都不少与 \(1\) 的个数的序列的数量为 \(cnt = C_{2n}^m - C_{2n}^{m-1}\)<br></li>
</ol>

<p>
其对应的序列为：<br>
</p>
<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(H_0\)</th>
<th scope="col" class="org-right">\(H_1\)</th>
<th scope="col" class="org-right">\(H_2\)</th>
<th scope="col" class="org-right">\(H_3\)</th>
<th scope="col" class="org-right">\(H_4\)</th>
<th scope="col" class="org-right">\(H_5\)</th>
<th scope="col" class="org-right">\(H_6\)</th>
<th scope="col" class="org-right">\(H_7\)</th>
<th scope="col" class="org-right">\(H_8\)</th>
<th scope="col" class="org-right">\(H_9\)</th>
<th scope="col" class="org-right">\(H_{10}\)</th>
<th scope="col" class="org-right">\(H_{11}\)</th>
<th scope="col" class="org-right">\(H_{12}\)</th>
<th scope="col" class="org-right">\(H_{13}\)</th>
<th scope="col" class="org-right">\(H_{14}\)</th>
<th scope="col" class="org-right">\(H_{15}\)</th>
<th scope="col" class="org-right">\(H_{16}\)</th>
<th scope="col" class="org-left">&hellip;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">5</td>
<td class="org-right">14</td>
<td class="org-right">42</td>
<td class="org-right">132</td>
<td class="org-right">429</td>
<td class="org-right">1430</td>
<td class="org-right">4862</td>
<td class="org-right">16796</td>
<td class="org-right">58786</td>
<td class="org-right">208012</td>
<td class="org-right">742900</td>
<td class="org-right">2674440</td>
<td class="org-right">9694845</td>
<td class="org-right">35357670</td>
<td class="org-left">&hellip;</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgf99a201" class="outline-2">
<h2 id="orgf99a201">递推式</h2>
<div class="outline-text-2" id="text-orgf99a201">
<p>
递推关系的解为：<br>
</p>
<ul class="org-ul">
<li>\(H_n = \frac{1}{n + 1} C_{2n}^{n}\ (n \geq 2, n \in N_{+})\)<br></li>
</ul>

<p>
关于 \(Catalan\) 数的常见公式：<br>
</p>
<ul class="org-ul">
<li>\(H_n = \begin{cases}\sum_{i = 1}^{n} H_{i - 1}H_{n - i} & n \geq 2, n \in N_{+}\\ 1 & n = 0, 1 \end{cases}\)<br></li>
<li>\(H_n = \frac{H_{n - 1}\ (4n - 2)}{n + 1}\)<br></li>
<li>\(H_n = C_{2n}^n - C_{2n}^{n - 1}\)<br></li>
</ul>
</div>
</div>
<div id="outline-container-org2a8fd45" class="outline-2">
<h2 id="org2a8fd45">出栈次序</h2>
<div class="outline-text-2" id="text-org2a8fd45">
<p>
一个栈（无穷大）的进栈序列为 \(1, 2, 3, \dots, n\)，有多少个不同的出栈序列?<br>
</p>
</div>
<div id="outline-container-orgdc09b51" class="outline-5">
<h5 id="orgdc09b51">常规分析</h5>
<div class="outline-text-5" id="text-orgdc09b51">
<p>
首先，我们设 \(f(n) = \) 序列个数为 \(n\) 的出栈序列种数（我们假定，最后出栈的元素为 \(k\)，显然，\(k\) 取不同值时的情况是相互独立的，也就是求出每种 \(k\) 最后出栈的情况数后可用加法原则，由于 \(k\) 最后出栈，因此，在 \(k\) 入栈之前，比 \(k\) 小的值均出栈，此处情况有 \(f(k - 1)\) 种，而之后比 \(k\) 大的值入栈，且都在 \(k\) 之前出栈，因此有 \(f(n - k)\) 种方式，由于比 \(k\) 小和比 \(k\) 大的值入栈出栈情况是相互独立的，此处可用乘法原则，\(f(n - k) \times f(k - 1)\) 种，求和便是 \(Catalan\) 递归式）。<br>
</p>

<p>
首次出空之前第一个出栈的序数 \(k\) 将 \(1 \sim n\) 的序列分成两个序列，其中一个是 \(1 \sim k - 1\)，序列个数为 \(k - 1\)，另外一个是 \(k + 1 \sim n\)，序列个数是 \(n - k\)。<br>
</p>

<p>
此时，我们若把 \(k\) 视为确定一个序数，那么根据乘法原理，\(f(n)\) 的问题就等价于序列个数为 \(k - 1\) 的出栈序列种数乘以序列个数为 \(n - k\) 的出栈序列种数，即选择 \(k\) 这个序数的 \(f(n) = f(k - 1) \times f(n - k)\)。而 \(k\) 可以选 \(1\) 到 \(n\)，所以再根据加法原理，将 \(k\) 取不同值的序列种数相加，得到的总序列种数为：\(f(n) = f(0)f(n - 1) + f(1)f(n - 2) + \dots + f(n - 1)f(0)\)<br>
</p>
</div>
</div>
<div id="outline-container-orgd10f1a2" class="outline-5">
<h5 id="orgd10f1a2">非常规分析</h5>
<div class="outline-text-5" id="text-orgd10f1a2">
<p>
对于每一个数来说，必须进栈一次、出栈一次。我们把进栈设为状态 <code>1</code> ，出栈设为状态 <code>0</code> 。\(n\) 个数的所有状态对应 \(n\) 个 \(1\) 和 \(n\) 个 \(0\) 组成的 \(2n\) 位二进制数。由于等待入栈的操作数按照 \(1, 2, 3, \dots, n\)的顺序排列、入栈的操作数 \(b\) 大于等于出栈的操作数 \(a (a \leq b)\)，因此输出序列的总数目 \(=\) 由左而右扫描由 \(n\) 个 \(1\) 和 \(n\) 个 \(0\) 组成的 \(2n\) 位二进制数，\(1\) 的累计数不小于 \(0\) 的累计数的方案种数。<br>
</p>

<p>
在 \(2n\) 位二进制数中填入 \(n\) 个 \(1\) 的方案数为 \(C_{2n}^n\) ,不填 \(1\) 的其余 \(n\) 位自动填 \(0\)。从中减去不符合要求（由左而右扫描，\(0\) 的累计数大于1的累计数）的方案数即为所求。<br>
</p>

<p>
不符合要求的数的特征是由左而右扫描时，必然在某一奇数位 \(2m + 1\) 位上首先出现 \(m + 1\) 个 \(0\) 的累计数和 \(m\) 个 \(1\) 的累计数，此后的 \(2(n - m) - 1\) 位上有 \(n - m\) 个 \(1\) 和 \(n - m - 1\) 个 \(0\)。如若把后面这 \(2(n - m) - 1\) 位上的 \(0\) 和 \(1\) 互换，使之成为 \(n - m\) 个 \(0\) 和 \(n - m - 1\) 个 \(1\)，结果得 \(1\) 个由 \(n + 1\) 个 \(0\) 和 \(n - 1\) 个 \(1\) 组成的 \(2n\) 位数，即一个不合要求的数对应于一个由 \(n + 1\) 个 \(0\) 和 \(n - 1\) 个 \(1\) 组成的排列。<br>
</p>

<p>
反过来，任何一个由 \(n + 1\) 个 \(0\) 和 \(n - 1\) 个 \(1\) 组成的 \(2n\) 位二进制数，由于 \(0\) 的个数多 \(2\) 个，\(2n\) 为偶数，故必在某一个奇数位上出现0的累计数超过 \(1\) 的累计数。同样在后面部分 \(0\) 和 \(1\) 互换，使之成为由 \(n\) 个 \(0\) 和 \(n\) 个 \(1\) 组成的 \(2n\) 位数，即 \(n + 1\) 个 \(0\) 和 \(n - 1\) 个 \(1\) 组成的 \(2n\) 位数必对应一个不符合要求的数。<br>
</p>

<p>
因而不合要求的 \(2n\) 位数与 \(n + 1\) 个 \(0\)，\(n - 1\) 个 \(1\) 组成的排列一一对应。<br>
</p>

<p>
显然，不符合要求的方案数为 \(C_{2n}^{n + 1}\)。由此得出输出序列的总数目 \(= C_{2n}^n - C_{2n}^{n - 1} = \frac{C_{2n}^n}{n + 1} = H_n\)。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org13d3680" class="outline-2">
<h2 id="org13d3680">路径计数问题</h2>
</div>
<div id="outline-container-orgb39d171" class="outline-2">
<h2 id="orgb39d171">排身高</h2>
<div class="outline-text-2" id="text-orgb39d171">
<p>
\(10\) 个高矮不同的人，排成两排，每排必须是从矮到高排列，而且第二排比对应的第一排的人高，问有多少种排列方式?<br>
我们可以先把这 \(10\) 个人从低到高排列，然后，选择 \(5\) 个人排在第一排，那么剩下的 \(5\) 个人肯定是在第二排。用 \(0\) 表示对应的人在第一排，用 \(1\) 表示对应的人在第二排，那么含有 \(5\) 个 \(0\)，\(5\) 个 \(1\) 的序列，就对应一种方案。<br>
比如 \(0000011111\) 就对应着<br>
第一排: \(0 1 2 3 4\)<br>
第二排: \(5 6 7 8 9\)<br>
\(0101010101\) 就对应着<br>
第一排: \(0 2 4 6 8\)<br>
第二排: \(1 3 5 7 9\)<br>
所以，看到问题相应的转换为，这样的满足条件的 \(01\) 序列有多少个。<br>
观察规律我们发现 \(1\) 的出现前边必须有一个相应的 \(0\) 对应，所以从左到右的所有序列中 \(0\) 的个数要一直大于 \(1\) 的个数。那这种数列有多少种排列方式呢？那么我们从左往右扫描，第一次出现 \(1\) 的个数等于 \(0\) 的个数是第k位，那么在此之前，\(0\) 的个数是大于 \(1\) 的个数的。在此之后，\(0\) 的个数也是大于 \(1\) 的个数的。所以第 \(k\) 位 \(0\) 和 \(1\) 的个数第一次相等的排列有他们这两部分的个数相称的结果。<br>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2021-10-14 Thu 09:43</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
