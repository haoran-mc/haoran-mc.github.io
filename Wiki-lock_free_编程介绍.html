<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2023-01-21 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>lock-free 编程介绍</title>
<meta name="author" content="L.M.haoran" />
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved." />
<meta name="generator" content="Org Mode" />
<link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
           <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
           <script type="module" src="static/js/main.js" defer></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">lock-free 编程介绍</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgf14fdf8">引言</a></li>
<li><a href="#org18293c3">什么才叫做无锁编程</a></li>
<li><a href="#orge9647b3">参考</a></li>
</ul>
</div>
</div>
<p>
摘自：<a href="https://colobu.com/2014/12/19/an-introduction-to-lock-free-programming/">lock-free 编程介绍</a><br>
</p>

<div id="outline-container-orgf14fdf8" class="outline-2">
<h2 id="orgf14fdf8">引言</h2>
<div class="outline-text-2" id="text-orgf14fdf8">
<p>
这篇文章收集整理了lock free的编程概念。<br>
</p>

<p>
如果在一个共享的数据结构上的操作都不需要互斥，那么它是无锁的。如果一个进程在操作中间被中断，其它进程不受影响。<br>
</p>

<p>
lock free（翻译成：无锁或者锁无关）的优势：<br>
</p>

<ul class="org-ul">
<li>通过减少阻塞和等待，来改进并发性和可扩展性；<br></li>
<li>消除条件竞争（race condition）、死锁、可组合性不足带来的潜在问题；<br></li>
<li><p>
避免优先级反转；<br>
</p>

<p>
但是无锁编程不是万能药，因为无锁算法实现起来更复杂，它也有潜在问题，比如竞争（contention），这会极大地影响性能。从这一点出发，Herb引出了他的第一条强烈建议：<br>
</p></li>

<li>在使用无锁技术前，你必须先测试你的程序，确定它有性能或可扩展性问题；<br></li>
<li>实现无锁算法后，再次测试你的程序，确定结果得到了有效的改进；<br></li>
</ul>

<p>
<a href="http://preshing.com/about/">Jeff Preshing</a> 在他的文章 <a href="https://preshing.com/20120612/an-introduction-to-lock-free-programming/">An Introduction to Lock-Free Programming</a> 详细介绍了无锁编程的概念。<br>
</p>
</div>
</div>
<div id="outline-container-org18293c3" class="outline-2">
<h2 id="org18293c3">什么才叫做无锁编程</h2>
<div class="outline-text-2" id="text-org18293c3">
<p>
如果不使用锁（mutex或lock），是不是就是 lock-free 了呢？大部分情况下是这样子的。 学术上的定义会更严格。一个定义就是：<br>
</p>

<blockquote>
<p>
一个“锁无关”的程序能够确保执行它的所有线程中至少有一个能够继续往下执行。<br>
</p>
</blockquote>

<p>
检查你的程序是不是lock-free的，可以遵循下面的图：<br>
</p>

<div class="div-center">
    <img src="./images/是不是无锁编程.png" />
</div>

<p>
像我们平常用的互斥锁，当一个线程获得锁，其他线程就被阻塞掉了，这里的问题就是如果获得锁的线程一直休眠，锁没有释放，那么整个程序其实就被block在那了，而如果程序是lock free的那么即使有线程挂掉，也不影响整个程序继续向下进行，也就是系统在整体上而言是一直前进的。<br>
</p>

<p>
这里的锁比比较广泛的概念， 不仅仅指mutex对象。 比如下面的例子<br>
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #87AFD7;">while</span> (x == 0) {
  x = 1-x;
 }
</pre>
</div>

<p>
在这里x由两个线程共享，如果两个线程同时执行，可能同时进入while循环，然后x在两个线程中分别改变一次，依然是0，那么两个线程就会一直互相在这里阻塞掉了，所以这里虽然没有锁，依然不是lock free的。<br>
</p>

<p>
写lock free的时候一般都会使用CAS（compare and set）操作来写，因为现在很多的cpu都是支持CAS操作并作为原子操作来处理的，CAS操作一般是这样的：<br>
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #8181a6;">bool</span> <span style="color: #faf4c6;">compare_and_swap</span> (<span style="color: #8181a6;">int</span> *<span style="color: #faf4c6;">oldval</span>, <span style="color: #8181a6;">int</span> *<span style="color: #faf4c6;">dest</span>, <span style="color: #8181a6;">int</span> <span style="color: #faf4c6;">newval</span>) {
  <span style="color: #87AFD7;">if</span> (*oldval == *dest) {
    *dest = newval;
    <span style="color: #87AFD7;">return</span> <span style="color: #578F8F;">true</span>;
  }
  <span style="color: #87AFD7;">return</span> <span style="color: #578F8F;">false</span>;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orge9647b3" class="outline-2">
<h2 id="orge9647b3">参考</h2>
<div class="outline-text-2" id="text-orge9647b3">
<ol class="org-ol">
<li><a href="https://preshing.com/20120612/an-introduction-to-lock-free-programming/">https://preshing.com/20120612/an-introduction-to-lock-free-programming/</a><br></li>
<li><a href="https://www.cs.cmu.edu/~410-s05/lectures/L31_LockFree.pdf">Lock-Free Programming</a><br></li>
<li><a href="http://www.infoq.com/cn/news/2014/11/cpp-lock-free-programming">http://www.infoq.com/cn/news/2014/11/cpp-lock-free-programming</a><br></li>
<li><a href="http://www.searchtb.com/2012/10/introduction_to_disruptor.html">一种高效无锁内存队列的实现</a><br></li>
<li><a href="https://coolshell.cn/articles/8239.html">无锁队列的实现</a><br></li>
</ol>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2023-01-21</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
