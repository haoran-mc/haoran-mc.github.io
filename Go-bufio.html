<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-06-23 Thu 20:01 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>go, bufio</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="static/MathJax/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div id="content">
<h1 class="title">go, bufio</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org68a63d5">Introduction</a></li>
<li><a href="#orgfab708a">Constants</a></li>
<li><a href="#orgea6724d">Variables</a></li>
<li><a href="#orgbda2986">type Reader</a>
<ul>
<li><a href="#org41f8543">func NewReader</a></li>
<li><a href="#orgd66174e">func NewReaderSize</a></li>
<li><a href="#org3d09aae">func (*Reader) Reset</a></li>
<li><a href="#orgbed5073">func (*Reader) Buffered</a></li>
<li><a href="#org0385794">func (*Reader) Peek</a></li>
<li><a href="#orgbeac2e4">func (*Reader) Read</a></li>
<li><a href="#org70d3e4f">func (*Reader) ReadByte</a></li>
<li><a href="#org48ec2e4">func (*Reader) UnreadByte</a></li>
<li><a href="#org8bf8d34">func (*Reader) ReadRune</a></li>
<li><a href="#orgc9517cc">func (*Reader) UnreadRune</a></li>
<li><a href="#orgcd58121">func (*Reader) ReadLine</a></li>
<li><a href="#org1d13835">func (*Reader) ReadSlice</a></li>
<li><a href="#org00c57d1">func (*Reader) ReadBytes</a></li>
<li><a href="#org47b14fa">func (*Reader) ReadString</a></li>
<li><a href="#org33803c7">func (*Reader) WriteTo</a></li>
</ul>
</li>
<li><a href="#org6be157e">type Writer</a>
<ul>
<li><a href="#orga5f0c37">func NewWriter</a></li>
<li><a href="#org38021be">func NewWriterSize</a></li>
<li><a href="#org6cb65d3">func (*Writer) Reset</a></li>
<li><a href="#orgab4c0cf">func (*Writer) Buffered</a></li>
<li><a href="#org608f017">func (*Writer) Available</a></li>
<li><a href="#orgbe03d15">func (*Writer) Write</a></li>
<li><a href="#org71bba15">func (*Writer) WriteString</a></li>
<li><a href="#orgcf5009e">func (*Writer) WriteByte</a></li>
<li><a href="#org49612cc">func (*Writer) WriteRune</a></li>
<li><a href="#org97868a4">func (*Writer) Flush</a></li>
<li><a href="#orgc67edbc">func (*Writer) ReadFrom</a></li>
</ul>
</li>
<li><a href="#org826361b">type ReadWriter</a>
<ul>
<li><a href="#orgc876b0c">func NewReadWriter</a></li>
</ul>
</li>
<li><a href="#orga8ddafe">type SplitFunc</a></li>
<li><a href="#orgaf236dd">func ScanBytes</a></li>
<li><a href="#orgf862148">func ScanRunes</a></li>
<li><a href="#org517e743">func ScanWords</a></li>
<li><a href="#org5ccd09e">func ScanLines</a></li>
<li><a href="#org36f7247">type Scanner</a>
<ul>
<li><a href="#org8ec6a5c">func NewScanner</a></li>
<li><a href="#org9bf80d0">func (*Scanner) Split</a></li>
<li><a href="#org5bc5137">func (*Scanner) Scan</a></li>
<li><a href="#org53fa836">func (*Scanner) Bytes</a></li>
<li><a href="#org638d836">func (*Scanner) Text</a></li>
<li><a href="#org530370e">func (*Scanner) Err</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org68a63d5" class="outline-2">
<h2 id="org68a63d5">Introduction</h2>
<div class="outline-text-2" id="text-org68a63d5">
<p>
bufio包实现了有缓冲的I/O。它包装一个io.Reader或io.Writer接口对象，创建另一个也实现了该接口，且同时还提供了缓冲和一些文本I/O的帮助函数的对象。<br>
</p>
</div>
</div>
<div id="outline-container-orgfab708a" class="outline-2">
<h2 id="orgfab708a">Constants</h2>
<div class="outline-text-2" id="text-orgfab708a">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">const</span> (
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#29992;&#20110;&#32531;&#20914;&#19968;&#20010;token&#65292;&#23454;&#38469;&#38656;&#35201;&#30340;&#26368;&#22823;token&#23610;&#23544;&#21487;&#33021;&#23567;&#19968;&#20123;&#65292;&#20363;&#22914;&#32531;&#20914;&#20013;&#38656;&#35201;&#20445;&#23384;&#19968;&#25972;&#34892;&#20869;&#23481;</span>
        <span style="color: #d75fd7;">MaxScanTokenSize</span> = 64 * 1024
)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgea6724d" class="outline-2">
<h2 id="orgea6724d">Variables</h2>
<div class="outline-text-2" id="text-orgea6724d">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">var</span> (
        <span style="color: #8787d7;">ErrInvalidUnreadByte</span> = errors.<span style="color: #d75fd7; font-weight: bold;">New</span>(<span style="color: #2aa198;">"bufio: invalid use of UnreadByte"</span>)
        <span style="color: #8787d7;">ErrInvalidUnreadRune</span> = errors.<span style="color: #d75fd7; font-weight: bold;">New</span>(<span style="color: #2aa198;">"bufio: invalid use of UnreadRune"</span>)
        <span style="color: #8787d7;">ErrBufferFull</span>        = errors.<span style="color: #d75fd7; font-weight: bold;">New</span>(<span style="color: #2aa198;">"bufio: buffer full"</span>)
        <span style="color: #8787d7;">ErrNegativeCount</span>     = errors.<span style="color: #d75fd7; font-weight: bold;">New</span>(<span style="color: #2aa198;">"bufio: negative count"</span>)
)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">var</span> (
        <span style="color: #8787d7;">ErrTooLong</span>         = errors.<span style="color: #d75fd7; font-weight: bold;">New</span>(<span style="color: #2aa198;">"bufio.Scanner: token too long"</span>)
        <span style="color: #8787d7;">ErrNegativeAdvance</span> = errors.<span style="color: #d75fd7; font-weight: bold;">New</span>(<span style="color: #2aa198;">"bufio.Scanner: SplitFunc returns negative advance count"</span>)
        <span style="color: #8787d7;">ErrAdvanceTooFar</span>   = errors.<span style="color: #d75fd7; font-weight: bold;">New</span>(<span style="color: #2aa198;">"bufio.Scanner: SplitFunc returns advance count beyond input"</span>)
)
</pre>
</div>

<p>
会被Scanner类型返回的错误。<br>
</p>
</div>
</div>
<div id="outline-container-orgbda2986" class="outline-2">
<h2 id="orgbda2986">type Reader</h2>
<div class="outline-text-2" id="text-orgbda2986">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Reader</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20869;&#21547;&#38544;&#34255;&#25110;&#38750;&#23548;&#20986;&#23383;&#27573;</span>
}
</pre>
</div>

<p>
Reader实现了给一个io.Reader接口对象附加缓冲。<br>
</p>
</div>
<div id="outline-container-org41f8543" class="outline-3">
<h3 id="org41f8543">func NewReader</h3>
<div class="outline-text-3" id="text-org41f8543">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">NewReader</span>(<span style="color: #8787d7;">rd</span> <span style="color: #df005f; font-weight: bold;">io.Reader</span>) *<span style="color: #df005f; font-weight: bold;">Reader</span>
</pre>
</div>

<p>
NewReader创建一个具有默认大小缓冲、从r读取的*Reader。<br>
</p>
</div>
</div>
<div id="outline-container-orgd66174e" class="outline-3">
<h3 id="orgd66174e">func NewReaderSize</h3>
<div class="outline-text-3" id="text-orgd66174e">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">NewReaderSize</span>(<span style="color: #8787d7;">rd</span> <span style="color: #df005f; font-weight: bold;">io.Reader</span>, <span style="color: #8787d7;">size</span> <span style="color: #df005f; font-weight: bold;">int</span>) *<span style="color: #df005f; font-weight: bold;">Reader</span>
</pre>
</div>

<p>
NewReaderSize创建一个具有最少有size尺寸的缓冲、从r读取的*Reader。如果参数r已经是一个具有足够大缓冲的* Reader类型值，会返回r。<br>
</p>
</div>
</div>
<div id="outline-container-org3d09aae" class="outline-3">
<h3 id="org3d09aae">func (*Reader) Reset</h3>
<div class="outline-text-3" id="text-org3d09aae">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">Reader</span>) <span style="color: #d75fd7; font-weight: bold;">Reset</span>(<span style="color: #8787d7;">r</span> <span style="color: #df005f; font-weight: bold;">io.Reader</span>)
</pre>
</div>

<p>
Reset丢弃缓冲中的数据，清除任何错误，将b重设为其下层从r读取数据。<br>
</p>
</div>
</div>
<div id="outline-container-orgbed5073" class="outline-3">
<h3 id="orgbed5073">func (*Reader) Buffered</h3>
<div class="outline-text-3" id="text-orgbed5073">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">Reader</span>) <span style="color: #d75fd7; font-weight: bold;">Buffered</span>() <span style="color: #df005f; font-weight: bold;">int</span>
</pre>
</div>

<p>
Buffered返回缓冲中现有的可读取的字节数。<br>
</p>
</div>
</div>
<div id="outline-container-org0385794" class="outline-3">
<h3 id="org0385794">func (*Reader) Peek</h3>
<div class="outline-text-3" id="text-org0385794">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">Reader</span>) <span style="color: #d75fd7; font-weight: bold;">Peek</span>(<span style="color: #8787d7;">n</span> <span style="color: #df005f; font-weight: bold;">int</span>) ([]<span style="color: #df005f; font-weight: bold;">byte</span>, <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>

<p>
Peek返回输入流的下n个字节，而不会移动读取位置。返回的[]byte只在下一次调用读取操作前合法。如果Peek返回的切片长度比n小，它也会返会一个错误说明原因。如果n比缓冲尺寸还大，返回的错误将是ErrBufferFull。<br>
</p>
</div>
</div>
<div id="outline-container-orgbeac2e4" class="outline-3">
<h3 id="orgbeac2e4">func (*Reader) Read</h3>
<div class="outline-text-3" id="text-orgbeac2e4">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">Reader</span>) <span style="color: #d75fd7; font-weight: bold;">Read</span>(<span style="color: #8787d7;">p</span> []<span style="color: #df005f; font-weight: bold;">byte</span>) (<span style="color: #8787d7;">n</span> <span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>

<p>
Read读取数据写入p。本方法返回写入p的字节数。本方法一次调用最多会调用下层Reader接口一次Read方法，因此返回值n可能小于len(p)。读取到达结尾时，返回值n将为0而err将为io.EOF。<br>
</p>
</div>
</div>
<div id="outline-container-org70d3e4f" class="outline-3">
<h3 id="org70d3e4f">func (*Reader) ReadByte</h3>
<div class="outline-text-3" id="text-org70d3e4f">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">Reader</span>) <span style="color: #d75fd7; font-weight: bold;">ReadByte</span>() (<span style="color: #8787d7;">c</span> <span style="color: #df005f; font-weight: bold;">byte</span>, <span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>

<p>
ReadByte读取并返回一个字节。如果没有可用的数据，会返回错误。<br>
</p>
</div>
</div>
<div id="outline-container-org48ec2e4" class="outline-3">
<h3 id="org48ec2e4">func (*Reader) UnreadByte</h3>
<div class="outline-text-3" id="text-org48ec2e4">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">Reader</span>) <span style="color: #d75fd7; font-weight: bold;">UnreadByte</span>() <span style="color: #df005f; font-weight: bold;">error</span>
</pre>
</div>

<p>
UnreadByte吐出最近一次读取操作读取的最后一个字节。（只能吐出最后一个，多次调用会出问题）<br>
</p>
</div>
</div>
<div id="outline-container-org8bf8d34" class="outline-3">
<h3 id="org8bf8d34">func (*Reader) ReadRune</h3>
<div class="outline-text-3" id="text-org8bf8d34">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">Reader</span>) <span style="color: #d75fd7; font-weight: bold;">ReadRune</span>() (<span style="color: #8787d7;">r</span> <span style="color: #df005f; font-weight: bold;">rune</span>, <span style="color: #8787d7;">size</span> <span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>

<p>
ReadRune读取一个utf-8编码的unicode码值，返回该码值、其编码长度和可能的错误。如果utf-8编码非法，读取位置只移动1字节，返回U+FFFD，返回值size为1而err为nil。如果没有可用的数据，会返回错误。<br>
</p>
</div>
</div>
<div id="outline-container-orgc9517cc" class="outline-3">
<h3 id="orgc9517cc">func (*Reader) UnreadRune</h3>
<div class="outline-text-3" id="text-orgc9517cc">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">Reader</span>) <span style="color: #d75fd7; font-weight: bold;">UnreadRune</span>() <span style="color: #df005f; font-weight: bold;">error</span>
</pre>
</div>

<p>
UnreadRune吐出最近一次ReadRune调用读取的unicode码值。如果最近一次读取不是调用的ReadRune，会返回错误。（从这点看，UnreadRune比UnreadByte严格很多）<br>
</p>
</div>
</div>
<div id="outline-container-orgcd58121" class="outline-3">
<h3 id="orgcd58121">func (*Reader) ReadLine</h3>
<div class="outline-text-3" id="text-orgcd58121">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">Reader</span>) <span style="color: #d75fd7; font-weight: bold;">ReadLine</span>() (<span style="color: #8787d7;">line</span> []<span style="color: #df005f; font-weight: bold;">byte</span>, <span style="color: #8787d7;">isPrefix</span> <span style="color: #df005f; font-weight: bold;">bool</span>, <span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>

<p>
ReadLine是一个低水平的行数据读取原语。大多数调用者应使用ReadBytes('\n')或ReadString('\n')代替，或者使用Scanner。<br>
</p>

<p>
ReadLine尝试返回一行数据，不包括行尾标志的字节。如果行太长超过了缓冲，返回值isPrefix会被设为true，并返回行的前面一部分。该行剩下的部分将在之后的调用中返回。返回值isPrefix会在返回该行最后一个片段时才设为false。返回切片是缓冲的子切片，只在下一次读取操作之前有效。ReadLine要么返回一个非nil的line，要么返回一个非nil的err，两个返回值至少一个非nil。<br>
</p>

<p>
返回的文本不包含行尾的标志字节（"\r\n"或"\n"）。如果输入流结束时没有行尾标志字节，方法不会出错，也不会指出这一情况。在调用ReadLine之后调用UnreadByte会总是吐出最后一个读取的字节（很可能是该行的行尾标志字节），即使该字节不是ReadLine返回值的一部分。<br>
</p>
</div>
</div>
<div id="outline-container-org1d13835" class="outline-3">
<h3 id="org1d13835">func (*Reader) ReadSlice</h3>
<div class="outline-text-3" id="text-org1d13835">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">Reader</span>) <span style="color: #d75fd7; font-weight: bold;">ReadSlice</span>(<span style="color: #8787d7;">delim</span> <span style="color: #df005f; font-weight: bold;">byte</span>) (<span style="color: #8787d7;">line</span> []<span style="color: #df005f; font-weight: bold;">byte</span>, <span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>

<p>
ReadSlice读取直到第一次遇到delim字节，返回缓冲里的包含已读取的数据和delim字节的切片。该返回值只在下一次读取操作之前合法。如果ReadSlice放在在读取到delim之前遇到了错误，它会返回在错误之前读取的数据在缓冲中的切片以及该错误（一般是io.EOF）。如果在读取到delim之前缓冲就被写满了，ReadSlice失败并返回ErrBufferFull。因为ReadSlice的返回值会被下一次I/O操作重写，调用者应尽量使用ReadBytes或ReadString替代本法功法。当且仅当ReadBytes方法返回的切片不以delim结尾时，会返回一个非nil的错误。<br>
</p>
</div>
</div>
<div id="outline-container-org00c57d1" class="outline-3">
<h3 id="org00c57d1">func (*Reader) ReadBytes</h3>
<div class="outline-text-3" id="text-org00c57d1">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">Reader</span>) <span style="color: #d75fd7; font-weight: bold;">ReadBytes</span>(<span style="color: #8787d7;">delim</span> <span style="color: #df005f; font-weight: bold;">byte</span>) (<span style="color: #8787d7;">line</span> []<span style="color: #df005f; font-weight: bold;">byte</span>, <span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>

<p>
ReadBytes读取直到第一次遇到delim字节，返回一个包含已读取的数据和delim字节的切片。如果ReadBytes方法在读取到delim之前遇到了错误，它会返回在错误之前读取的数据以及该错误（一般是io.EOF）。当且仅当ReadBytes方法返回的切片不以delim结尾时，会返回一个非nil的错误。<br>
</p>
</div>
</div>
<div id="outline-container-org47b14fa" class="outline-3">
<h3 id="org47b14fa">func (*Reader) ReadString</h3>
<div class="outline-text-3" id="text-org47b14fa">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">Reader</span>) <span style="color: #d75fd7; font-weight: bold;">ReadString</span>(<span style="color: #8787d7;">delim</span> <span style="color: #df005f; font-weight: bold;">byte</span>) (<span style="color: #8787d7;">line</span> <span style="color: #df005f; font-weight: bold;">string</span>, <span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>

<p>
ReadString读取直到第一次遇到delim字节，返回一个包含已读取的数据和delim字节的字符串。如果ReadString方法在读取到delim之前遇到了错误，它会返回在错误之前读取的数据以及该错误（一般是io.EOF）。当且仅当ReadString方法返回的切片不以delim结尾时，会返回一个非nil的错误。<br>
</p>
</div>
</div>
<div id="outline-container-org33803c7" class="outline-3">
<h3 id="org33803c7">func (*Reader) WriteTo</h3>
<div class="outline-text-3" id="text-org33803c7">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">Reader</span>) <span style="color: #d75fd7; font-weight: bold;">WriteTo</span>(<span style="color: #8787d7;">w</span> <span style="color: #df005f; font-weight: bold;">io.Writer</span>) (<span style="color: #8787d7;">n</span> <span style="color: #df005f; font-weight: bold;">int64</span>, <span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>

<p>
WriteTo方法实现了io.WriterTo接口。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org6be157e" class="outline-2">
<h2 id="org6be157e">type Writer</h2>
<div class="outline-text-2" id="text-org6be157e">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20869;&#21547;&#38544;&#34255;&#25110;&#38750;&#23548;&#20986;&#23383;&#27573;</span>
}
</pre>
</div>

<p>
Writer实现了为io.Writer接口对象提供缓冲。如果在向一个Writer类型值写入时遇到了错误，该对象将不再接受任何数据，且所有写操作都会返回该错误。在说有数据都写入后，调用者有义务调用Flush方法以保证所有的数据都交给了下层的io.Writer。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">w</span> := bufio.<span style="color: #d75fd7; font-weight: bold;">NewWriter</span>(os.Stdout)
fmt.<span style="color: #d75fd7; font-weight: bold;">Fprint</span>(w, <span style="color: #2aa198;">"Hello, "</span>)
fmt.<span style="color: #d75fd7; font-weight: bold;">Fprint</span>(w, <span style="color: #2aa198;">"world!"</span>)
w.<span style="color: #d75fd7; font-weight: bold;">Flush</span>() <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Don't forget to flush!</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Hello, world!</span>
</pre>
</div>
</div>
<div id="outline-container-orga5f0c37" class="outline-3">
<h3 id="orga5f0c37">func NewWriter</h3>
<div class="outline-text-3" id="text-orga5f0c37">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">NewWriter</span>(<span style="color: #8787d7;">w</span> <span style="color: #df005f; font-weight: bold;">io.Writer</span>) *<span style="color: #df005f; font-weight: bold;">Writer</span>
</pre>
</div>

<p>
NewWriter创建一个具有默认大小缓冲、写入w的*Writer。<br>
</p>
</div>
</div>
<div id="outline-container-org38021be" class="outline-3">
<h3 id="org38021be">func NewWriterSize</h3>
<div class="outline-text-3" id="text-org38021be">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">NewWriterSize</span>(<span style="color: #8787d7;">w</span> <span style="color: #df005f; font-weight: bold;">io.Writer</span>, <span style="color: #8787d7;">size</span> <span style="color: #df005f; font-weight: bold;">int</span>) *<span style="color: #df005f; font-weight: bold;">Writer</span>
</pre>
</div>

<p>
NewWriterSize创建一个具有最少有size尺寸的缓冲、写入w的*Writer。如果参数w已经是一个具有足够大缓冲的*Writer类型值，会返回w。<br>
</p>
</div>
</div>
<div id="outline-container-org6cb65d3" class="outline-3">
<h3 id="org6cb65d3">func (*Writer) Reset</h3>
<div class="outline-text-3" id="text-org6cb65d3">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">Writer</span>) <span style="color: #d75fd7; font-weight: bold;">Reset</span>(<span style="color: #8787d7;">w</span> <span style="color: #df005f; font-weight: bold;">io.Writer</span>)
</pre>
</div>

<p>
Reset丢弃缓冲中的数据，清除任何错误，将b重设为将其输出写入w。<br>
</p>
</div>
</div>
<div id="outline-container-orgab4c0cf" class="outline-3">
<h3 id="orgab4c0cf">func (*Writer) Buffered</h3>
<div class="outline-text-3" id="text-orgab4c0cf">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">Writer</span>) <span style="color: #d75fd7; font-weight: bold;">Buffered</span>() <span style="color: #df005f; font-weight: bold;">int</span>
</pre>
</div>

<p>
Buffered返回缓冲中已使用的字节数。<br>
</p>
</div>
</div>
<div id="outline-container-org608f017" class="outline-3">
<h3 id="org608f017">func (*Writer) Available</h3>
<div class="outline-text-3" id="text-org608f017">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">Writer</span>) <span style="color: #d75fd7; font-weight: bold;">Available</span>() <span style="color: #df005f; font-weight: bold;">int</span>
</pre>
</div>

<p>
Available返回缓冲中还有多少字节未使用。<br>
</p>
</div>
</div>
<div id="outline-container-orgbe03d15" class="outline-3">
<h3 id="orgbe03d15">func (*Writer) Write</h3>
<div class="outline-text-3" id="text-orgbe03d15">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">Writer</span>) <span style="color: #d75fd7; font-weight: bold;">Write</span>(<span style="color: #8787d7;">p</span> []<span style="color: #df005f; font-weight: bold;">byte</span>) (<span style="color: #8787d7;">nn</span> <span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>

<p>
Write将p的内容写入缓冲。返回写入的字节数。如果返回值nn &lt; len(p)，还会返回一个错误说明原因。<br>
</p>
</div>
</div>
<div id="outline-container-org71bba15" class="outline-3">
<h3 id="org71bba15">func (*Writer) WriteString</h3>
<div class="outline-text-3" id="text-org71bba15">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">Writer</span>) <span style="color: #d75fd7; font-weight: bold;">WriteString</span>(<span style="color: #8787d7;">s</span> <span style="color: #df005f; font-weight: bold;">string</span>) (<span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>

<p>
WriteString写入一个字符串。返回写入的字节数。如果返回值nn &lt; len(s)，还会返回一个错误说明原因。<br>
</p>
</div>
</div>
<div id="outline-container-orgcf5009e" class="outline-3">
<h3 id="orgcf5009e">func (*Writer) WriteByte</h3>
<div class="outline-text-3" id="text-orgcf5009e">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">Writer</span>) <span style="color: #d75fd7; font-weight: bold;">WriteByte</span>(<span style="color: #8787d7;">c</span> <span style="color: #df005f; font-weight: bold;">byte</span>) <span style="color: #df005f; font-weight: bold;">error</span>
</pre>
</div>

<p>
WriteByte写入单个字节。<br>
</p>
</div>
</div>
<div id="outline-container-org49612cc" class="outline-3">
<h3 id="org49612cc">func (*Writer) WriteRune</h3>
<div class="outline-text-3" id="text-org49612cc">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">Writer</span>) <span style="color: #d75fd7; font-weight: bold;">WriteRune</span>(<span style="color: #8787d7;">r</span> <span style="color: #df005f; font-weight: bold;">rune</span>) (<span style="color: #8787d7;">size</span> <span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>

<p>
WriteRune写入一个unicode码值（的utf-8编码），返回写入的字节数和可能的错误。<br>
</p>
</div>
</div>
<div id="outline-container-org97868a4" class="outline-3">
<h3 id="org97868a4">func (*Writer) Flush</h3>
<div class="outline-text-3" id="text-org97868a4">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">Writer</span>) <span style="color: #d75fd7; font-weight: bold;">Flush</span>() <span style="color: #df005f; font-weight: bold;">error</span>
</pre>
</div>

<p>
Flush方法将缓冲中的数据写入下层的io.Writer接口。<br>
</p>
</div>
</div>
<div id="outline-container-orgc67edbc" class="outline-3">
<h3 id="orgc67edbc">func (*Writer) ReadFrom</h3>
<div class="outline-text-3" id="text-orgc67edbc">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">Writer</span>) <span style="color: #d75fd7; font-weight: bold;">ReadFrom</span>(<span style="color: #8787d7;">r</span> <span style="color: #df005f; font-weight: bold;">io.Reader</span>) (<span style="color: #8787d7;">n</span> <span style="color: #df005f; font-weight: bold;">int64</span>, <span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>

<p>
ReadFrom实现了io.ReaderFrom接口。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org826361b" class="outline-2">
<h2 id="org826361b">type ReadWriter</h2>
<div class="outline-text-2" id="text-org826361b">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">ReadWriter</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
        *Reader
        *Writer
}
</pre>
</div>

<p>
ReadWriter类型保管了指向Reader和Writer类型的指针，（因此）实现了io.ReadWriter接口。<br>
</p>
</div>
<div id="outline-container-orgc876b0c" class="outline-3">
<h3 id="orgc876b0c">func NewReadWriter</h3>
<div class="outline-text-3" id="text-orgc876b0c">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">NewReadWriter</span>(<span style="color: #8787d7;">r</span> *<span style="color: #df005f; font-weight: bold;">Reader</span>, <span style="color: #8787d7;">w</span> *<span style="color: #df005f; font-weight: bold;">Writer</span>) *<span style="color: #df005f; font-weight: bold;">ReadWriter</span>
</pre>
</div>

<p>
NewReadWriter申请创建一个新的、将读写操作分派给r和w 的ReadWriter。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-orga8ddafe" class="outline-2">
<h2 id="orga8ddafe">type SplitFunc</h2>
<div class="outline-text-2" id="text-orga8ddafe">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">SplitFunc</span> <span style="color: #268bd2; font-weight: bold;">func</span>(<span style="color: #8787d7;">data</span> []<span style="color: #df005f; font-weight: bold;">byte</span>, <span style="color: #8787d7;">atEOF</span> <span style="color: #df005f; font-weight: bold;">bool</span>) (<span style="color: #8787d7;">advance</span> <span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #8787d7;">token</span> []<span style="color: #df005f; font-weight: bold;">byte</span>, <span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>

<p>
SplitFunc类型代表用于对输出作词法分析的分割函数。<br>
</p>

<p>
参数data是尚未处理的数据的一个开始部分的切片，参数atEOF表示是否Reader接口不能提供更多的数据。返回值是解析位置前进的字节数，将要返回给调用者的token切片，以及可能遇到的错误。如果数据不足以（保证）生成一个完整的token，例如需要一整行数据但data里没有换行符，SplitFunc可以返回(0, nil, nil)来告诉Scanner读取更多的数据写入切片然后用从同一位置起始、长度更长的切片再试一次（调用SplitFunc类型函数）。<br>
</p>

<p>
如果返回值err非nil，扫描将终止并将该错误返回给Scanner的调用者。<br>
</p>

<p>
除非atEOF为真，永远不会使用空切片data调用SplitFunc类型函数。然而，如果atEOF为真，data却可能是非空的、且包含着未处理的文本。<br>
</p>
</div>
</div>
<div id="outline-container-orgaf236dd" class="outline-2">
<h2 id="orgaf236dd">func ScanBytes</h2>
<div class="outline-text-2" id="text-orgaf236dd">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">ScanBytes</span>(<span style="color: #8787d7;">data</span> []<span style="color: #df005f; font-weight: bold;">byte</span>, <span style="color: #8787d7;">atEOF</span> <span style="color: #df005f; font-weight: bold;">bool</span>) (<span style="color: #8787d7;">advance</span> <span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #8787d7;">token</span> []<span style="color: #df005f; font-weight: bold;">byte</span>, <span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>

<p>
ScanBytes是用于Scanner类型的分割函数（符合SplitFunc），本函数会将每个字节作为一个token返回。<br>
</p>
</div>
</div>
<div id="outline-container-orgf862148" class="outline-2">
<h2 id="orgf862148">func ScanRunes</h2>
<div class="outline-text-2" id="text-orgf862148">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">ScanRunes</span>(<span style="color: #8787d7;">data</span> []<span style="color: #df005f; font-weight: bold;">byte</span>, <span style="color: #8787d7;">atEOF</span> <span style="color: #df005f; font-weight: bold;">bool</span>) (<span style="color: #8787d7;">advance</span> <span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #8787d7;">token</span> []<span style="color: #df005f; font-weight: bold;">byte</span>, <span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>

<p>
ScanRunes是用于Scanner类型的分割函数（符合SplitFunc），本函数会将每个utf-8编码的unicode码值作为一个token返回。本函数返回的rune序列和range一个字符串的输出rune序列相同。错误的utf-8编码会翻译为U+FFFD = "\xef\xbf\xbd"，但只会消耗一个字节。调用者无法区分正确编码的rune和错误编码的rune。<br>
</p>
</div>
</div>
<div id="outline-container-org517e743" class="outline-2">
<h2 id="org517e743">func ScanWords</h2>
<div class="outline-text-2" id="text-org517e743">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">ScanWords</span>(<span style="color: #8787d7;">data</span> []<span style="color: #df005f; font-weight: bold;">byte</span>, <span style="color: #8787d7;">atEOF</span> <span style="color: #df005f; font-weight: bold;">bool</span>) (<span style="color: #8787d7;">advance</span> <span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #8787d7;">token</span> []<span style="color: #df005f; font-weight: bold;">byte</span>, <span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>

<p>
ScanRunes是用于Scanner类型的分割函数（符合SplitFunc），本函数会将空白（参见unicode.IsSpace）分隔的片段（去掉前后空白后）作为一个token返回。本函数永远不会返回空字符串。<br>
</p>
</div>
</div>
<div id="outline-container-org5ccd09e" class="outline-2">
<h2 id="org5ccd09e">func ScanLines</h2>
<div class="outline-text-2" id="text-org5ccd09e">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">ScanLines</span>(<span style="color: #8787d7;">data</span> []<span style="color: #df005f; font-weight: bold;">byte</span>, <span style="color: #8787d7;">atEOF</span> <span style="color: #df005f; font-weight: bold;">bool</span>) (<span style="color: #8787d7;">advance</span> <span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #8787d7;">token</span> []<span style="color: #df005f; font-weight: bold;">byte</span>, <span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>

<p>
ScanRunes是用于Scanner类型的分割函数（符合SplitFunc），本函数会将每一行文本去掉末尾的换行标记作为一个token返回。返回的行可以是空字符串。换行标记为一个可选的回车后跟一个必选的换行符。最后一行即使没有换行符也会作为一个token返回。<br>
</p>
</div>
</div>
<div id="outline-container-org36f7247" class="outline-2">
<h2 id="org36f7247">type Scanner</h2>
<div class="outline-text-2" id="text-org36f7247">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Scanner</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20869;&#21547;&#38544;&#34255;&#25110;&#38750;&#23548;&#20986;&#23383;&#27573;</span>
}
</pre>
</div>

<p>
Scanner类型提供了方便的读取数据的接口，如从换行符分隔的文本里读取每一行。<br>
</p>

<p>
成功调用的Scan方法会逐步提供文件的token，跳过token之间的字节。token由SplitFunc类型的分割函数指定；默认的分割函数会将输入分割为多个行，并去掉行尾的换行标志。本包预定义的分割函数可以将文件分割为行、字节、unicode码值、空白分隔的word。调用者可以定制自己的分割函数。<br>
</p>

<p>
扫描会在抵达输入流结尾、遇到的第一个I/O错误、token过大不能保存进缓冲时，不可恢复的停止。当扫描停止后，当前读取位置可能会远在最后一个获得的token后面。需要更多对错误管理的控制或token很大，或必须从reader连续扫描的程序，应使用bufio.Reader代替。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Custom</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">An artificial input source.</span>
<span style="color: #268bd2; font-weight: bold;">const</span> <span style="color: #d75fd7;">input</span> = <span style="color: #2aa198;">"1234 5678 1234567901234567890"</span>
<span style="color: #8787d7;">scanner</span> := bufio.<span style="color: #d75fd7; font-weight: bold;">NewScanner</span>(strings.<span style="color: #d75fd7; font-weight: bold;">NewReader</span>(input))
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Create a custom split function by wrapping the existing ScanWords function.</span>
<span style="color: #8787d7;">split</span> := <span style="color: #268bd2; font-weight: bold;">func</span>(<span style="color: #8787d7;">data</span> []<span style="color: #df005f; font-weight: bold;">byte</span>, <span style="color: #8787d7;">atEOF</span> <span style="color: #df005f; font-weight: bold;">bool</span>) (<span style="color: #8787d7;">advance</span> <span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #8787d7;">token</span> []<span style="color: #df005f; font-weight: bold;">byte</span>, <span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>) {
        advance, token, err = bufio.<span style="color: #d75fd7; font-weight: bold;">ScanWords</span>(data, atEOF)
        <span style="color: #268bd2; font-weight: bold;">if</span> err == <span style="color: #d75fd7;">nil</span> &amp;&amp; token != <span style="color: #d75fd7;">nil</span> {
                _, err = strconv.<span style="color: #d75fd7; font-weight: bold;">ParseInt</span>(<span style="color: #d75fd7; font-weight: bold;">string</span>(token), 10, 32)
        }
        <span style="color: #268bd2; font-weight: bold;">return</span>
}
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Set the split function for the scanning operation.</span>
scanner.<span style="color: #d75fd7; font-weight: bold;">Split</span>(split)
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Validate the input</span>
<span style="color: #268bd2; font-weight: bold;">for</span> scanner.<span style="color: #d75fd7; font-weight: bold;">Scan</span>() {
        fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%s\n"</span>, scanner.<span style="color: #d75fd7; font-weight: bold;">Text</span>())
}
<span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #8787d7;">err</span> := scanner.<span style="color: #d75fd7; font-weight: bold;">Err</span>(); err != <span style="color: #d75fd7;">nil</span> {
        fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"Invalid input: %s"</span>, err)
}
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">1234</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">5678</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Invalid input: strconv.ParseInt: parsing "1234567901234567890": value out of range</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Lines</span>
<span style="color: #8787d7;">scanner</span> := bufio.<span style="color: #d75fd7; font-weight: bold;">NewScanner</span>(os.Stdin)
<span style="color: #268bd2; font-weight: bold;">for</span> scanner.<span style="color: #d75fd7; font-weight: bold;">Scan</span>() {
        fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(scanner.<span style="color: #d75fd7; font-weight: bold;">Text</span>()) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Println will add back the final '\n'</span>
}
<span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #8787d7;">err</span> := scanner.<span style="color: #d75fd7; font-weight: bold;">Err</span>(); err != <span style="color: #d75fd7;">nil</span> {
        fmt.<span style="color: #d75fd7; font-weight: bold;">Fprintln</span>(os.Stderr, <span style="color: #2aa198;">"reading standard input:"</span>, err)
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Words</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">An artificial input source.</span>
<span style="color: #268bd2; font-weight: bold;">const</span> <span style="color: #d75fd7;">input</span> = <span style="color: #2aa198;">"Now is the winter of our discontent,\nMade glorious summer by this sun of York.\n"</span>
<span style="color: #8787d7;">scanner</span> := bufio.<span style="color: #d75fd7; font-weight: bold;">NewScanner</span>(strings.<span style="color: #d75fd7; font-weight: bold;">NewReader</span>(input))
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Set the split function for the scanning operation.</span>
scanner.<span style="color: #d75fd7; font-weight: bold;">Split</span>(bufio.ScanWords)
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Count the words.</span>
<span style="color: #8787d7;">count</span> := 0
<span style="color: #268bd2; font-weight: bold;">for</span> scanner.<span style="color: #d75fd7; font-weight: bold;">Scan</span>() {
        count++
}
<span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #8787d7;">err</span> := scanner.<span style="color: #d75fd7; font-weight: bold;">Err</span>(); err != <span style="color: #d75fd7;">nil</span> {
        fmt.<span style="color: #d75fd7; font-weight: bold;">Fprintln</span>(os.Stderr, <span style="color: #2aa198;">"reading input:"</span>, err)
}
fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%d\n"</span>, count)
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">15</span>
</pre>
</div>
</div>
<div id="outline-container-org8ec6a5c" class="outline-3">
<h3 id="org8ec6a5c">func NewScanner</h3>
<div class="outline-text-3" id="text-org8ec6a5c">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">NewScanner</span>(<span style="color: #8787d7;">r</span> <span style="color: #df005f; font-weight: bold;">io.Reader</span>) *<span style="color: #df005f; font-weight: bold;">Scanner</span>
</pre>
</div>

<p>
NewScanner 创建并返回一个从 r 读取数据的 Scanner，默认的分割函数是 ScanLines。<br>
</p>
</div>
</div>
<div id="outline-container-org9bf80d0" class="outline-3">
<h3 id="org9bf80d0">func (*Scanner) Split</h3>
<div class="outline-text-3" id="text-org9bf80d0">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">s</span> *<span style="color: #df005f; font-weight: bold;">Scanner</span>) <span style="color: #d75fd7; font-weight: bold;">Split</span>(<span style="color: #8787d7;">split</span> <span style="color: #df005f; font-weight: bold;">SplitFunc</span>)
</pre>
</div>

<p>
Split设置该Scanner的分割函数。本方法必须在Scan之前调用。<br>
</p>
</div>
</div>
<div id="outline-container-org5bc5137" class="outline-3">
<h3 id="org5bc5137">func (*Scanner) Scan</h3>
<div class="outline-text-3" id="text-org5bc5137">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">s</span> *<span style="color: #df005f; font-weight: bold;">Scanner</span>) <span style="color: #d75fd7; font-weight: bold;">Scan</span>() <span style="color: #df005f; font-weight: bold;">bool</span>
</pre>
</div>

<p>
Scan 方法获取当前位置的 token（该 token 可以通过 Bytes 或 Text 方法获得），并让 Scanner 的扫描位置移动到下一个 token。当扫描因为抵达输入流结尾或者遇到错误而停止时，本方法会返回 false。在 Scan 方法返回 false 后，Err 方法将返回扫描时遇到的任何错误；除非是 io.EOF，此时 Err 会返回 nil。<br>
</p>
</div>
</div>
<div id="outline-container-org53fa836" class="outline-3">
<h3 id="org53fa836">func (*Scanner) Bytes</h3>
<div class="outline-text-3" id="text-org53fa836">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">s</span> *<span style="color: #df005f; font-weight: bold;">Scanner</span>) <span style="color: #d75fd7; font-weight: bold;">Bytes</span>() []<span style="color: #df005f; font-weight: bold;">byte</span>
</pre>
</div>

<p>
Bytes方法返回最近一次Scan调用生成的token。底层数组指向的数据可能会被下一次Scan的调用重写。<br>
</p>
</div>
</div>
<div id="outline-container-org638d836" class="outline-3">
<h3 id="org638d836">func (*Scanner) Text</h3>
<div class="outline-text-3" id="text-org638d836">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">s</span> *<span style="color: #df005f; font-weight: bold;">Scanner</span>) <span style="color: #d75fd7; font-weight: bold;">Text</span>() <span style="color: #df005f; font-weight: bold;">string</span>
</pre>
</div>

<p>
Bytes方法返回最近一次Scan调用生成的token，会申请创建一个字符串保存token并返回该字符串。<br>
</p>
</div>
</div>
<div id="outline-container-org530370e" class="outline-3">
<h3 id="org530370e">func (*Scanner) Err</h3>
<div class="outline-text-3" id="text-org530370e">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">s</span> *<span style="color: #df005f; font-weight: bold;">Scanner</span>) <span style="color: #d75fd7; font-weight: bold;">Err</span>() <span style="color: #df005f; font-weight: bold;">error</span>
</pre>
</div>

<p>
Err返回Scanner遇到的第一个非EOF的错误。<br>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-06-23 Thu 20:01</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
