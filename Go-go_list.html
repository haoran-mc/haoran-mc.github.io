<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-04-01 Fri 18:47 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>go list</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">go list</h1>
<p>
<code>go list</code> 命令的作用是列出指定的代码包的信息。与其他命令相同，我们需要以代码包导入路径的方式给定代码包。被给定的代码包可以有多个。这些代码包对应的目录中必须直接保存有Go语言源码文件，其子目录中的文件不算在内。否则，代码包将被看做是不完整的。现在我们来试用一下：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">hc@ubt:~$ go list cnet/ctcp pkgtool
cnet/ctcp
pkgtool
</pre>
</div>

<p>
我们看到，在不加任何标记的情况下，命令的结果信息中只包含了我们指定的代码包的导入路径。我们刚刚提到，作为参数的代码包必须是完整的代码包。例如：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">hc@ubt:~$ go list cnet pkgtool
can<span style="color: #2aa198;">'t load package: package cnet: no buildable Go source files in /home/hc/golang/goc2p/src/cnet/</span>
<span style="color: #2aa198;">pkgtool</span>
</pre>
</div>

<p>
这时， <code>go list</code> 命令报告了一个错误——代码包 <code>cnet</code> 对应的目录下没有 Go 源码文件。但是命令还是把代码包 pkgtool 的导入路径打印出来了。然而，当我们在执行 <code>go list</code> 命令并加入标记 <code>-e</code> 时，即使参数中包含有不完整的代码包，命令也不会提示错误。示例如下：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">hc@ubt:~$ go list -e cnet pkgtool
cnet
pkgtool
</pre>
</div>

<p>
标记 <code>-e</code> 的作用是以容错模式加载和分析指定的代码包。在这种情况下，命令程序如果在加载或分析的过程中遇到错误只会在内部记录一下，而不会直接把错误信息打印出来。我们为了看到错误信息可以使用 <code>-json</code> 标记。这个标记的作用是把代码包的结构体实例用 JSON 的样式打印出来。<br>
</p>

<p>
这里解释一下，JSON 的全称是 Javascript Object Notation。它一种轻量级的承载数据的格式。JSON 的优势在于语法简单、短小精悍，且非常易于处理。JSON 还是一种纯文本格式，独立于编程语言。正因为如此，得到了绝大多数编程语言和浏览器的支持，应用非常广泛。Go语言当然也不例外，在它的标准库中有专门用于处理和转换 JSON 格式的数据的代码包 =encoding/json=。关于 JSON 格式的具体内容，读者可以去它的 <a href="http://www.json.org">官方网站</a> 查看说明。<br>
</p>

<p>
在了解了这些基本概念之后，我们来试用一下 <code>-json</code> 标记。示例如下：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">hc@ubt:~$ go list -e -json cnet
  {
          <span style="color: #2aa198;">"Dir"</span>: <span style="color: #2aa198;">"/home/hc/golang/goc2p/src/cnet"</span>,
          <span style="color: #2aa198;">"ImportPath"</span>: <span style="color: #2aa198;">"cnet"</span>,
          <span style="color: #2aa198;">"Stale"</span>: true,
          <span style="color: #2aa198;">"Root"</span>: <span style="color: #2aa198;">"/home/hc/golang/goc2p"</span>,
          <span style="color: #2aa198;">"Incomplete"</span>: true,
          <span style="color: #2aa198;">"Error"</span>: {
                  <span style="color: #2aa198;">"ImportStack"</span>: [
                          <span style="color: #2aa198;">"cnet"</span>
                  ],
                  <span style="color: #2aa198;">"Pos"</span>: <span style="color: #2aa198;">""</span>,
                  <span style="color: #2aa198;">"Err"</span>: <span style="color: #2aa198;">"no Go source files in /home/hc/golang/goc2p/src/cnet"</span>
          }
  }
</pre>
</div>

<p>
在上述 JSON 格式的代码包信息中，对于结构体中的字段的显示是不完整的。因为命令程序认为我们指定 <code>cnet</code> 就是不完整的。在名为 <code>Error</code> 的字段中，我们可以看到具体说明。 <code>Error</code> 字段的内容其实也是一个结构体。在 JSON 格式下，这种嵌套的结构体被完美的展现了出来。 <code>Error</code> 字段所指代的结构体实例的 <code>Err</code> 字段说明了 <code>cnet</code> 不完整的原因。这与我们在没有使用 <code>-e =标记的情况下所打印出来的错误提示信息是一致的。我们再来看 =Incomplete</code> 字段。它的值为 <code>true</code> 。这同样说明 <code>cnet</code> 是一个不完整的代码包。<br>
</p>

<p>
实际上，在从这个代码包结构体实例到 JSON 格式文本的转换过程中，所有的值为其类型的空值的字段都已经被忽略了。<br>
</p>

<p>
现在我们使用带 <code>-json</code> 标记的 <code>go list =命令列出代码包 =cnet/ctcp</code> 的信息：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">hc@ubt:~$ go list -json cnet/ctcp
{
  <span style="color: #2aa198;">"Dir"</span>: <span style="color: #2aa198;">"/home/hc/golang/github/goc2p/src/cnet/ctcp"</span>,
  <span style="color: #2aa198;">"ImportPath"</span>: <span style="color: #2aa198;">"cnet/ctcp"</span>,
  <span style="color: #2aa198;">"Name"</span>: <span style="color: #2aa198;">"ctcp"</span>,
  <span style="color: #2aa198;">"Target"</span>: <span style="color: #2aa198;">"/home/hc/golang/github/goc2p/pkg/darwin_amd64/cnet/ctcp.a"</span>,
  <span style="color: #2aa198;">"Stale"</span>: true,
  <span style="color: #2aa198;">"Root"</span>: <span style="color: #2aa198;">"/home/hc/golang/github/goc2p"</span>,
  <span style="color: #2aa198;">"GoFiles"</span>: [
    <span style="color: #2aa198;">"base.go"</span>,
    <span style="color: #2aa198;">"tcp.go"</span>
  ],
  <span style="color: #2aa198;">"Imports"</span>: [
    <span style="color: #2aa198;">"bufio"</span>,
    <span style="color: #2aa198;">"bytes"</span>,
    <span style="color: #2aa198;">"errors"</span>,
    <span style="color: #2aa198;">"logging"</span>,
    <span style="color: #2aa198;">"net"</span>,
    <span style="color: #2aa198;">"sync"</span>,
    <span style="color: #2aa198;">"time"</span>
  ],
  <span style="color: #2aa198;">"Deps"</span>: [
    <span style="color: #2aa198;">"bufio"</span>,
    <span style="color: #2aa198;">"bytes"</span>,
    <span style="color: #2aa198;">"errors"</span>,
    <span style="color: #2aa198;">"fmt"</span>,
    <span style="color: #2aa198;">"internal/singleflight"</span>,
    <span style="color: #2aa198;">"io"</span>,
    <span style="color: #2aa198;">"log"</span>,
    <span style="color: #2aa198;">"logging"</span>,
    <span style="color: #2aa198;">"math"</span>,
    <span style="color: #2aa198;">"math/rand"</span>,
    <span style="color: #2aa198;">"net"</span>,
    <span style="color: #2aa198;">"os"</span>,
    <span style="color: #2aa198;">"reflect"</span>,
    <span style="color: #2aa198;">"runtime"</span>,
    <span style="color: #2aa198;">"runtime/cgo"</span>,
    <span style="color: #2aa198;">"sort"</span>,
    <span style="color: #2aa198;">"strconv"</span>,
    <span style="color: #2aa198;">"strings"</span>,
    <span style="color: #2aa198;">"sync"</span>,
    <span style="color: #2aa198;">"sync/atomic"</span>,
    <span style="color: #2aa198;">"syscall"</span>,
    <span style="color: #2aa198;">"time"</span>,
    <span style="color: #2aa198;">"unicode"</span>,
    <span style="color: #2aa198;">"unicode/utf8"</span>,
    <span style="color: #2aa198;">"unsafe"</span>
  ],
  <span style="color: #2aa198;">"TestGoFiles"</span>: [
    <span style="color: #2aa198;">"tcp_test.go"</span>
  ],
  <span style="color: #2aa198;">"TestImports"</span>: [
    <span style="color: #2aa198;">"bytes"</span>,
    <span style="color: #2aa198;">"fmt"</span>,
    <span style="color: #2aa198;">"net"</span>,
    <span style="color: #2aa198;">"runtime"</span>,
    <span style="color: #2aa198;">"strings"</span>,
    <span style="color: #2aa198;">"sync"</span>,
    <span style="color: #2aa198;">"testing"</span>,
    <span style="color: #2aa198;">"time"</span>
  ]
}
</pre>
</div>

<p>
由于 <code>cnet/ctcp</code> 包是一个完整有效的代码包，所以我们不使用 <code>-e</code> 标记也是没有问题的。在上面打印的 <code>cnet/ctcp</code> 包的信息中没有 <code>Incomplete</code> 字段。这是因为完整的代码包中的 <code>Incomplete</code> 字段的其类型的空值 <code>false</code> 。它已经在转换过程中被忽略掉了。另外，在 <code>cnet/ctcp</code> 包的信息中我们看到了很多其它的字段。现在我就来看看在 Go 命令程序中的代码包结构体都有哪些公开的字段。如下表。<br>
</p>

<p>
表 0-7 代码包结构体中的基本字段<br>
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">字段名称</th>
<th scope="col" class="org-left">字段类型</th>
<th scope="col" class="org-left">字段描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Dir</td>
<td class="org-left">字符串（string）</td>
<td class="org-left">代码包对应的目录。</td>
</tr>

<tr>
<td class="org-left">ImportPath</td>
<td class="org-left">字符串（string）</td>
<td class="org-left">代码包的导入路径。</td>
</tr>

<tr>
<td class="org-left">ImportComment</td>
<td class="org-left">字符串（string）</td>
<td class="org-left">代码包声明语句右边的用于自定义导入路径的注释。</td>
</tr>

<tr>
<td class="org-left">Name</td>
<td class="org-left">字符串（string）</td>
<td class="org-left">代码包的名称。</td>
</tr>

<tr>
<td class="org-left">Doc</td>
<td class="org-left">字符串（string）</td>
<td class="org-left">代码包的文档字符串。</td>
</tr>

<tr>
<td class="org-left">Target</td>
<td class="org-left">字符串（string）</td>
<td class="org-left">代码包的安装路径。</td>
</tr>

<tr>
<td class="org-left">Shlib</td>
<td class="org-left">字符串（string）</td>
<td class="org-left">包含该代码包的共享库（shared library）的名称。</td>
</tr>

<tr>
<td class="org-left">Goroot</td>
<td class="org-left">布尔（bool）</td>
<td class="org-left">该代码包是否在Go语言安装目录下。</td>
</tr>

<tr>
<td class="org-left">Standard</td>
<td class="org-left">布尔（bool）</td>
<td class="org-left">该代码包是否属于标准库的一部分。</td>
</tr>

<tr>
<td class="org-left">Stale</td>
<td class="org-left">布尔（bool）</td>
<td class="org-left">该代码包的最新代码是否未被安装。</td>
</tr>

<tr>
<td class="org-left">Root</td>
<td class="org-left">字符串（string）</td>
<td class="org-left">该代码包所属的工作区或Go安装目录的路径。</td>
</tr>
</tbody>
</table>

<p>
表 0-8 代码包结构体中与源码文件有关的字段<br>
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">字段名称</th>
<th scope="col" class="org-left">字段类型</th>
<th scope="col" class="org-left">字段描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">GoFiles</td>
<td class="org-left">字符串切片（[]string）</td>
<td class="org-left">Go源码文件的列表。不包含导入了代码包“C”的源码文件和测试源码文件。</td>
</tr>

<tr>
<td class="org-left">CgoFiles</td>
<td class="org-left">字符串切片（[]string）</td>
<td class="org-left">导入了代码包“C”的源码文件的列表。</td>
</tr>

<tr>
<td class="org-left">IgnoredGoFiles</td>
<td class="org-left">字符串切片（[]string）</td>
<td class="org-left">忽略编译的源码文件的列表。</td>
</tr>

<tr>
<td class="org-left">CFiles</td>
<td class="org-left">字符串切片（[]string）</td>
<td class="org-left">名称中有“.c”后缀的源码文件的列表。</td>
</tr>

<tr>
<td class="org-left">CXXFiles</td>
<td class="org-left">字符串切片（[]string）</td>
<td class="org-left">名称中有“.cc”、“.cxx”或“.cpp”后缀的源码文件的列表。</td>
</tr>

<tr>
<td class="org-left">MFiles</td>
<td class="org-left">字符串切片（[]string）</td>
<td class="org-left">名称中“.m”后缀的源码文件的列表。</td>
</tr>

<tr>
<td class="org-left">HFiles</td>
<td class="org-left">字符串切片（[]string）</td>
<td class="org-left">名称中有“.h”后缀的源码文件的列表。</td>
</tr>

<tr>
<td class="org-left">SFiles</td>
<td class="org-left">字符串切片（[]string）</td>
<td class="org-left">名称中有“.s”后缀的源码文件的列表。</td>
</tr>

<tr>
<td class="org-left">SwigFiles</td>
<td class="org-left">字符串切片（[]string）</td>
<td class="org-left">名称中有“.swig”后缀的文件的列表。</td>
</tr>

<tr>
<td class="org-left">SwigCXXFiles</td>
<td class="org-left">字符串切片（[]string）</td>
<td class="org-left">名称中有“.swigcxx”后缀的文件的列表。</td>
</tr>

<tr>
<td class="org-left">SysoFiles</td>
<td class="org-left">字符串切片（[]string）</td>
<td class="org-left">名称中有“.syso”后缀的文件的列表。这些文件是需要被加入到归档文件中的。</td>
</tr>
</tbody>
</table>

<p>
表 0-9 代码包结构体中与 Cgo 指令有关的字段<br>
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">字段名称</th>
<th scope="col" class="org-left">字段类型</th>
<th scope="col" class="org-left">字段描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">CgoCFLAGS</td>
<td class="org-left">字符串切片（[]string）</td>
<td class="org-left">需要传递给C编译器的标记的列表。针对Cgo。</td>
</tr>

<tr>
<td class="org-left">CgoCPPFLAGS</td>
<td class="org-left">字符串切片（[]string）</td>
<td class="org-left">需要传递给C预处理器的标记的列表。针对Cgo。</td>
</tr>

<tr>
<td class="org-left">CgoCXXFLAGS</td>
<td class="org-left">字符串切片（[]string）</td>
<td class="org-left">需要传递给C++编译器的标记的列表。针对Cgo。</td>
</tr>

<tr>
<td class="org-left">CgoLDFLAGS</td>
<td class="org-left">字符串切片（[]string）</td>
<td class="org-left">需要传递给链接器的标记的列表。针对Cgo。</td>
</tr>

<tr>
<td class="org-left">CgoPkgConfig</td>
<td class="org-left">字符串切片（[]string）</td>
<td class="org-left">pkg-config的名称的列表。针对Cgo。</td>
</tr>
</tbody>
</table>

<p>
表 0-10 代码包结构体中与依赖信息有关的字段<br>
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">字段名称</th>
<th scope="col" class="org-left">字段类型</th>
<th scope="col" class="org-left">字段描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Imports</td>
<td class="org-left">字符串切片（[]string）</td>
<td class="org-left">该代码包中的源码文件显式导入的依赖包的导入路径的列表。</td>
</tr>

<tr>
<td class="org-left">Deps</td>
<td class="org-left">字符串切片（[]string）</td>
<td class="org-left">所有的依赖包（包括间接依赖）的导入路径的列表。</td>
</tr>
</tbody>
</table>

<p>
表 0-11 代码包结构体中与错误信息有关的字段<br>
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">字段名称</th>
<th scope="col" class="org-left">字段类型</th>
<th scope="col" class="org-left">字段描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Incomplete</td>
<td class="org-left">布尔（bool）</td>
<td class="org-left">代码包是否是完整的，也即在载入或分析代码包及其依赖包时是否有错误发生。</td>
</tr>

<tr>
<td class="org-left">Error</td>
<td class="org-left">*PackageError类型</td>
<td class="org-left">载入或分析代码包时发生的错误。</td>
</tr>

<tr>
<td class="org-left">DepsErrors</td>
<td class="org-left">[]*PackageError类型</td>
<td class="org-left">载入或分析依赖包时发生的错误。</td>
</tr>
</tbody>
</table>

<p>
表 0-12 代码包结构体中与测试源码文件有关的字段<br>
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">字段名称</th>
<th scope="col" class="org-left">字段类型</th>
<th scope="col" class="org-left">字段描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">TestGoFiles</td>
<td class="org-left">字符串切片（[]string）</td>
<td class="org-left">代码包中的测试源码文件的名称列表。</td>
</tr>

<tr>
<td class="org-left">TestImports</td>
<td class="org-left">字符串切片（[]string）</td>
<td class="org-left">代码包中的测试源码文件显示导入的依赖包的导入路径的列表。</td>
</tr>

<tr>
<td class="org-left">XTestGoFiles</td>
<td class="org-left">字符串切片（[]string）</td>
<td class="org-left">代码包中的外部测试源码文件的名称列表。</td>
</tr>

<tr>
<td class="org-left">XTestImports</td>
<td class="org-left">字符串切片（[]string）</td>
<td class="org-left">代码包中的外部测试源码文件显示导入的依赖包的导入路径的列表。</td>
</tr>
</tbody>
</table>

<p>
代码包结构体中定义的字段很多，但有些时候我们只需要查看其中的一些字段。那要怎么做呢？标记=-f=可以满足这个需求。比如这样：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">hc@ubt:~$ go list -f {{.ImportPath}} cnet/ctcp
cnet/ctcp
</pre>
</div>

<p>
实际上， <code>-f</code> 标记的默认值就是 <code>{{.ImportPath}}</code> 。这也正是我们在使用不加任何标记的 <code>go list</code> 命令时依然能看到指定代码包的导入路径的原因了。<br>
</p>

<p>
标记 <code>-f</code> 的值需要满足标准库的代码包 <code>text/template</code> 中定义的语法。比如， <code>{{.S}}</code> 代表根结构体的 <code>S</code> 字段的值。在 <code>go list</code> 命令的场景下，这个根结构体就是指定的代码包所对应的结构体。如果 <code>S</code> 字段的值也是一个结构体的话，那么 <code>{{.S.F}}</code> 就代表根结构体的 <code>S</code> 字段的值中的 <code>F</code> 字段的值。如果我们要查看 <code>cnet/ctcp</code> 包中的命令源码文件和库源码文件的列表，可以这样使用 <code>-f</code> 标记：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">hc@ubt:~$ go list -f {{.GoFiles}} cnet/ctcp
[base.go tcp.go]
</pre>
</div>

<p>
如果我们想查看不完整的代码包=cnet=的错误提示信息，还可以这样：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">hc@ubt:~$ go list -e -f {{.Error.Err}} cnet
no buildable Go source files<span style="color: #268bd2; font-weight: bold;"> in</span> /home/hc/golang/goc2p/src/cnet
</pre>
</div>

<p>
我们还可以利用代码包 <code>text/template</code> 中定义的强大语法让 <code>go list</code> 命令输出定制化更高的代码包信息。比如：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">hc@ubt:~$ go list -e -f <span style="color: #2aa198;">'The package {{.ImportPath}} is {{if .Incomplete}}incomplete!{{else}}complete.{{end}}'</span> cnet
The package cnet is incomplete!
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash">hc@ubt:~$ go list -f <span style="color: #2aa198;">'The imports of package {{.ImportPath}} is [{{join .Imports ", "}}].'</span> cnet/ctcp
The imports of package cnet/ctcp is [bufio, bytes, errors, logging, net, sync, time].
</pre>
</div>

<p>
其中， <code>join</code> 是命令程序在 <code>text/template</code> 包原有语法之上自定义的语法，在底层使用标准库代码包 <code>strings</code> 中的 <code>Join</code> 函数。关于更多的语法规则，请读者查看代码包 <code>text/template</code> 的相关文档。<br>
</p>

<p>
另外， <code>-tags</code> 标记也可以被 <code>go list</code> 接受。它与我们在讲 <code>go build</code> 命令时提到的 <code>-tags</code> 标记是一致的。读者可以查看代码包 <code>go/build</code> 的文档以了解细节。<br>
</p>

<p>
<code>go list</code> 命令很有用。它可以为我们提供指定代码包的更深层次的信息。这些信息往往是我们无法从源码文件中直观看到的。<br>
</p>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2021-09-22 04:09 三</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-04-01 Fri 18:47</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
