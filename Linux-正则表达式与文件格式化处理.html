<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2023-02-06 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>正则表达式与文件格式化处理</title>
<meta name="author" content="L.M.haoran" />
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved." />
<meta name="generator" content="Org Mode" />
<link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
           <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
           <script type="module" src="static/js/main.js" defer></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="static/MathJax/cdn.bootcdn.net/ajax/libs/mathjax/3.1.2/es5/tex-mml-chtml.min.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">正则表达式与文件格式化处理</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org8e76693">基础正则表达式</a>
<ul>
<li><a href="#org6a8f738">语系对正则表达式的影响</a></li>
<li><a href="#org4a5d595">grep 的一些高级选项</a></li>
<li><a href="#orgfadb285">基础正则表达式练习</a>
<ul>
<li><a href="#org4d8dd37">1. 查找特定字符串</a></li>
<li><a href="#org10fe914">2. 利用中括号 [] 来查找集合字符</a></li>
<li><a href="#orgc2c8b6d">3. 行首与行尾字符 ^ $</a></li>
<li><a href="#orgcb1e6c0">4. 任意一个字符 . 与重复字符 *</a></li>
<li><a href="#org6f7c2a4">5. 限定连续 RE 字符范围 {}</a></li>
</ul>
</li>
<li><a href="#orgbffae0a">基础正则表达式字符集合（characters）</a></li>
<li><a href="#org930b2b5">sed 工具</a></li>
</ul>
</li>
<li><a href="#orge6943bf">扩展正则表达式</a></li>
<li><a href="#org15cfea5">文件的格式化与相关处理</a>
<ul>
<li><a href="#org4f3e5be">格式化打印：printf</a></li>
<li><a href="#orgfd27af5">好用的数据处理工具：awk</a></li>
<li><a href="#org904f645">文件比对工具：diff、cmp、patch</a>
<ul>
<li><a href="#org39feeb6">比较文件的差异（逐行）：diff</a></li>
<li><a href="#org2dfef41">比较文件的差异（逐字节）：cmp</a></li>
<li><a href="#org0fbc0d4">修补文件：patch</a></li>
</ul>
</li>
<li><a href="#orgdc7e787">文件打印设置：pr</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org8e76693" class="outline-2">
<h2 id="org8e76693">基础正则表达式</h2>
<div class="outline-text-2" id="text-org8e76693">
</div>
<div id="outline-container-org6a8f738" class="outline-3">
<h3 id="org6a8f738">语系对正则表达式的影响</h3>
<div class="outline-text-3" id="text-org6a8f738">
<p>
语系的数据会影响正则表达式的输出结果，一般建议使用【LANG=C】这个语系进行。<br>
</p>

<p>
另外，为了要避免这样编码所造成的英文与数字的选取问题，因此有些特殊的符号我们要了解一下：<br>
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特殊符号</th>
<th scope="col" class="org-left">代表意义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">[:alnum:]</td>
<td class="org-left">代表英文大小写字符及数字，亦即 0~9、A~Z、a~z</td>
</tr>

<tr>
<td class="org-left">[:alpha:]</td>
<td class="org-left">代表任何英文大小写字符，亦即 A~Z、a~z</td>
</tr>

<tr>
<td class="org-left">[:blank:]</td>
<td class="org-left">代表空格键与 [Tab] 按键两者</td>
</tr>

<tr>
<td class="org-left">[:cntrl:]</td>
<td class="org-left">代表键盘上面的控制按键，包括 CR、LF、Tab、Del 等</td>
</tr>

<tr>
<td class="org-left">[:digit:]</td>
<td class="org-left">代表数字，即0~9</td>
</tr>

<tr>
<td class="org-left">[:graph:]</td>
<td class="org-left">除了空格符（空格键与 [Tab] 按键）外的其他所有按键</td>
</tr>

<tr>
<td class="org-left">[:lower:]</td>
<td class="org-left">代表小写字符，即 a~z</td>
</tr>

<tr>
<td class="org-left">[:print:]</td>
<td class="org-left">代表任何可以被打印出来的字符</td>
</tr>

<tr>
<td class="org-left">[:punct:]</td>
<td class="org-left">代表标点符号（punctuation symbol），亦即："'?!;:#$</td>
</tr>

<tr>
<td class="org-left">[:upper:]</td>
<td class="org-left">代表大写字符，即 A~Z</td>
</tr>

<tr>
<td class="org-left">[:space:]</td>
<td class="org-left">任何会产生空白的字符，包括空格键、[Tab]、CR 等</td>
</tr>

<tr>
<td class="org-left">[xdight:]</td>
<td class="org-left">代表十六进制的数字类型，因此包括 0~9、A~F、a~f 的数字与字符</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org4a5d595" class="outline-3">
<h3 id="org4a5d595">grep 的一些高级选项<a id="org25964c4"></a></h3>
<div class="outline-text-3" id="text-org4a5d595">
<p>
<a href="Linux-bash.html#org5e616fb">grep的基础用法</a><br>
</p>

<pre class="example" id="orgac128c0">
grep [-A] [-B] [--color=auto] '查找字符' filename

-A: 后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来；
-B: 后面可加数字，为 before 的意思，除了列出该行外，前面的 n 行也列出来；
--color=auto: 可将正确的哪个选项数据列出颜色；
</pre>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #928374;"># </span><span style="color: #928374;">&#33539;&#20363;&#19968;&#65306;&#29992; dmesg &#21015;&#20986;&#20869;&#26680;&#20449;&#24687;&#65292;&#20877;&#20197; grep &#25214;&#20986;&#20869;&#21547; qxl &#37027;&#34892;</span>
dmesg | grep -n -A3 -B2 --color=auto <span style="color: #b8bb26;">'qxl'</span>
<span style="color: #928374;"># </span><span style="color: #928374;">&#22312;&#20851;&#38190;&#23383;&#25152;&#22312;&#34892;&#30340;&#21069;&#20004;&#34892;&#19982;&#21518;&#19977;&#34892;&#20063;&#19968;&#36215;&#35782;&#21035;&#20986;&#26469;&#26174;&#31034;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfadb285" class="outline-3">
<h3 id="orgfadb285">基础正则表达式练习</h3>
<div class="outline-text-3" id="text-orgfadb285">
</div>
<div id="outline-container-org4d8dd37" class="outline-4">
<h4 id="org4d8dd37">1. 查找特定字符串</h4>
<div class="outline-text-4" id="text-org4d8dd37">
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #928374;"># </span><span style="color: #928374;">&#33539;&#20363;&#19968;&#65306;&#26597;&#25214;&#29305;&#23450;&#23383;&#31526;&#20018;</span>
$ grep -n <span style="color: #b8bb26;">'the'</span> regular_express.txt

<span style="color: #928374;"># </span><span style="color: #928374;">&#33539;&#20363;&#20108;&#65306;&#21453;&#21521;&#36873;&#25321;&#65292;&#24403;&#35813;&#34892;&#27809;&#26377; 'the' &#36825;&#20010;&#23383;&#31526;&#20018;&#26102;&#65292;&#25165;&#26174;&#31034;&#22312;&#23631;&#24149;&#19978;</span>
$ grep -vn <span style="color: #b8bb26;">'the'</span> regular_express.txt
</pre>
</div>
</div>
</div>
<div id="outline-container-org10fe914" class="outline-4">
<h4 id="org10fe914">2. 利用中括号 [] 来查找集合字符</h4>
<div class="outline-text-4" id="text-org10fe914">
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #928374;"># </span><span style="color: #928374;">&#26597;&#25214; test &#25110; taste &#36825;&#20004;&#20010;&#20851;&#38190;&#35789;&#26102;&#65292;&#21487;&#20197;&#20351;&#29992;&#19979;&#38754;&#34920;&#36798;&#24335;</span>
$ grep -n <span style="color: #b8bb26;">'t[ar]st'</span> regular_repress.txt

<span style="color: #928374;"># </span><span style="color: #928374;">&#38598;&#21512;&#23383;&#31526;&#30340;&#21453;&#21521;&#36873;&#25321; [^]&#65292;&#22914;&#26524;&#25105;&#19981;&#24819; oo &#21069;&#38754;&#26377; g &#30340;&#35805;</span>
$ grep -n <span style="color: #b8bb26;">'[^g]oo'</span> regular_repress.txt

<span style="color: #928374;"># </span><span style="color: #928374;">&#20551;&#35774; oo &#21069;&#38754;&#19981;&#24819;&#35201;&#26377;&#23567;&#20889;&#23383;&#31526;</span>
$ grep -n <span style="color: #b8bb26;">'[^a-z]oo'</span> regular_repress.txt

<span style="color: #928374;"># </span><span style="color: #928374;">&#32771;&#34385;&#21040;&#35821;&#31995;&#23545;&#20110;&#32534;&#30721;&#39034;&#24207;&#30340;&#24433;&#21709;&#65292;&#36824;&#21487;&#20197;&#20351;&#29992;&#22914;&#19979;&#26041;&#27861;</span>
$ grep -n <span style="color: #b8bb26;">'[^[:lower:]]oo'</span> regular_repress.txt
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc2c8b6d" class="outline-4">
<h4 id="orgc2c8b6d">3. 行首与行尾字符 ^ $</h4>
<div class="outline-text-4" id="text-orgc2c8b6d">
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #928374;"># </span><span style="color: #928374;">&#20197; the &#24320;&#22836;&#30340;&#34892;</span>
$ grep -n <span style="color: #b8bb26;">'^the'</span> regular_repress.txt

<span style="color: #928374;"># </span><span style="color: #928374;">&#20197;&#23567;&#25968;&#28857;&#32467;&#23614;&#30340;&#34892;</span>
grep -n <span style="color: #b8bb26;">'\.$'</span> regular_repress.txt

<span style="color: #928374;"># </span><span style="color: #928374;">&#31354;&#30333;&#34892;</span>
grep -n <span style="color: #b8bb26;">'^$'</span> regular_repress.txt
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcb1e6c0" class="outline-4">
<h4 id="orgcb1e6c0">4. 任意一个字符 . 与重复字符 *</h4>
<div class="outline-text-4" id="text-orgcb1e6c0">
<dl class="org-dl">
<dt><code>.</code></dt><dd>代表【一定有一个任意字符】的意思；<br></dd>
<dt><code>*</code></dt><dd><p>
代表【重复前一个字符，0 到无穷多次】的意思；<br>
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #928374;"># </span><span style="color: #928374;">&#25214;&#20986; g &#24320;&#22836;&#19982; g &#32467;&#23614;&#30340;&#23383;&#31526;&#20018;</span>
grep -n <span style="color: #b8bb26;">'g.*g'</span> regular_express.txt
</pre>
</div></dd>
</dl>
</div>
</div>
<div id="outline-container-org6f7c2a4" class="outline-4">
<h4 id="org6f7c2a4">5. 限定连续 RE 字符范围 {}</h4>
<div class="outline-text-4" id="text-org6f7c2a4">
<p>
使用 <code>{}</code> 可以限制一个范围内的重复字符数，但是因为 <code>{</code> 与 <code>}</code> 的符号在 shell 是有特殊意义的，因此，我们必须要使用转义符 <code>\</code> 来让它失去特殊意义才行。<br>
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #928374;"># </span><span style="color: #928374;">&#25214;&#21040;&#20004;&#20010; o &#30340;&#23383;&#31526;&#20018;</span>
$ grep -n <span style="color: #b8bb26;">'o\{2\}'</span> regular_express.txt

<span style="color: #928374;"># </span><span style="color: #928374;">&#25214;&#21040; 2 &#21040; 5 &#20010; o&#65292;&#28982;&#21518;&#20877;&#25509;&#19968;&#20010; g &#30340;&#23383;&#31526;&#20018;</span>
$ grep -n <span style="color: #b8bb26;">'o\{2,5\}g'</span> regular_express.txt

<span style="color: #928374;"># </span><span style="color: #928374;">&#25214;&#21040;&#20004;&#20010; o &#20197;&#19978;&#30340; gooo...g</span>
grep -n <span style="color: #b8bb26;">'go\{2,\}g'</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgbffae0a" class="outline-3">
<h3 id="orgbffae0a">基础正则表达式字符集合（characters）</h3>
<div class="outline-text-3" id="text-orgbffae0a">
<dl class="org-dl">
<dt><code>^word</code></dt><dd>待搜寻的字串（word）在行首；<br></dd>
<dt><code>word$</code></dt><dd>待搜寻的字串（word）在行尾；<br></dd>
<dt><code>.</code></dt><dd>代表一定有一个任意字符的字符；<br></dd>
<dt><code>\</code></dt><dd>转义符，将特殊符号的特殊意义去除；<br></dd>
<dt><code>*</code></dt><dd>重复零个到无穷多个的前一个 RE 字符；<br></dd>
<dt><code>[list]</code></dt><dd>字符集合的 RE 字符，里面列出想要撷取的字符；<br></dd>
<dt><code>[n1-n2]</code></dt><dd>字符集合的 RE 字符，里面列出想要撷取的字符范围；<br></dd>
<dt><code>[^list]</code></dt><dd>字符集合的 RE 字符，里面列出不要的字串或范围；<br></dd>
<dt><code>{n,m}</code></dt><dd>连续 n 到 m 个的前一个 RE 字符；若为 {n} 则是连续 n 个的前一个 RE 字符；若是 {n,} 则是连续 n 个以上的前一个 RE 字符；<br></dd>
</dl>
</div>
</div>
<div id="outline-container-org930b2b5" class="outline-3">
<h3 id="org930b2b5"><a href="Shell-sed_awk_grep.html#org7aa8c70">sed 工具</a></h3>
</div>
</div>
<div id="outline-container-orge6943bf" class="outline-2">
<h2 id="orge6943bf">扩展正则表达式</h2>
<div class="outline-text-2" id="text-orge6943bf">
<ul class="org-ul">
<li><p>
+：重复【一个或一个以上】的前一个 RE 字符；<br>
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #928374;"># </span><span style="color: #928374;">&#33539;&#20363;&#65306;&#25628;&#23547;&#65288;god&#65289;&#65288;good&#65289;&#65288;goood&#65289;&#31561;&#30340;&#23383;&#20018;&#65292;&#37027;&#20010; o+ &#20195;&#34920;&#19968;&#20010;&#20197;&#19978;&#30340; o&#65307;</span>
egrep -n <span style="color: #b8bb26;">'go+d'</span> regular_express.txt
</pre>
</div></li>
<li><p>
?：【零个或一个】的前一个 RE 字符；<br>
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #928374;"># </span><span style="color: #928374;">&#33539;&#20363;&#65306;&#25628;&#23547;&#65288;gd&#65289;&#65288;god&#65289;&#36825;&#20004;&#20010;&#23383;&#20018;&#65292;&#37027;&#20010; o? &#20195;&#34920;&#31354;&#30340;&#25110; 1 &#20010; o&#65307;</span>
egrep -n <span style="color: #b8bb26;">'go?d'</span> regular_express.txt
</pre>
</div></li>
<li><p>
|：用或（or）的方法找出整个字符串；<br>
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #928374;"># </span><span style="color: #928374;">&#33539;&#20363;&#65306;&#25628;&#23547; gd &#25110; good &#36825;&#20004;&#20010;&#23383;&#20018;&#65292;&#27880;&#24847;&#65292;&#26159;&#12304;&#25110;&#12305;&#65307;&#37027;&#22914;&#26524;&#36824;&#24819;&#35201;&#25214;&#20986; dog &#21602;&#65311;</span>
egrep -n <span style="color: #b8bb26;">'gd|good'</span> regular_express.txt
egrep -n <span style="color: #b8bb26;">'gd|good|dog'</span> regular_express.txt
</pre>
</div></li>
<li><p>
()：找出群组字符串；<br>
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #928374;"># </span><span style="color: #928374;">&#33539;&#20363;&#65306;&#25628;&#23547; &#65288;glad&#65289; &#25110; &#65288;good&#65289; &#36825;&#20004;&#20010;&#23383;&#20018;&#65292;&#22240;&#20026; g &#19982; d &#26159;&#37325;&#22797;&#30340;&#65292;&#25152;&#20197;&#65292; &#25105;&#23601;&#21487;&#20197;&#23558; la &#19982; oo &#21015;&#20110;&#65288; &#65289;&#24403;&#20013;&#65292;&#24182;&#20197; | &#26469;&#20998;&#38548;&#24320;&#26469;&#23601;&#21487;&#20197;&#20102;&#65307;</span>
egrep -n <span style="color: #b8bb26;">'g&#65288;la&amp;#124;oo&#65289;d'</span> regular_express.txt
</pre>
</div></li>
<li><p>
()+：多个重复群组的判别；<br>
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #928374;"># </span><span style="color: #928374;">&#33539;&#20363;&#65306;&#23558; AxyzxyzxyzxyzC &#29992; echo &#21483;&#20986;&#65292;&#28982;&#21518;&#20877;&#20351;&#29992;&#22914;&#19979;&#30340;&#26041;&#27861;&#25628;&#23547;&#19968;&#19979;&#65307;</span>
<span style="color: #fe8019;">echo</span> <span style="color: #b8bb26;">'AxyzxyzxyzxyzC'</span> | egrep <span style="color: #b8bb26;">'A&#65288;xyz&#65289;+C'</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org15cfea5" class="outline-2">
<h2 id="org15cfea5">文件的格式化与相关处理</h2>
<div class="outline-text-2" id="text-org15cfea5">
</div>
<div id="outline-container-org4f3e5be" class="outline-3">
<h3 id="org4f3e5be">格式化打印：printf<a id="org635fa2a"></a></h3>
<div class="outline-text-3" id="text-org4f3e5be">
<pre class="example" id="org5693693">
printf '打印格式' 实际内容

\a 警告声音输出
\b 退格键（backspace）
\f 清除屏幕
\n 输出新的一行
\r 亦即回车按键
\t 水平的 [tab] 按键
\v 垂直的 [tab] 按键
\xNN NN 为两位数的数字，可以转换数字成为字符

%ns 多少个字符
%ni 多少整数位数
%N.nf 小数点为 n 位，总长位 N
</pre>

<pre class="example" id="org3be00b6">
Name Chinese English Math Average
DmTsai    80      60   92   77.33
VBird     75      55   80   70.00
Ken       60      90   70   73.33
</pre>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #928374;"># </span><span style="color: #928374;">&#33539;&#20363;&#19968;&#65306;&#23558;&#21018;&#21018;&#19978;&#38754;&#25968;&#25454;&#30340;&#25991;&#20214;&#65288;printf.txt&#65289;&#20869;&#23481;&#20165;&#21015;&#20986;&#22995;&#21517;&#19982;&#25104;&#32489;&#65288;&#29992; [tab] &#20998;&#38548;&#65289;</span>
$ printf <span style="color: #b8bb26;">'%s\t %s\t %s\t %s\t %s\t \n'</span> $(cat printf.txt)

<span style="color: #928374;"># </span><span style="color: #928374;">&#33539;&#20363;&#20108;&#65306;&#23558;&#19978;&#36848;&#25968;&#25454;&#20851;&#20110;&#31532;&#20108;&#34892;&#20197;&#21518;&#65292;&#20998;&#21035;&#20197;&#23383;&#31526;&#12289;&#25972;&#25968;&#12289;&#23567;&#25968;&#28857;&#26174;&#31034;</span>
$ printf <span style="color: #b8bb26;">'%10s %5i %5i %5i %8.2f \n'</span> $(cat printf.txt | grep -v Name)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #928374;"># </span><span style="color: #928374;">&#33539;&#20363;&#19977;&#65306;&#21015;&#20986;&#21313;&#20845;&#36827;&#21046;&#30340;&#25968;&#20540; 45 &#20195;&#34920;&#30340;&#23383;&#31526;&#26159;&#20160;&#20040;</span>
$ printf <span style="color: #b8bb26;">'\x45\n'</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfd27af5" class="outline-3">
<h3 id="orgfd27af5">好用的数据处理工具：awk<a id="orgced5258"></a></h3>
<div class="outline-text-3" id="text-orgfd27af5">
<p>
awk 也是一个非常棒的数据处理工具，相较于 sed 常常作用于一整个行的处理， awk 则比较倾向于一行当中分成数个字段来处理。因此，awk 相当的适合处理小型的数据数据处理，awk 通常运行的模式是这样的：<br>
</p>

<pre class="example" id="org9050bd9">
$ awk '条件类型1{动作1} 条件类型2{动作2} ...' filename
</pre>

<p>
awk 后面接两个单引号并加上大括号 {} 来设置想要对数据进行的处理动作。awk 可以处理后续接的文件，也可以读取来自前个命令的标准输出。但如前面说的，awk 主要是处理每一行的字段内的数据， <span class="underline">而默认的字段的分隔符号为 "空白键" 或 "[tab]键"</span> 。举例来说，我们用 last 可以将登陆者的数据取出来，结果如下所示：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">$ last -n 5 <span style="color: #928374;"># </span><span style="color: #928374;">&lt;== &#20165;&#21462;&#20986;&#21069;&#20116;&#34892;</span>
dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged<span style="color: #fb4934;"> in</span>
dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 &#65288;03:22&#65289;
dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 &#65288;06:12&#65289;
dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 &#65288;00:14&#65289;
dmtsai tty1 Fri May 29 11:55 - 12:11 &#65288;00:15&#65289;
</pre>
</div>

<p>
若我想要取出帐号与登陆者的 IP，且帐号与 IP 之间以 [tab] 隔开，则会变成这样：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">$ last -n 5 | awk <span style="color: #b8bb26;">'{print $1 "\t" $3}'</span>
dmtsai 192.168.1.100
dmtsai 192.168.1.100
dmtsai 192.168.1.100
dmtsai 192.168.1.100
dmtsai Fri
</pre>
</div>

<p>
上表是 awk 最常使用的操作，通过 print 的功能将字段数据列出来。字段的分隔则以空格键或 [tab] 按键来隔开。因为不论哪一行我都要处理，因此，就不需要有 "条件类型" 的限制。我所想要的是第一栏以及第三栏，但是，第五行的内容怪怪的，这是因为数据格式的问题。所以在使用 awk 的时候，请先确认一下你的数据当中，如果是连续性的数据，请不要有空格或 [tab] 在内，否则，就会像这个例子这样，会发生误判。<br>
</p>

<p>
另外，由上面这个例子你也会知道，在 awk 的括号内，每一行的每个字段都是有变量名称的，那就是 $1, $2&#x2026; 等变量名称。以上面的例子来说， dmtsai 是 $1 ，因为他是第一栏嘛。至于 192.168.1.100 是第三栏，所以他就是 $3 ，后面以此类推，呵呵，还有个变量，那就是 $0 ，$0 代表【一整列数据】的意思，以上面的例子来说，第一行的 $0 代表的就是【dmtsai &#x2026;. 】那一行，由此可知，刚刚上面五行当中，整个 awk 的处理流程是：<br>
</p>

<ol class="org-ol">
<li>读入第一行，并将第一行的数据填入 $0, $1, $2&#x2026;. 等变量当中；<br></li>
<li>依据 "条件类型" 的限制，判断是否需要进行后面的 "操作"；<br></li>
<li>做完所有的动作与条件类型；<br></li>
<li>若还有后续的【行】的数据，则重复上面 1~3 的步骤，直到所有的数据都读完为止；<br></li>
</ol>

<p>
经过这样的步骤，你会晓得，awk 是 <span class="underline">以行为一次处理的单位</span> ，而 <span class="underline">以字段为最小的处理单位</span> 。好了，那么 awk 怎么知道我到底这个数据有几行？有几栏呢？这就需要 awk 的内置变量的帮忙。<br>
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">变量名称</th>
<th scope="col" class="org-left">代表意义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">NF</td>
<td class="org-left">每一行 （$0） 拥有的字段总数</td>
</tr>

<tr>
<td class="org-left">NR</td>
<td class="org-left">目前 awk 所处理的是“第几行”数据</td>
</tr>

<tr>
<td class="org-left">FS</td>
<td class="org-left">目前的分隔字符，默认是空白键</td>
</tr>
</tbody>
</table>

<p>
我们继续以上面 last -n 5 的例子来做说明，如果我想要：<br>
</p>
<ul class="org-ul">
<li>列出每一行的帐号（就是 $1）；<br></li>
<li>列出目前处理的行数（就是 awk 内的 NR 变量）；<br></li>
<li>并且说明，该行有多少字段（就是 awk 内的 NF 变量）；<br></li>
</ul>

<p>
则可以这样：<br>
</p>

<blockquote>
<p>
Tips 要注意喔，awk 后续的所有动作是以单引号【'】括住的，由于单引号与双引号都必须是成对的，所以，awk 的格式内容如果想要以 print 打印时，记得非变量的文字部分，包含上一小节 printf 提到的格式中，都需要使用双引号来定义出来， <span class="underline">因为单引号已经是 awk 的指令固定用法了</span> 。<br>
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-bash">$ last -n 5 | awk <span style="color: #b8bb26;">'{print $1 "\t lines: " NR "\t columns: " NF}'</span>
dmtsai lines: 1 columns: 10
dmtsai lines: 2 columns: 10
dmtsai lines: 3 columns: 10
dmtsai lines: 4 columns: 10
dmtsai lines: 5 columns: 9
<span style="color: #928374;"># </span><span style="color: #928374;">&#27880;&#24847;&#65292;&#22312; awk &#20869;&#30340; NR, NF &#31561;&#21464;&#37327;&#35201;&#29992;&#22823;&#20889;&#65292;&#19988;&#19981;&#38656;&#35201;&#26377;&#32654;&#20803;&#31526;&#21495; $</span>
</pre>
</div>

<p>
这样可以了解 NR 与 NF 的差别了吧？好了，下面来谈一谈所谓的 "条件类型" 了吧！<br>
</p>

<p>
<b>awk 的逻辑运算字符</b><br>
</p>

<p>
既然有需要用到 "条件" 的类别，自然就需要一些逻辑运算啰～例如下面这些：<br>
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">运算单元</th>
<th scope="col" class="org-left">代表意义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&gt;</td>
<td class="org-left">大于</td>
</tr>

<tr>
<td class="org-left">&lt;</td>
<td class="org-left">小于</td>
</tr>

<tr>
<td class="org-left">&gt;=</td>
<td class="org-left">大于或等于</td>
</tr>

<tr>
<td class="org-left">&lt;=</td>
<td class="org-left">小于或等于</td>
</tr>

<tr>
<td class="org-left">==</td>
<td class="org-left">等于</td>
</tr>

<tr>
<td class="org-left">!=</td>
<td class="org-left">不等于</td>
</tr>
</tbody>
</table>

<p>
值得注意的是那个【==】的符号，因为：<br>
</p>
<ul class="org-ul">
<li>逻辑运算上面亦即所谓的大于、小于、等于等判断式上面，习惯上是以【==】来表示；<br></li>
<li>如果是直接给予一个值，例如变量设置时，就直接使用 = 而已；<br></li>
</ul>

<p>
好了，我们实际来运用一下逻辑判断吧！举例来说，在 /etc/passwd 当中是以冒号 ":" 来作为字段的分隔， 该文件中第一字段为帐号，第三字段则是 UID。那假设我要查阅，第三栏小于 10 以下的数据，并且仅列出帐号与第三栏， 那么可以这样做：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">$ cat /etc/passwd | awk <span style="color: #b8bb26;">'{FS=":"} $3 &lt; 10 {print $1 "\t " $3}'</span>
root:x:0:0:root:/root:/bin/bash
bin 1
daemon 2
....&#65288;&#20197;&#19979;&#30465;&#30053;&#65289;....
</pre>
</div>

<p>
有趣吧！不过，怎么第一行没有正确的显示出来呢？这是因为我们读入第一行的时候，那些变量 $1, $2&#x2026; 默认还是以空白键为分隔的，所以虽然我们定义了 FS=":" 了， 但是却仅能在第二行后才开始生效。那么怎么办呢？我们可以预先设置 awk 的变量，利用 BEGIN 这个关键字，这样做：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">$ cat /etc/passwd | awk <span style="color: #b8bb26;">'BEGIN {FS=":"} $3 &lt; 10 {print $1 "\t " $3}'</span>
root 0
bin 1
daemon 2
......&#65288;&#20197;&#19979;&#30465;&#30053;&#65289;......
</pre>
</div>

<p>
很有趣吧！而除了 BEGIN 之外，我们还有 END，另外，如果要用 awk 来进行计算功能，以下面的例子来看， 假设我有一个薪资数据表文件名为 pay.txt ，内容是这样的：<br>
</p>

<pre class="example" id="org6e2a1ca">
Name 1st 2nd 3th
VBird 23000 24000 25000
DMTsai 21000 20000 23000
Bird2 43000 42000 41000
</pre>

<p>
如何帮我计算每个人的总额呢？而且我还想要格式化输出。我们可以这样考虑：<br>
</p>
<ul class="org-ul">
<li>第一行只是说明，所以第一行不要进行加总 （NR==1 时处理）；<br></li>
<li>第二行以后就会有加总的情况出现 （NR&gt;=2 以后处理）<br></li>
</ul>

<div class="org-src-container">
<pre class="src src-bash">$ cat pay.txt | <span style="color: #b8bb26;">\</span>
  &gt; awk <span style="color: #b8bb26;">'NR==1{printf "%10s %10s %10s %10s %10s\n",$1,$2,$3,$4,"Total" }</span>
<span style="color: #b8bb26;">&gt; NR&gt;=2{total = $2 + $3 + $4</span>
<span style="color: #b8bb26;">&gt; printf "%10s %10d %10d %10d %10.2f\n", $1, $2, $3, $4, total}'</span>
Name 1st 2nd 3th Total
VBird 23000 24000 25000 72000.00
DMTsai 21000 20000 23000 64000.00
Bird2 43000 42000 41000 126000.00
</pre>
</div>

<p>
上面的例子有几个重要事项应该要先说明的：<br>
</p>
<ul class="org-ul">
<li>awk 的指令间隔：所有 awk 的动作，亦即在 {} 内的动作，如果有需要多个指令辅助时，可利用分号【;】间隔，或者直接以 [Enter] 按键来隔开每个指令，例如上面的范例中，共按了三次 [enter]；<br></li>
<li>逻辑运算当中，如果是【等于】的情况，则务必使用两个等号【==】；<br></li>
<li>格式化输出时，在 printf 的格式设置当中，务必加上 \n ，才能进行分行；<br></li>
<li>与 bash shell 的变量不同，在 awk 当中，变量可以直接使用，不需加上 $ 符号。<br></li>
</ul>

<p>
利用 awk 这个玩意儿，就可以帮我们处理很多日常工作。此外，awk 的输出格式当中，常常会以 printf 来辅助，所以，最好你对 printf 也稍微熟悉一下比较好。另外，awk 的动作内 {} 也是支持 if (条件) 的，举例来说，上面的指令可以修订成为这样：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">$ cat pay.txt | <span style="color: #b8bb26;">\</span>
  &gt; awk <span style="color: #b8bb26;">'{if&#65288;NR==1&#65289; printf "%10s %10s %10s %10s %10s\n",$1,$2,$3,$4,"Total"}</span>
<span style="color: #b8bb26;">&gt; NR&gt;=2{total = $2 + $3 + $4</span>
<span style="color: #b8bb26;">&gt; printf "%10s %10d %10d %10d %10.2f\n", $1, $2, $3, $4, total}'</span>
</pre>
</div>

<p>
你可以仔细的比对一下上面两个输入有啥不同，从中去了解两种语法吧！我个人是比较倾向于使用第一种语法，因为会比较有统一性。<br>
</p>
</div>
</div>
<div id="outline-container-org904f645" class="outline-3">
<h3 id="org904f645">文件比对工具：diff、cmp、patch</h3>
<div class="outline-text-3" id="text-org904f645">
</div>
<div id="outline-container-org39feeb6" class="outline-4">
<h4 id="org39feeb6">比较文件的差异（逐行）：diff<a id="org79a06c1"></a></h4>
<div class="outline-text-4" id="text-org39feeb6">
<pre class="example" id="orgdeb0f25">
diff [-bBi] from-file to-file

-b: 忽略一行当中，仅有多个空白的差异（"about me" 与 "about   me" 视为相同；
-B: 忽略空白行的差异；
-i: 忽略大小写的差异；
</pre>

<p>
diff 还可以对比不同目录下相同文件名的内容。<br>
</p>
</div>
</div>
<div id="outline-container-org2dfef41" class="outline-4">
<h4 id="org2dfef41">比较文件的差异（逐字节）：cmp<a id="orgea85a0d"></a></h4>
<div class="outline-text-4" id="text-org2dfef41">
<pre class="example" id="org9dea576">
cmp [-l] file1 file2

-l: 将所有不同点处的字节都列出来，默认仅列出第一个发现的不同点；
</pre>
</div>
</div>
<div id="outline-container-org0fbc0d4" class="outline-4">
<h4 id="org0fbc0d4">修补文件：patch<a id="orgbb468b6"></a></h4>
<div class="outline-text-4" id="text-org0fbc0d4">
<p>
patch 这个指令与 diff 可是有密不可分的关系。我们前面提到，diff 可以用来分辨两个版本之间的差异， 举例来说，刚刚我们所创建的 passwd.old 及 passwd.new 之间就是两个不同版本的文件。那么，如果要升级，就是 <span class="underline">将旧的文件升级成为新的文件</span> 时，应该要怎么做？其实也不难，就是先比较先旧版本的差异，并将差异档制作成为补丁文件，再由补丁文件更新旧文件即可。举例来说，我们可以这样做测试：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #928374;"># </span><span style="color: #928374;">&#33539;&#20363;&#19968;&#65306;&#26356;&#25913; passwd &#30340;&#19968;&#20123;&#20869;&#23481;&#65292;&#24182;&#23384;&#20026; passwd.new&#65292;&#20197; passwd.old &#19982; passwd.new &#21046;&#20316;&#34917;&#19969;&#25991;&#20214;</span>
diff -Naur passwd.old passwd.new &gt; passwd.patch
</pre>
</div>

<p>
一般来说，使用 diff 制作出来的比较文件通常使用扩展名 .patch，然后将旧文件更新成为新内的内容：<br>
</p>

<pre class="example" id="orgdb6cd4b">
patch -pN &lt; patch_file      &lt;== 更新
patch -R -pN &lt; patch_file   &lt;== 还原

-p: 后面可以接【取消几层目录】的意思；
-R: 代表还原，将新的文件还原成原来旧的版本；
</pre>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #928374;"># </span><span style="color: #928374;">&#33539;&#20363;&#20108;&#65306;&#23558;&#21018;&#21018;&#21046;&#20316;&#20986;&#26469;&#30340; patchf file &#29992;&#26469;&#26356;&#26032;&#26087;&#29256;&#25968;&#25454;</span>
$ patch -p0 &lt; passwd.patch
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #928374;"># </span><span style="color: #928374;">&#33539;&#20363;&#19977;&#65306;&#24674;&#22797;&#26087;&#25991;&#20214;&#30340;&#20869;&#23481;</span>
$ patch -R -p0 &lt; passwd.patch
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgdc7e787" class="outline-3">
<h3 id="orgdc7e787">文件打印设置：pr<a id="orga6d63a5"></a></h3>
<div class="outline-text-3" id="text-orgdc7e787">
<p>
使用 pr 可以选择打印时的标头，也可以设置页码，pr 的简单使用：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">$ pr /etc/man_db.conf
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2023-02-06</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
