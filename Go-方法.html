<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-02-05 Sat 01:25 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>方法</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">方法</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgba264bf">方法是什么</a></li>
<li><a href="#orgde6a55e">函数与方法的区别</a></li>
<li><a href="#orgf0ffd87">指针或值作为接收者</a></li>
<li><a href="#org1d2c3ee">方法和未导出字段</a></li>
<li><a href="#org539c0e2">内嵌类型的方法和继承</a></li>
<li><a href="#orgf359a85">如何在类型中嵌入功能</a></li>
<li><a href="#org2e86693">多重继承</a></li>
<li><a href="#org32a40ae">通用方法和方法命名</a></li>
<li><a href="#org4d60dbd">和其他面向对象语言比较Go的类型和方法</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgba264bf" class="outline-2">
<h2 id="orgba264bf">方法是什么</h2>
<div class="outline-text-2" id="text-orgba264bf">
<p>
在 Go 语言中，结构体就像是类的一种简化形式，那么面向对象程序员可能会问：类的方法在哪里呢？在 Go 中有一个概念，它和方法有着同样的名字，并且大体上意思相同：Go 方法是作用在接收者（receiver）上的一个函数，接收者是某种类型的变量。因此方法是一种特殊类型的函数。<br>
</p>

<p>
接收者类型可以是（几乎）任何类型，不仅仅是结构体类型：任何类型都可以有方法，甚至可以是函数类型，可以是 int、bool、string 或数组的别名类型。但是接收者不能是一个接口类型（参考 第 11 章），因为接口是一个抽象定义，但是方法却是具体实现；如果这样做会引发一个编译错误：invalid receiver type…。<br>
</p>

<p>
最后接收者不能是一个指针类型，但是它可以是任何其他允许类型的指针。<br>
</p>

<p>
一个类型加上它的方法等价于面向对象中的一个类。一个重要的区别是：在 Go 中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在在不同的源文件，唯一的要求是：它们必须是同一个包的。<br>
</p>

<p>
类型 T（或 *T）上的所有方法的集合叫做类型 T（或 *T）的方法集。<br>
</p>

<p>
因为方法是函数，所以同样的，不允许方法重载，即对于一个类型只能有一个给定名称的方法。但是如果基于接收者类型，是有重载的：具有同样名字的方法可以在 2 个或多个不同的接收者类型上存在，比如在同一个包里这么做是允许的：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">a</span> *<span style="color: #df005f; font-weight: bold;">denseMatrix</span>) <span style="color: #d75fd7; font-weight: bold;">Add</span>(<span style="color: #8787d7;">b</span> <span style="color: #df005f; font-weight: bold;">Matrix</span>) <span style="color: #df005f; font-weight: bold;">Matrix</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">a</span> *<span style="color: #df005f; font-weight: bold;">sparseMatrix</span>) <span style="color: #d75fd7; font-weight: bold;">Add</span>(<span style="color: #8787d7;">b</span> <span style="color: #df005f; font-weight: bold;">Matrix</span>) <span style="color: #df005f; font-weight: bold;">Matrix</span>
</pre>
</div>

<p>
别名类型不能有它原始类型上已经定义过的方法。<br>
</p>

<p>
定义方法的一般格式如下：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">recv</span> <span style="color: #df005f; font-weight: bold;">receiver_type</span>) <span style="color: #d75fd7; font-weight: bold;">methodName</span>(<span style="color: #df005f; font-weight: bold;">parameter_list</span>) (<span style="color: #df005f; font-weight: bold;">return_value_list</span>) { ... }
</pre>
</div>

<p>
在方法名之前，func 关键字之后的括号中指定 receiver。<br>
</p>

<p>
如果 recv 是 receiver 的实例，Method1 是它的方法名，那么方法调用遵循传统的 object.name 选择器符号：recv.Method1()。<br>
</p>

<p>
如果 recv 一个指针，Go 会自动解引用。<br>
</p>

<p>
如果方法不需要使用 recv 的值，可以用 _ 替换它，比如：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">_</span> <span style="color: #df005f; font-weight: bold;">receiver_type</span>) <span style="color: #d75fd7; font-weight: bold;">methodName</span>(<span style="color: #df005f; font-weight: bold;">parameter_list</span>) (<span style="color: #df005f; font-weight: bold;">return_value_list</span>) { ... }
</pre>
</div>

<p>
recv 就像是面向对象语言中的 this 或 self，但是 Go 中并没有这两个关键字。随个人喜好，你可以使用 this 或 self 作为 receiver 的名字。下面是一个结构体上的简单方法的例子：<br>
</p>

<p>
示例 10.10 method .go：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> main

<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">TwoInts</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    a <span style="color: #df005f; font-weight: bold;">int</span>
    b <span style="color: #df005f; font-weight: bold;">int</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">two1</span> := <span style="color: #268bd2;">new</span>(<span style="color: #df005f; font-weight: bold;">TwoInts</span>)
    two1.a = <span style="color: #d75fd7;">12</span>
    two1.b = <span style="color: #d75fd7;">10</span>

    fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"The sum is: %d\n"</span>, two1.<span style="color: #d75fd7; font-weight: bold;">AddThem</span>())
    fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"Add them to the param: %d\n"</span>, two1.<span style="color: #d75fd7; font-weight: bold;">AddToParam</span>(<span style="color: #d75fd7;">20</span>))

    <span style="color: #8787d7;">two2</span> := <span style="color: #df005f; font-weight: bold;">TwoInts</span>{<span style="color: #d75fd7;">3</span>, <span style="color: #d75fd7;">4</span>}
    fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"The sum is: %d\n"</span>, two2.<span style="color: #d75fd7; font-weight: bold;">AddThem</span>())
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">tn</span> *<span style="color: #df005f; font-weight: bold;">TwoInts</span>) <span style="color: #d75fd7; font-weight: bold;">AddThem</span>() <span style="color: #df005f; font-weight: bold;">int</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> tn.a + tn.b
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">tn</span> *<span style="color: #df005f; font-weight: bold;">TwoInts</span>) <span style="color: #d75fd7; font-weight: bold;">AddToParam</span>(<span style="color: #8787d7;">param</span> <span style="color: #df005f; font-weight: bold;">int</span>) <span style="color: #df005f; font-weight: bold;">int</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> tn.a + tn.b + param
}
</pre>
</div>

<p>
输出：<br>
</p>

<pre class="example" id="org25c18dd">
The sum is: 22
Add them to the param: 42
The sum is: 7
</pre>

<p>
下面是非结构体类型上方法的例子：<br>
</p>

<p>
示例 10.11 method2.go：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> main

<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">IntVector</span> []<span style="color: #df005f; font-weight: bold;">int</span>

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">v</span> <span style="color: #df005f; font-weight: bold;">IntVector</span>) <span style="color: #d75fd7; font-weight: bold;">Sum</span>() (<span style="color: #8787d7;">s</span> <span style="color: #df005f; font-weight: bold;">int</span>) {
    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">_</span>, <span style="color: #8787d7;">x</span> := <span style="color: #268bd2; font-weight: bold;">range</span> v {
        s += x
    }
    <span style="color: #268bd2; font-weight: bold;">return</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #df005f; font-weight: bold;">IntVector</span>{<span style="color: #d75fd7;">1</span>, <span style="color: #d75fd7;">2</span>, <span style="color: #d75fd7;">3</span>}.<span style="color: #d75fd7; font-weight: bold;">Sum</span>()) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36755;&#20986;&#26159;6</span>
}
</pre>
</div>

<p>
下面这段代码有什么错？<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> main

<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #2aa198;">"container/list"</span>

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">p</span> *<span style="color: #df005f; font-weight: bold;">list.List</span>) <span style="color: #d75fd7; font-weight: bold;">Iter</span>() {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">...</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">lst</span> := <span style="color: #268bd2;">new</span>(<span style="color: #df005f; font-weight: bold;">list.List</span>)
    <span style="color: #268bd2; font-weight: bold;">for</span> _= <span style="color: #268bd2; font-weight: bold;">range</span> lst.<span style="color: #d75fd7; font-weight: bold;">Iter</span>() {
    }
}
&#31867;&#22411;&#21644;&#20316;&#29992;&#22312;&#23427;&#19978;&#38754;&#23450;&#20041;&#30340;&#26041;&#27861;&#24517;&#39035;&#22312;&#21516;&#19968;&#20010;&#21253;&#37324;&#23450;&#20041;&#65292;&#36825;&#23601;&#26159;&#20026;&#20160;&#20040;&#19981;&#33021;&#22312; <span style="color: #df005f; font-weight: bold;">int&#12289;float</span> &#25110;&#31867;&#20284;&#36825;&#20123;&#30340;&#31867;&#22411;&#19978;&#23450;&#20041;&#26041;&#27861;&#12290;&#35797;&#22270;&#22312; <span style="color: #df005f; font-weight: bold;">int</span> &#31867;&#22411;&#19978;&#23450;&#20041;&#26041;&#27861;&#20250;&#24471;&#21040;&#19968;&#20010;&#32534;&#35793;&#38169;&#35823;&#65306;

cannot <span style="color: #df005f; font-weight: bold;">define</span> new <span style="color: #df005f; font-weight: bold;">methods</span> on <span style="color: #df005f; font-weight: bold;">non</span>-local <span style="color: #268bd2; font-weight: bold;">type</span> int
&#27604;&#22914;&#24819;&#22312; <span style="color: #df005f; font-weight: bold;">time.Time</span> &#19978;&#23450;&#20041;&#22914;&#19979;&#26041;&#27861;&#65306;

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">t</span> <span style="color: #df005f; font-weight: bold;">time.Time</span>) <span style="color: #d75fd7; font-weight: bold;">first3Chars</span>() <span style="color: #df005f; font-weight: bold;">string</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> time.<span style="color: #d75fd7; font-weight: bold;">LocalTime</span>().<span style="color: #d75fd7; font-weight: bold;">String</span>()[<span style="color: #d75fd7;">0</span>:<span style="color: #d75fd7;">3</span>]
}
</pre>
</div>

<p>
类型在其他的，或是非本地的包里定义，在它上面定义方法都会得到和上面同样的错误。<br>
</p>

<p>
但是有一个间接的方式：可以先定义该类型（比如：int 或 float）的别名类型，然后再为别名类型定义方法。或者像下面这样将它作为匿名类型嵌入在一个新的结构体中。当然方法只在这个别名类型上有效。<br>
</p>

<p>
示例 10.12 method_on_time.go：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> main

<span style="color: #268bd2; font-weight: bold;">import</span> (
    <span style="color: #2aa198;">"fmt"</span>
    <span style="color: #2aa198;">"time"</span>
)

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">myTime</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    time.Time <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">anonymous field</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">t</span> <span style="color: #df005f; font-weight: bold;">myTime</span>) <span style="color: #d75fd7; font-weight: bold;">first3Chars</span>() <span style="color: #df005f; font-weight: bold;">string</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> t.Time.<span style="color: #d75fd7; font-weight: bold;">String</span>()[<span style="color: #d75fd7;">0</span>:<span style="color: #d75fd7;">3</span>]
}
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">m</span> := <span style="color: #df005f; font-weight: bold;">myTime</span>{time.<span style="color: #d75fd7; font-weight: bold;">Now</span>()}
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35843;&#29992;&#21311;&#21517;Time&#19978;&#30340;String&#26041;&#27861;</span>
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"Full time now:"</span>, m.<span style="color: #d75fd7; font-weight: bold;">String</span>())
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35843;&#29992;myTime.first3Chars</span>
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"First 3 chars:"</span>, m.<span style="color: #d75fd7; font-weight: bold;">first3Chars</span>())
}

<span style="color: #008787; background-color: #262626;">/* </span><span style="color: #008787; background-color: #262626;">Output:</span>
<span style="color: #008787; background-color: #262626;">     Full time now: Mon Oct 24 15:34:54 Romance Daylight Time 2011</span>
<span style="color: #008787; background-color: #262626;">     First 3 chars: Mon</span>
<span style="color: #008787; background-color: #262626;">*/</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgde6a55e" class="outline-2">
<h2 id="orgde6a55e">函数与方法的区别</h2>
<div class="outline-text-2" id="text-orgde6a55e">
<p>
函数将变量作为参数： <b>Function1(recv)</b><br>
</p>

<p>
方法在变量上被调用： <b>recv.Method1()</b><br>
</p>

<p>
在接收者是指针时，方法可以改变接收者的值（或状态），这点函数也可以做到（当参数作为指针传递，即通过引用调用时，函数也可以改变参数的状态）。<br>
</p>

<p>
不要忘记 Method1 后边的括号 ()，否则会引发编译器错误：method recv.Method1 is not an expression, must be called<br>
</p>

<p>
接收者必须有一个显式的名字，这个名字必须在方法中被使用。<br>
</p>

<p>
<b>receiver_type</b> 叫做 <b>（接收者）基本类型</b> ，这个类型必须在和方法同样的包中被声明。<br>
</p>

<p>
在 Go 中，（接收者）类型关联的方法不写在类型结构里面，就像类那样；耦合更加宽松；类型和方法之间的关联由接收者来建立。<br>
</p>

<p>
<b>方法没有和数据定义（结构体）混在一起：它们是正交的类型；表示（数据）和行为（方法）是独立的。</b><br>
</p>
</div>
</div>
<div id="outline-container-orgf0ffd87" class="outline-2">
<h2 id="orgf0ffd87">指针或值作为接收者</h2>
<div class="outline-text-2" id="text-orgf0ffd87">
<p>
鉴于性能的原因，recv 最常见的是一个指向 receiver_type 的指针（因为我们不想要一个实例的拷贝，如果按值调用的话就会是这样），特别是在 receiver 类型是结构体时，就更是如此了。<br>
</p>

<p>
如果想要方法改变接收者的数据，就在接收者的指针类型上定义该方法。否则，就在普通的值类型上定义方法。<br>
</p>

<p>
下面的例子 pointer_value.go 作了说明：change() 接受一个指向 B 的指针，并改变它内部的成员；write() 接受通过拷贝接受 B 的值并只输出 B 的内容。注意 Go 为我们做了探测工作，我们自己并没有指出是否在指针上调用方法，Go 替我们做了这些事情。b1 是值而 b2 是指针，方法都支持运行了。<br>
</p>

<p>
示例 10.13 pointer_value.go：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> main

<span style="color: #268bd2; font-weight: bold;">import</span> (
    <span style="color: #2aa198;">"fmt"</span>
)

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">B</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    thing <span style="color: #df005f; font-weight: bold;">int</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">B</span>) <span style="color: #d75fd7; font-weight: bold;">change</span>() { b.thing = <span style="color: #d75fd7;">1</span> }

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> <span style="color: #df005f; font-weight: bold;">B</span>) <span style="color: #d75fd7; font-weight: bold;">write</span>() <span style="color: #df005f; font-weight: bold;">string</span> { <span style="color: #268bd2; font-weight: bold;">return</span> fmt.<span style="color: #d75fd7; font-weight: bold;">Sprint</span>(b) }

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">b1</span> <span style="color: #df005f; font-weight: bold;">B</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">b1&#26159;&#20540;</span>
    b1.<span style="color: #d75fd7; font-weight: bold;">change</span>()
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(b1.<span style="color: #d75fd7; font-weight: bold;">write</span>())

    <span style="color: #8787d7;">b2</span> := <span style="color: #268bd2;">new</span>(<span style="color: #df005f; font-weight: bold;">B</span>) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">b2&#26159;&#25351;&#38024;</span>
    b2.<span style="color: #d75fd7; font-weight: bold;">change</span>()
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(b2.<span style="color: #d75fd7; font-weight: bold;">write</span>())
}

<span style="color: #008787; background-color: #262626;">/* </span><span style="color: #008787; background-color: #262626;">&#36755;&#20986;&#65306;</span>
<span style="color: #008787; background-color: #262626;">     {1}</span>
<span style="color: #008787; background-color: #262626;">     {1}</span>
<span style="color: #008787; background-color: #262626;">*/</span>
</pre>
</div>

<p>
试着在 write() 中改变接收者 b 的值：将会看到它可以正常编译，但是开始的 b 没有被改变。<br>
</p>

<p>
我们知道方法将指针作为接收者不是必须的，如下面的例子，我们只是需要 Point3 的值来做计算：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Point3</span> <span style="color: #268bd2; font-weight: bold;">struct</span> { x, y, z <span style="color: #df005f; font-weight: bold;">float64</span> }
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">A method on Point3</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">p</span> <span style="color: #df005f; font-weight: bold;">Point3</span>) <span style="color: #d75fd7; font-weight: bold;">Abs</span>() <span style="color: #df005f; font-weight: bold;">float64</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> math.<span style="color: #d75fd7; font-weight: bold;">Sqrt</span>(p.x*p.x + p.y*p.y + p.z*p.z)
}
</pre>
</div>

<p>
这样做稍微有点昂贵，因为 Point3 是作为值传递给方法的，因此传递的是它的拷贝，这在 Go 中合法的。也可以在指向这个类型的指针上调用此方法（会自动解引用）。<br>
</p>

<p>
假设 p3 定义为一个指针：p3 := &amp;Point{ 3, 4, 5}。<br>
</p>

<p>
可以使用 p3.Abs() 来替代 (*p3).Abs()。<br>
</p>

<p>
像例子 10.11（method1.go）中接收者类型是 *TwoInts 的方法 AddThem()，它能在类型 TwoInts 的值上被调用，这是自动间接发生的。<br>
</p>

<p>
因此 two2.AddThem 可以替代 (&amp;two2).AddThem()。<br>
</p>

<p>
在值和指针上调用方法：<br>
</p>

<p>
可以有连接到类型的方法，也可以有连接到类型指针的方法。<br>
</p>

<p>
但是这没关系：对于类型 T，如果在 *T 上存在方法 Meth()，并且 t 是这个类型的变量，那么 t.Meth() 会被自动转换为 (&amp;t).Meth()。<br>
</p>

<p>
<b>指针方法和值方法都可以在指针或非指针上被调用</b> ，如下面程序所示，类型 List 在值上有一个方法 Len()，在指针上有一个方法 Append()，但是可以看到两个方法都可以在两种类型的变量上被调用。<br>
</p>

<p>
示例 10.14 methodset1.go：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> main

<span style="color: #268bd2; font-weight: bold;">import</span> (
    <span style="color: #2aa198;">"fmt"</span>
)

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">List</span> []<span style="color: #df005f; font-weight: bold;">int</span>

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">l</span> <span style="color: #df005f; font-weight: bold;">List</span>) <span style="color: #d75fd7; font-weight: bold;">Len</span>() <span style="color: #df005f; font-weight: bold;">int</span>        { <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #268bd2;">len</span>(l) }
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">l</span> *<span style="color: #df005f; font-weight: bold;">List</span>) <span style="color: #d75fd7; font-weight: bold;">Append</span>(<span style="color: #8787d7;">val</span> <span style="color: #df005f; font-weight: bold;">int</span>) { *l = <span style="color: #268bd2;">append</span>(*l, val) }

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20540;</span>
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">lst</span> <span style="color: #df005f; font-weight: bold;">List</span>
    lst.<span style="color: #d75fd7; font-weight: bold;">Append</span>(<span style="color: #d75fd7;">1</span>)
    fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%v (len: %d)"</span>, lst, lst.<span style="color: #d75fd7; font-weight: bold;">Len</span>()) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">[1] (len: 1)</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#25351;&#38024;</span>
    <span style="color: #8787d7;">plst</span> := <span style="color: #268bd2;">new</span>(<span style="color: #df005f; font-weight: bold;">List</span>)
    plst.<span style="color: #d75fd7; font-weight: bold;">Append</span>(<span style="color: #d75fd7;">2</span>)
    fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%v (len: %d)"</span>, plst, plst.<span style="color: #d75fd7; font-weight: bold;">Len</span>()) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&amp;[2] (len: 1)</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org1d2c3ee" class="outline-2">
<h2 id="org1d2c3ee">方法和未导出字段</h2>
<div class="outline-text-2" id="text-org1d2c3ee">
<p>
考虑 person2.go 中的 person 包：类型 Person 被明确的导出了，但是它的字段没有被导出。例如在 use_person2.go 中 p.firstName 就是错误的。该如何在另一个程序中修改或者只是读取一个 Person 的名字呢？<br>
</p>

<p>
这可以通过面向对象语言一个众所周知的技术来完成：提供 getter 和 setter 方法。对于 setter 方法使用 Set 前缀，对于 getter 方法只使用成员名。<br>
</p>

<p>
示例 10.15 person2.go：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> person

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Person</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    firstName <span style="color: #df005f; font-weight: bold;">string</span>
    lastName  <span style="color: #df005f; font-weight: bold;">string</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">p</span> *<span style="color: #df005f; font-weight: bold;">Person</span>) <span style="color: #d75fd7; font-weight: bold;">FirstName</span>() <span style="color: #df005f; font-weight: bold;">string</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> p.firstName
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">p</span> *<span style="color: #df005f; font-weight: bold;">Person</span>) <span style="color: #d75fd7; font-weight: bold;">SetFirstName</span>(<span style="color: #8787d7;">newName</span> <span style="color: #df005f; font-weight: bold;">string</span>) {
    p.firstName = newName
}
</pre>
</div>

<p>
示例 10.16—use_person2.go：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> main

<span style="color: #268bd2; font-weight: bold;">import</span> (
    <span style="color: #2aa198;">"./person"</span>
    <span style="color: #2aa198;">"fmt"</span>
)

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">p</span> := <span style="color: #268bd2;">new</span>(<span style="color: #df005f; font-weight: bold;">person.Person</span>)
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">p.firstName undefined</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">(cannot refer to unexported field or method firstName)</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">p.firstName = "Eric"</span>
    p.<span style="color: #d75fd7; font-weight: bold;">SetFirstName</span>(<span style="color: #2aa198;">"Eric"</span>)
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(p.<span style="color: #d75fd7; font-weight: bold;">FirstName</span>()) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Output: Eric</span>
}
</pre>
</div>

<p>
<b>并发访问对象</b><br>
</p>

<p>
对象的字段（属性）不应该由 2 个或 2 个以上的不同线程在同一时间去改变。如果在程序发生这种情况，为了安全并发访问，可以使用包 <a href="Go-锁和sync包.html">锁和sync包</a> 中的方法。在第 14.17 节中我们会通过 goroutines 和 channels 探索另一种方式。<br>
</p>
</div>
</div>
<div id="outline-container-org539c0e2" class="outline-2">
<h2 id="org539c0e2">内嵌类型的方法和继承</h2>
<div class="outline-text-2" id="text-org539c0e2">
<p>
当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌，这在效果上等同于外层类型 <b>继承</b> 了这些方法： <b>将父类型放在子类型中来实现亚型</b> 。这个机制提供了一种简单的方式来模拟经典面向对象语言中的子类和继承相关的效果，也类似 Ruby 中的混入（mixin）。<br>
</p>

<p>
下面是一个示例（可以在练习 10.8 中进一步学习）：假定有一个 Engine 接口类型，一个 Car 结构体类型，它包含一个 Engine 类型的匿名字段：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Engine</span> <span style="color: #268bd2; font-weight: bold;">interface</span> {
    <span style="color: #d75fd7; font-weight: bold;">Start</span>()
    <span style="color: #d75fd7; font-weight: bold;">Stop</span>()
}

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Car</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    Engine
}
</pre>
</div>

<p>
我们可以构建如下的代码：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">Car</span>) <span style="color: #d75fd7; font-weight: bold;">GoToWorkIn</span>() {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">get in car</span>
    c.<span style="color: #d75fd7; font-weight: bold;">Start</span>()
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">drive to work</span>
    c.<span style="color: #d75fd7; font-weight: bold;">Stop</span>()
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">get out of car</span>
}
</pre>
</div>

<p>
下面是 method3.go 的完整例子，它展示了内嵌结构体上的方法可以直接在外层类型的实例上调用：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> main

<span style="color: #268bd2; font-weight: bold;">import</span> (
    <span style="color: #2aa198;">"fmt"</span>
    <span style="color: #2aa198;">"math"</span>
)

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Point</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    x, y <span style="color: #df005f; font-weight: bold;">float64</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">p</span> *<span style="color: #df005f; font-weight: bold;">Point</span>) <span style="color: #d75fd7; font-weight: bold;">Abs</span>() <span style="color: #df005f; font-weight: bold;">float64</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> math.<span style="color: #d75fd7; font-weight: bold;">Sqrt</span>(p.x*p.x + p.y*p.y)
}

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">NamedPoint</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    Point
    name <span style="color: #df005f; font-weight: bold;">string</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">n</span> := &amp;<span style="color: #df005f; font-weight: bold;">NamedPoint</span>{<span style="color: #df005f; font-weight: bold;">Point</span>{<span style="color: #d75fd7;">3</span>, <span style="color: #d75fd7;">4</span>}, <span style="color: #2aa198;">"Pythagoras"</span>}
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(n.<span style="color: #d75fd7; font-weight: bold;">Abs</span>()) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#25171;&#21360;5</span>
}
</pre>
</div>
<p>
内嵌将一个已存在类型的字段和方法注入到了另一个类型里：匿名字段上的方法 “晋升” 成为了外层类型的方法。当然类型可以有只作用于本身实例而不作用于内嵌 “父” 类型上的方法，<br>
</p>

<p>
可以覆写方法（像字段一样）：和内嵌类型方法具有同样名字的外层类型的方法会覆写内嵌类型对应的方法。<br>
</p>

<p>
在示例 10.18 method4.go 中添加：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">n</span> *<span style="color: #df005f; font-weight: bold;">NamedPoint</span>) <span style="color: #d75fd7; font-weight: bold;">Abs</span>() <span style="color: #df005f; font-weight: bold;">float64</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> n.Point.<span style="color: #d75fd7; font-weight: bold;">Abs</span>() * <span style="color: #d75fd7;">100</span>.
}
</pre>
</div>

<p>
现在 fmt.Println(n.Abs()) 会打印 500。<br>
</p>

<p>
因为一个结构体可以嵌入多个匿名类型，所以实际上我们可以有一个简单版本的多重继承，就像：type Child struct { Father; Mother}。在第 10.6.7 节中会进一步讨论这个问题。<br>
</p>

<p>
结构体内嵌和自己在同一个包中的结构体时，可以彼此访问对方所有的字段和方法。<br>
</p>
</div>
</div>
<div id="outline-container-orgf359a85" class="outline-2">
<h2 id="orgf359a85">如何在类型中嵌入功能</h2>
<div class="outline-text-2" id="text-orgf359a85">
<p>
主要有两种方法来实现在类型中嵌入功能：<br>
</p>

<p>
A：聚合（或组合）：包含一个所需功能类型的具名字段。<br>
</p>

<p>
B：内嵌：内嵌（匿名地）所需功能类型，像前一节 10.6.5 所演示的那样。<br>
</p>

<p>
为了使这些概念具体化，假设有一个 Customer 类型，我们想让它通过 Log 类型来包含日志功能，Log 类型只是简单地包含一个累积的消息（当然它可以是复杂的）。如果想让特定类型都具备日志功能，你可以实现一个这样的 Log 类型，然后将它作为特定类型的一个字段，并提供 Log()，它返回这个日志的引用。<br>
</p>

<p>
方式 A 可以通过如下方法实现（使用了第 10.7 节中的 String() 功能）：<br>
</p>

<p>
示例 10.19 embed_func1.go：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> main

<span style="color: #268bd2; font-weight: bold;">import</span> (
    <span style="color: #2aa198;">"fmt"</span>
)

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Log</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    msg <span style="color: #df005f; font-weight: bold;">string</span>
}

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Customer</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    Name <span style="color: #df005f; font-weight: bold;">string</span>
    log  *<span style="color: #df005f; font-weight: bold;">Log</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">c</span> := <span style="color: #268bd2;">new</span>(<span style="color: #df005f; font-weight: bold;">Customer</span>)
    c.Name = <span style="color: #2aa198;">"Barak Obama"</span>
    c.log = <span style="color: #268bd2;">new</span>(<span style="color: #df005f; font-weight: bold;">Log</span>)
    c.log.msg = <span style="color: #2aa198;">"1 - Yes we can!"</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">shorter</span>
    c = &amp;<span style="color: #df005f; font-weight: bold;">Customer</span>{<span style="color: #2aa198;">"Barak Obama"</span>, &amp;<span style="color: #df005f; font-weight: bold;">Log</span>{<span style="color: #2aa198;">"1 - Yes we can!"</span>}}
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">fmt.Println(c) &amp;{Barak Obama 1 - Yes we can!}</span>
    c.<span style="color: #d75fd7; font-weight: bold;">Log</span>().<span style="color: #d75fd7; font-weight: bold;">Add</span>(<span style="color: #2aa198;">"2 - After me the world will be a better place!"</span>)
    <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">fmt.Println(c.log)</span>
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(c.<span style="color: #d75fd7; font-weight: bold;">Log</span>())

}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">l</span> *<span style="color: #df005f; font-weight: bold;">Log</span>) <span style="color: #d75fd7; font-weight: bold;">Add</span>(<span style="color: #8787d7;">s</span> <span style="color: #df005f; font-weight: bold;">string</span>) {
    l.msg += <span style="color: #2aa198;">"\n"</span> + s
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">l</span> *<span style="color: #df005f; font-weight: bold;">Log</span>) <span style="color: #d75fd7; font-weight: bold;">String</span>() <span style="color: #df005f; font-weight: bold;">string</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> l.msg
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">Customer</span>) <span style="color: #d75fd7; font-weight: bold;">Log</span>() *<span style="color: #df005f; font-weight: bold;">Log</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> c.log
}
</pre>
</div>

<p>
输出：<br>
</p>

<pre class="example" id="orgb49dc62">
1 - Yes we can!
2 - After me the world will be a better place!
</pre>

<p>
相对的方式 B 可能会像这样：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> main

<span style="color: #268bd2; font-weight: bold;">import</span> (
    <span style="color: #2aa198;">"fmt"</span>
)

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Log</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    msg <span style="color: #df005f; font-weight: bold;">string</span>
}

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Customer</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    Name <span style="color: #df005f; font-weight: bold;">string</span>
    Log
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">c</span> := &amp;<span style="color: #df005f; font-weight: bold;">Customer</span>{<span style="color: #2aa198;">"Barak Obama"</span>, <span style="color: #df005f; font-weight: bold;">Log</span>{<span style="color: #2aa198;">"1 - Yes we can!"</span>}}
    c.<span style="color: #d75fd7; font-weight: bold;">Add</span>(<span style="color: #2aa198;">"2 - After me the world will be a better place!"</span>)
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(c)

}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">l</span> *<span style="color: #df005f; font-weight: bold;">Log</span>) <span style="color: #d75fd7; font-weight: bold;">Add</span>(<span style="color: #8787d7;">s</span> <span style="color: #df005f; font-weight: bold;">string</span>) {
    l.msg += <span style="color: #2aa198;">"\n"</span> + s
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">l</span> *<span style="color: #df005f; font-weight: bold;">Log</span>) <span style="color: #d75fd7; font-weight: bold;">String</span>() <span style="color: #df005f; font-weight: bold;">string</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> l.msg
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">Customer</span>) <span style="color: #d75fd7; font-weight: bold;">String</span>() <span style="color: #df005f; font-weight: bold;">string</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> c.Name + <span style="color: #2aa198;">"\nLog:"</span> + fmt.<span style="color: #d75fd7; font-weight: bold;">Sprintln</span>(c.Log)
}
</pre>
</div>

<p>
输出：<br>
</p>

<pre class="example" id="orgaee9f7b">
Barak Obama
Log:{1 - Yes we can!
2 - After me the world will be a better place!}
</pre>

<p>
内嵌的类型不需要指针，Customer 也不需要 Add 方法，它使用 Log 的 Add 方法，Customer 有自己的 String 方法，并且在它里面调用了 Log 的 String 方法。<br>
</p>

<p>
如果内嵌类型嵌入了其他类型，也是可以的，那些类型的方法可以直接在外层类型中使用。<br>
</p>

<p>
因此一个好的策略是创建一些小的、可复用的类型作为一个工具箱，用于组成域类型。<br>
</p>
</div>
</div>
<div id="outline-container-org2e86693" class="outline-2">
<h2 id="org2e86693">多重继承</h2>
<div class="outline-text-2" id="text-org2e86693">
<p>
多重继承指的是类型获得多个父类型行为的能力，它在传统的面向对象语言中通常是不被实现的（C++ 和 Python 例外）。因为在类继承层次中，多重继承会给编译器引入额外的复杂度。但是在 Go 语言中，通过在类型中嵌入所有必要的父类型，可以很简单的实现多重继承。<br>
</p>

<p>
作为一个例子，假设有一个类型 CameraPhone，通过它可以 Call()，也可以 TakeAPicture()，但是第一个方法属于类型 Phone，第二个方法属于类型 Camera。<br>
</p>

<p>
只要嵌入这两个类型就可以解决问题，如下所示：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> main

<span style="color: #268bd2; font-weight: bold;">import</span> (
    <span style="color: #2aa198;">"fmt"</span>
)

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Camera</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">Camera</span>) <span style="color: #d75fd7; font-weight: bold;">TakeAPicture</span>() <span style="color: #df005f; font-weight: bold;">string</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #2aa198;">"Click"</span>
}

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Phone</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">p</span> *<span style="color: #df005f; font-weight: bold;">Phone</span>) <span style="color: #d75fd7; font-weight: bold;">Call</span>() <span style="color: #df005f; font-weight: bold;">string</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #2aa198;">"Ring Ring"</span>
}

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">CameraPhone</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    Camera
    Phone
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">cp</span> := <span style="color: #268bd2;">new</span>(<span style="color: #df005f; font-weight: bold;">CameraPhone</span>)
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"Our new CameraPhone exhibits multiple behaviors..."</span>)
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"It exhibits behavior of a Camera: "</span>, cp.<span style="color: #d75fd7; font-weight: bold;">TakeAPicture</span>())
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"It works like a Phone too: "</span>, cp.<span style="color: #d75fd7; font-weight: bold;">Call</span>())
}
</pre>
</div>

<p>
输出：<br>
</p>

<pre class="example" id="orgc2571b0">
Our new CameraPhone exhibits multiple behaviors...
It exhibits behavior of a Camera: Click
It works like a Phone too: Ring Ring
</pre>
</div>
</div>
<div id="outline-container-org32a40ae" class="outline-2">
<h2 id="org32a40ae">通用方法和方法命名</h2>
<div class="outline-text-2" id="text-org32a40ae">
<p>
在编程中一些基本操作会一遍又一遍的出现，比如打开（Open）、关闭（Close）、读（Read）、写（Write）、排序（Sort）等等，并且它们都有一个大致的意思：打开（Open）可以作用于一个文件、一个网络连接、一个数据库连接等等。具体的实现可能千差万别，但是基本的概念是一致的。在 Go 语言中，通过使用接口，标准库广泛的应用了这些规则，在标准库中这些通用方法都有一致的名字，比如 Open()、Read()、Write() 等。想写规范的 Go 程序，就应该遵守这些约定，给方法合适的名字和签名，就像那些通用方法那样。这样做会使 Go 开发的软件更加具有一致性和可读性。比如：如果需要一个 convert-to-string 方法，应该命名为 String()，而不是 ToString()<br>
</p>
</div>
</div>
<div id="outline-container-org4d60dbd" class="outline-2">
<h2 id="org4d60dbd">和其他面向对象语言比较Go的类型和方法</h2>
<div class="outline-text-2" id="text-org4d60dbd">
<p>
在如 C++、Java、C# 和 Ruby 这样的面向对象语言中，方法在类的上下文中被定义和继承：在一个对象上调用方法时，运行时会检测类以及它的超类中是否有此方法的定义，如果没有会导致异常发生。<br>
</p>

<p>
在 Go 语言中，这样的继承层次是完全没必要的：如果方法在此类型定义了，就可以调用它，和其他类型上是否存在这个方法没有关系。在这个意义上，Go 具有更大的灵活性。<br>
</p>

<p>
下面的模式就很好的说明了这个问题：<br>
</p>



<p>
Go 不需要一个显式的类定义，如同 Java、C++、C# 等那样，相反地，“类” 是通过提供一组作用于一个共同类型的方法集来隐式定义的。类型可以是结构体或者任何用户自定义类型。<br>
</p>

<p>
比如：我们想定义自己的 Integer 类型，并添加一些类似转换成字符串的方法，在 Go 中可以如下定义：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Integer</span> <span style="color: #df005f; font-weight: bold;">int</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">i</span> *<span style="color: #df005f; font-weight: bold;">Integer</span>) <span style="color: #d75fd7; font-weight: bold;">String</span>() <span style="color: #df005f; font-weight: bold;">string</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> strconv.<span style="color: #d75fd7; font-weight: bold;">Itoa</span>(<span style="color: #d75fd7; font-weight: bold;">int</span>(*i))
}
</pre>
</div>

<p>
在 Java 或 C# 中，这个方法需要和类 Integer 的定义放在一起，在 Ruby 中可以直接在基本类型 int 上定义这个方法。<br>
</p>

<p>
<b>总结</b><br>
</p>

<p>
在 Go 中，类型就是类（数据和关联的方法）。Go 拥有类似面向对象语言的类继承的概念。继承有两个好处：代码复用和多态。<br>
</p>

<p>
在 Go 中，代码复用通过组合和委托实现，多态通过接口的使用来实现：有时这也叫 组件编程（Component Programming）。<br>
</p>

<p>
许多开发者说相比于类继承，Go 的接口提供了更强大、却更简单的多态行为。<br>
</p>

<p>
<b>备注</b><br>
</p>

<p>
如果真的需要更多面向对象的能力，看一下 goop 包（Go Object-Oriented Programming），它由 Scott Pakin 编写：它给 Go 提供了 JavaScript 风格的对象（基于原型的对象），并且支持多重继承和类型独立分派，通过它可以实现你喜欢的其他编程语言里的一些结构。<br>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-02-03 21:02 Thu</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-02-05 Sat 01:25</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
