<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-10-04 一 18:46 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>PYTHON-YIELD</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">PYTHON-YIELD</h1>
<p>
yield就是 return 返回一个值，并且记住这个返回的位置，下次迭代就从这个位置后开始。<br>
</p>

<p>
&gt; Fibonacci数列<br>
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BD93F9;">def</span> <span style="color: #AFAFAF;">Fibo</span>(n):
        <span style="color: #AFAFAF;">f0</span>, <span style="color: #AFAFAF;">f1</span> = <span style="color: #009F9F;">0</span>, <span style="color: #009F9F;">1</span>
        <span style="color: #BD93F9;">for</span> _ <span style="color: #BD93F9;">in</span> <span style="color: #AFAFAF;">range</span>(n):
                <span style="color: #BD93F9;">yield</span> f0
                <span style="color: #AFAFAF;">f0</span>, <span style="color: #AFAFAF;">f1</span> = f1, f0+f1

<span style="color: #AFAFAF;">n</span> = <span style="color: #AFAFAF;">eval</span>(<span style="color: #AFAFAF;">input</span>(<span style="color: #FC9F4E;">"input the number of terms: "</span>))
<span style="color: #AFAFAF;">listFibo</span> = <span style="color: #AFAFAF;">list</span>(Fibo(n))
<span style="color: #BD93F9;">print</span>(listFibo)
</pre>
</div>

<p>
&gt; 这里修改了下文的代码，并不会输出res: 1，那是因为print函数所在的作用域内有res变量，这个变量覆盖了上面的res变量，如果没有res = yield 4这条语句，那么就会输出res: 1<br>
&gt; 上文的Fibonacci数列中的f0, f1的值能修改，也是因为他的作用域不在循环体内<br>
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BD93F9;">def</span> <span style="color: #AFAFAF;">foo</span>():
        <span style="color: #BD93F9;">print</span>(<span style="color: #FC9F4E;">"starting..."</span>)
        <span style="color: #AFAFAF;">res</span> = <span style="color: #009F9F;">1</span>
        <span style="color: #BD93F9;">while</span> <span style="color: #009F9F;">True</span>:
                <span style="color: #AFAFAF;">res</span> = <span style="color: #BD93F9;">yield</span> <span style="color: #009F9F;">4</span>
                <span style="color: #BD93F9;">print</span>(<span style="color: #FC9F4E;">"res:"</span>, res)

<span style="color: #AFAFAF;">g</span> = foo()
<span style="color: #BD93F9;">print</span>(<span style="color: #AFAFAF;">next</span>(g))
<span style="color: #BD93F9;">print</span>(<span style="color: #FC9F4E;">"*"</span>*<span style="color: #009F9F;">20</span>)
<span style="color: #BD93F9;">print</span>(<span style="color: #AFAFAF;">next</span>(g))
</pre>
</div>

<p>
就这么简单的几行代码就让你明白什么是yield，代码的输出这个：<br>
starting&#x2026;<br>
4<br>
<b><b><b><b><b><b><b><b><b>**</b></b></b></b></b></b></b></b></b><br>
res: None<br>
4<br>
</p>





<p>
<b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b>**</b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b><br>
</p>

<p>
首先，如果你还没有对yield有个初步分认识，那么你先把yield看做“return”，这个是直观的，它首先是个return，普通的return是什么意思，就是在程序中返回某个值，返回之后程序就不再往下运行了。看做return之后再把它看做一个是生成器（generator）的一部分（带yield的函数才是真正的迭代器），好了，如果你对这些不明白的话，那先把yield看做return,然后直接看下面的程序，你就会明白yield的全部意思了：<br>
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BD93F9;">def</span> <span style="color: #AFAFAF;">foo</span>():
        <span style="color: #BD93F9;">print</span>(<span style="color: #FC9F4E;">"starting..."</span>)
        <span style="color: #BD93F9;">while</span> <span style="color: #009F9F;">True</span>:
                <span style="color: #AFAFAF;">res</span> = <span style="color: #BD93F9;">yield</span> <span style="color: #009F9F;">4</span>
                <span style="color: #BD93F9;">print</span>(<span style="color: #FC9F4E;">"res:"</span>,res)
                <span style="color: #AFAFAF;">g</span> = foo()
                <span style="color: #BD93F9;">print</span>(<span style="color: #AFAFAF;">next</span>(g))
                <span style="color: #BD93F9;">print</span>(<span style="color: #FC9F4E;">"*"</span>*<span style="color: #009F9F;">20</span>)
                <span style="color: #BD93F9;">print</span>(<span style="color: #AFAFAF;">next</span>(g))
</pre>
</div>

<p>
就这么简单的几行代码就让你明白什么是yield，代码的输出这个：<br>
starting&#x2026;<br>
4<br>
<b><b><b><b><b><b><b><b><b>**</b></b></b></b></b></b></b></b></b><br>
res: None<br>
4<br>
</p>


<p>
我直接解释代码运行顺序，相当于代码单步调试：<br>
</p>
<ol class="org-ol">
<li>程序开始执行以后，因为foo函数中有yield关键字，所以foo函数并不会真的执行，而是先得到一个生成器g(相当于一个对象)<br></li>
<li>直到调用next方法，foo函数正式开始执行，先执行foo函数中的print方法，然后进入while循环<br></li>
<li>程序遇到yield关键字，然后把yield想想成return,return了一个4之后，程序停止，并没有执行赋值给res操作，此时next(g)语句执行完成，所以输出的前两行（第一个是while上面的print的结果,第二个是return出的结果）是执行print(next(g))的结果，<br></li>
<li>程序执行print("<b>"*20)，输出20个</b><br></li>
<li>又开始执行下面的print(next(g)),这个时候和上面那个差不多，不过不同的是，这个时候是从刚才那个next程序停止的地方开始执行的，也就是要执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值是None,所以接着下面的输出就是res:None,<br></li>
<li>程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print函数输出的4就是这次return出的4.<br></li>
</ol>

<p>
到这里你可能就明白yield和return的关系和区别了，带yield的函数是一个生成器，而不是一个函数了，这个生成器有一个函数就是next函数，next就相当于“下一步”生成哪个数，这一次的next开始的地方是接着上一次的next停止的地方执行的，所以调用next的时候，生成器并不会从foo函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束。<br>
</p>


<p>
<b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b>**</b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b><br>
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BD93F9;">def</span> <span style="color: #AFAFAF;">foo</span>():
        <span style="color: #BD93F9;">print</span>(<span style="color: #FC9F4E;">"starting..."</span>)
        <span style="color: #BD93F9;">while</span> <span style="color: #009F9F;">True</span>:
                <span style="color: #AFAFAF;">res</span> = <span style="color: #BD93F9;">yield</span> <span style="color: #009F9F;">4</span>
                <span style="color: #BD93F9;">print</span>(<span style="color: #FC9F4E;">"res:"</span>,res)
                <span style="color: #AFAFAF;">g</span> = foo()
                <span style="color: #BD93F9;">print</span>(<span style="color: #AFAFAF;">next</span>(g))
                <span style="color: #BD93F9;">print</span>(<span style="color: #FC9F4E;">"*"</span>*<span style="color: #009F9F;">20</span>)
                <span style="color: #BD93F9;">print</span>(g.send(<span style="color: #009F9F;">7</span>))
</pre>
</div>

<p>
再看一个这个生成器的send函数的例子，这个例子就把上面那个例子的最后一行换掉了，输出结果：<br>
starting&#x2026;<br>
4<br>
<b><b><b><b><b><b><b><b><b>**</b></b></b></b></b></b></b></b></b><br>
res: 7<br>
4<br>
</p>

<p>
先大致说一下send函数的概念：此时你应该注意到上面那个的紫色的字，还有上面那个res的值为什么是None，这个变成了7，到底为什么，这是因为，send是发送一个参数给res的，因为上面讲到，return的时候，并没有把4赋值给res，下次执行的时候只好继续执行赋值操作，只好赋值为None了，而如果用send的话，开始执行的时候，先接着上一次（return 4之后）执行，先把7赋值给了res,然后执行next的作用，遇见下一回的yield，return出结果后结束。<br>
</p>

<ol class="org-ol">
<li>程序执行g.send(7)，程序会从yield关键字那一行继续向下运行，send会把7这个值赋值给res变量<br></li>
<li>由于send方法中包含next()方法，所以程序会继续向下运行执行print方法，然后再次进入while循环<br></li>
<li>程序执行再次遇到yield关键字，yield会返回后面的值后，程序再次暂停，直到再次调用next方法或send方法。<br></li>
</ol>


<p>
这就结束了，说一下，为什么用这个生成器，是因为如果用List的话，会占用更大的空间，比如说取0,1,2,3,4,5,6&#x2026;&#x2026;&#x2026;&#x2026;1000<br>
你可能会这样：<br>
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BD93F9;">for</span> n <span style="color: #BD93F9;">in</span> <span style="color: #AFAFAF;">range</span>(<span style="color: #009F9F;">1000</span>):
        <span style="color: #AFAFAF;">a</span>=n
</pre>
</div>

<p>
这个时候range(1000)就默认生成一个含有1000个数的list了，所以很占内存。<br>
这个时候你可以用刚才的yield组合成生成器进行实现，也可以用xrange(1000)这个生成器实现<br>
</p>

<p>
yield组合：<br>
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BD93F9;">def</span> <span style="color: #AFAFAF;">foo</span>(num):
        <span style="color: #BD93F9;">print</span>(<span style="color: #FC9F4E;">"starting..."</span>)
        <span style="color: #BD93F9;">while</span> num&lt;<span style="color: #009F9F;">10</span>:
                <span style="color: #AFAFAF;">num</span>=num+<span style="color: #009F9F;">1</span>
                <span style="color: #BD93F9;">yield</span> num
<span style="color: #BD93F9;">for</span> n <span style="color: #BD93F9;">in</span> foo(<span style="color: #009F9F;">0</span>):
        <span style="color: #BD93F9;">print</span>(n)
</pre>
</div>

<p>
输出：<br>
starting&#x2026;<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
</p>


<p>
xrange(1000):<br>
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BD93F9;">for</span> n <span style="color: #BD93F9;">in</span> <span style="color: #AFAFAF;">xrange</span>(<span style="color: #009F9F;">1000</span>):
        <span style="color: #AFAFAF;">a</span>=n
</pre>
</div>

<p>
其中要注意的是python3时已经没有xrange()了，在python3中，range()就是xrange()了，你可以在python3中查看range()的类型，它已经是个&lt;class 'range'&gt;了，而不是一个list了，毕竟这个是需要优化的。<br>
</p>
</div>
</body>
</html>
