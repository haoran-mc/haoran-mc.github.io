<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-02-19 Sat 03:00 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>GO-数组</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">GO-数组</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org310294f">简介</a></li>
<li><a href="#orga531a7a">概述</a></li>
<li><a href="#orge08ffbe">初始化</a>
<ul>
<li><a href="#org74f8fef">上限推导</a></li>
<li><a href="#org0cfe9a9">语句转换</a></li>
</ul>
</li>
<li><a href="#orgf96d2b2">访问和赋值</a></li>
<li><a href="#org84bb70d">小结</a></li>
</ul>
</div>
</div>

<div id="outline-container-org310294f" class="outline-2">
<h2 id="org310294f">简介</h2>
<div class="outline-text-2" id="text-org310294f">
<p>
数组和切片是 Go 语言中常见的数据结构，很多刚刚使用 Go 的开发者往往会混淆这两个概念。数组作为最常见的集合在编程语言中是非常重要的，除了数组之外，Go 语言引入了另一个概念 — 切片，切片与数组有一些类似，但是它们的不同导致了使用上的巨大差别。我们在这一节中会从 Go 语言的 <a href="Go-编译过程.html">2.1 编译过程</a> 运行时来介绍数组的底层实现原理，其中会包括数组的初始化、访问和赋值几种常见操作。<br>
</p>
</div>
</div>
<div id="outline-container-orga531a7a" class="outline-2">
<h2 id="orga531a7a">概述</h2>
<div class="outline-text-2" id="text-orga531a7a">
<p>
数组是由相同类型元素的集合组成的数据结构，计算机会为数组分配一块连续的内存来保存其中的元素，我们可以利用数组中元素的索引快速访问特定元素，常见的数组大多都是一维的线性数组，而多维数组在数值和图形计算领域却有比较常见的应用。<br>
</p>

<img src="./images/Go语言设计与实现-多维数组.jpg" width=650px/>

<p>
数组作为一种基本的数据类型，我们通常会从两个维度描述数组，也就是数组中存储的元素类型和数组最大能存储的元素个数，在 Go 语言中我们往往会使用如下所示的方式来表示数组类型：<br>
</p>

<div class="org-src-container">
<pre class="src src-go">[<span style="color: #d75fd7;">10</span>]<span style="color: #df005f; font-weight: bold;">int</span>
[<span style="color: #d75fd7;">200</span>]<span style="color: #268bd2; font-weight: bold;">interface</span>{}
</pre>
</div>

<p>
Go 语言数组在初始化之后大小就无法改变，存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，只有两个条件都相同才是同一类型。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">NewArray</span>(<span style="color: #8787d7;">elem</span> *<span style="color: #df005f; font-weight: bold;">Type</span>, <span style="color: #8787d7;">bound</span> <span style="color: #df005f; font-weight: bold;">int64</span>) *<span style="color: #df005f; font-weight: bold;">Type</span> {
    <span style="color: #268bd2; font-weight: bold;">if</span> bound &lt; <span style="color: #d75fd7;">0</span> {
        <span style="color: #d75fd7; font-weight: bold;">Fatalf</span>(<span style="color: #2aa198;">"NewArray: invalid bound %v"</span>, bound)
    }
    <span style="color: #8787d7;">t</span> := <span style="color: #d75fd7; font-weight: bold;">New</span>(TARRAY)
    t.Extra = &amp;<span style="color: #df005f; font-weight: bold;">Array</span>{<span style="color: #d75fd7;">Elem</span>: elem, <span style="color: #d75fd7;">Bound</span>: bound}
    t.<span style="color: #d75fd7; font-weight: bold;">SetNotInHeap</span>(elem.<span style="color: #d75fd7; font-weight: bold;">NotInHeap</span>())
    <span style="color: #268bd2; font-weight: bold;">return</span> t
}
</pre>
</div>

<p>
编译期间的数组类型是由上述的 <a href="https://github.com/golang/go/blob/da54dfb6a1f3bef827b9ec3780c98fde77a97d11/src/cmd/compile/internal/types/type.go#L482">cmd/compile/internal/types.NewArray</a>  函数生成的，该类型包含两个字段，分别是元素类型 <code>Elem</code> 和数组的大小 <code>Bound</code> ，这两个字段共同构成了数组类型，而当前数组是否应该在堆栈中初始化也在编译期就确定了。<br>
</p>
</div>
</div>
<div id="outline-container-orge08ffbe" class="outline-2">
<h2 id="orge08ffbe">初始化</h2>
<div class="outline-text-2" id="text-orge08ffbe">
<p>
Go 语言的数组有两种不同的创建方式，一种是显式的指定数组大小，另一种是使用 <code>[...]T</code> 声明数组，Go 语言会在编译期间通过源代码推导数组的大小：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">arr1</span> := [<span style="color: #d75fd7;">3</span>]<span style="color: #df005f; font-weight: bold;">int</span>{<span style="color: #d75fd7;">1</span>, <span style="color: #d75fd7;">2</span>, <span style="color: #d75fd7;">3</span>}
<span style="color: #8787d7;">arr2</span> := [...]<span style="color: #df005f; font-weight: bold;">int</span>{<span style="color: #d75fd7;">1</span>, <span style="color: #d75fd7;">2</span>, <span style="color: #d75fd7;">3</span>}
</pre>
</div>

<p>
上述两种声明方式在运行期间得到的结果是完全相同的，后一种声明方式在编译期间就会被转换成前一种，这也就是编译器对数组大小的推导，下面我们来介绍编译器的推导过程。<br>
</p>
</div>
<div id="outline-container-org74f8fef" class="outline-3">
<h3 id="org74f8fef">上限推导</h3>
<div class="outline-text-3" id="text-org74f8fef">
<p>
两种不同的声明方式会导致编译器做出完全不同的处理，如果我们使用第一种方式 <code>[10]T</code> ，那么变量的类型在编译进行到 <a href="Go-类型检查.html">类型检查</a> 阶段就会被提取出来，随后使用 <a href="https://draveness.me/golang/tree/cmd/compile/internal/types.NewArray">cmd/compile/internal/types.NewArray</a> 创建包含数组大小的 <a href="https://draveness.me/golang/tree/cmd/compile/internal/types.Array">cmd/compile/internal/types.Array</a>  结构体。<br>
</p>

<p>
当我们使用 <code>[...]T</code> 的方式声明数组时，编译器会在的 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheckcomplit">cmd/compile/internal/gc.typecheckcomplit</a>  函数中对该数组的大小进行推导：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">typecheckcomplit</span>(<span style="color: #8787d7;">n</span> *<span style="color: #df005f; font-weight: bold;">Node</span>) (<span style="color: #8787d7;">res</span> *<span style="color: #df005f; font-weight: bold;">Node</span>) {
    ...
        <span style="color: #268bd2; font-weight: bold;">if</span> n.Right.Op == OTARRAY &amp;&amp; n.Right.Left != <span style="color: #d75fd7;">nil</span> &amp;&amp; n.Right.Left.Op == ODDD {
        n.Right.Right = <span style="color: #d75fd7; font-weight: bold;">typecheck</span>(n.Right.Right, ctxType)
        <span style="color: #268bd2; font-weight: bold;">if</span> n.Right.Right.Type == <span style="color: #d75fd7;">nil</span> {
            n.Type = <span style="color: #d75fd7;">nil</span>
            <span style="color: #268bd2; font-weight: bold;">return</span> n
        }
        <span style="color: #8787d7;">elemType</span> := n.Right.Right.Type

        <span style="color: #8787d7;">length</span> := <span style="color: #d75fd7; font-weight: bold;">typecheckarraylit</span>(elemType, -<span style="color: #d75fd7;">1</span>, n.List.<span style="color: #d75fd7; font-weight: bold;">Slice</span>(), <span style="color: #2aa198;">"array literal"</span>)

        n.Op = OARRAYLIT
        n.Type = types.<span style="color: #d75fd7; font-weight: bold;">NewArray</span>(elemType, length)
        n.Right = <span style="color: #d75fd7;">nil</span>
        <span style="color: #268bd2; font-weight: bold;">return</span> n
    }
    ...

        <span style="color: #268bd2; font-weight: bold;">switch</span> t.Etype {
    <span style="color: #268bd2; font-weight: bold;">case</span> TARRAY:
        <span style="color: #d75fd7; font-weight: bold;">typecheckarraylit</span>(t.<span style="color: #d75fd7; font-weight: bold;">Elem</span>(), t.<span style="color: #d75fd7; font-weight: bold;">NumElem</span>(), n.List.<span style="color: #d75fd7; font-weight: bold;">Slice</span>(), <span style="color: #2aa198;">"array literal"</span>)
        n.Op = OARRAYLIT
        n.Right = <span style="color: #d75fd7;">nil</span>
    }
}
</pre>
</div>

<p>
这个删减后的 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheckcomplit">cmd/compile/internal/gc.typecheckcomplit</a>  会调用 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheckarraylit">cmd/compile/internal/gc.typecheckarraylit</a>  通过遍历元素的方式来计算数组中元素的数量。<br>
</p>

<p>
所以我们可以看出 <code>[...]T{1, 2, 3}</code> 和 <code>[3]T{1, 2, 3}</code> 在运行时是完全等价的， <code>[...]T</code> 这种初始化方式也只是 Go 语言为我们提供的一种语法糖，当我们不想计算数组中的元素个数时可以通过这种方法减少一些工作量。<br>
</p>
</div>
</div>
<div id="outline-container-org0cfe9a9" class="outline-3">
<h3 id="org0cfe9a9">语句转换</h3>
<div class="outline-text-3" id="text-org0cfe9a9">
<p>
对于一个由字面量组成的数组，根据数组元素数量的不同，编译器会在负责初始化字面量的 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.fixedlit">cmd/compile/internal/gc.anylit</a>  函数中做两种不同的优化：<br>
</p>

<ol class="org-ol">
<li>当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上；<br></li>
<li>当元素数量大于 4 个时，会将数组中的元素放置到静态区并在运行时取出；<br></li>
</ol>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">anylit</span>(<span style="color: #8787d7;">n</span> *<span style="color: #df005f; font-weight: bold;">Node</span>, <span style="color: #8787d7;">var_</span> *<span style="color: #df005f; font-weight: bold;">Node</span>, <span style="color: #8787d7;">init</span> *<span style="color: #df005f; font-weight: bold;">Nodes</span>) {
    <span style="color: #8787d7;">t</span> := n.Type
    <span style="color: #268bd2; font-weight: bold;">switch</span> n.Op {
    <span style="color: #268bd2; font-weight: bold;">case</span> OSTRUCTLIT, OARRAYLIT:
        <span style="color: #268bd2; font-weight: bold;">if</span> n.List.<span style="color: #d75fd7; font-weight: bold;">Len</span>() &gt; <span style="color: #d75fd7;">4</span> {
            ...
            }

        <span style="color: #d75fd7; font-weight: bold;">fixedlit</span>(inInitFunction, initKindLocalCode, n, var_, init)
        ...
        }
}
</pre>
</div>

<p>
当数组的元素 <b>小于或者等于四个</b> 时， <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.fixedlit">cmd/compile/internal/gc.fixedlit</a>  会负责在函数编译之前将 <code>[3]{1, 2, 3}</code> 转换成更加原始的语句：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">fixedlit</span>(<span style="color: #8787d7;">ctxt</span> <span style="color: #df005f; font-weight: bold;">initContext</span>, <span style="color: #8787d7;">kind</span> <span style="color: #df005f; font-weight: bold;">initKind</span>, <span style="color: #8787d7;">n</span> *<span style="color: #df005f; font-weight: bold;">Node</span>, <span style="color: #8787d7;">var_</span> *<span style="color: #df005f; font-weight: bold;">Node</span>, <span style="color: #8787d7;">init</span> *<span style="color: #df005f; font-weight: bold;">Nodes</span>) {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">splitnode</span> <span style="color: #268bd2; font-weight: bold;">func</span>(*<span style="color: #df005f; font-weight: bold;">Node</span>) (<span style="color: #8787d7;">a</span> *<span style="color: #df005f; font-weight: bold;">Node</span>, <span style="color: #8787d7;">value</span> *<span style="color: #df005f; font-weight: bold;">Node</span>)
    ...

        <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">_</span>, <span style="color: #8787d7;">r</span> := <span style="color: #268bd2; font-weight: bold;">range</span> n.List.<span style="color: #d75fd7; font-weight: bold;">Slice</span>() {
        <span style="color: #8787d7;">a</span>, <span style="color: #8787d7;">value</span> := <span style="color: #d75fd7; font-weight: bold;">splitnode</span>(r)
        a = <span style="color: #d75fd7; font-weight: bold;">nod</span>(OAS, a, value)
        a = <span style="color: #d75fd7; font-weight: bold;">typecheck</span>(a, ctxStmt)
        <span style="color: #268bd2; font-weight: bold;">switch</span> kind {
        <span style="color: #268bd2; font-weight: bold;">case</span> initKindStatic:
            <span style="color: #d75fd7; font-weight: bold;">genAsStatic</span>(a)
        <span style="color: #268bd2; font-weight: bold;">case</span> initKindLocalCode:
            a = <span style="color: #d75fd7; font-weight: bold;">orderStmtInPlace</span>(a, <span style="color: #268bd2; font-weight: bold;">map</span>[<span style="color: #df005f; font-weight: bold;">string</span>][]*<span style="color: #df005f; font-weight: bold;">Node</span>{})
            a = <span style="color: #d75fd7; font-weight: bold;">walkstmt</span>(a)
            init.<span style="color: #d75fd7; font-weight: bold;">Append</span>(a)
        }
    }
}
</pre>
</div>

<p>
当数组中元素的个数小于或者等于四个并且 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.fixedlit">cmd/compile/internal/gc.fixedlit</a>  函数接收的 <code>kind</code> 是 <code>initKindLocalCode</code> 时，上述代码会将原有的初始化语句 <code>[3]int{1, 2, 3}</code> 拆分成一个声明变量的表达式和几个赋值表达式，这些表达式会完成对数组的初始化：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">arr</span> [<span style="color: #d75fd7;">3</span>]<span style="color: #df005f; font-weight: bold;">int</span>
arr[<span style="color: #d75fd7;">0</span>] = <span style="color: #d75fd7;">1</span>
arr[<span style="color: #d75fd7;">1</span>] = <span style="color: #d75fd7;">2</span>
arr[<span style="color: #d75fd7;">2</span>] = <span style="color: #d75fd7;">3</span>
</pre>
</div>

<p>
但是如果当前数组的元素大于四个， <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.anylit">cmd/compile/internal/gc.anylit</a>  会先获取一个唯一的 <code>staticname</code> ，然后调用 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.fixedlit">cmd/compile/internal/gc.fixedlit</a>  函数在静态存储区初始化数组中的元素并将临时变量赋值给数组：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">anylit</span>(<span style="color: #8787d7;">n</span> *<span style="color: #df005f; font-weight: bold;">Node</span>, <span style="color: #8787d7;">var_</span> *<span style="color: #df005f; font-weight: bold;">Node</span>, <span style="color: #8787d7;">init</span> *<span style="color: #df005f; font-weight: bold;">Nodes</span>) {
    <span style="color: #8787d7;">t</span> := n.Type
    <span style="color: #268bd2; font-weight: bold;">switch</span> n.Op {
    <span style="color: #268bd2; font-weight: bold;">case</span> OSTRUCTLIT, OARRAYLIT:
        <span style="color: #268bd2; font-weight: bold;">if</span> n.List.<span style="color: #d75fd7; font-weight: bold;">Len</span>() &gt; <span style="color: #d75fd7;">4</span> {
            <span style="color: #8787d7;">vstat</span> := <span style="color: #d75fd7; font-weight: bold;">staticname</span>(t)
            vstat.Name.<span style="color: #d75fd7; font-weight: bold;">SetReadonly</span>(<span style="color: #d75fd7;">true</span>)

            <span style="color: #d75fd7; font-weight: bold;">fixedlit</span>(inNonInitFunction, initKindStatic, n, vstat, init)

            <span style="color: #8787d7;">a</span> := <span style="color: #d75fd7; font-weight: bold;">nod</span>(OAS, var_, vstat)
            a = <span style="color: #d75fd7; font-weight: bold;">typecheck</span>(a, ctxStmt)
            a = <span style="color: #d75fd7; font-weight: bold;">walkexpr</span>(a, init)
            init.<span style="color: #d75fd7; font-weight: bold;">Append</span>(a)
            <span style="color: #268bd2; font-weight: bold;">break</span>
        }

        ...
        }
}
</pre>
</div>

<p>
假设代码需要初始化 <code>[5]int{1, 2, 3, 4, 5}</code> ，那么我们可以将上述过程理解成以下的伪代码：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">arr</span> [<span style="color: #d75fd7;">5</span>]<span style="color: #df005f; font-weight: bold;">int</span>
statictmp_0[<span style="color: #d75fd7;">0</span>] = <span style="color: #d75fd7;">1</span>
statictmp_0[<span style="color: #d75fd7;">1</span>] = <span style="color: #d75fd7;">2</span>
statictmp_0[<span style="color: #d75fd7;">2</span>] = <span style="color: #d75fd7;">3</span>
statictmp_0[<span style="color: #d75fd7;">3</span>] = <span style="color: #d75fd7;">4</span>
statictmp_0[<span style="color: #d75fd7;">4</span>] = <span style="color: #d75fd7;">5</span>
arr = statictmp_0
</pre>
</div>

<p>
总结起来，在不考虑逃逸分析的情况下，如果数组中元素的个数小于或者等于 4 个，那么所有的变量会直接在栈上初始化，如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上，这些转换后的代码才会继续进入 <a href="Go-中间代码生成.html">中间代码生成</a> 和 <a href="Go-机器码生成.html">机器码生成</a> 两个阶段，最后生成可以执行的二进制文件。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-orgf96d2b2" class="outline-2">
<h2 id="orgf96d2b2">访问和赋值</h2>
<div class="outline-text-2" id="text-orgf96d2b2">
<p>
无论是在栈上还是静态存储区，数组在内存中都是一连串的内存空间，我们通过指向数组开头的指针、元素的数量以及元素类型占的空间大小表示数组。如果我们不知道数组中元素的数量，访问时可能发生越界；而如果不知道数组中元素类型的大小，就没有办法知道应该一次取出多少字节的数据，无论丢失了哪个信息，我们都无法知道这片连续的内存空间到底存储了什么数据：<br>
</p>

<p>
数组访问越界是非常严重的错误，Go 语言中可以在编译期间的静态类型检查判断数组越界， <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheck1">cmd/compile/internal/gc.typecheck1</a>  会验证访问数组的索引：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">typecheck1</span>(<span style="color: #8787d7;">n</span> *<span style="color: #df005f; font-weight: bold;">Node</span>, <span style="color: #8787d7;">top</span> <span style="color: #df005f; font-weight: bold;">int</span>) (<span style="color: #8787d7;">res</span> *<span style="color: #df005f; font-weight: bold;">Node</span>) {
    <span style="color: #268bd2; font-weight: bold;">switch</span> n.Op {
    <span style="color: #268bd2; font-weight: bold;">case</span> OINDEX:
        ok |= ctxExpr
        <span style="color: #8787d7;">l</span> := n.Left  <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">array</span>
        <span style="color: #8787d7;">r</span> := n.Right <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">index</span>
        <span style="color: #268bd2; font-weight: bold;">switch</span> n.Left.Type.Etype {
        <span style="color: #268bd2; font-weight: bold;">case</span> TSTRING, TARRAY, TSLICE:
            ...
                <span style="color: #268bd2; font-weight: bold;">if</span> n.Right.Type != <span style="color: #d75fd7;">nil</span> &amp;&amp; <span style="color: #d75fd7;">!</span>n.Right.Type.<span style="color: #d75fd7; font-weight: bold;">IsInteger</span>() {
                <span style="color: #d75fd7; font-weight: bold;">yyerror</span>(<span style="color: #2aa198;">"non-integer array index %v"</span>, n.Right)
                <span style="color: #268bd2; font-weight: bold;">break</span>
            }
            <span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #d75fd7;">!</span>n.<span style="color: #d75fd7; font-weight: bold;">Bounded</span>() &amp;&amp; <span style="color: #d75fd7; font-weight: bold;">Isconst</span>(n.Right, CTINT) {
                <span style="color: #8787d7;">x</span> := n.Right.<span style="color: #d75fd7; font-weight: bold;">Int64</span>()
                <span style="color: #268bd2; font-weight: bold;">if</span> x &lt; <span style="color: #d75fd7;">0</span> {
                    <span style="color: #d75fd7; font-weight: bold;">yyerror</span>(<span style="color: #2aa198;">"invalid array index %v (index must be non-negative)"</span>, n.Right)
                } <span style="color: #268bd2; font-weight: bold;">else</span> <span style="color: #268bd2; font-weight: bold;">if</span> n.Left.Type.<span style="color: #d75fd7; font-weight: bold;">IsArray</span>() &amp;&amp; x &gt;= n.Left.Type.<span style="color: #d75fd7; font-weight: bold;">NumElem</span>() {
                    <span style="color: #d75fd7; font-weight: bold;">yyerror</span>(<span style="color: #2aa198;">"invalid array index %v (out of bounds for %d-element array)"</span>, n.Right, n.Left.Type.<span style="color: #d75fd7; font-weight: bold;">NumElem</span>())
                }
            }
        }
        ...
        }
}
</pre>
</div>

<p>
访问数组的索引是非整数时，报错 “non-integer array index %v”；<br>
访问数组的索引是负数时，报错 “invalid array index %v (index must be non-negative)"；<br>
访问数组的索引越界时，报错 “invalid array index %v (out of bounds for %d-element array)"；<br>
数组和字符串的一些简单越界错误都会在编译期间发现，例如：直接使用整数或者常量访问数组；但是如果使用变量去访问数组或者字符串时，编译器就无法提前发现错误，我们需要 Go 语言运行时阻止不合法的访问：<br>
</p>

<pre class="example" id="org0c95223">
arr[4]: invalid array index 4 (out of bounds for 3-element array)
arr[i]: panic: runtime error: index out of range [4] with length 3
</pre>

<p>
Go 语言运行时在发现数组、切片和字符串的越界操作会由运行时的 <a href="https://draveness.me/golang/tree/runtime.panicIndex">runtime.panicIndex</a> 和 <a href="https://draveness.me/golang/tree/runtime.goPanicIndex">runtime.goPanicIndex</a>  触发程序的运行时错误并导致崩溃退出：<br>
</p>

<div class="org-src-container">
<pre class="src src-go">TEXT <span style="color: #df005f; font-weight: bold;">runtime&#183;panicIndex</span>(SB),NOSPLIT,$0-<span style="color: #d75fd7;">8</span>
MOVL    <span style="color: #df005f; font-weight: bold;">AX</span>, x+<span style="color: #d75fd7;">0</span>(FP)
MOVL    <span style="color: #df005f; font-weight: bold;">CX</span>, y+<span style="color: #d75fd7;">4</span>(FP)
JMP <span style="color: #df005f; font-weight: bold;">runtime&#183;goPanicIndex</span>(SB)

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">goPanicIndex</span>(<span style="color: #8787d7;">x</span> <span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #8787d7;">y</span> <span style="color: #df005f; font-weight: bold;">int</span>) {
    <span style="color: #d75fd7; font-weight: bold;">panicCheck1</span>(<span style="color: #d75fd7; font-weight: bold;">getcallerpc</span>(), <span style="color: #2aa198;">"index out of range"</span>)
    <span style="color: #268bd2;">panic</span>(<span style="color: #df005f; font-weight: bold;">boundsError</span>{<span style="color: #d75fd7;">x</span>: <span style="color: #d75fd7; font-weight: bold;">int64</span>(x), <span style="color: #d75fd7;">signed</span>: <span style="color: #d75fd7;">true</span>, <span style="color: #d75fd7;">y</span>: y, <span style="color: #d75fd7;">code</span>: boundsIndex})
}
</pre>
</div>

<p>
当数组的访问操作 <code>OINDEX</code> 成功通过编译器的检查后，会被转换成几个 SSA 指令，假设我们有如下所示的 Go 语言代码，通过如下的方式进行编译会得到 ssa.html 文件：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> check

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">outOfRange</span>() <span style="color: #df005f; font-weight: bold;">int</span> {
    <span style="color: #8787d7;">arr</span> := [<span style="color: #d75fd7;">3</span>]<span style="color: #df005f; font-weight: bold;">int</span>{<span style="color: #d75fd7;">1</span>, <span style="color: #d75fd7;">2</span>, <span style="color: #d75fd7;">3</span>}
    <span style="color: #8787d7;">i</span> := <span style="color: #d75fd7;">4</span>
    <span style="color: #8787d7;">elem</span> := arr[i]
    <span style="color: #268bd2; font-weight: bold;">return</span> elem
}

$ <span style="color: #df005f; font-weight: bold;">GOSSAFUNC</span>=outOfRange <span style="color: #268bd2; font-weight: bold;">go</span> build <span style="color: #df005f; font-weight: bold;">array.go</span>
dumped <span style="color: #df005f; font-weight: bold;">SSA</span> to ./ssa.html
</pre>
</div>

<p>
start 阶段生成的 SSA 代码就是优化之前的第一版中间代码，下面展示的部分是 <code>elem := arr[i]</code> 对应的中间代码，在这段中间代码中我们发现 Go 语言为数组的访问操作生成了判断数组上限的指令 <code>IsInBounds</code> 以及当条件不满足时触发程序崩溃的 <code>PanicBounds</code> 指令：<br>
</p>

<pre class="example" id="org9edbec6">
b1:
		...
		v22 (6) = LocalAddr &lt;*[3]int&gt; {arr} v2 v20
		v23 (6) = IsInBounds &lt;bool&gt; v21 v11
If v23 → b2 b3 (likely) (6)

b2: ← b1-
		v26 (6) = PtrIndex &lt;*int&gt; v22 v21
		v27 (6) = Copy &lt;mem&gt; v20
		v28 (6) = Load &lt;int&gt; v26 v27 (elem[int])
		...
Ret v30 (+7)

b3: ← b1-
		v24 (6) = Copy &lt;mem&gt; v20
		v25 (6) = PanicBounds &lt;mem&gt; [0] v21 v11 v24
Exit v25 (6)
</pre>

<p>
编译器会将 <code>PanicBounds</code> 指令转换成上面提到的 <a href="https://draveness.me/golang/tree/runtime.panicIndex">runtime.panicIndex</a>  函数，当数组下标没有越界时，编译器会先获取数组的内存地址和访问的下标、利用 <code>PtrIndex</code> 计算出目标元素的地址，最后使用 <code>Load</code> 操作将指针中的元素加载到内存中。<br>
</p>

<p>
当然只有当编译器无法对数组下标是否越界无法做出判断时才会加入 <code>PanicBounds</code> 指令交给运行时进行判断，在使用字面量整数访问数组下标时会生成非常简单的中间代码，当我们将上述代码中的 <code>arr[i]</code> 改成 <code>arr[2]</code> 时，就会得到如下所示的代码：<br>
</p>

<pre class="example" id="org2d5aa01">
b1:
		...
		v21 (5) = LocalAddr &lt;*[3]int&gt; {arr} v2 v20
		v22 (5) = PtrIndex &lt;*int&gt; v21 v14
		v23 (5) = Load &lt;int&gt; v22 v20 (elem[int])
		...
</pre>

<p>
Go 语言对于数组的访问还是有着比较多的检查的，它不仅会在编译期间提前发现一些简单的越界错误并插入用于检测数组上限的函数调用，还会在运行期间通过插入的函数保证不会发生越界。<br>
</p>

<p>
数组的赋值和更新操作 <code>a[i] = 2</code> 也会生成 SSA 生成期间计算出数组当前元素的内存地址，然后修改当前内存地址的内容，这些赋值语句会被转换成如下所示的 SSA 代码：<br>
</p>

<pre class="example" id="orge134945">
b1:
		...
		v21 (5) = LocalAddr &lt;*[3]int&gt; {arr} v2 v19
		v22 (5) = PtrIndex &lt;*int&gt; v21 v13
		v23 (5) = Store &lt;mem&gt; {int} v22 v20 v19
		...
</pre>

<p>
赋值的过程中会先确定目标数组的地址，再通过 <code>PtrIndex</code> 获取目标元素的地址，最后使用 <code>Store</code> 指令将数据存入地址中，从上面的这些 SSA 代码中我们可以看出 上述数组寻址和赋值都是在编译阶段完成的，没有运行时的参与。<br>
</p>
</div>
</div>
<div id="outline-container-org84bb70d" class="outline-2">
<h2 id="org84bb70d">小结</h2>
<div class="outline-text-2" id="text-org84bb70d">
<p>
数组是 Go 语言中重要的数据结构，了解它的实现能够帮助我们更好地理解这门语言，通过对其实现的分析，我们知道了对数组的访问和赋值需要同时依赖编译器和运行时，它的大多数操作在 <a href="Go-编译过程.html">编译期间</a> 都会转换成直接读写内存，在中间代码生成期间，编译器还会插入运行时方法 <a href="https://draveness.me/golang/tree/runtime.panicIndex">runtime.panicIndex</a>  调用防止发生越界错误。<br>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-02-02 20:02 Wed</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-02-19 Sat 03:00</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
