<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-07-17 日 16:31 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>面向对象编程之构造函数</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>
<link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
            <link rel="stylesheet" href="css/style.css" type="text/css"  />
            <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
            <script type="module" src="js/main.js" defer></script>
</head>
<body>
<div id="content">
<h1 class="title">面向对象编程之构造函数</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org31a3730">引言</a></li>
<li><a href="#org81b3adb">一个简单的构造函数的实现</a></li>
<li><a href="#orge39c833">使用闭包实现构造函数</a></li>
</ul>
</div>
</div>

<div id="outline-container-org31a3730" class="outline-2">
<h2 id="org31a3730">引言</h2>
<div class="outline-text-2" id="text-org31a3730">
<p>
构造函数是一种特殊的方法，主要用来在创建对象时初始化对象，即为对象成员变量赋初始值。特别的一个类可以有多个构造函数 ，可根据其参数个数的不同或参数类型的不同来区分它们，即构造函数的重载。
</p>

<p>
Golang 里面没有构造函数，但是 Golang 却可以像 C++ 一样实现类似继承、构造函数一样等面向对象编程的思想和方法。Golang 里面要实现相关的构造函数定义可以通过 <code>new</code> 来创建构造函数。
</p>
</div>
</div>
<div id="outline-container-org81b3adb" class="outline-2">
<h2 id="org81b3adb">一个简单的构造函数的实现</h2>
<div class="outline-text-2" id="text-org81b3adb">
<div class="org-src-container">
<pre class="src src-go">type ContentMsg struct {
    EffectId int         `json:"effect_id"`
    Text     string      `json:"text"`
    Data     interface{} `json: "data"`
}	
</pre>
</div>

<p>
通过 <code>new</code> 一个对象，或者利用 Golang 本身的 <code>&amp;</code> 方式来生成一个对象并返回一个对象指针：
</p>

<div class="org-src-container">
<pre class="src src-go">func NewContentMsg1(data, effectId int) *ContentMsg {
    instance := new(ContentMsg)
    instance.Data = data
    instance.EffectId = effectId
    return instance
}

func NewContentMsg2(data, effectId int) *ContentMsg {
    return &amp;ContentMsg{
        Data:     data,
        EffectId: effectId,
    }
}	
</pre>
</div>
</div>
</div>
<div id="outline-container-orge39c833" class="outline-2">
<h2 id="orge39c833">使用闭包实现构造函数</h2>
<div class="outline-text-2" id="text-orge39c833">
<div class="org-src-container">
<pre class="src src-go">// 链接：https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html
package main

import (
    "fmt"
    "time"

    "golang.org/x/net/context"
)

type Cluster struct {
    opts options
}

type options struct {
    connectionTimeout time.Duration
    readTimeout       time.Duration
    writeTimeout      time.Duration
    logError          func(ctx context.Context, err error)
}

// 通过一个选项实现为一个函数指针来达到一个目的：设置选项中的数据的状态
// Golang函数指针的用法
type Option func(c *options)

// 设置某个参数的一个具体实现，用到了闭包的用法。
// 不仅仅只是设置而采用闭包的目的是为了更为优化，更好用，对用户更友好
func LogError(f func(ctx context.Context, err error)) Option {
    return func(opts *options) {
        opts.logError = f
    }
}

func ConnectionTimeout(d time.Duration) Option {
    return func(opts *options) {
        opts.connectionTimeout = d
    }
}

func WriteTimeout(d time.Duration) Option {
    return func(opts *options) {
        opts.writeTimeout = d
    }
}

func ReadTimeout(d time.Duration) Option {
    return func(opts *options) {
        opts.readTimeout = d
    }
}

// 构造函数具体实现，传入相关Option，new一个对象并赋值
// 如果参数很多，也不需要传入很多参数，只需要传入opts ...Option即可
func NewCluster(opts ...Option) *Cluster {
    clusterOpts := options{}
    for _, opt := range opts {
        // 函数指针的赋值调用
        opt(&amp;clusterOpts)
    }

    cluster := new(Cluster)
    cluster.opts = clusterOpts

    return cluster
}

func main() {
    // 前期储备，设定相关参数
    commonsOpts := []Option{
        ConnectionTimeout(1 * time.Second),
        ReadTimeout(2 * time.Second),
        WriteTimeout(3 * time.Second),
        LogError(func(ctx context.Context, err error) {
        }),
    }

    // 终极操作，构造函数
    cluster := NewCluster(commonsOpts...)

    // 测试验证
    fmt.Println(cluster.opts.connectionTimeout)
    fmt.Println(cluster.opts.writeTimeout)
}	
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-07-17 日 16:31</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
