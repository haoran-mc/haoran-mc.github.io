<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-10-07 Thu 10:38 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>二分</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran &lt;haoran.mc@outlook.com&gt;">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">二分</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org54a476e">整数集合上的二分</a>
<ul>
<li><a href="#org04e08aa">寻找一个数</a></li>
<li><a href="#orge211786">寻找左侧边界的二分查找</a></li>
<li><a href="#org1e3cb7d">寻找右侧边界的二分查找</a></li>
<li><a href="#org20288fa">使用lower_bound和upper_bound查找</a>
<ul>
<li>
<ul>
<li><a href="#orgb2cb032">lower_bound</a></li>
<li><a href="#org9c5c86a">upper_bound</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org14b7724">实数域上的二分</a></li>
<li><a href="#org3842110">三分求单峰函数极值</a></li>
<li><a href="#org8015577">二分答案转化为判定</a></li>
<li><a href="#org5eacd98">二分拓展</a>
<ul>
<li><a href="#org40c8397">快速幂</a></li>
<li><a href="#org719861c">使用二分法计算 \(\sqrt{2}\) 的近似值</a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-org54a476e" class="outline-2">
<h2 id="org54a476e">整数集合上的二分</h2>
<div class="outline-text-2" id="text-org54a476e">
<p>
二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列<br>
</p>
</div>
<div id="outline-container-org04e08aa" class="outline-3">
<h3 id="org04e08aa">寻找一个数</h3>
<div class="outline-text-3" id="text-org04e08aa">
<ul class="org-ul">
<li>二分查找是基于有序序列的查找算法(以下以递增序列为例)<br></li>
<li>查找的下标区间为[left, right]<br></li>
<li>每次使mid = (left + right) / 2, 比较num[mid]与目标值<br></li>
<li>如果比目标值大，就向右查找<br></li>
<li>如果比目标值小，就向左查找<br></li>
<li>如果与目标值相等，返回目标值下标<br></li>
<li>如果没找到目标值，返回-1<br></li>
<li>如果二分上界超过int型数据范围的一半，(left + right)会溢出<br></li>
<li><p>
所以使用 mid = left + (right - left) / 2 避免溢出<br>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #009F9F;">#include</span> <span style="color: #FC9F4E;">&lt;cstdio&gt;</span>
<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">binarySearch</span>(<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">num</span>[], <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">n</span>, <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">val</span>) {
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">left</span>  = <span style="color: #009F9F;">0</span>;
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">right</span> = n-<span style="color: #009F9F;">1</span>;
    <span style="color: #BD93F9;">while</span> (left &lt;= right) {
        <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">mid</span> = left + (right - left) / <span style="color: #009F9F;">2</span>;
        <span style="color: #BD93F9;">if</span> (num[mid] == val)
            <span style="color: #BD93F9;">return</span> mid;
        <span style="color: #BD93F9;">else</span> <span style="color: #BD93F9;">if</span> (num[mid] &lt; val)
            left  = mid + <span style="color: #009F9F;">1</span>;
        <span style="color: #BD93F9;">else</span> <span style="color: #BD93F9;">if</span> (num[mid] &gt; val)
            right = mid - <span style="color: #009F9F;">1</span>;
    }
    <span style="color: #BD93F9;">return</span> -<span style="color: #009F9F;">1</span>;
}

<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">main</span>() {
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">num</span>[] = {<span style="color: #009F9F;">0</span>, <span style="color: #009F9F;">1</span>, <span style="color: #009F9F;">2</span>, <span style="color: #009F9F;">3</span>, <span style="color: #009F9F;">4</span>, <span style="color: #009F9F;">5</span>, <span style="color: #009F9F;">6</span>, <span style="color: #009F9F;">7</span>, <span style="color: #009F9F;">8</span>, <span style="color: #009F9F;">9</span>};
    <span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">val</span> = <span style="color: #009F9F;">0</span>; val &lt;= <span style="color: #009F9F;">9</span>; val++)
        printf(<span style="color: #FC9F4E;">"%d\n"</span>, binarySearch(num, <span style="color: #009F9F;">10</span>, val));
    <span style="color: #BD93F9;">return</span> <span style="color: #009F9F;">0</span>;
}
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orge211786" class="outline-3">
<h3 id="orge211786">寻找左侧边界的二分查找</h3>
<div class="outline-text-3" id="text-orge211786">
<ul class="org-ul">
<li>如果寻找的递增序列中的元素重复，要求找到第一个重复元素的位置<br></li>
<li><p>
例如在0, 1, 1, 1, 1, 1, 2中找到第一个1<br>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #009F9F;">#include</span> <span style="color: #FC9F4E;">&lt;cstdio&gt;</span>
<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">binarySearch</span>(<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">num</span>[], <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">n</span>, <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">val</span>) {
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">left</span>  = <span style="color: #009F9F;">0</span>;
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">right</span> = n - <span style="color: #009F9F;">1</span>;
    <span style="color: #BD93F9;">while</span> (left &lt;= right) {
        <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">mid</span> = left + (right - left) / <span style="color: #009F9F;">2</span>;
        <span style="color: #BD93F9;">if</span> (left == right)
            <span style="color: #BD93F9;">return</span> mid + <span style="color: #009F9F;">1</span>;
        <span style="color: #BD93F9;">else</span> <span style="color: #BD93F9;">if</span> (num[mid] &lt; val)
            left = mid + <span style="color: #009F9F;">1</span>;
        <span style="color: #BD93F9;">else</span> <span style="color: #BD93F9;">if</span> (num[mid] &gt;= val)
            right = mid - <span style="color: #009F9F;">1</span>;
    }
    <span style="color: #BD93F9;">return</span> -<span style="color: #009F9F;">1</span>;
}

<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">main</span>() {
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">num</span>[] = {<span style="color: #009F9F;">0</span>, <span style="color: #009F9F;">1</span>, <span style="color: #009F9F;">1</span>, <span style="color: #009F9F;">1</span>, <span style="color: #009F9F;">1</span>, <span style="color: #009F9F;">1</span>, <span style="color: #009F9F;">2</span>};
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">val</span> = <span style="color: #009F9F;">1</span>;
    printf(<span style="color: #FC9F4E;">"%d\n"</span>, binarySearch(num, <span style="color: #009F9F;">7</span>, val));
    <span style="color: #BD93F9;">return</span> <span style="color: #009F9F;">0</span>;
}
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org1e3cb7d" class="outline-3">
<h3 id="org1e3cb7d">寻找右侧边界的二分查找</h3>
<div class="outline-text-3" id="text-org1e3cb7d">
<ul class="org-ul">
<li><p>
找到最后一个重复元素<br>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #009F9F;">#include</span> <span style="color: #FC9F4E;">&lt;cstdio&gt;</span>
<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">binarySearch</span>(<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">num</span>[], <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">n</span>, <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">val</span>) {
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">left</span>  = <span style="color: #009F9F;">0</span>;
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">right</span> = n - <span style="color: #009F9F;">1</span>;
    <span style="color: #BD93F9;">while</span> (left &lt;= right) {
        <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">mid</span> = left + (right - left) / <span style="color: #009F9F;">2</span>;
        <span style="color: #BD93F9;">if</span> (left == right)
            <span style="color: #BD93F9;">return</span> mid - <span style="color: #009F9F;">1</span>;
        <span style="color: #BD93F9;">else</span> <span style="color: #BD93F9;">if</span> (num[mid] &lt;= val)
            left = mid + <span style="color: #009F9F;">1</span>;
        <span style="color: #BD93F9;">else</span> <span style="color: #BD93F9;">if</span> (num[mid] &gt; val)
            right = mid - <span style="color: #009F9F;">1</span>;
    }
    <span style="color: #BD93F9;">return</span> -<span style="color: #009F9F;">1</span>;
}

<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">main</span>() {
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">num</span>[] = {<span style="color: #009F9F;">0</span>, <span style="color: #009F9F;">1</span>, <span style="color: #009F9F;">1</span>, <span style="color: #009F9F;">1</span>, <span style="color: #009F9F;">1</span>, <span style="color: #009F9F;">1</span>, <span style="color: #009F9F;">2</span>};
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">val</span> = <span style="color: #009F9F;">1</span>;
    printf(<span style="color: #FC9F4E;">"%d\n"</span>, binarySearch(num, <span style="color: #009F9F;">7</span>, val));
    <span style="color: #BD93F9;">return</span> <span style="color: #009F9F;">0</span>;
}
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org20288fa" class="outline-3">
<h3 id="org20288fa">使用lower_bound和upper_bound查找</h3>
<div class="outline-text-3" id="text-org20288fa">
<ul class="org-ul">
<li>以上对于序列中重复元素的查找，可以直接使用头文件algorithm中的lower_bound与upper_bound<br></li>
</ul>
</div>
<div id="outline-container-orgb2cb032" class="outline-5">
<h5 id="orgb2cb032">lower_bound</h5>
<div class="outline-text-5" id="text-orgb2cb032">
<ul class="org-ul">
<li>lower_bound(begin, end, val)<br></li>
<li>[begin, end)范围内第一个小于等于val的元素的位置<br>
<ul class="org-ul">
<li>如果是数组，返回该位置指针<br></li>
<li>如果是容器，返回该位置迭代器<br></li>
</ul></li>
<li>如果没有找到val，返回可以插入该元素位置的指针或迭代器<br></li>
<li>时间复杂度O(log(begin - end))<br></li>
</ul>
</div>
</div>
<div id="outline-container-org9c5c86a" class="outline-5">
<h5 id="org9c5c86a">upper_bound</h5>
<div class="outline-text-5" id="text-org9c5c86a">
<ul class="org-ul">
<li>upper_bound(begin, end, val)<br></li>
<li>[begin, end)范围内第一个大于val的元素的位置<br>
<ul class="org-ul">
<li>如果是数组，返回该位置指针<br></li>
<li>如果是容器，返回该位置迭代器<br></li>
</ul></li>
<li>如果没有找到val，返回可以插入该元素位置的指针或迭代器<br></li>
<li><p>
时间复杂度O(log(begin - end))<br>
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #009F9F;">#include</span> <span style="color: #FC9F4E;">&lt;cstdio&gt;</span>
<span style="color: #009F9F;">#include</span> <span style="color: #FC9F4E;">&lt;algorithm&gt;</span>
<span style="color: #009F9F;">#include</span> <span style="color: #FC9F4E;">&lt;vector&gt;</span>
<span style="color: #BD93F9;">using</span> <span style="color: #BD93F9;">namespace</span> <span style="color: #009F9F;">std</span>;

<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">main</span>() {
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">num</span>[] = {<span style="color: #009F9F;">0</span>, <span style="color: #009F9F;">1</span>, <span style="color: #009F9F;">1</span>, <span style="color: #009F9F;">1</span>, <span style="color: #009F9F;">1</span>, <span style="color: #009F9F;">1</span>, <span style="color: #009F9F;">2</span>};
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">val</span> = <span style="color: #009F9F;">1</span>;
    <span style="color: #AFAFAF;">int</span>* <span style="color: #AFAFAF;">lowerPos</span> = lower_bound(num, num + <span style="color: #009F9F;">7</span>, val);
    printf(<span style="color: #FC9F4E;">"%d\n"</span>, (<span style="color: #AFAFAF;">int</span>)(lowerPos - num));
    printf(<span style="color: #FC9F4E;">"%d\n"</span>, *lowerPos);

    <span style="color: #AFAFAF;">int</span>* <span style="color: #AFAFAF;">upperPos</span> = upper_bound(num, num + <span style="color: #009F9F;">7</span>, val);
    printf(<span style="color: #FC9F4E;">"%d\n"</span>, (<span style="color: #AFAFAF;">int</span>)(upperPos - num));
    printf(<span style="color: #FC9F4E;">"%d\n"</span>, *upperPos);

    <span style="color: #AFAFAF;">vector</span>&lt;<span style="color: #AFAFAF;">int</span>&gt; <span style="color: #AFAFAF;">vec</span>;
    vec.push_back(<span style="color: #009F9F;">0</span>);
    vec.push_back(<span style="color: #009F9F;">1</span>);
    vec.push_back(<span style="color: #009F9F;">1</span>);
    vec.push_back(<span style="color: #009F9F;">1</span>);
    vec.push_back(<span style="color: #009F9F;">1</span>);
    vec.push_back(<span style="color: #009F9F;">1</span>);
    vec.push_back(<span style="color: #009F9F;">2</span>);
    <span style="color: #009F9F;">vector</span>&lt;<span style="color: #AFAFAF;">int</span>&gt;::<span style="color: #AFAFAF;">iterator</span> <span style="color: #AFAFAF;">it</span>;
    it = lower_bound(vec.begin(), vec.end(), val);
    printf(<span style="color: #FC9F4E;">"%d\n"</span>, (<span style="color: #AFAFAF;">int</span>)(it - vec.begin()));
    printf(<span style="color: #FC9F4E;">"%d\n"</span>, *it);

    it = upper_bound(vec.begin(), vec.end(), val);
    printf(<span style="color: #FC9F4E;">"%d\n"</span>, (<span style="color: #AFAFAF;">int</span>)(it - vec.begin()));
    printf(<span style="color: #FC9F4E;">"%d\n"</span>, *it);

    <span style="color: #BD93F9;">return</span> <span style="color: #009F9F;">0</span>;
}
</pre>
</div></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org14b7724" class="outline-2">
<h2 id="org14b7724">实数域上的二分</h2>
<div class="outline-text-2" id="text-org14b7724">
<p>
在实数域上二分较为简单，确定好所需的精度eps，以l + eps &lt; r为循环条件，每次根据在mid上的判定选择r = mid或l = mid分支之一即可，一般需要保留k位小数时，则取eps = 10^(-(k+2))<br>
</p>
</div>
</div>
<div id="outline-container-org3842110" class="outline-2">
<h2 id="org3842110">三分求单峰函数极值</h2>
<div class="outline-text-2" id="text-org3842110">
<p>
有一类函数被称为单峰函数，它们拥有唯一的极大值点，在极大值点左侧严格单调上升，右侧严格单调下降：或者拥有唯一的极小值点，在极小值点左侧严格单调下降，在极小值点右侧严格单调上升，为了避免混淆，我们也称后一种为单谷函数。对于单峰函数或单谷函数，可以通过三分法求其极值<br>
以单峰函数f为例，在函数定义域[l, r]上任取两个点lmid与rmid，把函数分为三段。<br>
</p>
<ol class="org-ol">
<li>若f(lmid) &lt; f(rmid)，则lmid与rmid要么同时处于极大值点左侧(单调上升函数段)，要么处于极大值点两侧。无论那种情况下，极大值点都在lmid右侧，可令l = lmid<br></li>
<li>同理，若f(lmid) &gt; f(rmid)，则极大值点一定在rmid左侧，可令r = rmid<br>
如果我们取lmid与rmid为三等分点，那么定义域范围每次缩小1/3，如果我们取lmid与rmid在二等分点两侧及其接近的地方，嘛呢定义域范围每次近似缩小1/2，通过log级别的时间复杂度即可在指定精度下求出极值，这就是三分法<br>
注意：这里强调了严格单调性，如果函数中存在一段值相等的部分，那么三分法就不在适用<br></li>
</ol>
</div>
</div>
<div id="outline-container-org8015577" class="outline-2">
<h2 id="org8015577">二分答案转化为判定</h2>
</div>
<div id="outline-container-org5eacd98" class="outline-2">
<h2 id="org5eacd98">二分拓展</h2>
<div class="outline-text-2" id="text-org5eacd98">
<p>
二分的思想其实就是通过 mid = (left + right) / 2 不断逼近的思想，它不止应用于查找<br>
</p>
</div>
<div id="outline-container-org40c8397" class="outline-3">
<h3 id="org40c8397"><a href="Algorithm-快速幂.html">快速幂</a></h3>
</div>
<div id="outline-container-org719861c" class="outline-3">
<h3 id="org719861c">使用二分法计算 \(\sqrt{2}\) 的近似值</h3>
<div class="outline-text-3" id="text-org719861c">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #009F9F;">#include</span> <span style="color: #FC9F4E;">&lt;cstdio&gt;</span>
<span style="color: #BD93F9;">const</span> <span style="color: #AFAFAF;">double</span> <span style="color: #AFAFAF;">eps</span> = <span style="color: #009F9F;">1e-5</span>;
<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">main</span>() {
    <span style="color: #AFAFAF;">double</span> <span style="color: #AFAFAF;">left</span>  = <span style="color: #009F9F;">1</span>;
    <span style="color: #AFAFAF;">double</span> <span style="color: #AFAFAF;">right</span> = <span style="color: #009F9F;">2</span>;
    <span style="color: #AFAFAF;">double</span> <span style="color: #AFAFAF;">mid</span>;
    <span style="color: #BD93F9;">while</span> (right - left &gt; eps) {
        mid = (right + left) / <span style="color: #009F9F;">2</span>;
        <span style="color: #BD93F9;">if</span> (mid * mid &lt; <span style="color: #009F9F;">2</span>)
            left = mid;
        <span style="color: #BD93F9;">else</span>
            right = mid;
    }
    printf(<span style="color: #FC9F4E;">"%f\n"</span>, mid);
    <span style="color: #BD93F9;">return</span> <span style="color: #009F9F;">0</span>;
}
</pre>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
