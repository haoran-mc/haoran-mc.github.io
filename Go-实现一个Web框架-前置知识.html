<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-12-25 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>HTTP基础</title>
<meta name="author" content="L.M.haoran" />
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved." />
<meta name="generator" content="Org Mode" />
<link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
           <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
           <script type="module" src="static/js/main.js" defer></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">HTTP基础</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org4de6730">标准库启动Web服务</a></li>
<li><a href="#org5b17d1a">实现 http.Handler 接口</a></li>
<li><a href="#orga9ed745">Gee 框架的雏形</a>
<ul>
<li><a href="#org79977b4">go.mod</a></li>
<li><a href="#orgb0208d7">main.go</a></li>
<li><a href="#orgc32f9be">gee.go</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org4de6730" class="outline-2">
<h2 id="org4de6730">标准库启动Web服务</h2>
<div class="outline-text-2" id="text-org4de6730">
<p>
Go语言内置了 <code>net/http</code> 库，封装了 HTTP 网络编程的基础接口，我们实现的是 <code>Gee</code> Web框架便是基于 <code>net/http</code> 的，简单介绍下 <code>net/http</code> 库的使用。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #e45649;">package</span> main

<span style="color: #e45649;">import</span> (
    <span style="color: #50a14f;">"fmt"</span>
    <span style="color: #50a14f;">"log"</span>
    <span style="color: #50a14f;">"net/http"</span>
)

<span style="color: #e45649;">func</span> <span style="color: #a626a4;">main</span>() {
    http.<span style="color: #a626a4;">HandleFunc</span>(<span style="color: #50a14f;">"/"</span>, indexHandler)
    http.<span style="color: #a626a4;">HandleFunc</span>(<span style="color: #50a14f;">"/hello"</span>, helloHandler)
    log.<span style="color: #a626a4;">Fatal</span>(http.<span style="color: #a626a4;">ListenAndServe</span>(<span style="color: #50a14f;">":9999"</span>, <span style="color: #b751b6;">nil</span>))
}

<span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">handler echoes r.URL.Path</span>
<span style="color: #e45649;">func</span> <span style="color: #a626a4;">indexHandler</span>(<span style="color: #6a1868;">w</span> <span style="color: #986801;">http.ResponseWriter</span>, <span style="color: #6a1868;">req</span> *<span style="color: #986801;">http.Request</span>) {
    fmt.<span style="color: #a626a4;">Fprintf</span>(w, <span style="color: #50a14f;">"URL.Path = %q\n"</span>, req.URL.Path)
}

<span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">handler echoes r.URL.Header</span>
<span style="color: #e45649;">func</span> <span style="color: #a626a4;">helloHandler</span>(<span style="color: #6a1868;">w</span> <span style="color: #986801;">http.ResponseWriter</span>, <span style="color: #6a1868;">req</span> *<span style="color: #986801;">http.Request</span>) {
    <span style="color: #e45649;">for</span> <span style="color: #6a1868;">k</span>, <span style="color: #6a1868;">v</span> := <span style="color: #e45649;">range</span> req.Header {
        fmt.<span style="color: #a626a4;">Fprintf</span>(w, <span style="color: #50a14f;">"Header[%q] = %q\n"</span>, k, v)
    }
}
</pre>
</div>

<p>
<code>http.HandleFunc</code> 函数第一个参数是路由，第二个参数是 <code>Handler</code> 函数，其参数固定是请求（ <code>*http.Request</code> ）和响应（ <code>http.ResponseWriter</code> ）。<br>
</p>

<p>
<a href="wiki.html#org202be7c">handle 与 handler 的区别</a><br>
</p>

<p>
我们设置了两个路由， <code>/</code> 和 <code>/hello</code> ，分别绑定 <i>indexHandler</i> 和 <i>helloHandler</i> ，根据不同的 HTTP 请求会调用不同的处理函数。 <span class="underline">处理函数内部（服务端）将客户端请求的信息写入到响应（ <code>w http.ResponseWriter</code> ）中，函数内部还可以设置 HTTP 响应报文，比如响应状态码、响应报文头属性（Content-Type、Cache-Control、Set-Cookie &#x2026;&#x2026;）、响应报文体等。</span><br>
</p>

<p>
<a href="Network-HTTP请求行、请求头、请求体详解.html">HTTP请求行、请求头、请求体详解</a><br>
</p>

<p>
根据我们的代码，访问 <code>/</code> ，响应是 <code>URL.Path = /</code> ，而 <code>/hello</code> 的响应则是请求头（header）中的键值对信息。<br>
</p>

<p>
用 <code>curl</code> 这个工具测试一下，将会得到如下结果：<br>
</p>

<pre class="example" id="org00d1600">
$ curl http://localhost:9999/
URL.Path = "/"
$ curl http://localhost:9999/hello
Header["User-Agent"] = ["curl/7.68.0"]
Header["Accept"] = ["*/*"]
</pre>

<p>
<i>main</i> 函数的最后一行，是用来启动Web服务的，第一个参数是地址， <code>:9999</code> 表示在 <i>9999</i> 端口监听。 <span class="underline">而第二个参数则代表所有的 HTTP 请求的实例， <code>nil</code> 代表使用标准库中的实例处理。第二个参数，则是我们基于 <code>net/http</code> 标准库实现 Web 框架的入口（我们通过第二个参数这个入口实现web框架）。</span><br>
</p>
</div>
</div>
<div id="outline-container-org5b17d1a" class="outline-2">
<h2 id="org5b17d1a">实现 http.Handler 接口</h2>
<div class="outline-text-2" id="text-org5b17d1a">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #e45649;">package</span> http

<span style="color: #e45649;">type</span> <span style="color: #986801;">Handler</span> <span style="color: #e45649;">interface</span> {
    <span style="color: #a626a4;">ServeHTTP</span>(<span style="color: #6a1868;">w</span> <span style="color: #986801;">ResponseWriter</span>, <span style="color: #6a1868;">r</span> *<span style="color: #986801;">Request</span>)
}

<span style="color: #e45649;">func</span> <span style="color: #a626a4;">ListenAndServe</span>(<span style="color: #6a1868;">address</span> <span style="color: #986801;">string</span>, <span style="color: #6a1868;">h</span> <span style="color: #986801;">Handler</span>) <span style="color: #986801;">error</span>
</pre>
</div>

<p>
第二个参数的类型是什么呢？通过查看 <code>net/http</code> 的源码可以发现， <code>Handler</code> 是一个接口，需要实现方法 <i>ServeHTTP</i> ， <span class="underline">也就是说，只要传入任何实现了 <i>ServerHTTP</i> 接口的实例，所有的 HTTP 请求，就都交给了该实例处理了</span> ，马上来试一试吧。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #e45649;">package</span> main

<span style="color: #e45649;">import</span> (
    <span style="color: #50a14f;">"fmt"</span>
    <span style="color: #50a14f;">"log"</span>
    <span style="color: #50a14f;">"net/http"</span>
)

<span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">Engine is the union handler for all requests.</span>
<span style="color: #e45649;">type</span> <span style="color: #986801;">Engine</span> <span style="color: #e45649;">struct</span>{}

<span style="color: #e45649;">func</span> (<span style="color: #6a1868;">engine</span> *<span style="color: #986801;">Engine</span>) <span style="color: #a626a4;">ServeHTTP</span>(<span style="color: #6a1868;">w</span> <span style="color: #986801;">http.ResponseWriter</span>, <span style="color: #6a1868;">req</span> *<span style="color: #986801;">http.Request</span>) {
    <span style="color: #e45649;">switch</span> req.URL.Path {
    <span style="color: #e45649;">case</span> <span style="color: #50a14f;">"/"</span>:
        _, _ = fmt.<span style="color: #a626a4;">Fprintf</span>(w, <span style="color: #50a14f;">"URL.Path = %q\n"</span>, req.URL.Path)
    <span style="color: #e45649;">case</span> <span style="color: #50a14f;">"/hello"</span>:
        <span style="color: #e45649;">for</span> <span style="color: #6a1868;">k</span>, <span style="color: #6a1868;">v</span> := <span style="color: #e45649;">range</span> req.Header {
            _, _ = fmt.<span style="color: #a626a4;">Fprintf</span>(w, <span style="color: #50a14f;">"Header[%q] = %q\n"</span>, k, v)
        }
    <span style="color: #e45649;">default</span>:
        _, _ = fmt.<span style="color: #a626a4;">Fprintf</span>(w, <span style="color: #50a14f;">"404 NOT FOUND: %s\n"</span>, req.URL)
    }
}

<span style="color: #e45649;">func</span> <span style="color: #a626a4;">main</span>() {
    <span style="color: #6a1868;">engine</span> := <span style="color: #a626a4;">new</span>(<span style="color: #986801;">Engine</span>)
    log.<span style="color: #a626a4;">Fatal</span>(http.<span style="color: #a626a4;">ListenAndServe</span>(<span style="color: #50a14f;">":9999"</span>, engine))
}
</pre>
</div>

<ul class="org-ul">
<li>我们定义了一个空的结构体 <code>Engine</code> ，实现了方法 <code>ServeHTTP</code> 。这个方法有 2 个参数，第二个参数是 <i>Request</i> ，该对象包含了该 HTTP 请求的所有信息，比如请求地址、Header 和 Body 等信息；第一个参数是 <i>ResponseWriter</i> ， <span class="underline">利用 <i>ResponseWriter</i> 可以构造针对该请求的响应（也就是设置HTTP响应报文中的信息 <a href="Network-HTTP请求行、请求头、请求体详解.html">HTTP请求行、请求头、请求体详解</a>）</span> 。<br></li>
<li>在 <i>main</i> 函数中，我们给 <i>ListenAndServe</i> 方法的第二个参数传入了刚才创建的 <i>engine</i> 实例。 <span class="underline">至此，我们走出了实现 Web 框架的第一步</span> ，即，将所有的 HTTP 请求转向了我们自己的处理逻辑。还记得吗，在实现 <code>Engine</code> 之前，我们调用 <i>http.HandleFunc</i> 实现了路由和 Handle 的映射，也就是只能针对具体的路由写处理逻辑，比如 <code>/hello</code> 。但是在实现 <code>Engine</code> 之后，我们拦截了所有的 HTTP 请求，拥有了统一的控制入口。在这里我们可以自由定义路由映射的规则，也可以同意添加一些处理逻辑，例如日志、异常处理等。<br></li>
<li>代码的运行结果与之前是一致的。<br></li>
</ul>
</div>
</div>
<div id="outline-container-orga9ed745" class="outline-2">
<h2 id="orga9ed745">Gee 框架的雏形</h2>
<div class="outline-text-2" id="text-orga9ed745">
<p>
我们接下来重新组织上面的代码，搭建出整个框架的雏形。<br>
</p>

<p>
最终的代码目录结构是这样的：<br>
</p>

<pre class="example" id="org08d713b">
gee/
 |--gee.go
 |--go.mod
main.go
go.mod
</pre>
</div>
<div id="outline-container-org79977b4" class="outline-3">
<h3 id="org79977b4">go.mod</h3>
<div class="outline-text-3" id="text-org79977b4">
<pre class="example" id="org2eb9c2c">
module example

go 1.13

require gee v0.0.0

replace gee =&gt; ./gee
</pre>

<ul class="org-ul">
<li>在 <code>go.mod</code> 中使用 <code>replace</code> 将 gee 指向 <code>./gee</code><br></li>
</ul>

<blockquote>
<p>
从 go 1.11 版本开始，引用相对路径的 package 需要使用上述方式。<br>
</p>
</blockquote>
</div>
</div>
<div id="outline-container-orgb0208d7" class="outline-3">
<h3 id="orgb0208d7">main.go</h3>
<div class="outline-text-3" id="text-orgb0208d7">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #e45649;">package</span> main

<span style="color: #e45649;">import</span> (
    <span style="color: #50a14f;">"fmt"</span>
    <span style="color: #50a14f;">"net/http"</span>

    <span style="color: #50a14f;">"gee"</span>
)

<span style="color: #e45649;">func</span> <span style="color: #a626a4;">main</span>() {
    <span style="color: #6a1868;">r</span> := gee.<span style="color: #a626a4;">New</span>()
    r.<span style="color: #a626a4;">GET</span>(<span style="color: #50a14f;">"/"</span>, <span style="color: #e45649;">func</span>(<span style="color: #6a1868;">w</span> <span style="color: #986801;">http.ResponseWriter</span>, <span style="color: #6a1868;">req</span> *<span style="color: #986801;">http.Request</span>) {
        fmt.<span style="color: #a626a4;">Fprintf</span>(w, <span style="color: #50a14f;">"URL.Path = %q\n"</span>, req.URL.Path)
    })

    r.<span style="color: #a626a4;">GET</span>(<span style="color: #50a14f;">"/hello"</span>, <span style="color: #e45649;">func</span>(<span style="color: #6a1868;">w</span> <span style="color: #986801;">http.ResponseWriter</span>, <span style="color: #6a1868;">req</span> *<span style="color: #986801;">http.Request</span>) {
        <span style="color: #e45649;">for</span> <span style="color: #6a1868;">k</span>, <span style="color: #6a1868;">v</span> := <span style="color: #e45649;">range</span> req.Header {
            fmt.<span style="color: #a626a4;">Fprintf</span>(w, <span style="color: #50a14f;">"Header[%q] = %q\n"</span>, k, v)
        }
    })

    r.<span style="color: #a626a4;">Run</span>(<span style="color: #50a14f;">":9999"</span>)
}
</pre>
</div>

<p>
看到这里，如果你使用过 <i>gin</i> 框架的话，肯定会觉得无比的亲切。 <i>gee</i> 框架的设计以及 API 均参考了 <i>gin</i> 。使用 <code>New()</code> 创建 gee 的实例，使用 <code>GET()</code> 方法添加路由，最后使用 <code>Run()</code> 启动 Web 服务。这里的路由，只是静态路由，不支持 <code>/hello/:name</code> 这样的动态路由，动态路由我们将在下一次实现。<br>
</p>
</div>
</div>
<div id="outline-container-orgc32f9be" class="outline-3">
<h3 id="orgc32f9be">gee.go</h3>
<div class="outline-text-3" id="text-orgc32f9be">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #e45649;">package</span> gee

<span style="color: #e45649;">import</span> (
    <span style="color: #50a14f;">"fmt"</span>
    <span style="color: #50a14f;">"net/http"</span>
)

<span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">HandlerFunc defines the request handler used by gee</span>
<span style="color: #e45649;">type</span> <span style="color: #986801;">HandlerFunc</span> <span style="color: #e45649;">func</span>(<span style="color: #986801;">http.ResponseWriter</span>, *<span style="color: #986801;">http.Request</span>)

<span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">Engine implement the interface of ServeHTTP</span>
<span style="color: #e45649;">type</span> <span style="color: #986801;">Engine</span> <span style="color: #e45649;">struct</span> {
    router <span style="color: #e45649;">map</span>[<span style="color: #986801;">string</span>]<span style="color: #986801;">HandlerFunc</span>
}

<span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">New is the constructor of gee.Engine</span>
<span style="color: #e45649;">func</span> <span style="color: #a626a4;">New</span>() *<span style="color: #986801;">Engine</span> {
    <span style="color: #e45649;">return</span> &amp;<span style="color: #986801;">Engine</span>{<span style="color: #b751b6;">router</span>: <span style="color: #a626a4;">make</span>(<span style="color: #e45649;">map</span>[<span style="color: #986801;">string</span>]<span style="color: #986801;">HandlerFunc</span>)}
}

<span style="color: #e45649;">func</span> (<span style="color: #6a1868;">engine</span> *<span style="color: #986801;">Engine</span>) <span style="color: #a626a4;">addRoute</span>(<span style="color: #6a1868;">method</span> <span style="color: #986801;">string</span>, <span style="color: #6a1868;">pattern</span> <span style="color: #986801;">string</span>, <span style="color: #6a1868;">handler</span> <span style="color: #986801;">HandlerFunc</span>) {
    <span style="color: #6a1868;">key</span> := method + <span style="color: #50a14f;">"-"</span> + pattern
    engine.router[key] = handler
}

<span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">GET defines the method to add GET request</span>
<span style="color: #e45649;">func</span> (<span style="color: #6a1868;">engine</span> *<span style="color: #986801;">Engine</span>) <span style="color: #a626a4;">GET</span>(<span style="color: #6a1868;">pattern</span> <span style="color: #986801;">string</span>, <span style="color: #6a1868;">handler</span> <span style="color: #986801;">HandlerFunc</span>) {
    engine.<span style="color: #a626a4;">addRoute</span>(<span style="color: #50a14f;">"GET"</span>, pattern, handler)
}

<span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">POST defines the method to add POST request</span>
<span style="color: #e45649;">func</span> (<span style="color: #6a1868;">engine</span> *<span style="color: #986801;">Engine</span>) <span style="color: #a626a4;">POST</span>(<span style="color: #6a1868;">pattern</span> <span style="color: #986801;">string</span>, <span style="color: #6a1868;">handler</span> <span style="color: #986801;">HandlerFunc</span>) {
    engine.<span style="color: #a626a4;">addRoute</span>(<span style="color: #50a14f;">"POST"</span>, pattern, handler)
}

<span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">Run defines the method to start a http server</span>
<span style="color: #e45649;">func</span> (<span style="color: #6a1868;">engine</span> *<span style="color: #986801;">Engine</span>) <span style="color: #a626a4;">Run</span>(<span style="color: #6a1868;">addr</span> <span style="color: #986801;">string</span>) (<span style="color: #6a1868;">err</span> <span style="color: #986801;">error</span>) {
    <span style="color: #e45649;">return</span> http.<span style="color: #a626a4;">ListenAndServe</span>(addr, engine)
}

<span style="color: #e45649;">func</span> (<span style="color: #6a1868;">engine</span> *<span style="color: #986801;">Engine</span>) <span style="color: #a626a4;">ServeHTTP</span>(<span style="color: #6a1868;">w</span> <span style="color: #986801;">http.ResponseWriter</span>, <span style="color: #6a1868;">req</span> *<span style="color: #986801;">http.Request</span>) {
    <span style="color: #6a1868;">key</span> := req.Method + <span style="color: #50a14f;">"-"</span> + req.URL.Path
    <span style="color: #e45649;">if</span> <span style="color: #6a1868;">handler</span>, <span style="color: #6a1868;">ok</span> := engine.router[key]; ok {
        <span style="color: #a626a4;">handler</span>(w, req)
    } <span style="color: #e45649;">else</span> {
        fmt.<span style="color: #a626a4;">Fprintf</span>(w, <span style="color: #50a14f;">"404 NOT FOUND: %s\n"</span>, req.URL)
    }
}
</pre>
</div>

<p>
那么 <code>gee.go</code> 就是重头戏了。我们重点介绍一下这部分的实现。<br>
</p>

<ul class="org-ul">
<li>首先定义了类型 <code>HandlerFunc</code> ，这是提供给框架用户的，用来定义路由映射的处理方法。 我们在 <code>Engine</code> 中，添加了一张路由映射表 <code>router</code> ，key 由请求方法和静态路由地址构成，例如 <code>GET-/</code> 、 <code>GET-/hello</code> 、 <code>POST-/hello</code> ，这样针对相同的路由，如果请求方法不同，可以映射不同的处理方法(Handler)，value 是用户映射的处理方法 <span class="underline">（也就是 RESTful 风格，否则 <code>/hello</code> 这个 URL 路径只能映射到一个 handler 函数）</span> 。<br></li>
<li>当用户调用 <code>(*Engine).GET()</code> 方法时，会将路由和处理方法注册到映射表 <i>router</i> 中， <code>(*Engine).Run()</code> 方法，是 <i>ListenAndServe</i> 的包装。<br></li>
<li><code>Engine</code> 实现的 <i>ServeHTTP</i> 方法的作用就是，解析请求的路径，查找路由映射表，如果查到，就执行注册的处理方法。如果查不到，就返回 <i>404 NOT FOUND</i> 。<br></li>
</ul>

<p>
执行 <code>go run main.go</code> ，再用 <i>curl</i> 工具访问，结果与最开始的一致。<br>
</p>

<pre class="example" id="org291d8c2">
$ curl http://localhost:9999/
URL.Path = "/"
$ curl http://localhost:9999/hello
Header["User-Agent"] = ["curl/7.68.0"]
Header["Accept"] = ["*/*"]
$ curl http://localhost:9999/world
404 NOT FOUND: /world
</pre>

<p>
至此，整个 <code>Gee</code> 框架的原型已经出来了。实现了路由映射表，提供了用户注册静态路由的方法，包装了启动服务的函数。当然，到目前为止，我们还没有实现比 <code>net/http</code> 标准库更强大的能力，不用担心，很快就可以将动态路由、中间件等功能添加上去了。<br>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-12-25</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
