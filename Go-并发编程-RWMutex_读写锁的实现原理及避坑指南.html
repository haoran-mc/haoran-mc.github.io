<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-06-28 Tue 23:03 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>RWMutex 读写锁的实现原理及避坑指南</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">RWMutex 读写锁的实现原理及避坑指南</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org71d0444">引言</a></li>
<li><a href="#org01e3964">什么是 RWMutex</a></li>
<li><a href="#org566ff12">RWMutex 的实现原理</a>
<ul>
<li><a href="#orge5d5035">RLock/RUnlock 的实现</a></li>
<li><a href="#org0824cf1">Lock</a></li>
<li><a href="#org1c4d91c">Unlock</a></li>
</ul>
</li>
<li><a href="#org52585f5">RWMutex 的 3 个踩坑点</a>
<ul>
<li><a href="#org5719381">坑点1：不可复制</a></li>
<li><a href="#org8a7b541">坑点2：重入导致死锁</a></li>
<li><a href="#org1b1b3ad">坑点3：释放未加锁的 RWMutex</a></li>
</ul>
</li>
<li><a href="#org747b144">流行的 Go 开发项目中的坑</a>
<ul>
<li><a href="#org7c14eda">Docker</a>
<ul>
<li><a href="#orgc8793c3">issue 36840</a></li>
</ul>
</li>
<li><a href="#org5fa1851">Kubernetes</a>
<ul>
<li><a href="#org1e929e8">issue 62464</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org15d8499">总结</a></li>
</ul>
</div>
</div>

<div id="outline-container-org71d0444" class="outline-2">
<h2 id="org71d0444">引言</h2>
<div class="outline-text-2" id="text-org71d0444">
<p>
我们使用 <code>Mutex</code> 来保证读写共享资源的安全性，不管是读还是写，我们都通过 Mutex 来保证只有一个 goroutine 访问共享资源，这在某些情况下有点“浪费”。比如说，在写少读多的情况下，即使一段时间内没有写操作，大量并发的读访问也不得不在 Mutex 的保护下变成了串行访问，这个时候，使用 Mutex，对性能的影响就比较大。<br>
</p>

<p>
怎么办呢？区分读写操作。<br>
</p>

<p>
如果某个读操作的 goroutine 持有了锁，在这种情况下，其它读操作的 goroutine 就不必一直傻傻地等待了，而是可以并发地访问共享变量，这样我们就可以 <b>将串行的读变成并行读</b> ，提高读操作的性能。当写操作的 goroutine 持有锁的时候，它就是一个排外锁，其它的写操作和读操作的 goroutine，需要阻塞等待持有这个锁的 goroutine 释放锁。<br>
</p>

<p>
这一类并发读写问题叫作 <a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem">readers-writers</a> 问题，意思就是，同时可能有多个读或者多个写，但是只要有一个线程在执行写操作，其它的线程都不能执行读写操作。<br>
</p>

<p>
Go 标准库中的 RWMutex（读写锁）用来解决这类 readers-writers 问题。<br>
</p>
</div>
</div>
<div id="outline-container-org01e3964" class="outline-2">
<h2 id="org01e3964">什么是 RWMutex</h2>
<div class="outline-text-2" id="text-org01e3964">
<p>
标准库中的 <code>RWMutex</code> 是一个 reader/writer 互斥锁。 <code>RWMutex</code> 在某一时刻只能由任意数量的 reader 持有，或者是只被单个的 writer 持有。<br>
</p>

<p>
<code>RWMutex</code> 的方法也很少，总共有 5 个。<br>
</p>

<ul class="org-ul">
<li><b>Lock/Unlock：写操作时调用的方法</b> 。如果锁已经被 reader 或者 writer 持有，那么， <code>Lock</code> 方法会一直阻塞，直到能获取到锁； <code>Unlock</code> 则是配对的释放锁的方法。<br></li>
<li><b>RLock/RUnlock：读操作时调用的方法</b> 。如果锁已经被 writer 持有的话， <code>RLock</code> 方法会一直阻塞，直到能获取到锁，否则就直接返回；而 <code>RUnlock</code> 是 reader 释放锁的方法。<br></li>
<li><b>RLocker</b> ：这个方法的作用是为读操作返回一个 Locker 接口的对象。它的 Lock 方法会调用 RWMutex 的 RLock 方法，它的 Unlock 方法会调用 RWMutex 的 RUnlock 方法。<br></li>
</ul>

<p>
<code>RWMutex</code> 的零值是未加锁的状态，所以，当你使用 <code>RWMutex</code> 的时候，无论是声明变量，还是嵌入到其它 <code>struct</code> 中，都不必显式地初始化。<br>
</p>

<p>
以计数器为例，来说明一下，如何使用 <code>RWMutex</code> 保护共享资源。计数器的 <code>count++</code> 操作是写操作，而获取 <code>count</code> 的值是读操作，这个场景非常适合读写锁，因为读操作可以并行执行，写操作时只允许一个线程执行，这正是 readers-writers 问题。<br>
</p>

<p>
在这个例子中，使用 10 个 goroutine 进行读操作，每读取一次，sleep 1 毫秒，同时，还有一个 gorotine 进行写操作，每一秒写一次，这是一个 1 writer-n reader 的读写场景，而且写操作还不是很频繁（一秒一次）：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">counter</span> <span style="color: #df005f; font-weight: bold;">Counter</span>
    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := 0; i &lt; 10; i++ { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">10&#20010;reader</span>
        <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
            <span style="color: #268bd2; font-weight: bold;">for</span> {
                counter.<span style="color: #d75fd7; font-weight: bold;">Count</span>() <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35745;&#25968;&#22120;&#35835;&#25805;&#20316;</span>
                time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(time.Millisecond)
            }
        }()
    }

    <span style="color: #268bd2; font-weight: bold;">for</span> { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#19968;&#20010;writer</span>
        counter.<span style="color: #d75fd7; font-weight: bold;">Incr</span>() <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35745;&#25968;&#22120;&#20889;&#25805;&#20316;</span>
        time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(time.Second)
    }
}
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#19968;&#20010;&#32447;&#31243;&#23433;&#20840;&#30340;&#35745;&#25968;&#22120;</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Counter</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    mu    <span style="color: #df005f; font-weight: bold;">sync.RWMutex</span>
    count <span style="color: #df005f; font-weight: bold;">uint64</span>
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20351;&#29992;&#20889;&#38145;&#20445;&#25252;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">Counter</span>) <span style="color: #d75fd7; font-weight: bold;">Incr</span>() {
    c.mu.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
    c.count++
    c.mu.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20351;&#29992;&#35835;&#38145;&#20445;&#25252;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">Counter</span>) <span style="color: #d75fd7; font-weight: bold;">Count</span>() <span style="color: #df005f; font-weight: bold;">uint64</span> {
    c.mu.<span style="color: #d75fd7; font-weight: bold;">RLock</span>()
    <span style="color: #268bd2; font-weight: bold;">defer</span> c.mu.<span style="color: #d75fd7; font-weight: bold;">RUnlock</span>()
    <span style="color: #268bd2; font-weight: bold;">return</span> c.count
}
</pre>
</div>

<p>
可以看到， <code>Incr</code> 方法会修改计数器的值，是一个写操作，我们使用 Lock/Unlock 进行保护。 <code>Count</code> 方法会读取当前计数器的值，是一个读操作，我们使用 RLock/RUnlock 方法进行保护。<br>
</p>

<p>
<code>Incr</code> 方法每秒才调用一次，所以，writer 竞争锁的频次是比较低的，而 10 个 goroutine 每毫秒都要执行一次查询，通过读写锁，可以极大提升计数器的性能，因为在读取的时候，可以并发进行。如果使用 <code>Mutex</code> ，性能就不会像读写锁这么好。因为多个 reader 并发读的时候，使用互斥锁导致了 reader 要排队读的情况，没有 <code>RWMutex</code> 并发读的性能好。<br>
</p>

<p>
<span class="underline">如果你遇到可以明确区分 reader 和 writer goroutine 的场景，且有大量的并发读、少量的并发写，并且有强烈的性能需求，你就可以考虑使用读写锁 RWMutex 替换 Mutex。</span><br>
</p>

<p>
在实际使用 <code>RWMutex</code> 的时候，如果我们在 <code>struct</code> 中使用 <code>RWMutex</code> 保护某个字段，一般会把它和这个字段放在一起，用来指示两个字段是一组字段。除此之外，我们还可以采用匿名字段的方式嵌入 <code>struct</code> ，这样，在使用这个 <code>struct</code> 时，我们就可以直接调用 Lock/Unlock、RLock/RUnlock 方法了。<br>
</p>
</div>
</div>
<div id="outline-container-org566ff12" class="outline-2">
<h2 id="org566ff12">RWMutex 的实现原理</h2>
<div class="outline-text-2" id="text-org566ff12">
<p>
<code>RWMutex</code> 是很常见的并发原语，很多编程语言的库都提供了类似的并发类型。 <code>RWMutex</code> 一般都是基于互斥锁、条件变量（condition variables）或者信号量（semaphores）等并发原语来实现。Go 标准库中的 <code>RWMutex</code> 是基于 <code>Mutex</code> 实现的。<br>
</p>

<p>
readers-writers 问题一般有三类，基于对读和写操作的优先级，读写锁的设计和实现也分成三类。<br>
</p>

<ul class="org-ul">
<li><b>Read-preferring</b> ：读优先的设计可以提供很高的并发性，但是，在竞争激烈的情况下可能会导致写饥饿。这是因为，如果有大量的读，这种设计会导致只有所有的读都释放了锁之后，写才可能获取到锁。<br></li>
<li><b>Write-preferring</b> ：写优先的设计意味着，如果已经有一个 writer 在等待请求锁的话，它会阻止新来的请求锁的 reader 获取到锁，所以优先保障 writer。当然，如果有一些 reader 已经请求了锁的话，新请求的 writer 也会等待已经存在的 reader 都释放锁之后才能获取。所以，写优先级设计中的优先权是针对新来的请求而言的。这种设计主要避免了 writer 的饥饿问题。<br></li>
<li><b>不指定优先级</b> ：这种设计比较简单，不区分 reader 和 writer 优先级，某些场景下这种不指定优先级的设计反而更有效，因为第一类优先级会导致写饥饿，第二类优先级可能会导致读饥饿，这种不指定优先级的访问不再区分读写，大家都是同一个优先级，解决了饥饿的问题。<br></li>
</ul>

<p>
Go 标准库中的 <code>RWMutex</code> 设计是 Write-preferring 方案。一个正在阻塞的 Lock 调用会排除新的 reader 请求到锁。<br>
</p>

<p>
<code>RWMutex</code> 包含一个 <code>Mutex</code> ，以及四个辅助字段 <code>writerSem</code> 、 <code>readerSem</code> 、 <code>readerCount</code> 和 <code>readerWait</code> ：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">RWMutex</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    w           <span style="color: #df005f; font-weight: bold;">Mutex</span>   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20114;&#26021;&#38145;&#35299;&#20915;&#22810;&#20010;writer&#30340;&#31454;&#20105;</span>
    writerSem   <span style="color: #df005f; font-weight: bold;">uint32</span>  <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">writer&#20449;&#21495;&#37327;</span>
    readerSem   <span style="color: #df005f; font-weight: bold;">uint32</span>  <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">reader&#20449;&#21495;&#37327;</span>
    readerCount <span style="color: #df005f; font-weight: bold;">int32</span>   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">reader&#30340;&#25968;&#37327;</span>
    readerWait  <span style="color: #df005f; font-weight: bold;">int32</span>   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">writer&#31561;&#24453;&#23436;&#25104;&#30340;reader&#30340;&#25968;&#37327;</span>
}

<span style="color: #268bd2; font-weight: bold;">const</span> <span style="color: #d75fd7;">rwmutexMaxReaders</span> = 1 &lt;&lt; 30
</pre>
</div>

<ul class="org-ul">
<li>字段 w：为 writer 的竞争锁而设计；<br></li>
<li>字段 readerCount：记录当前 reader 的数量（以及是否有 writer 竞争锁）；<br></li>
<li>readerWait：记录 writer 请求锁时需要等待 read 完成的 reader 的数量；<br></li>
<li>writerSem 和 readerSem：都是为了阻塞设计的信号量。<br></li>
</ul>

<p>
常量 <code>rwmutexMaxReaders</code> 定义了最大的 reader 数量。<br>
</p>
</div>
<div id="outline-container-orge5d5035" class="outline-3">
<h3 id="orge5d5035">RLock/RUnlock 的实现</h3>
<div class="outline-text-3" id="text-orge5d5035">
<p>
移除了 race 等无关紧要的代码后的 <code>RLock</code> 和 <code>RUnlock</code> 方法：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">rw</span> *<span style="color: #df005f; font-weight: bold;">RWMutex</span>) <span style="color: #d75fd7; font-weight: bold;">RLock</span>() {
    <span style="color: #268bd2; font-weight: bold;">if</span> atomic.<span style="color: #d75fd7; font-weight: bold;">AddInt32</span>(&amp;rw.readerCount, 1) &lt; 0 {
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">rw.readerCount&#26159;&#36127;&#20540;&#30340;&#26102;&#20505;&#65292;&#24847;&#21619;&#30528;&#27492;&#26102;&#26377;writer&#31561;&#24453;&#35831;&#27714;&#38145;&#65292;&#22240;&#20026;writer&#20248;&#20808;&#32423;&#39640;&#65292;&#25152;&#20197;&#25226;&#21518;&#26469;&#30340;reader&#38459;&#22622;&#20241;&#30496;</span>
        <span style="color: #d75fd7; font-weight: bold;">runtime_SemacquireMutex</span>(&amp;rw.readerSem, <span style="color: #d75fd7;">false</span>, 0)
    }
}
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">rw</span> *<span style="color: #df005f; font-weight: bold;">RWMutex</span>) <span style="color: #d75fd7; font-weight: bold;">RUnlock</span>() {
    <span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #8787d7;">r</span> := atomic.<span style="color: #d75fd7; font-weight: bold;">AddInt32</span>(&amp;rw.readerCount, -1); r &lt; 0 {
        rw.<span style="color: #d75fd7; font-weight: bold;">rUnlockSlow</span>(r) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#26377;&#31561;&#24453;&#30340;writer</span>
    }
}
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">rw</span> *<span style="color: #df005f; font-weight: bold;">RWMutex</span>) <span style="color: #d75fd7; font-weight: bold;">rUnlockSlow</span>(<span style="color: #8787d7;">r</span> <span style="color: #df005f; font-weight: bold;">int32</span>) {
    <span style="color: #268bd2; font-weight: bold;">if</span> atomic.<span style="color: #d75fd7; font-weight: bold;">AddInt32</span>(&amp;rw.readerWait, -1) == 0 {
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#26368;&#21518;&#19968;&#20010;reader&#20102;&#65292;writer&#32456;&#20110;&#26377;&#26426;&#20250;&#33719;&#24471;&#38145;&#20102;</span>
        <span style="color: #d75fd7; font-weight: bold;">runtime_Semrelease</span>(&amp;rw.writerSem, <span style="color: #d75fd7;">false</span>, 1)
    }
}
</pre>
</div>

<p>
第 2 行是对 reader 计数加 1。你可能比较困惑的是， <code>readerCount</code> 怎么还可能为负数呢？其实，这是因为， <code>readerCount</code> 这个字段有双重含义：<br>
</p>

<ul class="org-ul">
<li>没有 writer 竞争或持有锁时， <code>readerCount</code> 和我们正常理解的 reader 的计数是一样的；<br></li>
<li>但是，如果有 writer 竞争锁或者持有锁时，那么， <code>readerCount</code> 不仅仅承担着 reader 的计数功能，还能够标识当前是否有 writer 竞争或持有锁，在这种情况下，请求锁的 reader 的处理进入第 4 行，阻塞等待锁的释放。<br></li>
</ul>

<p>
调用 <code>RUnlock</code> 的时候，我们需要将 Reader 的计数减去 1（第 8 行），因为 reader 的数量减少了一个。但是，第 8 行的 <code>AddInt32</code> 的返回值还有另外一个含义。如果它是负值，就表示当前有 writer 竞争锁，在这种情况下，还会调用 <code>rUnlockSlow</code> 方法，检查是不是 reader 都释放读锁了，如果读锁都释放了，那么可以唤醒请求写锁的 writer 了。<br>
</p>

<p>
当一个或者多个 reader 持有锁的时候，竞争锁的 writer 会等待这些 reader 释放完，才可能持有这把锁。打个比方，在房地产行业中有条规矩叫做“买卖不破租赁”，意思是说，就算房东把房子卖了，新业主也不能把当前的租户赶走，而是要等到租约结束后，才能接管房子。这和 <code>RWMutex</code> 的设计是一样的。当 writer 请求锁的时候，是无法改变既有的 reader 持有锁的现实的，也不会强制这些 reader 释放锁，它的优先权只是限定后来的 reader 不要和它抢。<br>
</p>

<p>
所以， <code>rUnlockSlow</code> 将持有锁的 reader 计数减少 1 的时候，会检查既有的 reader 是不是都已经释放了锁，如果都释放了锁，就会唤醒 writer，让 writer 持有锁。<br>
</p>
</div>
</div>
<div id="outline-container-org0824cf1" class="outline-3">
<h3 id="org0824cf1">Lock</h3>
<div class="outline-text-3" id="text-org0824cf1">
<p>
<code>RWMutex</code> 是一个多 writer 多 reader 的读写锁，所以同时可能有多个 writer 和 reader。那么，为了避免 writer 之间的竞争， <code>RWMutex</code> 就会使用一个 <code>Mutex</code> 来保证 writer 的互斥。<br>
</p>

<p>
一旦一个 writer 获得了内部的互斥锁，就会反转 <code>readerCount</code> 字段，把它从原来的正整数 <code>readerCount</code> (&gt;=0) 修改为负数 <code>（readerCount-rwmutexMaxReaders）</code> ，让这个字段保持两个含义（既保存了 reader 的数量，又表示当前有 writer）。<br>
</p>

<p>
我们来看下下面的代码。第 5 行，还会记录当前活跃的 reader 数量，所谓活跃的 reader，就是指持有读锁还没有释放的那些 reader。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">rw</span> *<span style="color: #df005f; font-weight: bold;">RWMutex</span>) <span style="color: #d75fd7; font-weight: bold;">Lock</span>() {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#39318;&#20808;&#35299;&#20915;&#20854;&#20182;writer&#31454;&#20105;&#38382;&#39064;</span>
    rw.w.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21453;&#36716;readerCount&#65292;&#21578;&#35785;reader&#26377;writer&#31454;&#20105;&#38145;</span>
    <span style="color: #8787d7;">r</span> := atomic.<span style="color: #d75fd7; font-weight: bold;">AddInt32</span>(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22914;&#26524;&#24403;&#21069;&#26377;reader&#25345;&#26377;&#38145;&#65292;&#37027;&#20040;&#38656;&#35201;&#31561;&#24453;</span>
    <span style="color: #268bd2; font-weight: bold;">if</span> r != 0 &amp;&amp; atomic.<span style="color: #d75fd7; font-weight: bold;">AddInt32</span>(&amp;rw.readerWait, r) != 0 {
        <span style="color: #d75fd7; font-weight: bold;">runtime_SemacquireMutex</span>(&amp;rw.writerSem, <span style="color: #d75fd7;">false</span>, 0)
    }
}
</pre>
</div>

<p>
如果 <code>readerCount</code> 不是 0，就说明当前有持有读锁的 reader， <code>RWMutex</code> 需要把这个当前 <code>readerCount</code> 赋值给 <code>readerWait</code> 字段保存下来（第 7 行）， 同时，这个 writer 进入阻塞等待状态（第 8 行）。<br>
</p>

<p>
每当一个 reader 释放读锁的时候（调用 <code>RUnlock</code> 方法时）， <code>readerWait</code> 字段就减 1，直到所有的活跃的 reader 都释放了读锁，才会唤醒这个 writer。<br>
</p>
</div>
</div>
<div id="outline-container-org1c4d91c" class="outline-3">
<h3 id="org1c4d91c">Unlock</h3>
<div class="outline-text-3" id="text-org1c4d91c">
<p>
当一个 writer 释放锁的时候，它会再次反转 <code>readerCount</code> 字段。可以肯定的是，因为当前锁由 writer 持有，所以， <code>readerCount</code> 字段是反转过的，并且减去了 <code>rwmutexMaxReaders</code> 这个常数，变成了负数。所以，这里的反转方法就是给它增加 <code>rwmutexMaxReaders</code> 这个常数值。<br>
</p>

<p>
既然 writer 要释放锁了，那么就需要唤醒之后新来的 reader，不必再阻塞它们了，让它们开开心心地继续执行就好了。<br>
</p>

<p>
在 <code>RWMutex</code> 的 <code>Unlock</code> 返回之前，需要把内部的互斥锁释放。释放完毕后，其他的 writer 才可以继续竞争这把锁。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">rw</span> *<span style="color: #df005f; font-weight: bold;">RWMutex</span>) <span style="color: #d75fd7; font-weight: bold;">Unlock</span>() {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21578;&#35785;reader&#27809;&#26377;&#27963;&#36291;&#30340;writer&#20102;</span>
    <span style="color: #8787d7;">r</span> := atomic.<span style="color: #d75fd7; font-weight: bold;">AddInt32</span>(&amp;rw.readerCount, rwmutexMaxReaders)

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21796;&#37266;&#38459;&#22622;&#30340;reader&#20204;</span>
    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := 0; i &lt; <span style="color: #d75fd7; font-weight: bold;">int</span>(r); i++ {
        <span style="color: #d75fd7; font-weight: bold;">runtime_Semrelease</span>(&amp;rw.readerSem, <span style="color: #d75fd7;">false</span>, 0)
    }
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#37322;&#25918;&#20869;&#37096;&#30340;&#20114;&#26021;&#38145;</span>
    rw.w.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
} 
</pre>
</div>

<p>
在这段代码中，我删除了 race 的处理和异常情况的检查，总体看来还是比较简单的。这里有几个重点，我要再提醒你一下。首先，你要理解 <code>readerCount</code> 这个字段的含义以及反转方式。其次，你还要注意字段的更改和内部互斥锁的顺序关系。在 <code>Lock</code> 方法中，是先获取内部互斥锁，才会修改的其他字段；而在 <code>Unlock</code> 方法中，是先修改的其他字段，才会释放内部互斥锁，这样才能保证字段的修改也受到互斥锁的保护。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org52585f5" class="outline-2">
<h2 id="org52585f5">RWMutex 的 3 个踩坑点</h2>
<div class="outline-text-2" id="text-org52585f5">
</div>
<div id="outline-container-org5719381" class="outline-3">
<h3 id="org5719381">坑点1：不可复制</h3>
<div class="outline-text-3" id="text-org5719381">
<p>
前面刚刚说过，RWMutex 是由一个互斥锁和四个辅助字段组成的。我们很容易想到，互斥锁是不可复制的，再加上四个有状态的字段，RWMutex 就更加不能复制使用了。<br>
</p>

<p>
不能复制的原因和互斥锁一样。一旦读写锁被使用，它的字段就会记录它当前的一些状态。这个时候你去复制这把锁，就会把它的状态也给复制过来。但是，原来的锁在释放的时候，并不会修改你复制出来的这个读写锁，这就会导致复制出来的读写锁的状态不对，可能永远无法释放锁。<br>
</p>

<p>
那该怎么办呢？其实，解决方案也和互斥锁一样。你可以借助 vet 工具，在变量赋值、函数传参、函数返回值、遍历数据、struct 初始化等时，检查是否有读写锁隐式复制的情景。<br>
</p>
</div>
</div>
<div id="outline-container-org8a7b541" class="outline-3">
<h3 id="org8a7b541">坑点2：重入导致死锁</h3>
<div class="outline-text-3" id="text-org8a7b541">
<p>
读写锁因为重入（或递归调用）导致死锁的情况更多。<br>
</p>

<p>
先介绍第一种情况。因为读写锁内部基于互斥锁实现对 writer 的并发访问，而互斥锁本身是有重入问题的，所以，writer 重入调用 <code>Lock</code> 的时候，就会出现死锁的现象。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">foo</span>(<span style="color: #8787d7;">l</span> *<span style="color: #df005f; font-weight: bold;">sync.RWMutex</span>) {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"in foo"</span>)
    l.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
    <span style="color: #d75fd7; font-weight: bold;">bar</span>(l)
    l.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">bar</span>(<span style="color: #8787d7;">l</span> *<span style="color: #df005f; font-weight: bold;">sync.RWMutex</span>) {
    l.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"in bar"</span>)
    l.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">l</span> := &amp;<span style="color: #df005f; font-weight: bold;">sync.RWMutex</span>{}
    <span style="color: #d75fd7; font-weight: bold;">foo</span>(l)
} 
</pre>
</div>

<p>
第二种死锁的场景有点隐蔽。我们知道，有活跃 reader 的时候，writer 会等待，如果我们在 reader 的读操作时调用 writer 的写操作（它会调用 Lock 方法），那么，这个 reader 和 writer 就会形成互相依赖的死锁状态。Reader 想等待 writer 完成后再释放锁，而 writer 需要这个 reader 释放锁之后，才能不阻塞地继续执行。这是一个读写锁常见的死锁场景。<br>
</p>

<p>
第三种死锁的场景更加隐蔽。<br>
</p>

<p>
当一个 writer 请求锁的时候，如果已经有一些活跃的 reader，它会等待这些活跃的 reader 完成，才有可能获取到锁，但是，如果之后活跃的 reader 再依赖新的 reader 的话，这些新的 reader 就会等待 writer 释放锁之后才能继续执行，这就形成了一个环形依赖： <span class="underline">writer 依赖活跃的 reader -&gt; 活跃的 reader 依赖新来的 reader -&gt; 新来的 reader 依赖 writer</span> 。<br>
</p>

<p>
这个死锁相当隐蔽，原因在于它和 RWMutex 的设计和实现有关。啥意思呢？我们来看一个计算阶乘 (n!) 的例子：<br>
</p>

<div class="org-src-container">
<pre class="src src-go">
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
        <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">mu</span> <span style="color: #df005f; font-weight: bold;">sync.RWMutex</span>

        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">writer,&#31245;&#24494;&#31561;&#24453;&#65292;&#28982;&#21518;&#21046;&#36896;&#19968;&#20010;&#35843;&#29992;Lock&#30340;&#22330;&#26223;</span>
        <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
                time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(200 * time.Millisecond)
                mu.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
                fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"Lock"</span>)
                time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(100 * time.Millisecond)
                mu.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
                fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"Unlock"</span>)
        }()

        <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
                <span style="color: #d75fd7; font-weight: bold;">factorial</span>(&amp;mu, 10) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35745;&#31639;10&#30340;&#38454;&#20056;, 10!</span>
        }()

        <span style="color: #268bd2; font-weight: bold;">select</span> {}
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36882;&#24402;&#35843;&#29992;&#35745;&#31639;&#38454;&#20056;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">factorial</span>(<span style="color: #8787d7;">m</span> *<span style="color: #df005f; font-weight: bold;">sync.RWMutex</span>, <span style="color: #8787d7;">n</span> <span style="color: #df005f; font-weight: bold;">int</span>) <span style="color: #df005f; font-weight: bold;">int</span> {
        <span style="color: #268bd2; font-weight: bold;">if</span> n &lt; 1 { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#38454;&#20056;&#36864;&#20986;&#26465;&#20214; </span>
                <span style="color: #268bd2; font-weight: bold;">return</span> 0
        }
        fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"RLock"</span>)
        m.<span style="color: #d75fd7; font-weight: bold;">RLock</span>()
        <span style="color: #268bd2; font-weight: bold;">defer</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
                fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"RUnlock"</span>)
                m.<span style="color: #d75fd7; font-weight: bold;">RUnlock</span>()
        }()
        time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(100 * time.Millisecond)
        <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7; font-weight: bold;">factorial</span>(m, n-1) * n <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36882;&#24402;&#35843;&#29992;</span>
} 
</pre>
</div>

<p>
factoria 方法是一个递归计算阶乘的方法，我们用它来模拟 reader。为了更容易地制造出死锁场景，我在这里加上了 sleep 的调用，延缓逻辑的执行。这个方法会调用读锁（第 27 行），在第 33 行递归地调用此方法，每次调用都会产生一次读锁的调用，所以可以不断地产生读锁的调用，而且必须等到新请求的读锁释放，这个读锁才能释放。<br>
</p>

<p>
同时，我们使用另一个 goroutine 去调用 Lock 方法，来实现 writer，这个 writer 会等待 200 毫秒后才会调用 Lock，这样在调用 Lock 的时候，factoria 方法还在执行中不断调用 RLock。<br>
</p>

<p>
这两个 goroutine 互相持有锁并等待，谁也不会退让一步，满足了“writer 依赖活跃的 reader -&gt; 活跃的 reader 依赖新来的 reader -&gt; 新来的 reader 依赖 writer”的死锁条件，所以就导致了死锁的产生。<br>
</p>

<p>
所以，使用读写锁最需要注意的一点就是尽量避免重入，重入带来的死锁非常隐蔽，而且难以诊断。<br>
</p>
</div>
</div>
<div id="outline-container-org1b1b3ad" class="outline-3">
<h3 id="org1b1b3ad">坑点3：释放未加锁的 RWMutex</h3>
<div class="outline-text-3" id="text-org1b1b3ad">
<p>
和互斥锁一样，Lock 和 Unlock 的调用总是成对出现的，RLock 和 RUnlock 的调用也必须成对出现。Lock 和 RLock 多余的调用会导致锁没有被释放，可能会出现死锁，而 Unlock 和 RUnlock 多余的调用会导致 panic。在生产环境中出现 panic 是大忌，你总不希望半夜爬起来处理生产环境程序崩溃的问题吧？所以，在使用读写锁的时候，一定要注意，不遗漏不多余。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org747b144" class="outline-2">
<h2 id="org747b144">流行的 Go 开发项目中的坑</h2>
<div class="outline-text-2" id="text-org747b144">
</div>
<div id="outline-container-org7c14eda" class="outline-3">
<h3 id="org7c14eda">Docker</h3>
<div class="outline-text-3" id="text-org7c14eda">
</div>
<div id="outline-container-orgc8793c3" class="outline-4">
<h4 id="orgc8793c3">issue 36840</h4>
<div class="outline-text-4" id="text-orgc8793c3">
<p>
<a href="https://github.com/moby/moby/pull/36840/files">issue 36840</a> 修复的是错误地把 writer 当成 reader 的 Bug。 这个地方本来需要修改数据，需要调用的是写锁，结果用的却是读锁。或许是被它紧挨着的 findNode 方法调用迷惑了，认为这只是一个读操作。可实际上，代码后面还会有 changeNodeState 方法的调用，这是一个写操作。修复办法也很简单，只需要改成 Lock/Unlock 即可。<br>
</p>

<div class="div-center">
	<img src="./images/Go-并发编程-Docker_issue36840.webp" />
</div>
</div>
</div>
</div>
<div id="outline-container-org5fa1851" class="outline-3">
<h3 id="org5fa1851">Kubernetes</h3>
<div class="outline-text-3" id="text-org5fa1851">
</div>
<div id="outline-container-org1e929e8" class="outline-4">
<h4 id="org1e929e8">issue 62464</h4>
<div class="outline-text-4" id="text-org1e929e8">
<p>
<a href="https://github.com/kubernetes/kubernetes/pull/62464">issue 62464</a> 就是读写锁第二种死锁的场景，这是一个典型的 reader 导致的死锁的例子。知道墨菲定律吧？“凡是可能出错的事，必定会出错”。你可能觉得我前面讲的 RWMutex 的坑绝对不会被人踩的，因为道理大家都懂，但是你看，Kubernetes 就踩了这个重入的坑。<br>
</p>

<p>
这个 issue 在移除 pod 的时候可能会发生，原因就在于，GetCPUSetOrDefault 方法会请求读锁，同时，它还会调用 GetCPUSet 或 GetDefaultCPUSet 方法，这时又会请求读锁。如果期间有其它 goroutine 请求写锁的话，GetCPUSetOrDefault 方法调用 GetCPUSet 或 GetDefaultCPUSet 方法时就不会返回了，请求写锁的 goroutine 也不会返回，这就会形成死锁。<br>
</p>

<div class="div-center">
	<img src="./images/Go-并发编程-Kubernetes_issue62464.webp" />
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org15d8499" class="outline-2">
<h2 id="org15d8499">总结</h2>
<div class="outline-text-2" id="text-org15d8499">
<p>
在开发过程中，一开始考虑共享资源并发访问问题的时候，我们就会想到互斥锁 Mutex。因为刚开始的时候，我们还并不太了解并发的情况，所以，就会使用最简单的同步原语来解决问题。等到系统成熟，真正到了需要性能优化的时候，我们就能静下心来分析并发场景的可能性，这个时候，我们就要考虑将 Mutex 修改为 RWMutex，来压榨系统的性能。<br>
</p>

<p>
当然，如果一开始你的场景就非常明确了，比如我就要实现一个线程安全的 map，那么，一开始你就可以考虑使用读写锁。<br>
</p>

<p>
正如前面提到的，如果你能意识到你要解决的问题是一个 readers-writers 问题，那么你就可以毫不犹豫地选择 RWMutex，不用考虑其它选择。那在使用 RWMutex 时，最需要注意的一点就是尽量避免重入，重入带来的死锁非常隐蔽，而且难以诊断。<br>
</p>

<p>
另外我们也可以扩展 RWMutex，不过实现方法和互斥锁 Mutex 差不多，在技术上是一样的，都是通过 unsafe 来实现。<br>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-05-14 15:05 Sat</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-06-28 Tue 23:03</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
