<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2023-02-01 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>孤儿进程与僵尸进程</title>
<meta name="author" content="L.M.haoran" />
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved." />
<meta name="generator" content="Org Mode" />
<link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
           <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
           <script type="module" src="static/js/main.js" defer></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">孤儿进程与僵尸进程</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org533a9db">基本概念</a></li>
<li><a href="#org4f9a8d1">问题及危害</a></li>
</ul>
</div>
</div>

<div id="outline-container-org533a9db" class="outline-2">
<h2 id="org533a9db">基本概念</h2>
<div class="outline-text-2" id="text-org533a9db">
<p>
我们知道在 unix/linux 中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。当一个进程完成它的工作终止之后，它的父进程需要调用 wait() 或者 waitpid() 系统调用取得子进程的终止状态。<br>
</p>

<ul class="org-ul">
<li>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被 init 进程（进程号为1）所收养，并由 init 进程对它们完成状态收集工作。（父进程死了，子进程活着）<br></li>
<li>僵尸进程：一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息，那么 <span class="underline">子进程的进程描述符仍然保存在系统中</span> 。这种进程称之为僵死进程。（父进程没有调用 wait/waitpid）<br></li>
</ul>
</div>
</div>
<div id="outline-container-org4f9a8d1" class="outline-2">
<h2 id="org4f9a8d1">问题及危害</h2>
<div class="outline-text-2" id="text-org4f9a8d1">
<p>
unix 提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: 在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息（包括进程号 the process ID，退出状态 the termination status of the process，运行时间 the amount of CPU time taken by the process 等）。直到父进程通过 wait/waitpid 来取时才释放。但这样就导致了问题， <span class="underline">如果进程不调用 wait/waitpid 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免</span> 。<br>
</p>

<p>
<span class="underline">孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了 init 进程身上，</span> init 进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为 init，而 init 进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。 <span class="underline">因此孤儿进程并不会有什么危害。</span><br>
</p>

<p>
<span class="underline">任何一个子进程（init 除外）在 exit() 之后，并非马上就消失掉，而是留下一个称为僵尸进程（Zombie）的数据结构，等待父进程处理。</span> 这是每个 子进程在结束时都要经过的阶段。如果子进程在 exit() 之后，父进程没有来得及处理，这时用 ps 命令就能看到子进程的状态是“Z”。如果父进程能及时处理，可能用 ps 命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由 init 接管。init 将会以父进程的身份对僵尸状态的子进程进行处理。<br>
</p>

<p>
僵尸进程危害场景：<br>
</p>

<p>
例如有个进程，它定期的产 生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程 退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵死进程，倘若用 ps 命令查看的话，就会看到很多状态为 Z 的进程。 严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大 量僵死进程的那个元凶枪毙掉（也就是通过 kill 发送 SIGTERM 或者 SIGKILL 信号啦）。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被 init 进程接管，init 进程会 wait() 这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程 就能瞑目而去了。<br>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2023-02-01</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
