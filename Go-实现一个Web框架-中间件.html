<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-12-25 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>中间件</title>
<meta name="author" content="L.M.haoran" />
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved." />
<meta name="generator" content="Org Mode" />
<link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
           <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
           <script type="module" src="static/js/main.js" defer></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">中间件</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org1cc1438">中间件是什么</a></li>
<li><a href="#org70288c8">中间件设计</a></li>
<li><a href="#org211a212">代码实现</a></li>
<li><a href="#orga510feb">使用 Demo</a></li>
</ul>
</div>
</div>

<div id="outline-container-org1cc1438" class="outline-2">
<h2 id="org1cc1438">中间件是什么</h2>
<div class="outline-text-2" id="text-org1cc1438">
<p>
中间件（middlewares），简单说，就是非业务的技术类组件。Web 框架本身不可能去理解所有的业务，因而不可能实现所有的功能。因此，框架需要有一个插口，允许用户自己定义功能，嵌入到框架中，仿佛这个功能是框架原生支持的一样。因此，对中间件而言，需要考虑2个比较关键的点：<br>
</p>

<ul class="org-ul">
<li>插入点在哪？使用框架的人并不关心底层逻辑的具体实现，如果插入点太底层，中间件逻辑就会非常复杂。如果插入点离用户太近，那和用户直接定义一组函数，每次在 Handler 中手工调用没有多大的优势了。<br></li>
<li>中间件的输入是什么？中间件的输入，决定了扩展能力。暴露的参数太少，用户发挥空间有限。<br></li>
</ul>

<p>
那对于一个 Web 框架而言，中间件应该设计成什么样呢？接下来的实现，基本参考了 Gin 框架。<br>
</p>
</div>
</div>
<div id="outline-container-org70288c8" class="outline-2">
<h2 id="org70288c8">中间件设计</h2>
<div class="outline-text-2" id="text-org70288c8">
<p>
Gee 的中间件的定义与路由映射的 Handler 一致，处理的输入是 Context 对象。插入点是框架接收到请求初始化 Context 对象后，允许用户使用自己定义的中间件做一些额外的处理，例如记录日志等，以及对 Context 进行二次加工。另外通过调用 <code>(*Context).Next()</code> 函数，中间件可等待用户自己定义的 Handler 处理结束后，再做一些额外的操作，例如计算本次处理所用时间等。即 Gee 的中间件支持用户在请求被处理的前后，做一些额外的操作。举个例子，我们希望最终能够支持如下定义的中间件， <code>c.Next()</code> 表示等待执行其他的中间件或用户的 Handler：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #e45649;">func</span> <span style="color: #a626a4;">Logger</span>() <span style="color: #986801;">HandlerFunc</span> {
    <span style="color: #e45649;">return</span> <span style="color: #e45649;">func</span>(<span style="color: #6a1868;">c</span> *<span style="color: #986801;">Context</span>) {
        <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">Start timer</span>
        <span style="color: #6a1868;">t</span> := time.<span style="color: #a626a4;">Now</span>()
        <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">Process request</span>
        c.<span style="color: #a626a4;">Next</span>()
        <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">Calculate resolution time</span>
        log.<span style="color: #a626a4;">Printf</span>(<span style="color: #50a14f;">"[%d] %s in %v"</span>, c.StatusCode, c.Req.RequestURI, time.<span style="color: #a626a4;">Since</span>(t))
    }
}
</pre>
</div>

<p>
我们上一篇文章分组控制 Group Control 中讲到，中间件是应用在 RouterGroup 上的，应用在最顶层的 Group，相当于作用于全局，所有的请求都会被中间件处理。那为什么不作用在每一条路由规则上呢？作用在某条路由规则，那还不如用户直接在 Handler 中调用直观。只作用在某条路由规则的功能通用性太差，不适合定义为中间件。<br>
</p>

<p>
我们之前的框架设计是这样的，当接收到请求后，匹配路由，该请求的所有信息都保存在Context中。中间件也不例外，接收到请求后，应查找所有应作用于该路由的中间件，保存在Context中，依次进行调用。为什么依次调用后，还需要在Context中保存呢？因为在设计中，中间件不仅作用在处理流程前，也可以作用在处理流程后，即在用户定义的 Handler 处理完毕后，还可以执行剩下的操作。<br>
</p>

<p>
为此，我们给 Context 添加了2个参数，定义了 Next 方法：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #e45649;">type</span> <span style="color: #986801;">Context</span> <span style="color: #e45649;">struct</span> {
    <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">origin objects</span>
    Writer <span style="color: #986801;">http.ResponseWriter</span>
    Req    *<span style="color: #986801;">http.Request</span>
    <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">request info</span>
    Path   <span style="color: #986801;">string</span>
    Method <span style="color: #986801;">string</span>
    Params <span style="color: #e45649;">map</span>[<span style="color: #986801;">string</span>]<span style="color: #986801;">string</span>
    <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">response info</span>
    StatusCode <span style="color: #986801;">int</span>
    <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">middleware</span>
    handlers []<span style="color: #986801;">HandlerFunc</span>
    index    <span style="color: #986801;">int</span>
}

<span style="color: #e45649;">func</span> <span style="color: #a626a4;">newContext</span>(<span style="color: #6a1868;">w</span> <span style="color: #986801;">http.ResponseWriter</span>, <span style="color: #6a1868;">req</span> *<span style="color: #986801;">http.Request</span>) *<span style="color: #986801;">Context</span> {
    <span style="color: #e45649;">return</span> &amp;<span style="color: #986801;">Context</span>{
        <span style="color: #b751b6;">Path</span>:   req.URL.Path,
        <span style="color: #b751b6;">Method</span>: req.Method,
        <span style="color: #b751b6;">Req</span>:    req,
        <span style="color: #b751b6;">Writer</span>: w,
        <span style="color: #b751b6;">index</span>:  -1,
    }
}

<span style="color: #e45649;">func</span> (<span style="color: #6a1868;">c</span> *<span style="color: #986801;">Context</span>) <span style="color: #a626a4;">Next</span>() {
    c.index++
    <span style="color: #6a1868;">s</span> := <span style="color: #a626a4;">len</span>(c.handlers)
    <span style="color: #e45649;">for</span> ; c.index &lt; s; c.index++ {
        c.handlers[c.index](c)
    }
}
</pre>
</div>

<p>
index 是记录当前执行到第几个中间件，当在中间件中调用 Next 方法时，控制权交给了下一个中间件，直到调用到最后一个中间件，然后再从后往前，调用每个中间件在 Next 方法之后定义的部分。如果我们将用户在映射路由时定义的 Handler 添加到 c.handlers 列表中，结果会怎么样呢？想必你已经猜到了。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #e45649;">func</span> <span style="color: #a626a4;">A</span>(<span style="color: #6a1868;">c</span> *<span style="color: #986801;">Context</span>) {
    part1
    c.<span style="color: #a626a4;">Next</span>()
    part2
}
<span style="color: #e45649;">func</span> <span style="color: #a626a4;">B</span>(<span style="color: #6a1868;">c</span> *<span style="color: #986801;">Context</span>) {
    part3
    c.<span style="color: #a626a4;">Next</span>()
    part4
}
</pre>
</div>

<p>
假设我们应用了中间件 A 和 B，和路由映射的 Handler。c.handlers 是这样的[A, B, Handler]，c.index 初始化为-1。调用 c.Next()，接下来的流程是这样的：<br>
</p>

<ul class="org-ul">
<li>c.index++，c.index 变为 0<br></li>
<li>0 &lt; 3，调用 c.handlers[0]，即 A<br></li>
<li>执行 part1，调用 c.Next()<br></li>
<li>c.index++，c.index 变为 1<br></li>
<li>1 &lt; 3，调用 c.handlers[1]，即 B<br></li>
<li>执行 part3，调用 c.Next()<br></li>
<li>c.index++，c.index 变为 2<br></li>
<li>2 &lt; 3，调用 c.handlers[2]，即 Handler<br></li>
<li>Handler 调用完毕，返回到 B 中的 part4，执行 part4<br></li>
<li>part4 执行完毕，返回到 A 中的 part2，执行 part2<br></li>
<li>part2 执行完毕，结束。<br></li>
</ul>

<p>
一句话说清楚重点，最终的顺序是 part1 -&gt; part3 -&gt; Handler -&gt; part 4 -&gt; part2。恰恰满足了我们对中间件的要求，接下来看调用部分的代码，就能全部串起来了。<br>
</p>
</div>
</div>
<div id="outline-container-org211a212" class="outline-2">
<h2 id="org211a212">代码实现</h2>
<div class="outline-text-2" id="text-org211a212">
<ul class="org-ul">
<li>定义 Use 函数，将中间件应用到某个 Group<br></li>
</ul>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">Use is defined to add middleware to the group</span>
<span style="color: #e45649;">func</span> (<span style="color: #6a1868;">group</span> *<span style="color: #986801;">RouterGroup</span>) <span style="color: #a626a4;">Use</span>(<span style="color: #6a1868;">middlewares</span> ...<span style="color: #986801;">HandlerFunc</span>) {
    group.middlewares = <span style="color: #a626a4;">append</span>(group.middlewares, middlewares...)
}

<span style="color: #e45649;">func</span> (<span style="color: #6a1868;">engine</span> *<span style="color: #986801;">Engine</span>) <span style="color: #a626a4;">ServeHTTP</span>(<span style="color: #6a1868;">w</span> <span style="color: #986801;">http.ResponseWriter</span>, <span style="color: #6a1868;">req</span> *<span style="color: #986801;">http.Request</span>) {
    <span style="color: #e45649;">var</span> <span style="color: #6a1868;">middlewares</span> []<span style="color: #986801;">HandlerFunc</span>
    <span style="color: #e45649;">for</span> <span style="color: #6a1868;">_</span>, <span style="color: #6a1868;">group</span> := <span style="color: #e45649;">range</span> engine.groups {
        <span style="color: #e45649;">if</span> strings.<span style="color: #a626a4;">HasPrefix</span>(req.URL.Path, group.prefix) {
            middlewares = <span style="color: #a626a4;">append</span>(middlewares, group.middlewares...)
        }
    }
    <span style="color: #6a1868;">c</span> := <span style="color: #a626a4;">newContext</span>(w, req)
    c.handlers = middlewares
    engine.router.<span style="color: #a626a4;">handle</span>(c)
}
</pre>
</div>

<p>
ServeHTTP 函数也有变化，当我们接收到一个具体请求时，要判断该请求适用于哪些中间件，在这里我们简单通过 URL 的前缀来判断。得到中间件列表后，赋值给 c.handlers。<br>
</p>

<ul class="org-ul">
<li>handle 函数中，将从路由匹配得到的 Handler 添加到 c.handlers 列表中，执行 c.Next()。<br></li>
</ul>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #e45649;">func</span> (<span style="color: #6a1868;">r</span> *<span style="color: #986801;">router</span>) <span style="color: #a626a4;">handle</span>(<span style="color: #6a1868;">c</span> *<span style="color: #986801;">Context</span>) {
    <span style="color: #6a1868;">n</span>, <span style="color: #6a1868;">params</span> := r.<span style="color: #a626a4;">getRoute</span>(c.Method, c.Path)

    <span style="color: #e45649;">if</span> n != <span style="color: #b751b6;">nil</span> {
        <span style="color: #6a1868;">key</span> := c.Method + <span style="color: #50a14f;">"-"</span> + n.pattern
        c.Params = params
        c.handlers = <span style="color: #a626a4;">append</span>(c.handlers, r.handlers[key])
    } <span style="color: #e45649;">else</span> {
        c.handlers = <span style="color: #a626a4;">append</span>(c.handlers, <span style="color: #e45649;">func</span>(<span style="color: #6a1868;">c</span> *<span style="color: #986801;">Context</span>) {
            c.<span style="color: #a626a4;">String</span>(http.StatusNotFound, <span style="color: #50a14f;">"404 NOT FOUND: %s\n"</span>, c.Path)
        })
    }
    c.<span style="color: #a626a4;">Next</span>()
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orga510feb" class="outline-2">
<h2 id="orga510feb">使用 Demo</h2>
<div class="outline-text-2" id="text-orga510feb">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #e45649;">func</span> <span style="color: #a626a4;">onlyForV2</span>() <span style="color: #986801;">gee.HandlerFunc</span> {
    <span style="color: #e45649;">return</span> <span style="color: #e45649;">func</span>(<span style="color: #6a1868;">c</span> *<span style="color: #986801;">gee.Context</span>) {
        <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">Start timer</span>
        <span style="color: #6a1868;">t</span> := time.<span style="color: #a626a4;">Now</span>()
        <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">if a server error occurred</span>
        c.<span style="color: #a626a4;">Fail</span>(500, <span style="color: #50a14f;">"Internal Server Error"</span>)
        <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">Calculate resolution time</span>
        log.<span style="color: #a626a4;">Printf</span>(<span style="color: #50a14f;">"[%d] %s in %v for group v2"</span>, c.StatusCode, c.Req.RequestURI, time.<span style="color: #a626a4;">Since</span>(t))
    }
}

<span style="color: #e45649;">func</span> <span style="color: #a626a4;">main</span>() {
    <span style="color: #6a1868;">r</span> := gee.<span style="color: #a626a4;">New</span>()
    r.<span style="color: #a626a4;">Use</span>(gee.<span style="color: #a626a4;">Logger</span>()) <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">global midlleware</span>
    r.<span style="color: #a626a4;">GET</span>(<span style="color: #50a14f;">"/"</span>, <span style="color: #e45649;">func</span>(<span style="color: #6a1868;">c</span> *<span style="color: #986801;">gee.Context</span>) {
        c.<span style="color: #a626a4;">HTML</span>(http.StatusOK, <span style="color: #50a14f;">"&lt;h1&gt;Hello Gee&lt;/h1&gt;"</span>)
    })

    <span style="color: #6a1868;">v2</span> := r.<span style="color: #a626a4;">Group</span>(<span style="color: #50a14f;">"/v2"</span>)
    v2.<span style="color: #a626a4;">Use</span>(<span style="color: #a626a4;">onlyForV2</span>()) <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">v2 group middleware</span>
    {
        v2.<span style="color: #a626a4;">GET</span>(<span style="color: #50a14f;">"/hello/:name"</span>, <span style="color: #e45649;">func</span>(<span style="color: #6a1868;">c</span> *<span style="color: #986801;">gee.Context</span>) {
            <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">expect /hello/geektutu</span>
            c.<span style="color: #a626a4;">String</span>(http.StatusOK, <span style="color: #50a14f;">"hello %s, you're at %s\n"</span>, c.<span style="color: #a626a4;">Param</span>(<span style="color: #50a14f;">"name"</span>), c.Path)
        })
    }

    r.<span style="color: #a626a4;">Run</span>(<span style="color: #50a14f;">":9999"</span>)
}
</pre>
</div>

<p>
gee.Logger() 即我们一开始就介绍的中间件，我们将这个中间件和框架代码放在了一起，作为框架默认提供的中间件。在这个例子中，我们将 gee.Logger() 应用在了全局，所有的路由都会应用该中间件。onlyForV2() 是用来测试功能的，仅在 v2 对应的 Group 中应用了。<br>
</p>

<p>
接下来使用 curl 测试，可以看到，v2 Group 2 个中间件都生效了。<br>
</p>

<pre class="example" id="org36bf71a">
$ curl http://localhost:9999
2022/12/24 14:52:53 [200] / in 17.958µs

$ curl http://localhost:9999/v2/hello/haoran
2022/12/24 14:53:25 [500] /v2/hello/haoran in 2.856708ms for group v2
2022/12/24 14:53:25 [500] /v2/hello/haoran in 3.097667ms
</pre>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-12-25</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
