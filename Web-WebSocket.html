<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-01-31 Mon 16:37 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>WEBSOCKET</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">WEBSOCKET</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org8f3cebf">什么是 WebSocket</a></li>
<li><a href="#org3399ea5">WebSocket 原理</a></li>
<li><a href="#org42e425b">WebSocket 是怎样的协议，具体有什么优点</a></li>
<li><a href="#orga4699eb">WebSocket 的作用</a>
<ul>
<li><a href="#org0d6e993">ajax 轮询、long poll</a></li>
<li><a href="#org337ca54">WebSocket</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org8f3cebf" class="outline-2">
<h2 id="org8f3cebf">什么是 WebSocket</h2>
<div class="outline-text-2" id="text-org8f3cebf">
<p>
WebSocket 协议在 2008 年诞生，2011 年成为国际标准，现在所有浏览器都已经支持了。WebSocket 最大的特点就是服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话。<br>
</p>

<p>
HTTP 有 1.1 和 1.0 之说，也就是所谓的 keep-alive，把多个 HTTP 请求合并为一个，但是 WebSocket 其实是一个新协议，跟 HTTP 协议基本没有关系，只是为了兼容现有浏览器，所以在握手阶段使用了 HTTP。<br>
</p>

<p>
HTTP 与 Web Socket 的主要区别：<br>
</p>

<img src="./images/HTTP与WebSocket的区别.jpeg" height="420px" width="700px" />

<p>
WebSocket 的其他特点：<br>
</p>
<ul class="org-ul">
<li>建立在 TCP 协议之上，服务器端的实现比较容易<br></li>
<li>与 HTTP 协议有着良好的兼容性，默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器<br></li>
<li>数据格式比较轻量，性能开销小，通信高效<br></li>
<li>可以发送文本，也可以发送二进制数据<br></li>
<li>没有同源限制，客户端可以与任意服务器通信<br></li>
<li>协议标识符是 wx（如果加密，则为 wss），服务器网址就是 URL<br></li>
</ul>
</div>
</div>
<div id="outline-container-org3399ea5" class="outline-2">
<h2 id="org3399ea5">WebSocket 原理</h2>
<div class="outline-text-2" id="text-org3399ea5">
<blockquote>
<p>
WebSocket 是应用层第七层上的一个应用层协议，它必须依赖 HTTP 协议进行一次握手，握手成功后，数据就直接从 TCP 通道传输，与 HTTP 无关了。即：WebSocket 分为握手和数据传输阶段，即进行了 HTTP 握手 + 双工的 TCP 连接。<br>
</p>
</blockquote>

<p>
WebSocket 是一种在单个 TCP 连接上进行 <b>全双工通信</b> 的协议。<br>
</p>

<p>
WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。<br>
</p>
</div>
</div>
<div id="outline-container-org42e425b" class="outline-2">
<h2 id="org42e425b">WebSocket 是怎样的协议，具体有什么优点</h2>
<div class="outline-text-2" id="text-org42e425b">
<ul class="org-ul">
<li>首先，相对于 HTTP 这种非持久的协议来说，WebSocket 是一个持久化的协议<br></li>
</ul>

<p>
HTTP 的生命周期通过 Request 来界定，也就是一个 Request、一个 Response，那么在 HTTP1.0 中，这次 HTTP 请求就结束了。<br>
</p>

<p>
在 HTTP1.1 中进行了改进，使得有一个 keep-alive，也就是说，在一个 HTTP 连接中，可以发送多个 Request，接收多个 Response。但是请记住 Request 的数量 = Response 的数量。在 HTTP 中永远是这样，也就是说一个 Request 只能有一个 Response，而且这个 Response 也是被动的，不能主动发起。<br>
</p>

<p>
那么 WebSocket 呢？<br>
</p>

<p>
WebSocket 是基于 HTTP 协议的，或者说借用了 HTTP 协议来完成一部分握手。<br>
</p>

<p>
首先来看个典型的 WebSocket 握手：<br>
</p>

<pre class="example" id="org2a8d42e">
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
</pre>

<p>
熟悉 HTTP 的同学可能发现了，这段类似 HTTP 协议的握手请求中，多了这么几个东西：<br>
</p>

<pre class="example" id="orgd0b27d5">
Upgrade: websocket
Connection: Upgrade
</pre>

<p>
这就是 WebSocket 的核心了，告诉 Apache、Nginx 等服务器：注意啦，我发起的请求要用 WebSocket 协议，快点帮我找到对应的助理处理&#x2026;而不是那个老土的HTTP。<br>
</p>

<pre class="example" id="org5ec075e">
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
</pre>

<ul class="org-ul">
<li>Sec-WebSocket-Key 是一个 Base64 encode 的值，这个是浏览器随机生成的，用来验证服务器是否使用的是 WebSocket 助理。<br></li>
<li>Sec-WebSocket-Protocol 是一个用户定义的字符串，用来区分同 URL 下，不同的服务所需要的协议。简单理解：我要服务A，别搞错了。<br></li>
<li>Sec-WebSocket-Version 是告诉服务器所使用的 WebSocket Draft（协议版本），在最初的时候，WebSocket 协议还在 Draft 阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么 Firefox 和 Chrome 用的不是一个版本之类的，当初 WebSocket 协议太多可是一个大难题。。不过现在已经定下来了，大家都使用同一个版本。<br></li>
</ul>

<p>
然后服务器会返回下列东西，表示已经接收到请求，成功建立 WebSocket 啦！<br>
</p>

<pre class="example" id="org9ad0383">
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
</pre>

<p>
这里开始就是 HTTP 最后负责的区域了，告诉客户，我已经成功切换协议啦～<br>
</p>

<pre class="example" id="org8e21a68">
Upgrade: websocket
Connection: Upgrade
</pre>

<p>
依然是固定的，告诉客户端即将升级的是 WebSocket 协议，而不是 mosillasocket，lurnarsocket 或者 shitsocket。<br>
</p>

<p>
然后，Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key，服务器：好啦好啦，知道啦，给你看我的 ID CARD 来证明行了吧。<br>
</p>

<p>
后面的，Sec-WebSocket-Protocol 则是表示最终使用的协议。<br>
</p>

<p>
至此，HTTP 已经完成它所有工作了，接下来就是完全按照 WebSocket 协议进行了。<br>
</p>
</div>
</div>
<div id="outline-container-orga4699eb" class="outline-2">
<h2 id="orga4699eb">WebSocket 的作用</h2>
<div class="outline-text-2" id="text-orga4699eb">
</div>
<div id="outline-container-org0d6e993" class="outline-3">
<h3 id="org0d6e993">ajax 轮询、long poll</h3>
<div class="outline-text-3" id="text-org0d6e993">
<dl class="org-dl">
<dt>ajax 轮询</dt><dd>让浏览器每隔几秒就发送一次请求，询问服务器是否有新消息。<br></dd>
<dt>long poll</dt><dd>与 ajax 轮询差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起请求后，如果没消息，就一直不返回 Response 给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。<br></dd>
</dl>

<p>
上面这两种方式都是在不断的建立 HTTP 连接，然后等待服务端处理，可以体现 HTTP 协议的另一个特点： <b>被动性</b> 。<br>
</p>

<p>
也就是服务端不能主动联系客户端，只能由客户端发起。<br>
</p>

<p>
上面这两种方式也是非常消耗资源的。ajax 轮询需要服务器有很快的处理速度和资源；long poll 需要有很高的并发，也就是说同时接待客户的能力。<br>
</p>
</div>
</div>
<div id="outline-container-org337ca54" class="outline-3">
<h3 id="org337ca54">WebSocket</h3>
<div class="outline-text-3" id="text-org337ca54">
<p>
上面的 ajax 轮询与 long poll 都不是最好的方式，需要很多资源，一种需要更快的速度，一种需要更多的电话，这两种都会导致 "电话" 的需求越来越高。<br>
</p>

<p>
HTTP 还是一个无状态协议。通俗的说就是，服务器因为每天要接待太多客户了，是个健忘鬼，你一挂电话，他就把你的东西全忘光，把你的东西全丢掉，第二次连接还要再告诉服务器一遍。<br>
</p>

<p>
所以在这种情况下出现了 WebSocket，它解决了 HTTP 的这几个难题。首先，被动性，当服务器完成协议升级后（HTTP -&gt; WebSocket），服务端就可以主动推送信息给客户端了。<br>
</p>

<pre class="example" id="org61719e4">
客户端：啦啦啦，我要建立Websocket协议，需要的服务：chat，Websocket协议版本：17（HTTP Request）

服务端：ok，确认，已升级为Websocket协议（HTTP Protocols Switched）

客户端：麻烦你有信息的时候推送给我噢。。

服务端：ok，有的时候会告诉你的。

服务端：balabalabalabala

服务端：balabalabalabala

服务端：哈哈哈哈哈啊哈哈哈哈

服务端：笑死我了哈哈哈哈哈哈哈
</pre>

<p>
这样，只需要经过一次 HTTP 请求，就可以做到源源不断的信息传送了。<br>
</p>

<p>
本文转载：<a href="https://www.cnblogs.com/nnngu/p/9347635.html">https://www.cnblogs.com/nnngu/p/9347635.html</a><br>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-01-30 21:01 Sun</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-01-31 Mon 16:37</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
