<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-10-06 Wed 17:54 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>COOKIE SESSION TOKEN JWT</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">COOKIE SESSION TOKEN JWT</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org5c31a69">什么是认证(Authentication)</a></li>
<li><a href="#org9fa3113">什么是授权(Authorization)</a></li>
<li><a href="#orgfcb6f34">什么是凭证(Credentials)</a></li>
<li><a href="#org7825791">什么是Cookie</a></li>
<li><a href="#org6f9641b">什么是Session</a>
<ul>
<li><a href="#orgde54a56">Session 认证流程：</a></li>
<li><a href="#org77b3858">Cookie 与 Session 的区别</a></li>
</ul>
</li>
<li><a href="#orgc365880">什么是Token</a>
<ul>
<li><a href="#orgefc6979">Token 的特点：</a></li>
<li><a href="#orgb640c00">Token 的身份验证流程：</a></li>
</ul>
</li>
<li><a href="#org6277dc2">什么是Jwt</a>
<ul>
<li><a href="#org17cdc06">JWT 的组成部分</a></li>
<li><a href="#org88be869">JWT 的认证流程：</a></li>
<li><a href="#org403e8fd">JWT 的使用方式</a></li>
<li><a href="#org4430822">Token 和 JWT 的区别：</a>
<ul>
<li><a href="#org6193c9a">相同点：</a></li>
<li><a href="#orge22526b">不同点：</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org5c31a69" class="outline-2">
<h2 id="org5c31a69">什么是认证(Authentication)</h2>
<div class="outline-text-2" id="text-org5c31a69">
<p>
通俗地讲就是验证当前用户的身份，证明“你是你自己”（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功），比如互联网中的认证：用户密码登录，邮箱发送登录链接，手机号接收验证码，只要你能收到邮件或者验证码就默认你是主人。<br>
</p>
</div>
</div>
<div id="outline-container-org9fa3113" class="outline-2">
<h2 id="org9fa3113">什么是授权(Authorization)</h2>
<div class="outline-text-2" id="text-org9fa3113">
<p>
用户授予第三方应用访问该用户某些资源的权限就是授权。打个比方：你在安装手机应用的时候，APP 会询问是否允许授予权限（访问相册、地理位置等权限），你在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息）等。<br>
</p>

<p>
一般实现实现授权的方式有：cookie、session、token。<br>
</p>
</div>
</div>
<div id="outline-container-orgfcb6f34" class="outline-2">
<h2 id="orgfcb6f34">什么是凭证(Credentials)</h2>
<div class="outline-text-2" id="text-orgfcb6f34">
<p>
实现认证和授权的前提是需要一种媒介（证书） 来标记访问者的身份，打个比方，在互联网应用中，一般网站（如掘金）会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。<br>
</p>
</div>
</div>
<div id="outline-container-org7825791" class="outline-2">
<h2 id="org7825791">什么是Cookie</h2>
<div class="outline-text-2" id="text-org7825791">
<p>
HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。cookie 存储在客户端： cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。<br>
</p>

<p>
cookie 是不可跨域的： 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。<br>
</p>
</div>
</div>
<div id="outline-container-org6f9641b" class="outline-2">
<h2 id="org6f9641b">什么是Session</h2>
<div class="outline-text-2" id="text-org6f9641b">
<p>
Session 字⾯意思是会话，主要⽤来标识⾃⼰的身份。<br>
</p>

<p>
⽐如在⽆状态的 api 服务在多次请求数据库时，如何 知道是同⼀个⽤户，这个就可以通过 session 的机制，服务器要知道当前发请求给⾃⼰的是谁，为了区分客户端请求， 服务端会给具体的客户端⽣成身份标识 session ，然后客户端每次向服务器发请求 的时候，都带上这个 “身份标识”，服务器就知道这个请求来⾃于谁了。<br>
</p>

<p>
⾄于客户端如何保存该标识，可以有很多⽅式，对于浏览器⽽⾔，⼀般都是使⽤ cookie 的⽅式 ，服务器使⽤ session 把⽤户信息临时保存了服务器上，⽤户离开⽹站就会销毁，这种凭证存储⽅式相对于 ，cookie 来说更加安全。<br>
</p>

<p>
但是 session 会有⼀个缺陷：如果 web 服务器做了负载均衡，那么下⼀个操作请求到 了另⼀台服务器的时候 session 会丢失。<br>
</p>

<p>
因此，通常企业⾥会使⽤ redis,memcached 缓存中间件来实现 session 的共享，此时 web 服务器就是⼀ 个完全⽆状态的存在，所有的⽤户凭证可以通过共享 session 的⽅式存取，当前 session 的过期和销毁机制 需要⽤户做控制。<br>
</p>

<p>
注意：session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中<br>
</p>
</div>
<div id="outline-container-orgde54a56" class="outline-3">
<h3 id="orgde54a56">Session 认证流程：</h3>
<div class="outline-text-3" id="text-orgde54a56">
<p>
1:用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session<br>
</p>

<p>
2:请求返回时将此 Session 的唯一标识信息 SessionId 返回给浏览器<br>
</p>

<p>
3:浏览器接收到服务器返回的 SessionId 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionId 属于哪个域名<br>
</p>

<p>
4:当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionId，再根据 SessionId 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。<br>
根据以上流程可知，SessionId 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。<br>
</p>
</div>
</div>
<div id="outline-container-org77b3858" class="outline-3">
<h3 id="org77b3858">Cookie 与 Session 的区别</h3>
<div class="outline-text-3" id="text-org77b3858">
<ul class="org-ul">
<li>安全性： Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。<br></li>
<li>存取值的类型不同：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。<br></li>
<li>有效期不同： Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。<br></li>
<li>存储大小不同： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。<br></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgc365880" class="outline-2">
<h2 id="orgc365880">什么是Token</h2>
<div class="outline-text-2" id="text-orgc365880">
<p>
Acesss Token全称，意思是 “令牌”，是⽤户身份的验证⽅式访问资源接口（API）时所需要的资源凭证，，最简单的 token 组成: uid (⽤户唯⼀标识) + time (当前 时间戳) + sign (签名，由 token 的前⼏位 + 盐以哈希算法压缩成⼀定⻓度的⼗六进制字符串) ，同时还可 以将不变的参数也放进 token<br>
</p>

<p>
这里说的 token 只的是 JWT（Json Web Token）<br>
</p>
</div>
<div id="outline-container-orgefc6979" class="outline-3">
<h3 id="orgefc6979">Token 的特点：</h3>
<div class="outline-text-3" id="text-orgefc6979">
<ul class="org-ul">
<li>服务端无状态化<br></li>
<li>可扩展性好<br></li>
<li>支持移动端设备<br></li>
<li>安全<br></li>
<li>支持跨程序调用<br></li>
</ul>
</div>
</div>
<div id="outline-container-orgb640c00" class="outline-3">
<h3 id="orgb640c00">Token 的身份验证流程：</h3>
<div class="outline-text-3" id="text-orgb640c00">
<ol class="org-ol">
<li>客户端使用用户名跟密码请求登录<br></li>
<li>服务端收到请求，去验证用户名与密码<br></li>
<li>验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端<br></li>
<li>客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里<br></li>
<li>客户端每次向服务端请求资源的时候需要带着服务端签发的 token<br></li>
<li>服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据<br></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org6277dc2" class="outline-2">
<h2 id="org6277dc2">什么是Jwt</h2>
<div class="outline-text-2" id="text-org6277dc2">
<p>
JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案。是一种认证授权机制。<br>
JWT 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（RFC 7519）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。<br>
可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。<br>
一般而言，用户注册登陆后会生成一个 jwt token 返回给浏览器，浏览器向服务端请求数据时携带 token ，服务器端使用 signature 中定义的方式进行解码，进而对 token 进行解析和验证。<br>
</p>
</div>
<div id="outline-container-org17cdc06" class="outline-3">
<h3 id="org17cdc06">JWT 的组成部分</h3>
<div class="outline-text-3" id="text-org17cdc06">
<pre class="example" id="orge3effce">
..head      payload   signature
XXXXXXXXXX.YYYYYYYYYY.ZZZZZZZZZZ
</pre>

<dl class="org-dl">
<dt>head</dt><dd>用来指定使用的算法 (HMAC SHA256 RSA) 和 token 类型 (如 JWT)<br></dd>
<dt>payload</dt><dd>包含声明 (要求)，声明通常是⽤户信息或其他数据的声明，⽐如⽤户 id，名称，邮箱等。声明。可分为三种: registered,public,private<br></dd>
<dt>signature</dt><dd>⽤来保证 JWT 的真实性，可以使⽤不同的算法<br></dd>
</dl>
</div>
</div>
<div id="outline-container-org88be869" class="outline-3">
<h3 id="org88be869">JWT 的认证流程：</h3>
<div class="outline-text-3" id="text-org88be869">
<ol class="org-ol">
<li>用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT<br></li>
<li>客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）<br></li>
<li>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用Bearer 模式添加 JWT，服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为<br></li>
</ol>
</div>
</div>
<div id="outline-container-org403e8fd" class="outline-3">
<h3 id="org403e8fd">JWT 的使用方式</h3>
<div class="outline-text-3" id="text-org403e8fd">
<ol class="org-ol">
<li>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage<br></li>
<li>当用户希望访问一个受保护的路由或者资源的时候，可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求头信息的 Authorization 字段里，使用 Bearer 模式添加 JWT<br></li>
<li>跨域的时候，可以把 JWT 放在 POST 请求的数据体里。<br></li>
<li>通过URL<br></li>
</ol>
</div>
</div>
<div id="outline-container-org4430822" class="outline-3">
<h3 id="org4430822">Token 和 JWT 的区别：</h3>
<div class="outline-text-3" id="text-org4430822">
</div>
<div id="outline-container-org6193c9a" class="outline-4">
<h4 id="org6193c9a">相同点：</h4>
<div class="outline-text-4" id="text-org6193c9a">
<ul class="org-ul">
<li>都是访问资源的令牌<br></li>
<li>都可以记录用户的信息<br></li>
<li>都是使服务端无状态化<br></li>
<li>都是只有验证成功后，客户端才能访问服务端上受保护的资源<br></li>
</ul>
</div>
</div>
<div id="outline-container-orge22526b" class="outline-4">
<h4 id="orge22526b">不同点：</h4>
<div class="outline-text-4" id="text-orge22526b">
<ul class="org-ul">
<li>Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。<br></li>
<li>JWT：将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。<br></li>
</ul>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
