<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-05-09 Mon 14:20 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Goroutine调度器概述</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">Goroutine调度器概述</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgd4fb9ae">goroutine 简介</a></li>
<li><a href="#org735d41a">线程模型与调度器</a></li>
<li><a href="#org3fd7960">调度器数据结构概述</a></li>
<li><a href="#orgbb056ce">重要的结构体</a>
<ul>
<li><a href="#org36b762d">stack结构体</a></li>
<li><a href="#org6716c27">gobuf结构体</a></li>
<li><a href="#orgc779e35">g 结构体</a></li>
<li><a href="#orgd2c441e">m 结构体</a></li>
<li><a href="#orgc2e9cf4">p 结构体</a></li>
<li><a href="#org8bef44b">schedt 结构体</a></li>
</ul>
</li>
<li><a href="#orgae24959">重要的全局变量</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgd4fb9ae" class="outline-2">
<h2 id="orgd4fb9ae">goroutine 简介</h2>
<div class="outline-text-2" id="text-orgd4fb9ae">
<p>
goroutine 是 Go 语言实现的用户态线程，主要用来解决操作系统线程太"重"的问题，所谓的太重，主要表现在以下两个方面：<br>
</p>

<ul class="org-ul">
<li>创建和切换太重：操作系统线程的创建和切换都需要进入内核，而进入内核所消耗的性能代价比较高，开销较大；<br></li>
<li>内存使用太重：一方面，为了尽量避免极端情况下操作系统线程栈的溢出，内核在创建操作系统线程时默认会为其分配一个较大的栈内存（虚拟地址空间，内核并不会一开始就分配这么多的物理内存），然而在绝大多数情况下，系统线程远远用不了这么多内存，这导致了浪费；另一方面，栈内存空间一旦创建和初始化完成之后其大小就不能再有变化，这决定了在某些特殊场景下系统线程栈还是有溢出的风险。<br></li>
</ul>

<p>
而相对的，用户态的 goroutine 则轻量得多：<br>
</p>

<ul class="org-ul">
<li>goroutine 是用户态线程，其创建和切换都在用户代码中完成而无需进入操作系统内核，所以其开销要远远小于系统线程的创建和切换；<br></li>
<li>goroutine 启动时默认栈大小只有2k，这在多数情况下已经够用了，即使不够用，goroutine 的栈也会自动扩大，同时，如果栈太大了过于浪费它还能自动收缩，这样既没有栈溢出的风险，也不会造成栈内存空间的大量浪费。<br></li>
</ul>

<p>
正是因为 Go 语言中实现了如此轻量级的线程，才使得我们在 Go 程序中，可以轻易的创建成千上万甚至上百万的 goroutine 出来并发的执行任务而不用太担心性能和内存等问题。<br>
</p>

<p>
<b>注意：</b> 为了避免混淆，从现在开始，后面出现的所有的线程一词均是指操作系统线程，而 goroutine 我们不再称之为什么什么线程而是直接使用 goroutine 这个词。<br>
</p>
</div>
</div>
<div id="outline-container-org735d41a" class="outline-2">
<h2 id="org735d41a">线程模型与调度器</h2>
<div class="outline-text-2" id="text-org735d41a">
<p>
第一章讨论操作系统线程调度的时候我们曾经提到过，goroutine 建立在操作系统线程基础之上，它与操作系统线程之间实现了一个多对多（M:N）的两级线程模型。<br>
</p>

<p>
这里的 M:N 是指 M 个 goroutine 运行在N个操作系统线程之上，内核负责对这 N 个操作系统线程进行调度，而这 N 个系统线程又负责对这 M 个 goroutine 进行调度和运行。<br>
</p>

<p>
所谓的对 goroutine 的调度，是指程序代码按照一定的算法在适当的时候挑选出合适的 goroutine 并放到 CPU 上去运行的过程，这些负责对 goroutine 进行调度的程序代码我们称之为 goroutine 调度器。用极度简化了的伪代码来描述 goroutine 调度器的工作流程大概是下面这个样子：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#31243;&#24207;&#21551;&#21160;&#26102;&#30340;&#21021;&#22987;&#21270;&#20195;&#30721;</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">......</span>
<span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := 0; i &lt; N; i++ { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21019;&#24314;N&#20010;&#25805;&#20316;&#31995;&#32479;&#32447;&#31243;&#25191;&#34892;schedule&#20989;&#25968;</span>
    <span style="color: #d75fd7; font-weight: bold;">create_os_thread</span>(schedule) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21019;&#24314;&#19968;&#20010;&#25805;&#20316;&#31995;&#32479;&#32447;&#31243;&#25191;&#34892;schedule&#20989;&#25968;</span>
}

<span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">schedule&#20989;&#25968;&#23454;&#29616;&#35843;&#24230;&#36923;&#36753;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">schedule</span>() {
    <span style="color: #268bd2; font-weight: bold;">for</span> { <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#35843;&#24230;&#24490;&#29615;</span>
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#26681;&#25454;&#26576;&#31181;&#31639;&#27861;&#20174;M&#20010;goroutine&#20013;&#25214;&#20986;&#19968;&#20010;&#38656;&#35201;&#36816;&#34892;&#30340;goroutine</span>
        <span style="color: #8787d7;">g</span> := <span style="color: #d75fd7; font-weight: bold;">find_a_runnable_goroutine_from_M_goroutines</span>()
        <span style="color: #d75fd7; font-weight: bold;">run_g</span>(g) <span style="color: #008787; background-color: #262626;">//  </span><span style="color: #008787; background-color: #262626;">CPU &#36816;&#34892;&#35813;goroutine&#65292;&#30452;&#21040;&#38656;&#35201;&#35843;&#24230;&#20854;&#23427;goroutine&#25165;&#36820;&#22238;</span>
        <span style="color: #d75fd7; font-weight: bold;">save_status_of_g</span>(g) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20445;&#23384;goroutine&#30340;&#29366;&#24577;&#65292;&#20027;&#35201;&#26159;&#23492;&#23384;&#22120;&#30340;&#20540;</span>
    }
}
</pre>
</div>

<p>
这段伪代码表达的意思是，程序运行起来之后创建了 N 个由内核调度的操作系统线程（为了方便描述，我们称这些系统线程为工作线程）去执行 <code>shedule</code> 函数，而 <code>schedule</code> 函数在一个调度循环中反复从 M 个 goroutine 中挑选出一个需要运行的 goroutine 并跳转到该 goroutine 去运行，直到需要调度其它 goroutine 时才返回到 <code>schedule</code> 函数中通过 <code>save_status_of_g</code> 保存刚刚正在运行的 goroutine 的状态然后再次去寻找下一个 goroutine 。<br>
</p>

<p>
需要强调的是，这段伪代码对 goroutine 的调度代码做了高度的抽象、修改和简化处理，放在这里只是为了帮助我们从宏观上了解 goroutine 的两级调度模型，具体的实现原理和细节将从本章开始进行全面介绍。<br>
</p>
</div>
</div>
<div id="outline-container-org3fd7960" class="outline-2">
<h2 id="org3fd7960">调度器数据结构概述</h2>
<div class="outline-text-2" id="text-org3fd7960">
<p>
第一章我们讨论操作系统线程及其调度时还说过，可以把内核对系统线程的调度简单的归纳为：在执行操作系统代码时，内核调度器按照一定的算法挑选出一个线程并把该线程保存在内存之中的寄存器的值放入 CPU 对应的寄存器从而恢复该线程的运行。<br>
</p>

<p>
<span class="underline">万变不离其宗，系统线程对 goroutine 的调度与内核对系统线程的调度原理是一样的，实质都是通过保存和修改 CPU 寄存器的值来达到切换线程/goroutine的目的。</span><br>
</p>

<p>
因此，为了实现对 goroutine 的调度，需要引入一个数据结构来保存 CPU 寄存器的值以及 goroutine 的其它一些状态信息，在 Go 语言调度器源代码中，这个数据结构是一个名叫 <code>g</code> 的结构体，它保存了 goroutine 的所有信息，该结构体的每一个实例对象都代表了一个 goroutine ，调度器代码可以通过 <code>g</code> 对象来对 goroutine 进行调度，当 goroutine 被调离 CPU 时，调度器代码负责把 CPU 寄存器的值保存在 <code>g</code> 对象的成员变量之中，当 goroutine 被调度起来运行时，调度器代码又负责把 <code>g</code> 对象的成员变量所保存的寄存器的值恢复到 CPU 的寄存器。<br>
</p>

<p>
要实现对 goroutine 的调度，仅仅有 <code>g</code> 结构体对象是不够的，至少还需要一个存放所有（可运行） goroutine 的容器，便于工作线程寻找需要被调度起来运行的 goroutine ，于是 Go 调度器又引入了 <code>schedt</code> 结构体，一方面用来保存调度器自身的状态信息，另一方面它还拥有一个用来保存 goroutine 的运行队列。因为每个 Go 程序只有一个调度器，所以在每个 Go 程序中 <code>schedt</code> 结构体只有一个实例对象，该实例对象在源代码中被定义成了一个共享的全局变量，这样每个工作线程都可以访问它以及它所拥有的 goroutine 运行队列，我们称这个运行队列为全局运行队列。<br>
</p>

<p>
既然说到全局运行队列，读者可能猜想到应该还有一个局部运行队列。确实如此，因为全局运行队列是每个工作线程都可以读写的，因此访问它需要加锁，然而在一个繁忙的系统中，加锁会导致严重的性能问题。于是，调度器又为每个工作线程引入了一个私有的局部 goroutine 运行队列，工作线程优先使用自己的局部运行队列，只有必要时才会去访问全局运行队列，这大大减少了锁冲突，提高了工作线程的并发性。在 Go 调度器源代码中，局部运行队列被包含在 <code>p</code> 结构体的实例对象之中，每一个运行着 go 代码的工作线程都会与一个 <code>p</code> 结构体的实例对象关联在一起。<br>
</p>

<p>
除了上面介绍的 g 、 schedt 和 p 结构体，Go调度器源代码中还有一个用来代表工作线程的 m 结构体，每个工作线程都有唯一的一个 m 结构体的实例对象与之对应，m结构体对象除了记录着工作线程的诸如栈的起止位置、当前正在执行的 goroutine 以及是否空闲等等状态信息之外，还通过指针维持着与p结构体的实例对象之间的绑定关系。于是，通过m既可以找到与之对应的工作线程正在运行的 goroutine ，又可以找到工作线程的局部运行队列等资源。下面是 g、p、m 和 <code>schedt</code> 之间的关系图：<br>
</p>

<div class="div-center">
<img src="./images/g_p_m和schedt之间的关系.webp" width="460px" />
</div>

<p>
上图中圆形图案代表 g 结构体的实例对象，三角形代表 m 结构体的实例对象，正方形代表p结构体的实例对象，其中红色的 g 表示 m 对应的工作线程正在运行的 goroutine ，而灰色的g表示处于运行队列之中正在等待被调度起来运行的 goroutine 。<br>
</p>

<p>
从上图可以看出，每个m都绑定了一个p，每个p都有一个私有的本地 goroutine 队列，m对应的线程从本地和全局 goroutine 队列中获取 goroutine 并运行之。<br>
</p>

<p>
前面我们说每个工作线程都有一个 m 结构体对象与之对应，但并未详细说明它们之间是如何对应起来的，工作线程执行的代码是如何找到属于自己的那个 m 结构体实例对象的呢？<br>
</p>

<p>
如果只有一个工作线程，那么就只会有一个 m 结构体对象，问题就很简单，定义一个全局的 m 结构体变量就行了。可是我们有多个工作线程和多个 m 需要一一对应，怎么办呢？还记得第一章我们讨论过的线程本地存储吗？当时我们说过，线程本地存储其实就是线程私有的全局变量，这不正是我们所需要的吗？！只要每个工作线程拥有了各自私有的 m 结构体全局变量，我们就能在不同的工作线程中使用相同的全局变量名来访问不同的 m 结构体对象，这完美的解决我们的问题。<br>
</p>

<p>
具体到 goroutine 调度器代码，每个工作线程在刚刚被创建出来进入调度循环之前就利用线程本地存储机制为该工作线程实现了一个指向 m 结构体实例对象的私有全局变量，这样在之后的代码中就使用该全局变量来访问自己的 m 结构体对象以及与 m 相关联的 p 和 g 对象。<br>
</p>

<p>
有了上述数据结构以及工作线程与数据结构之间的映射机制，我们可以把前面的调度伪代码写得更丰满一点：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#31243;&#24207;&#21551;&#21160;&#26102;&#30340;&#21021;&#22987;&#21270;&#20195;&#30721;</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">......</span>
<span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := 0; i &lt; N; i++ { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21019;&#24314;N&#20010;&#25805;&#20316;&#31995;&#32479;&#32447;&#31243;&#25191;&#34892;schedule&#20989;&#25968;</span>
    <span style="color: #d75fd7; font-weight: bold;">create_os_thread</span>(schedule) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21019;&#24314;&#19968;&#20010;&#25805;&#20316;&#31995;&#32479;&#32447;&#31243;&#25191;&#34892;schedule&#20989;&#25968;</span>
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#23450;&#20041;&#19968;&#20010;&#32447;&#31243;&#31169;&#26377;&#20840;&#23616;&#21464;&#37327;&#65292;&#27880;&#24847;&#23427;&#26159;&#19968;&#20010;&#25351;&#21521;m&#32467;&#26500;&#20307;&#23545;&#35937;&#30340;&#25351;&#38024;</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">ThreadLocal&#29992;&#26469;&#23450;&#20041;&#32447;&#31243;&#31169;&#26377;&#20840;&#23616;&#21464;&#37327;</span>
ThreadLocal <span style="color: #df005f; font-weight: bold;">self</span> *m
<span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">schedule&#20989;&#25968;&#23454;&#29616;&#35843;&#24230;&#36923;&#36753;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">schedule</span>() {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21019;&#24314;&#21644;&#21021;&#22987;&#21270;m&#32467;&#26500;&#20307;&#23545;&#35937;&#65292;&#24182;&#36171;&#20540;&#32473;&#31169;&#26377;&#20840;&#23616;&#21464;&#37327;self</span>
    self = <span style="color: #d75fd7; font-weight: bold;">initm</span>()  
    <span style="color: #268bd2; font-weight: bold;">for</span> { <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#35843;&#24230;&#24490;&#29615;</span>
        <span style="color: #268bd2; font-weight: bold;">if</span> (self.p.runqueue <span style="color: #df005f; font-weight: bold;">is</span> empty) {
            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#26681;&#25454;&#26576;&#31181;&#31639;&#27861;&#20174;&#20840;&#23616;&#36816;&#34892;&#38431;&#21015;&#20013;&#25214;&#20986;&#19968;&#20010;&#38656;&#35201;&#36816;&#34892;&#30340;goroutine</span>
            <span style="color: #8787d7;">g</span> := <span style="color: #d75fd7; font-weight: bold;">find_a_runnable_goroutine_from_global_runqueue</span>()
        } <span style="color: #268bd2; font-weight: bold;">else</span> {
            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#26681;&#25454;&#26576;&#31181;&#31639;&#27861;&#20174;&#31169;&#26377;&#30340;&#23616;&#37096;&#36816;&#34892;&#38431;&#21015;&#20013;&#25214;&#20986;&#19968;&#20010;&#38656;&#35201;&#36816;&#34892;&#30340;goroutine</span>
            <span style="color: #8787d7;">g</span> := <span style="color: #d75fd7; font-weight: bold;">find_a_runnable_goroutine_from_local_runqueue</span>()
        }
        <span style="color: #d75fd7; font-weight: bold;">run_g</span>(g) <span style="color: #008787; background-color: #262626;">//  </span><span style="color: #008787; background-color: #262626;">CPU &#36816;&#34892;&#35813;goroutine&#65292;&#30452;&#21040;&#38656;&#35201;&#35843;&#24230;&#20854;&#23427;goroutine&#25165;&#36820;&#22238;</span>
        <span style="color: #d75fd7; font-weight: bold;">save_status_of_g</span>(g) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20445;&#23384;goroutine&#30340;&#29366;&#24577;&#65292;&#20027;&#35201;&#26159;&#23492;&#23384;&#22120;&#30340;&#20540;</span>
    }
}
</pre>
</div>

<p>
仅仅从上面这个伪代码来看，我们完全不需要线程私有全局变量，只需在 <code>schedule</code> 函数中定义一个局部变量就行了。但真实的调度代码错综复杂，不光是这个 <code>schedule</code> 函数会需要访问 m，其它很多地方还需要访问它，所以需要使用全局变量来方便其它地方对 m 的以及与 m 相关的 g 和 p 的访问。<br>
</p>

<p>
在简单的介绍了 Go 语言调度器以及它所需要的数据结构之后，下面我们来看一下 Go 的调度代码中对上述的几个结构体的定义。<br>
</p>
</div>
</div>
<div id="outline-container-orgbb056ce" class="outline-2">
<h2 id="orgbb056ce">重要的结构体</h2>
<div class="outline-text-2" id="text-orgbb056ce">
<p>
下面介绍的这些结构体中的字段非常多，牵涉到的细节也很庞杂，光是看这些结构体的定义我们没有必要也无法真正理解它们的用途，所以在这里我们只需要大概了解一下就行了，看不懂记不住都没有关系，随着后面对代码逐步深入的分析，我们也必将会对这些结构体有越来越清晰的认识。为了节省篇幅，下面各结构体的定义略去了跟调度器无关的成员。另外，这些结构体的定义全部位于Go语言的源代码路径下的 <a href="https://github.com/golang/go/blob/master/src/runtime/runtime2.go">runtime/runtime2.go</a> 文件之中。<br>
</p>
</div>
<div id="outline-container-org36b762d" class="outline-3">
<h3 id="org36b762d">stack结构体</h3>
<div class="outline-text-3" id="text-org36b762d">
<p>
<code>stack</code> 结构体主要用来记录 goroutine 所使用的栈的信息，包括栈顶和栈底位置：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Stack describes a Go execution stack.</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">The bounds of the stack are exactly [lo, hi),</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">with no implicit data structures on either side.</span>
<span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#29992;&#20110;&#35760;&#24405;goroutine&#20351;&#29992;&#30340;&#26632;&#30340;&#36215;&#22987;&#21644;&#32467;&#26463;&#20301;&#32622;</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">stack</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {  
    lo <span style="color: #df005f; font-weight: bold;">uintptr</span>    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#26632;&#39030;&#65292;&#25351;&#21521;&#20869;&#23384;&#20302;&#22320;&#22336;</span>
    hi <span style="color: #df005f; font-weight: bold;">uintptr</span>    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#26632;&#24213;&#65292;&#25351;&#21521;&#20869;&#23384;&#39640;&#22320;&#22336;</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org6716c27" class="outline-3">
<h3 id="org6716c27">gobuf结构体</h3>
<div class="outline-text-3" id="text-org6716c27">
<p>
<code>gobuf</code> 结构体用于保存 goroutine 的调度信息，主要包括 CPU 的几个寄存器的值：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">gobuf</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">The offsets of sp, pc, and g are known to (hard-coded in) libmach.</span>
    <span style="color: #008787; background-color: #262626;">//</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">ctxt is unusual with respect to GC: it may be a</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">heap-allocated funcval, so GC needs to track it, but it</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">needs to be set and cleared from assembly, where it's</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">difficult to have write barriers. However, ctxt is really a</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">saved, live register, and we only ever exchange it between</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">the real register and the gobuf. Hence, we treat it as a</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">root during stack scanning, which means assembly that saves</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">and restores it doesn't need write barriers. It's still</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">typed as a pointer so that any other writes from Go get</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">write barriers.</span>
    sp   <span style="color: #df005f; font-weight: bold;">uintptr</span>  <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20445;&#23384; CPU &#30340;rsp&#23492;&#23384;&#22120;&#30340;&#20540;</span>
    pc   <span style="color: #df005f; font-weight: bold;">uintptr</span>  <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20445;&#23384; CPU &#30340;rip&#23492;&#23384;&#22120;&#30340;&#20540;</span>
    g    <span style="color: #df005f; font-weight: bold;">guintptr</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35760;&#24405;&#24403;&#21069;&#36825;&#20010;gobuf&#23545;&#35937;&#23646;&#20110;&#21738;&#20010;goroutine</span>
    ctxt <span style="color: #df005f; font-weight: bold;">unsafe.Pointer</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20445;&#23384;&#31995;&#32479;&#35843;&#29992;&#30340;&#36820;&#22238;&#20540;&#65292;&#22240;&#20026;&#20174;&#31995;&#32479;&#35843;&#29992;&#36820;&#22238;&#20043;&#21518;&#22914;&#26524;p&#34987;&#20854;&#23427;&#24037;&#20316;&#32447;&#31243;&#25250;&#21344;&#65292;</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21017;&#36825;&#20010;goroutine&#20250;&#34987;&#25918;&#20837;&#20840;&#23616;&#36816;&#34892;&#38431;&#21015;&#34987;&#20854;&#23427;&#24037;&#20316;&#32447;&#31243;&#35843;&#24230;&#65292;&#20854;&#23427;&#32447;&#31243;&#38656;&#35201;&#30693;&#36947;&#31995;&#32479;&#35843;&#29992;&#30340;&#36820;&#22238;&#20540;&#12290;</span>
    ret  <span style="color: #df005f; font-weight: bold;">sys.Uintreg</span>  
    lr   <span style="color: #df005f; font-weight: bold;">uintptr</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20445;&#23384; CPU &#30340;rip&#23492;&#23384;&#22120;&#30340;&#20540;</span>
    bp   <span style="color: #df005f; font-weight: bold;">uintptr</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">for GOEXPERIMENT=framepointer</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc779e35" class="outline-3">
<h3 id="orgc779e35">g 结构体</h3>
<div class="outline-text-3" id="text-orgc779e35">
<p>
g 结构体用于代表一个 goroutine ，该结构体保存了 goroutine 的所有信息，包括栈， <code>gobuf</code> 结构体和其它的一些状态信息：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21069;&#25991;&#25152;&#35828;&#30340;g&#32467;&#26500;&#20307;&#65292;&#23427;&#20195;&#34920;&#20102;&#19968;&#20010;goroutine</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">g</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Stack parameters.</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">stack describes the actual stack memory: [stack.lo, stack.hi).</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">stackguard0 is the stack pointer compared in the Go stack growth prologue.</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">stackguard1 is the stack pointer compared in the C stack growth prologue.</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">It is stack.lo+StackGuard on g0 and gsignal stacks.</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35760;&#24405;&#35813;goroutine&#20351;&#29992;&#30340;&#26632;</span>
    stack       <span style="color: #df005f; font-weight: bold;">stack</span>   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">offset known to runtime/cgo</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#19979;&#38754;&#20004;&#20010;&#25104;&#21592;&#29992;&#20110;&#26632;&#28322;&#20986;&#26816;&#26597;&#65292;&#23454;&#29616;&#26632;&#30340;&#33258;&#21160;&#20280;&#32553;&#65292;&#25250;&#21344;&#35843;&#24230;&#20063;&#20250;&#29992;&#21040;stackguard0</span>
    stackguard0 <span style="color: #df005f; font-weight: bold;">uintptr</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">offset known to liblink</span>
    stackguard1 <span style="color: #df005f; font-weight: bold;">uintptr</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">offset known to liblink</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">......</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#27492;goroutine&#27491;&#22312;&#34987;&#21738;&#20010;&#24037;&#20316;&#32447;&#31243;&#25191;&#34892;</span>
    m              *<span style="color: #df005f; font-weight: bold;">m</span>      <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">current m; offset known to arm liblink</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20445;&#23384;&#35843;&#24230;&#20449;&#24687;&#65292;&#20027;&#35201;&#26159;&#20960;&#20010;&#23492;&#23384;&#22120;&#30340;&#20540;</span>
    sched          <span style="color: #df005f; font-weight: bold;">gobuf</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">......</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">schedlink&#23383;&#27573;&#25351;&#21521;&#20840;&#23616;&#36816;&#34892;&#38431;&#21015;&#20013;&#30340;&#19979;&#19968;&#20010;g&#65292;</span>
    <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#25152;&#26377;&#20301;&#20110;&#20840;&#23616;&#36816;&#34892;&#38431;&#21015;&#20013;&#30340;g&#24418;&#25104;&#19968;&#20010;&#38142;&#34920;</span>
    schedlink      <span style="color: #df005f; font-weight: bold;">guintptr</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">......</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#25250;&#21344;&#35843;&#24230;&#26631;&#24535;&#65292;&#22914;&#26524;&#38656;&#35201;&#25250;&#21344;&#35843;&#24230;&#65292;&#35774;&#32622;preempt&#20026;true</span>
    preempt        <span style="color: #df005f; font-weight: bold;">bool</span>       <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">preemption signal, duplicates stackguard0 = stackpreempt</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">......</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd2c441e" class="outline-3">
<h3 id="orgd2c441e">m 结构体</h3>
<div class="outline-text-3" id="text-orgd2c441e">
<p>
m 结构体用来代表工作线程，它保存了 m 自身使用的栈信息，当前正在运行的 goroutine 以及与 m 绑定的 p 等信息，详见下面定义中的注释：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">m</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">g0&#20027;&#35201;&#29992;&#26469;&#35760;&#24405;&#24037;&#20316;&#32447;&#31243;&#20351;&#29992;&#30340;&#26632;&#20449;&#24687;&#65292;&#22312;&#25191;&#34892;&#35843;&#24230;&#20195;&#30721;&#26102;&#38656;&#35201;&#20351;&#29992;&#36825;&#20010;&#26632;</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#25191;&#34892;&#29992;&#25143;goroutine&#20195;&#30721;&#26102;&#65292;&#20351;&#29992;&#29992;&#25143;goroutine&#33258;&#24049;&#30340;&#26632;&#65292;&#35843;&#24230;&#26102;&#20250;&#21457;&#29983;&#26632;&#30340;&#20999;&#25442;</span>
    g0      *<span style="color: #df005f; font-weight: bold;">g</span>     <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">goroutine with scheduling stack</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36890;&#36807;TLS&#23454;&#29616;m&#32467;&#26500;&#20307;&#23545;&#35937;&#19982;&#24037;&#20316;&#32447;&#31243;&#20043;&#38388;&#30340;&#32465;&#23450;</span>
    tls           [6]<span style="color: #df005f; font-weight: bold;">uintptr</span>   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">thread-local storage (for x86 extern register)</span>
    mstartfn      <span style="color: #268bd2; font-weight: bold;">func</span>()
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#25351;&#21521;&#24037;&#20316;&#32447;&#31243;&#27491;&#22312;&#36816;&#34892;&#30340;goroutine&#30340;g&#32467;&#26500;&#20307;&#23545;&#35937;</span>
    curg          *<span style="color: #df005f; font-weight: bold;">g</span>       <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">current running goroutine</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35760;&#24405;&#19982;&#24403;&#21069;&#24037;&#20316;&#32447;&#31243;&#32465;&#23450;&#30340;p&#32467;&#26500;&#20307;&#23545;&#35937;</span>
    p             <span style="color: #df005f; font-weight: bold;">puintptr</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">attached p for executing go code (nil if not executing go code)</span>
    nextp         <span style="color: #df005f; font-weight: bold;">puintptr</span>
    oldp          <span style="color: #df005f; font-weight: bold;">puintptr</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">the p that was attached before executing a syscall</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">spinning&#29366;&#24577;&#65306;&#34920;&#31034;&#24403;&#21069;&#24037;&#20316;&#32447;&#31243;&#27491;&#22312;&#35797;&#22270;&#20174;&#20854;&#23427;&#24037;&#20316;&#32447;&#31243;&#30340;&#26412;&#22320;&#36816;&#34892;&#38431;&#21015;&#20599;&#21462;goroutine</span>
    spinning      <span style="color: #df005f; font-weight: bold;">bool</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">m is out of work and is actively looking for work</span>
    blocked       <span style="color: #df005f; font-weight: bold;">bool</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">m is blocked on a note</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#27809;&#26377;goroutine&#38656;&#35201;&#36816;&#34892;&#26102;&#65292;&#24037;&#20316;&#32447;&#31243;&#30561;&#30496;&#22312;&#36825;&#20010;park&#25104;&#21592;&#19978;&#65292;</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20854;&#23427;&#32447;&#31243;&#36890;&#36807;&#36825;&#20010;park&#21796;&#37266;&#35813;&#24037;&#20316;&#32447;&#31243;</span>
    park          <span style="color: #df005f; font-weight: bold;">note</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35760;&#24405;&#25152;&#26377;&#24037;&#20316;&#32447;&#31243;&#30340;&#19968;&#20010;&#38142;&#34920;</span>
    alllink       *<span style="color: #df005f; font-weight: bold;">m</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">on allm</span>
    schedlink     <span style="color: #df005f; font-weight: bold;">muintptr</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Linux&#24179;&#21488;thread&#30340;&#20540;&#23601;&#26159;&#25805;&#20316;&#31995;&#32479;&#32447;&#31243;ID</span>
    thread        <span style="color: #df005f; font-weight: bold;">uintptr</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">thread handle</span>
    freelink      *<span style="color: #df005f; font-weight: bold;">m</span>      <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">on sched.freem</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">......</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc2e9cf4" class="outline-3">
<h3 id="orgc2e9cf4">p 结构体</h3>
<div class="outline-text-3" id="text-orgc2e9cf4">
<p>
p 结构体用于保存工作线程执行 go 代码时所必需的资源，比如 goroutine 的运行队列，内存分配用到的缓存等等。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">p</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    lock <span style="color: #df005f; font-weight: bold;">mutex</span>

    status       <span style="color: #df005f; font-weight: bold;">uint32</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">one of pidle/prunning/...</span>
    link            <span style="color: #df005f; font-weight: bold;">puintptr</span>
    schedtick   <span style="color: #df005f; font-weight: bold;">uint32</span>     <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">incremented on every scheduler call</span>
    syscalltick  <span style="color: #df005f; font-weight: bold;">uint32</span>     <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">incremented on every system call</span>
    sysmontick  <span style="color: #df005f; font-weight: bold;">sysmontick</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">last tick observed by sysmon</span>
    m                <span style="color: #df005f; font-weight: bold;">muintptr</span>   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">back-link to associated m (nil if idle)</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">......</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Queue of runnable goroutines. Accessed without lock.</span>
    <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#26412;&#22320;goroutine&#36816;&#34892;&#38431;&#21015;</span>
    runqhead <span style="color: #df005f; font-weight: bold;">uint32</span>  <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#38431;&#21015;&#22836;</span>
    runqtail <span style="color: #df005f; font-weight: bold;">uint32</span>     <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#38431;&#21015;&#23614;</span>
    runq     [256]<span style="color: #df005f; font-weight: bold;">guintptr</span>  <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#20351;&#29992;&#25968;&#32452;&#23454;&#29616;&#30340;&#24490;&#29615;&#38431;&#21015;</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">runnext, if non-nil, is a runnable G that was ready'd by</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">the current G and should be run next instead of what's in</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">runq if there's time remaining in the running G's time</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">slice. It will inherit the time left in the current time</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">slice. If a set of goroutines is locked in a</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">communicate-and-wait pattern, this schedules that set as a</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">unit and eliminates the (potentially large) scheduling</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">latency that otherwise arises from adding the ready'd</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">goroutines to the end of the run queue.</span>
    runnext <span style="color: #df005f; font-weight: bold;">guintptr</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Available G's (status == Gdead)</span>
    gFree <span style="color: #268bd2; font-weight: bold;">struct</span> {
        gList
        n <span style="color: #df005f; font-weight: bold;">int32</span>
    }

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">......</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org8bef44b" class="outline-3">
<h3 id="org8bef44b">schedt 结构体</h3>
<div class="outline-text-3" id="text-org8bef44b">
<p>
<code>schedt</code> 结构体用来保存调度器的状态信息和 goroutine 的全局运行队列：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">schedt</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">accessed atomically. keep at top to ensure alignment on 32-bit systems.</span>
    goidgen  <span style="color: #df005f; font-weight: bold;">uint64</span>
    lastpoll <span style="color: #df005f; font-weight: bold;">uint64</span>

    lock <span style="color: #df005f; font-weight: bold;">mutex</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">sure to call checkdead().</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#30001;&#31354;&#38386;&#30340;&#24037;&#20316;&#32447;&#31243;&#32452;&#25104;&#38142;&#34920;</span>
    midle        <span style="color: #df005f; font-weight: bold;">muintptr</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">idle m's waiting for work</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#31354;&#38386;&#30340;&#24037;&#20316;&#32447;&#31243;&#30340;&#25968;&#37327;</span>
    nmidle       <span style="color: #df005f; font-weight: bold;">int32</span>    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">number of idle m's waiting for work</span>
    nmidlelocked <span style="color: #df005f; font-weight: bold;">int32</span>    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">number of locked m's waiting for work</span>
    mnext        <span style="color: #df005f; font-weight: bold;">int64</span>    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">number of m's that have been created and next M ID</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#26368;&#22810;&#21482;&#33021;&#21019;&#24314;maxmcount&#20010;&#24037;&#20316;&#32447;&#31243;</span>
    maxmcount    <span style="color: #df005f; font-weight: bold;">int32</span>    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">maximum number of m's allowed (or die)</span>
    nmsys        <span style="color: #df005f; font-weight: bold;">int32</span>    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">number of system m's not counted for deadlock</span>
    nmfreed      <span style="color: #df005f; font-weight: bold;">int64</span>    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">cumulative number of freed m's</span>

    ngsys <span style="color: #df005f; font-weight: bold;">uint32</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">number of system goroutines; updated atomically</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#30001;&#31354;&#38386;&#30340;p&#32467;&#26500;&#20307;&#23545;&#35937;&#32452;&#25104;&#30340;&#38142;&#34920;</span>
    pidle      <span style="color: #df005f; font-weight: bold;">puintptr</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">idle p's</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#31354;&#38386;&#30340;p&#32467;&#26500;&#20307;&#23545;&#35937;&#30340;&#25968;&#37327;</span>
    npidle     <span style="color: #df005f; font-weight: bold;">uint32</span>
    nmspinning <span style="color: #df005f; font-weight: bold;">uint32</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">See "Worker thread parking/unparking" comment in proc.go.</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Global runnable queue.</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">goroutine&#20840;&#23616;&#36816;&#34892;&#38431;&#21015;</span>
    runq     <span style="color: #df005f; font-weight: bold;">gQueue</span>
    runqsize <span style="color: #df005f; font-weight: bold;">int32</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">......</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Global cache of dead G's.</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">gFree&#26159;&#25152;&#26377;&#24050;&#32463;&#36864;&#20986;&#30340;goroutine&#23545;&#24212;&#30340;g&#32467;&#26500;&#20307;&#23545;&#35937;&#32452;&#25104;&#30340;&#38142;&#34920;</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#29992;&#20110;&#32531;&#23384;g&#32467;&#26500;&#20307;&#23545;&#35937;&#65292;&#36991;&#20813;&#27599;&#27425;&#21019;&#24314;goroutine&#26102;&#37117;&#37325;&#26032;&#20998;&#37197;&#20869;&#23384;</span>
    gFree <span style="color: #268bd2; font-weight: bold;">struct</span> {
        lock          <span style="color: #df005f; font-weight: bold;">mutex</span>
        stack        <span style="color: #df005f; font-weight: bold;">gList</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Gs with stacks</span>
        noStack   <span style="color: #df005f; font-weight: bold;">gList</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Gs without stacks</span>
        n              <span style="color: #df005f; font-weight: bold;">int32</span>
    }

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">......</span>
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgae24959" class="outline-2">
<h2 id="orgae24959">重要的全局变量</h2>
<div class="outline-text-2" id="text-orgae24959">
<div class="org-src-container">
<pre class="src src-go">allgs     []*<span style="color: #df005f; font-weight: bold;">g</span>     <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20445;&#23384;&#25152;&#26377;&#30340;g</span>
allm       *<span style="color: #df005f; font-weight: bold;">m</span>    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#25152;&#26377;&#30340;m&#26500;&#25104;&#30340;&#19968;&#20010;&#38142;&#34920;&#65292;&#21253;&#25324;&#19979;&#38754;&#30340;m0</span>
allp       []*<span style="color: #df005f; font-weight: bold;">p</span>    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20445;&#23384;&#25152;&#26377;&#30340;p&#65292;len(allp) == gomaxprocs</span>

ncpu             <span style="color: #df005f; font-weight: bold;">int32</span>   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#31995;&#32479;&#20013;cpu&#26680;&#30340;&#25968;&#37327;&#65292;&#31243;&#24207;&#21551;&#21160;&#26102;&#30001;runtime&#20195;&#30721;&#21021;&#22987;&#21270;</span>
gomaxprocs <span style="color: #df005f; font-weight: bold;">int32</span>   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">p&#30340;&#26368;&#22823;&#20540;&#65292;&#40664;&#35748;&#31561;&#20110;ncpu&#65292;&#20294;&#21487;&#20197;&#36890;&#36807;GOMAXPROCS&#20462;&#25913;</span>

sched      <span style="color: #df005f; font-weight: bold;">schedt</span>     <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35843;&#24230;&#22120;&#32467;&#26500;&#20307;&#23545;&#35937;&#65292;&#35760;&#24405;&#20102;&#35843;&#24230;&#22120;&#30340;&#24037;&#20316;&#29366;&#24577;</span>

m0  <span style="color: #df005f; font-weight: bold;">m</span>       <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20195;&#34920;&#36827;&#31243;&#30340;&#20027;&#32447;&#31243;</span>
g0   <span style="color: #df005f; font-weight: bold;">g</span>        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">m0&#30340;g0&#65292;&#20063;&#23601;&#26159;m0.g0 = &amp;g0</span>
</pre>
</div>

<p>
在程序初始化时，这些全变量都会被初始化为 0 值，指针会被初始化为 <code>nil</code> 指针，切片初始化为 <code>nil</code> 切片， <code>int</code> 被初始化为数字 0，结构体的所有成员变量按其本类型初始化为其类型的 0 值。所以程序刚启动时 <code>allgs</code> ， <code>allm</code> 和 <code>allp</code> 都不包含任何 g，m 和 p。<br>
</p>

<div class="reference">
<ul style="list-style: none;">
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU1OTg5NDkzOA==&mid=2247483761&idx=1&sn=15949fbeb48985c6c3781583df6956e6&scene=19#wechat_redirect" target="_blank">goroutine调度器概述（11）</a></li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-02-20 15:02 Sun</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-05-09 Mon 14:20</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
