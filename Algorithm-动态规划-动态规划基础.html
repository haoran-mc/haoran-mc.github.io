<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-10-27 Wed 22:29 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>动态规划基础</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran &lt;haoran.mc@outlook.com&gt;">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">动态规划基础</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org270eb01">钢条切割</a></li>
<li><a href="#orgc2d8dfa">矩阵链乘法</a></li>
<li><a href="#org9ba95c2">动态规划原理</a>
<ul>
<li><a href="#org36369bd">最优子结构</a></li>
<li><a href="#org4d34193">子问题重叠</a></li>
<li><a href="#org5329e3f">重构最优解</a></li>
</ul>
</li>
<li><a href="#org8e05eef">最优二叉搜索树</a></li>
<li><a href="#orgc6fff00">最长连续不下降子序列</a></li>
<li><a href="#orgae96b99">最长不下降子序列</a></li>
<li><a href="#org9b73e1e">最大连续子序列和</a>
<ul>
<li><a href="#org181cbce">最大连续子序列和</a>
<ul>
<li><a href="#org0992b91">前缀和</a></li>
<li><a href="#org62c3c83">动态规划</a></li>
<li><a href="#orgfa5d773">单调队列</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgcee69d4">最长非递增子串</a></li>
<li><a href="#org5f85711">DAG 中的简单路径</a></li>
<li><a href="#orge9e40fc">最长回文子序列</a></li>
<li><a href="#orgd0fa4d5">最长回文子串</a></li>
<li><a href="#orge849a69">双调欧几里德旅行商问题</a></li>
<li><a href="#org0e6483d">整齐打印</a></li>
<li><a href="#org759defe">最优对齐问题</a></li>
<li><a href="#orge7c92a6">公司聚会计划</a></li>
<li><a href="#org91f6847">译码算法</a></li>
<li><a href="#org6c25b29">基于接缝裁剪的图像压缩</a></li>
<li><a href="#org30bc2c2">字符串拆分</a></li>
<li><a href="#org6f34a96">投资策略规划</a></li>
<li><a href="#org80ca6eb">库存规划</a></li>
<li><a href="#org6a00259">签约棒球自由球员</a></li>
</ul>
</div>
</div>

<div id="outline-container-org270eb01" class="outline-2">
<h2 id="org270eb01">钢条切割</h2>
</div>
<div id="outline-container-orgc2d8dfa" class="outline-2">
<h2 id="orgc2d8dfa">矩阵链乘法</h2>
</div>
<div id="outline-container-org9ba95c2" class="outline-2">
<h2 id="org9ba95c2">动态规划原理</h2>
<div class="outline-text-2" id="text-org9ba95c2">
</div>
<div id="outline-container-org36369bd" class="outline-3">
<h3 id="org36369bd">最优子结构</h3>
</div>
<div id="outline-container-org4d34193" class="outline-3">
<h3 id="org4d34193">子问题重叠</h3>
</div>
<div id="outline-container-org5329e3f" class="outline-3">
<h3 id="org5329e3f">重构最优解</h3>
</div>
</div>
<div id="outline-container-org8e05eef" class="outline-2">
<h2 id="org8e05eef">最优二叉搜索树</h2>
</div>
<div id="outline-container-orgc6fff00" class="outline-2">
<h2 id="orgc6fff00">最长连续不下降子序列</h2>
</div>
<div id="outline-container-orgae96b99" class="outline-2">
<h2 id="orgae96b99">最长不下降子序列</h2>
<div class="outline-text-2" id="text-orgae96b99">
<p>
&gt; 最长不下降子序列(Longest Increasing Sequence, LIS)<br>
&gt; 在一个数字序列中，找到一个最长的子序列(可以不连续), 使得这个子序列是不下降的(非递减的)<br>
</p>

<p>
A = {1, 2, 3, -1, -2, 7, 9}<br>
最长不下降子序列是{1, 2, 3, 7, 9}<br>
</p>
<ul class="org-ul">
<li>令dp[i]表示以A[i]结尾的最长不下降子序列长度(强制要求)<br></li>
<li>如果存在A[i]之前的元素A[j]\(j &lt; i)，使得A[j] &lt;= A[i]且dp[j] + 1 &gt; dp[i]<br></li>
<li>更新dp[i] = dp[j] + 1<br></li>
<li>状态转移方程：dp[i] = max{1, dp[j] + 1}(j = 1, 2, 3, &#x2026; , i-1 &amp;&amp; A[j] &lt; A[i])<br></li>

<li>对与每个A[i]来说，都要与之前的所有A[j]比较，时间复杂度为O(n^2)<br></li>
</ul>
</div>
</div>
<div id="outline-container-org9b73e1e" class="outline-2">
<h2 id="org9b73e1e">最大连续子序列和</h2>
<div class="outline-text-2" id="text-org9b73e1e">
</div>
<div id="outline-container-org181cbce" class="outline-3">
<h3 id="org181cbce">最大连续子序列和</h3>
<div class="outline-text-3" id="text-org181cbce">
<p>
给定一个数字序列，num1, num2, num3, num4, num5, &#x2026; , numn, 求出i, j使(numi + &#x2026; + numj)最大，输出这个最大和<br>
</p>
</div>
<div id="outline-container-org0992b91" class="outline-4">
<h4 id="org0992b91">前缀和</h4>
<div class="outline-text-4" id="text-org0992b91">
<p>
从第一个数开始，当前sequ[1].sum = sequ[1]<br>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">i</span> = <span style="color: #009F9F;">1</span>; i &lt; n; i++)
    <span style="color: #BD93F9;">if</span> (sequ[i-<span style="color: #009F9F;">1</span>].sum &gt;= <span style="color: #009F9F;">0</span>)
        sequ[i].sum += numi
        <span style="color: #BD93F9;">else</span>
            sequ[i].sum = numi
</pre>
</div>
</div>
</div>
<div id="outline-container-org62c3c83" class="outline-4">
<h4 id="org62c3c83">动态规划</h4>
<div class="outline-text-4" id="text-org62c3c83">
<p>
状态转移方程：dp[i] = max{sequ[i], dp[i-1] + sequ[i]}<br>
</p>
</div>
</div>
<div id="outline-container-orgfa5d773" class="outline-4">
<h4 id="orgfa5d773">单调队列</h4>
<div class="outline-text-4" id="text-orgfa5d773">
<p>
给定一个长度为N的整数序列(可能有负数)，从中找出一段长度不超过M的连续子序列，使得所有子序列中所有数的和最大(这里增加了不超过M的条件)<br>
最优选择的策略集合一定是一个"下标位置递增，对应的前缀和的值也递增"的序列，所以可以使用队列保存这个序列<br>
</p>
<ol class="org-ol">
<li>判断队头决策与i的距离是否超过M的范围，若超出则出队<br></li>
<li>此时队头就是右端点为i时，左端点j的最优选择<br></li>
<li>不断删除队尾决策，直到队尾对应的前缀和S小于S[i]，然后把i作为一个新的决策入队<br></li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-orgcee69d4" class="outline-2">
<h2 id="orgcee69d4">最长非递增子串</h2>
<div class="outline-text-2" id="text-orgcee69d4">
<ul class="org-ul">
<li><p>
导弹拦截<br>
</p>
<ul class="org-ul">
<li>[导弹拦截](<a href="https://vjudge.net/problem/OpenJ_Bailian-2945">https://vjudge.net/problem/OpenJ_Bailian-2945</a>)<br></li>
</ul>
<p>
&gt; 某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是它有一个缺陷: 虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在适用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。<br>
</p>

<p>
输入: 第一行输入导弹的枚数N，第二行是n个数表示导弹依次飞来的高度<br>
输出: 第一行输出最多可拦截的导弹数，第二行输出拦截的导弹序列<br>
</p>

<p>
输入样例:<br>
8<br>
389 207 155 300 299 170 158 65<br>
</p>

<p>
输出样例:<br>
6<br>
380 300 299 170 158 65<br>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #009F9F;">#include</span> <span style="color: #FC9F4E;">&lt;cstdio&gt;</span>
<span style="color: #009F9F;">#include</span> <span style="color: #FC9F4E;">&lt;cstring&gt;</span>
<span style="color: #009F9F;">#include</span> <span style="color: #FC9F4E;">&lt;algorithm&gt;</span>
<span style="color: #BD93F9;">using</span> <span style="color: #BD93F9;">namespace</span> <span style="color: #009F9F;">std</span>;
<span style="color: #BD93F9;">const</span> <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">maxn</span> = <span style="color: #009F9F;">25</span>;
<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">bomb</span>[maxn];
<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">dp</span>[maxn];
<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">main</span>() {
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">n</span>;
    scanf(<span style="color: #FC9F4E;">"%d"</span>, &amp;n);
    <span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">i</span> = <span style="color: #009F9F;">0</span>; i &lt; n; ++i)
        scanf(<span style="color: #FC9F4E;">"%d"</span>, &amp;bomb[i]);
    fill(dp, dp+n, <span style="color: #009F9F;">1</span>);
    <span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">i</span> = <span style="color: #009F9F;">0</span>; i &lt; n; ++i)
        <span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">j</span> = <span style="color: #009F9F;">0</span>; j &lt; i; ++j)
            <span style="color: #BD93F9;">if</span> (bomb[i] &lt;= bomb[j])
                dp[i] = max(dp[i], dp[j]+<span style="color: #009F9F;">1</span>);
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">res</span> = <span style="color: #009F9F;">0</span>;
    <span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">i</span> = <span style="color: #009F9F;">0</span>; i &lt; n; ++i)
        res = max(res, dp[i]);
    printf(<span style="color: #FC9F4E;">"%d\n"</span>, res);
    <span style="color: #BD93F9;">return</span> <span style="color: #009F9F;">0</span>;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #009F9F;">#include</span> <span style="color: #FC9F4E;">&lt;cstdio&gt;</span>
<span style="color: #009F9F;">#include</span> <span style="color: #FC9F4E;">&lt;cstring&gt;</span>
<span style="color: #009F9F;">#include</span> <span style="color: #FC9F4E;">&lt;algorithm&gt;</span>
<span style="color: #009F9F;">#include</span> <span style="color: #FC9F4E;">&lt;vector&gt;</span>
<span style="color: #BD93F9;">using</span> <span style="color: #BD93F9;">namespace</span> <span style="color: #009F9F;">std</span>;
<span style="color: #BD93F9;">const</span> <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">maxn</span> = <span style="color: #009F9F;">25</span>;
<span style="color: #BD93F9;">const</span> <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">inf</span>  = <span style="color: #009F9F;">0x3f3f3f3f</span>;
<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">bomb</span>[maxn];
<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">dp</span>[maxn]; <span style="color: #7c7c7c; font-style: italic;">/*</span><span style="color: #7c7c7c; font-style: italic;">&#24403;&#21069;&#23548;&#24377;&#20316;&#20026;&#32467;&#23614;&#26102;&#33021;&#25318;&#25130;&#30340;&#23548;&#24377;&#25968;</span><span style="color: #7c7c7c; font-style: italic;">*/</span>
<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">link</span>[maxn];
<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">main</span>() {
    freopen(<span style="color: #FC9F4E;">"in.txt"</span>, <span style="color: #FC9F4E;">"r"</span>, stdin);
    freopen(<span style="color: #FC9F4E;">"out.txt"</span>, <span style="color: #FC9F4E;">"w"</span>, stdout);
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">n</span>;
    scanf(<span style="color: #FC9F4E;">"%d"</span>, &amp;n);
    ++n;
    bomb[<span style="color: #009F9F;">0</span>] = inf; <span style="color: #7c7c7c; font-style: italic;">/*</span><span style="color: #7c7c7c; font-style: italic;">&#24517;&#39035;&#35774;&#32622;&#31532;&#19968;&#20010;&#26159;&#26368;&#22823;&#30340;&#65292;&#20445;&#35777;&#20043;&#21518;&#30340;&#26368;&#22823;&#30340;&#33021;&#34987;link&#22312;&#36825;&#27425;&#20043;&#21518;&#65292;&#21542;&#21017;&#20043;&#21518;&#30340;&#26368;&#22823;&#30340;link&#26159;&#23427;&#33258;&#24049;&#65292;&#32780;&#26368;&#21518;&#30340;&#36755;&#20986;&#26465;&#20214;&#26159;&#21040;&#36798;-1&#25165;&#20572;&#27490;&#36755;&#20986;</span><span style="color: #7c7c7c; font-style: italic;">*/</span>
    <span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">i</span> = <span style="color: #009F9F;">1</span>; i &lt;= n; ++i)
        scanf(<span style="color: #FC9F4E;">"%d"</span>, &amp;bomb[i]);
    memset(link, -<span style="color: #009F9F;">1</span>, <span style="color: #BD93F9;">sizeof</span>(link));
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">maxi</span>;
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">idx</span>;
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">res</span> = <span style="color: #009F9F;">1</span>;
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">start</span> = -<span style="color: #009F9F;">1</span>;
    dp[<span style="color: #009F9F;">0</span>] = <span style="color: #009F9F;">1</span>; <span style="color: #7c7c7c; font-style: italic;">/*</span><span style="color: #7c7c7c; font-style: italic;">&#31532;&#19968;&#20010;&#23548;&#24377;&#19968;&#23450;&#33021;&#34987;&#25318;&#25130;</span><span style="color: #7c7c7c; font-style: italic;">*/</span>
    <span style="color: #7c7c7c; font-style: italic;">/*</span><span style="color: #7c7c7c; font-style: italic;">dp[1]&#19981;&#38656;&#35201;&#39044;&#20808;&#35774;&#23450;&#65292;&#22914;&#26524;&#31243;&#24207;&#20013;&#27809;&#26377;&#25214;&#21040;&#21069;&#38754;&#27604;&#23427;&#39640;&#30340;&#23548;&#24377;&#65292;&#20250;&#33258;&#21160;&#35774;&#23450;1</span><span style="color: #7c7c7c; font-style: italic;">*/</span>
    <span style="color: #7c7c7c; font-style: italic;">/*</span><span style="color: #7c7c7c; font-style: italic;">&#32780;dp[0]&#36890;&#36807;&#24490;&#29615;&#33258;&#24049;&#35774;&#23450;1&#65292;&#22240;&#20026;&#20250;&#21516;&#26102;&#25913;&#21464;idx&#30340;&#20540;</span><span style="color: #7c7c7c; font-style: italic;">*/</span>
    <span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">i</span> = <span style="color: #009F9F;">1</span>; i &lt; n-<span style="color: #009F9F;">1</span>; ++i) {
        maxi = dp[i]; <span style="color: #7c7c7c; font-style: italic;">/*</span><span style="color: #7c7c7c; font-style: italic;">&#39318;&#20808;&#35748;&#20026;&#24403;&#21069;&#30340;dp&#26159;&#26368;&#22823;&#30340;&#65292;&#22914;&#26524;&#33021;&#21457;&#29616;&#26356;&#22823;&#30340;&#65292;&#37027;&#23601;&#26356;&#25913;&#20026;&#26356;&#22823;&#30340;</span><span style="color: #7c7c7c; font-style: italic;">*/</span>
        idx  = i; <span style="color: #7c7c7c; font-style: italic;">/*</span><span style="color: #7c7c7c; font-style: italic;">idx&#23547;&#25214;&#21069;&#38754;&#27604;&#24403;&#21069;&#23548;&#24377;&#39640;&#30340;&#65292;&#19988;dp&#26356;&#22823;&#30340;&#23548;&#24377;&#30340;&#19979;&#26631;</span><span style="color: #7c7c7c; font-style: italic;">*/</span>
        <span style="color: #7c7c7c; font-style: italic;">/*</span><span style="color: #7c7c7c; font-style: italic;">&#19968;&#23450;&#35201;&#20498;&#30528;&#23547;&#25214;&#65292;&#25214;&#21040;&#26368;&#36817;&#30340;</span><span style="color: #7c7c7c; font-style: italic;">*/</span>
        <span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">j</span> = i-<span style="color: #009F9F;">1</span>; j &gt;= <span style="color: #009F9F;">0</span>; --j)
            <span style="color: #BD93F9;">if</span> (bomb[j] &gt;= bomb[i] &amp;&amp; dp[j] &gt; maxi) {
                maxi = dp[j];
                idx  = j;
            }
        dp[i] = ++maxi;
        link[i] = idx;
        <span style="color: #BD93F9;">if</span> (dp[i] &gt; res) { <span style="color: #7c7c7c; font-style: italic;">/*</span><span style="color: #7c7c7c; font-style: italic;">&#26368;&#22810;&#30340;&#33021;&#25318;&#25130;&#30340;&#23548;&#24377;&#25968;</span><span style="color: #7c7c7c; font-style: italic;">*/</span>
            res = dp[i];
            start = i;
        }
    }
    printf(<span style="color: #FC9F4E;">"%d\n"</span>, res);
    <span style="color: #AFAFAF;">vector</span>&lt;<span style="color: #AFAFAF;">int</span>&gt; <span style="color: #AFAFAF;">vec</span>;
    <span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">i</span> = start; i != -<span style="color: #009F9F;">1</span>; i = link[i])
        <span style="color: #BD93F9;">if</span> (i != <span style="color: #009F9F;">0</span>)
            vec.push_back(bomb[i]);
    <span style="color: #BD93F9;">for</span> (<span style="color: #BD93F9;">auto</span> <span style="color: #AFAFAF;">it</span> = vec.begin(); it != vec.end(); ++it)
        printf(<span style="color: #FC9F4E;">"%d "</span>, *it);
    <span style="color: #BD93F9;">return</span> <span style="color: #009F9F;">0</span>;
}
</pre>
</div></li>

<li><p>
矩阵嵌套<br>
</p>

<p>
&gt; 有n个矩形，每个矩形可以用a,b来描述，表示长和宽。矩形X(a,b)可以嵌套在矩形Y(c,d)中当且仅当a&lt;c,b&lt;d或者b&lt;c,a&lt;d（相当于旋转X90度）。例如（1,5）可以嵌套在（6,2）内，但不能嵌套在（3,4）中。你的任务是选出尽可能多的矩形排成一行，使得除最后一个外，每一个矩形都可以嵌套在下一个矩形内。<br>
</p>

<p>
输入: 第一行是一个正正数N(0&lt;N&lt;10)，表示测试数据组数，每组测试数据的第一行是一个正正数n，表示该组测试数据中含有矩形的个数(n&lt;=1000)随后的n行，每行有两个数a,b(0&lt;a,b&lt;100)，表示矩形的长和宽<br>
输出: 每组测试数据都输出一个数，表示最多符合条件的矩形数目，每组输出占一行<br>
</p>

<p>
输入样例:<br>
1<br>
10<br>
1 2<br>
2 4<br>
5 8<br>
6 10<br>
7 9<br>
3 1<br>
5 8<br>
12 10<br>
9 7<br>
2 2<br>
</p>

<p>
输出样例:<br>
5<br>
</p>

<p>
思路: 与导弹拦截差不多，先排序，然后求最长递增子序列<br>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #009F9F;">#include</span> <span style="color: #FC9F4E;">&lt;stdio.h&gt;</span>
<span style="color: #009F9F;">#include</span> <span style="color: #FC9F4E;">&lt;string.h&gt;</span>
<span style="color: #009F9F;">#include</span> <span style="color: #FC9F4E;">&lt;algorithm&gt;</span>
<span style="color: #BD93F9;">const</span> <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">maxn</span> = <span style="color: #009F9F;">1005</span>;
<span style="color: #BD93F9;">using</span> <span style="color: #BD93F9;">namespace</span> <span style="color: #009F9F;">std</span>;

<span style="color: #BD93F9;">struct</span> <span style="color: #AFAFAF;">Matrix</span> {
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">x</span>;
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">y</span>;
} <span style="color: #AFAFAF;">matrix</span>[maxn];
<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">dp</span>[maxn]; <span style="color: #7c7c7c; font-style: italic;">/*</span><span style="color: #7c7c7c; font-style: italic;">&#34920;&#31034;&#20197;&#24403;&#21069;&#30697;&#38453;&#32467;&#26463;&#21487;&#20197;&#23884;&#22871;&#30340;&#30697;&#38453;&#26368;&#22810;&#26159;&#22810;&#23569;</span><span style="color: #7c7c7c; font-style: italic;">*/</span>
<span style="color: #AFAFAF;">bool</span> <span style="color: #AFAFAF;">cmp</span>(<span style="color: #AFAFAF;">Matrix</span> <span style="color: #AFAFAF;">a</span>, <span style="color: #AFAFAF;">Matrix</span> <span style="color: #AFAFAF;">b</span>) {
    <span style="color: #BD93F9;">return</span> a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;
}

<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">main</span>() {
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">n</span>;
    memset(dp, <span style="color: #009F9F;">0</span>, <span style="color: #BD93F9;">sizeof</span>(dp));
    scanf(<span style="color: #FC9F4E;">"%d"</span>, &amp;n);
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">tempx</span>;
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">tempy</span>;
    <span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">i</span> = <span style="color: #009F9F;">0</span>; i &lt; n; i++) {
        scanf(<span style="color: #FC9F4E;">"%d%d"</span>, &amp;tempx, &amp;tempy);
        <span style="color: #7c7c7c; font-style: italic;">/*</span><span style="color: #7c7c7c; font-style: italic;">&#23558;&#38271;&#23384;&#22312;y&#20013;&#65292;&#23485;&#23384;&#22312;x&#20013;</span><span style="color: #7c7c7c; font-style: italic;">*/</span>
        <span style="color: #BD93F9;">if</span> (tempx &lt; tempy) {
            matrix[i].x = tempx;
            matrix[i].y = tempy;
        }
        <span style="color: #BD93F9;">else</span> {
            matrix[i].x = tempy;
            matrix[i].y = tempx;
        }
    }
    sort(matrix, matrix+n, cmp);
    <span style="color: #BD93F9;">for</span>(<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">i</span> = <span style="color: #009F9F;">0</span>; i &lt; n; i++)
        dp[i] = <span style="color: #009F9F;">1</span>; <span style="color: #7c7c7c; font-style: italic;">/*</span><span style="color: #7c7c7c; font-style: italic;">&#26174;&#28982;&#26368;&#23569;&#20063;&#26159;&#19968;&#20010;&#37117;&#19981;&#33021;&#23884;&#22871;</span><span style="color: #7c7c7c; font-style: italic;">*/</span>
    <span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">i</span> = <span style="color: #009F9F;">1</span>; i &lt; n; i++)
        <span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">j</span> = i-<span style="color: #009F9F;">1</span>; j &gt;= <span style="color: #009F9F;">0</span>; j--)
            <span style="color: #BD93F9;">if</span> (matrix[i].x &gt; matrix[j].x &amp;&amp; matrix[i].y &gt; matrix[j].y  &amp;&amp; dp[j] &gt; dp[i])
                dp[i] = max(dp[i], dp[j] + <span style="color: #009F9F;">1</span>);
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">res</span> = <span style="color: #009F9F;">0</span>;
    <span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">i</span> = <span style="color: #009F9F;">0</span>; i &lt; n; i++)
        res = max(res, dp[i]);
    printf(<span style="color: #FC9F4E;">"%d\n"</span>, res);
}
</pre>
</div></li>
<li>木棍加工<br></li>
<li><p>
Dilworth定理<br>
狄尔沃斯定理(Dilworth's theorem)亦称偏序集分解定理，其定义是：对于任意有限偏序集，其最大反链中元素的数目必等于最小链划分中链的数目。对偶形式也成立：对于任意有限偏序集，其最长链中元素的数目必等于其最小反链划分中反链的数目<br>
以洛谷P1020为例，求解一套导弹拦截系统最多能拦截导弹的数量，这个其实就是一个简单的LIS；而求解需要多少个导弹拦截系统，就使用Dilworth定理，所有发射的导弹高度构成一个偏序集，导弹链接系统的数量就是全序集的个数，每一个导弹拦截系统下一次拦截高度都不能高于前一次拦截的高度，所以，其反链就是最长不严格上升子序列<br>
</p>

<p>
最少的下降序列个数就等于整个序列最长上升子序列的长度<br>
</p>

<p>
要先降序排列，`return (a.x &gt; b.x || (a.x == b.x &amp;&amp; a.y &gt; b.y)) ? true : false;`，然后由于x是一定非递增的，比较y，y中的最长上升序列长度就是最少的下降序列<br>
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org5f85711" class="outline-2">
<h2 id="org5f85711">DAG 中的简单路径</h2>
</div>
<div id="outline-container-orge9e40fc" class="outline-2">
<h2 id="orge9e40fc">最长回文子序列</h2>
</div>
<div id="outline-container-orgd0fa4d5" class="outline-2">
<h2 id="orgd0fa4d5">最长回文子串</h2>
</div>
<div id="outline-container-orge849a69" class="outline-2">
<h2 id="orge849a69">双调欧几里德旅行商问题</h2>
</div>
<div id="outline-container-org0e6483d" class="outline-2">
<h2 id="org0e6483d">整齐打印</h2>
</div>
<div id="outline-container-org759defe" class="outline-2">
<h2 id="org759defe">最优对齐问题</h2>
</div>
<div id="outline-container-orge7c92a6" class="outline-2">
<h2 id="orge7c92a6">公司聚会计划</h2>
</div>
<div id="outline-container-org91f6847" class="outline-2">
<h2 id="org91f6847">译码算法</h2>
</div>
<div id="outline-container-org6c25b29" class="outline-2">
<h2 id="org6c25b29">基于接缝裁剪的图像压缩</h2>
</div>
<div id="outline-container-org30bc2c2" class="outline-2">
<h2 id="org30bc2c2">字符串拆分</h2>
</div>
<div id="outline-container-org6f34a96" class="outline-2">
<h2 id="org6f34a96">投资策略规划</h2>
</div>
<div id="outline-container-org80ca6eb" class="outline-2">
<h2 id="org80ca6eb">库存规划</h2>
</div>
<div id="outline-container-org6a00259" class="outline-2">
<h2 id="org6a00259">签约棒球自由球员</h2>
</div>
</div>
</body>
</html>
