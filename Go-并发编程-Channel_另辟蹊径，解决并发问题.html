<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-07-01 Fri 11:09 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Go 并发编程 - Channel: 另辟蹊径，解决并发问题</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">Go 并发编程 - Channel: 另辟蹊径，解决并发问题</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org348d2c2">引言</a></li>
<li><a href="#org9a40f7e">Channel 的发展</a></li>
<li><a href="#orge909260">Channel 的应用场景</a></li>
<li><a href="#orgccc0ccb">Channel 基本用法</a>
<ul>
<li><a href="#org072833e">1. 发送数据</a></li>
<li><a href="#org1e8623b">2. 接收数据</a></li>
<li><a href="#orgc1b844b">3. 其他操作</a></li>
</ul>
</li>
<li><a href="#orgb6935b9">Channel 的实现原理</a>
<ul>
<li><a href="#org2d85abb">chan 数据结构</a></li>
<li><a href="#orgd5c0c01">初始化</a></li>
<li><a href="#org6f7a85b">send</a></li>
<li><a href="#orgfc59460">recv</a></li>
<li><a href="#org540e14e">close</a></li>
</ul>
</li>
<li><a href="#orgf72db6d">使用 Channel 容易犯的错误</a></li>
<li><a href="#org40a8397">总结</a></li>
</ul>
</div>
</div>

<div id="outline-container-org348d2c2" class="outline-2">
<h2 id="org348d2c2">引言</h2>
<div class="outline-text-2" id="text-org348d2c2">
<p>
Channel 是 Go 语言内建的 first-class 类型，也是 Go 语言与众不同的特性之一。Go 语言的 Channel 设计精巧简单，以至于也有人用其它语言编写了类似 Go 风格的 Channel 库，比如docker/libchan、tylertreat/chan，但是并不像 Go 语言一样把 Channel 内置到了语言规范中。从这一点，你也可以看出来，Channel 的地位在编程语言中的地位之高，比较罕见。<br>
</p>
</div>
</div>
<div id="outline-container-org9a40f7e" class="outline-2">
<h2 id="org9a40f7e">Channel 的发展</h2>
<div class="outline-text-2" id="text-org9a40f7e">
<p>
要想了解 Channel 这种 Go 编程语言中的特有的数据结构，我们要追溯到 CSP 模型，学习一下它的历史，以及它对 Go 创始人设计 Channel 类型的影响。<br>
</p>

<p>
CSP 是 Communicating Sequential Process 的简称，中文直译为通信顺序进程，或者叫做交换信息的循序进程，是用来描述并发系统中进行交互的一种模式。<br>
</p>

<p>
CSP 最早出现于计算机科学家 Tony Hoare 在 1978 年发表的 <a href="https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf">论文</a> 中（你可能不熟悉 Tony Hoare 这个名字，但是你一定很熟悉排序算法中的 Quicksort 算法，他就是 Quicksort 算法的作者，图灵奖的获得者）。最初，论文中提出的 CSP 版本在本质上不是一种进程演算，而是一种并发编程语言，但之后又经过了一系列的改进，最终发展并精炼出 CSP 的理论。 <span class="underline">CSP 允许使用进程组件来描述系统，它们独立运行，并且只通过消息传递的方式通信。</span><br>
</p>

<p>
就像 Go 的创始人之一 Rob Pike 所说的：“每一个计算机程序员都应该读一读 Tony Hoare 1978 年的关于 CSP 的论文。”他和 Ken Thompson 在设计 Go 语言的时候也深受此论文的影响，并将 CSP 理论真正应用于语言本身（Russ Cox 专门写了一篇文章记录这个<a href="https://swtch.com/~rsc/thread/">历史</a>），通过引入 Channel 这个新的类型，来实现 CSP 的思想。<br>
</p>

<p>
Channel 类型是 Go 语言内置的类型，你无需引入某个包，就能使用它。虽然 Go 也提供了传统的并发原语，但是它们都是通过库的方式提供的，你必须要引入 sync 包或者 atomic 包才能使用它们，而 Channel 就不一样了，它是内置类型，使用起来非常方便。<br>
</p>

<p>
Channel 和 Go 的另一个独特的特性 goroutine 一起为并发编程提供了优雅的、便利的、与传统并发控制不同的方案，并演化出很多并发模式。接下来，我们就来看一看 Channel 的应用场景。<br>
</p>
</div>
</div>
<div id="outline-container-orge909260" class="outline-2">
<h2 id="orge909260">Channel 的应用场景</h2>
<div class="outline-text-2" id="text-orge909260">
<p>
首先，带你看一条 Go 语言中流传很广的谚语：<br>
</p>

<blockquote>
<p>
Don’t communicate by sharing memory, share memory by communicating.<br>
</p>

<ul class="org-ul">
<li>Go Proverbs by Rob Pike<br></li>
</ul>
</blockquote>

<p>
这是 Rob Pike 在 2015 年的一次 Gopher 会议中提到的一句话，虽然有一点绕，但也指出了使用 Go 语言的哲学，尝试着翻译一下：“执行业务处理的 goroutine 不要通过共享内存的方式通信，而是要通过 Channel 通信的方式分享数据。”<br>
</p>

<p>
“communicate by sharing memory”和“share memory by communicating”是两种不同的并发处理模式。“communicate by sharing memory”是传统的并发编程处理方式，就是指，共享的数据需要用锁进行保护，goroutine 需要获取到锁，才能并发访问数据。<br>
</p>

<p>
“share memory by communicating”则是类似于 CSP 模型的方式，通过通信的方式，一个 goroutine 可以把数据的“所有权”交给另外一个 goroutine（虽然 Go 中没有“所有权”的概念，但是从逻辑上说，你可以把它理解为是所有权的转移）。<br>
</p>

<p>
从 Channel 的历史和设计哲学上，我们就可以了解到，Channel 类型和基本并发原语是有竞争关系的，它应用于并发场景，涉及到 goroutine 之间的通讯，可以提供并发的保护，等等。<br>
</p>

<p>
综合起来，我把 Channel 的应用场景分为五种类型。这里你先有个印象，这样你可以有目的地去学习 Channel 的基本原理。之后会借助具体的例子，来带你掌握这几种类型。<br>
</p>

<ul class="org-ul">
<li>数据交流：当作并发的 buffer 或者 queue，解决生产者 - 消费者问题。多个 goroutine 可以并发当作生产者（Producer）和消费者（Consumer）。<br></li>
<li>数据传递：一个 goroutine 将数据交给另一个 goroutine，相当于把数据的拥有权 (引用) 托付出去。<br></li>
<li>信号通知：一个 goroutine 可以将信号 (closing、closed、data ready 等) 传递给另一个或者另一组 goroutine 。<br></li>
<li>任务编排：可以让一组 goroutine 按照一定的顺序并发或者串行的执行，这就是编排的功能。<br></li>
<li>锁：利用 Channel 也可以实现互斥锁的机制。<br></li>
</ul>
</div>
</div>
<div id="outline-container-orgccc0ccb" class="outline-2">
<h2 id="orgccc0ccb">Channel 基本用法</h2>
<div class="outline-text-2" id="text-orgccc0ccb">
<p>
你可以往 Channel 中发送数据，也可以从 Channel 中接收数据，所以，Channel 类型（为了说起来方便，我们下面都把 Channel 叫做 chan）分为 <b>只能接收</b> 、 <b>只能发送</b> 、 <b>既可以接收又可以发送</b> 三种类型。下面是它的语法定义：<br>
</p>

<div class="org-src-container">
<pre class="src src-go">ChannelType = ( <span style="color: #2aa198;">"chan"</span> | <span style="color: #2aa198;">"chan"</span> <span style="color: #2aa198;">"&lt;-"</span> | <span style="color: #2aa198;">"&lt;-"</span> <span style="color: #2aa198;">"chan"</span> ) <span style="color: #df005f; font-weight: bold;">ElementType</span> .
</pre>
</div>

<p>
相应地，Channel 的正确语法如下：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">string</span>          <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21487;&#20197;&#21457;&#36865;&#25509;&#25910;string</span>
<span style="color: #268bd2; font-weight: bold;">chan</span>&lt;- <span style="color: #268bd2; font-weight: bold;">struct</span>{}      <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21482;&#33021;&#21457;&#36865;struct{}</span>
&lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">int</span>           <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21482;&#33021;&#20174;chan&#25509;&#25910;int</span>
</pre>
</div>

<p>
我们把既能接收又能发送的 chan 叫做双向的 chan，把只能发送和只能接收的 chan 叫做单向的 chan。其中，“&lt;-”表示单向的 chan。<br>
</p>

<p>
chan 中的元素是任意的类型，所以也可能是 chan 类型，我来举个例子，比如下面的 chan 类型也是合法的：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">chan</span>&lt;- <span style="color: #268bd2; font-weight: bold;">chan</span> int   
<span style="color: #268bd2; font-weight: bold;">chan</span>&lt;- &lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">int</span>  
&lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> &lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> int
<span style="color: #268bd2; font-weight: bold;">chan</span> (&lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">int</span>)
</pre>
</div>

<p>
可是，怎么判定箭头符号属于哪个 chan 呢？其实，“&lt;-”有个规则，总是尽量和左边的 chan 结合（The &lt;- operator associates with the leftmost chan possible:），因此，上面的定义和下面的使用括号的划分是一样的：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">chan</span>&lt;- &#65288;<span style="color: #268bd2; font-weight: bold;">chan</span> int&#65289; <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&lt;- &#21644;&#31532;&#19968;&#20010;chan&#32467;&#21512;</span>
<span style="color: #268bd2; font-weight: bold;">chan</span>&lt;- <span style="color: #df005f; font-weight: bold;">&#65288;</span>&lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">int&#65289;</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#31532;&#19968;&#20010;&lt;-&#21644;&#26368;&#24038;&#36793;&#30340;chan&#32467;&#21512;&#65292;&#31532;&#20108;&#20010;&lt;-&#21644;&#24038;&#36793;&#31532;&#20108;&#20010;chan&#32467;&#21512;</span>
&lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">&#65288;</span>&lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">int&#65289;</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#31532;&#19968;&#20010;&lt;-&#21644;&#26368;&#24038;&#36793;&#30340;chan&#32467;&#21512;&#65292;&#31532;&#20108;&#20010;&lt;-&#21644;&#24038;&#36793;&#31532;&#20108;&#20010;chan&#32467;&#21512; </span>
<span style="color: #268bd2; font-weight: bold;">chan</span> (&lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">int</span>) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22240;&#20026;&#25324;&#21495;&#30340;&#21407;&#22240;&#65292;&lt;-&#21644;&#25324;&#21495;&#20869;&#31532;&#19968;&#20010;chan&#32467;&#21512;</span>
</pre>
</div>

<p>
通过 make，我们可以初始化一个 chan，未初始化的 chan 的零值是 nil。你可以设置它的容量，比如下面的 chan 的容量是 9527，我们把这样的 chan 叫做 buffered chan；如果没有设置，它的容量是 0，我们把这样的 chan 叫做 unbuffered chan。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">int</span>, 9527)
</pre>
</div>

<p>
如果 chan 中还有数据，那么，从这个 chan 接收数据的时候就不会阻塞，如果 chan 还未满（“满”指达到其容量），给它发送数据也不会阻塞，否则就会阻塞。unbuffered chan 只有读写都准备好之后才不会阻塞，这也是很多使用 unbuffered chan 时的常见 Bug。<br>
</p>

<p>
还有一个知识点需要你记住：nil 是 chan 的零值，是一种特殊的 chan，对值是 nil 的 chan 的发送接收调用者总是会阻塞。<br>
</p>

<p>
下面，我来具体给你介绍几种基本操作，分别是发送数据、接收数据，以及一些其它操作。学会了这几种操作，你就能真正地掌握 Channel 的用法了。<br>
</p>
</div>
<div id="outline-container-org072833e" class="outline-3">
<h3 id="org072833e">1. 发送数据</h3>
<div class="outline-text-3" id="text-org072833e">
<p>
往 chan 中发送一个数据使用“ch&lt;-”，发送数据是一条语句:<br>
</p>

<div class="org-src-container">
<pre class="src src-go">ch &lt;- 2000
</pre>
</div>

<p>
这里的 ch 是 chan int 类型或者是 chan &lt;-int。<br>
</p>
</div>
</div>
<div id="outline-container-org1e8623b" class="outline-3">
<h3 id="org1e8623b">2. 接收数据</h3>
<div class="outline-text-3" id="text-org1e8623b">
<p>
从 chan 中接收一条数据使用“&lt;-ch”，接收数据也是一条语句：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">x</span> := &lt;-ch <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#25226;&#25509;&#25910;&#30340;&#19968;&#26465;&#25968;&#25454;&#36171;&#20540;&#32473;&#21464;&#37327;x</span>
<span style="color: #d75fd7; font-weight: bold;">foo</span>(&lt;-ch) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#25226;&#25509;&#25910;&#30340;&#19968;&#20010;&#30340;&#25968;&#25454;&#20316;&#20026;&#21442;&#25968;&#20256;&#32473;&#20989;&#25968;</span>
&lt;-ch <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20002;&#24323;&#25509;&#25910;&#30340;&#19968;&#26465;&#25968;&#25454;</span>
</pre>
</div>

<p>
这里的 ch 类型是 chan T 或者 &lt;-chan T。<br>
</p>

<p>
接收数据时，还可以返回两个值。第一个值是返回的 chan 中的元素，很多人不太熟悉的是第二个值。第二个值是 bool 类型，代表是否成功地从 chan 中读取到一个值，如果第二个参数是 false，chan 已经被 close 而且 chan 中没有缓存的数据，这个时候，第一个值是零值。所以，如果从 chan 读取到一个零值，可能是 sender 真正发送的零值，也可能是 closed 的并且没有缓存元素产生的零值。<br>
</p>
</div>
</div>
<div id="outline-container-orgc1b844b" class="outline-3">
<h3 id="orgc1b844b">3. 其他操作</h3>
<div class="outline-text-3" id="text-orgc1b844b">
<p>
Go 内建的函数 close、cap、len 都可以操作 chan 类型：close 会把 chan 关闭掉，cap 返回 chan 的容量，len 返回 chan 中缓存的还未被取走的元素数量。<br>
</p>

<p>
send 和 recv 都可以作为 select 语句的 case clause，如下面的例子：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">ch</span> = <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">int</span>, 10)
    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := 0; i &lt; 10; i++ {
        <span style="color: #268bd2; font-weight: bold;">select</span> {
        <span style="color: #268bd2; font-weight: bold;">case</span> ch &lt;- i:
        <span style="color: #268bd2; font-weight: bold;">case</span> <span style="color: #8787d7;">v</span> := &lt;-ch:
            fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(v)
        }
    }
}
</pre>
</div>

<p>
chan 还可以应用于 for-range 语句中，比如：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">v</span> := <span style="color: #268bd2; font-weight: bold;">range</span> ch {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(v)
}
</pre>
</div>

<p>
或者是忽略读取的值，只是清空 chan：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #268bd2; font-weight: bold;">range</span> ch {
}
</pre>
</div>

<p>
好了，到这里，Channel 的基本用法，我们就学完了。下面我从代码实现的角度分析 chan 类型的实现。毕竟，只有掌握了原理，你才能真正地用好它。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-orgb6935b9" class="outline-2">
<h2 id="orgb6935b9">Channel 的实现原理</h2>
<div class="outline-text-2" id="text-orgb6935b9">
<p>
接下来，我会给你介绍 chan 的数据结构、初始化的方法以及三个重要的操作方法，分别是 send、recv 和 close。通过学习 Channel 的底层实现，你会对 Channel 的功能和异常情况有更深的理解。<br>
</p>
</div>
<div id="outline-container-org2d85abb" class="outline-3">
<h3 id="org2d85abb">chan 数据结构</h3>
<div class="outline-text-3" id="text-org2d85abb">
<p>
chan 类型的数据结构如下图所示，它的数据类型是 <a href="https://github.com/golang/go/blob/master/src/runtime/chan.go#L32">runtime.hchan</a>。<br>
</p>

<div class="div-center">
	<img src="./images/Go-并发编程-Channel_chan数据结构.webp" width="620px" />
</div>

<ul class="org-ul">
<li>qcount：代表 chan 中已经接收但还没被取走的元素的个数。内建函数 len 可以返回这个字段的值。<br></li>
<li>dataqsiz：队列的大小。chan 使用一个循环队列来存放元素，循环队列很适合这种生产者 - 消费者的场景（我很好奇为什么这个字段省略 size 中的 e）。<br></li>
<li>buf：存放元素的循环队列的 buffer。<br></li>
<li>elemtype 和 elemsize：chan 中元素的类型和 size。因为 chan 一旦声明，它的元素类型是固定的，即普通类型或者指针类型，所以元素大小也是固定的。<br></li>
<li>sendx：处理发送数据的指针在 buf 中的位置。一旦接收了新的数据，指针就会加上 elemsize，移向下一个位置。buf 的总大小是 elemsize 的整数倍，而且 buf 是一个循环列表。<br></li>
<li>recvx：处理接收请求时的指针在 buf 中的位置。一旦取出数据，此指针会移动到下一个位置。recvq：chan 是多生产者多消费者的模式，如果消费者因为没有数据可读而被阻塞了，就会被加入到 recvq 队列中。<br></li>
<li>sendq：如果生产者因为 buf 满了而阻塞，会被加入到 sendq 队列中。<br></li>
</ul>
</div>
</div>
<div id="outline-container-orgd5c0c01" class="outline-3">
<h3 id="orgd5c0c01">初始化</h3>
<div class="outline-text-3" id="text-orgd5c0c01">
<p>
Go 在编译的时候，会根据容量的大小选择调用 makechan64，还是 makechan。<br>
</p>

<p>
下面的代码是处理 make chan 的逻辑，它会决定是使用 makechan 还是 makechan64 来实现 chan 的初始化：<br>
</p>

<div class="div-center">
	<img src="./images/Go-并发编程-Channel_初始化.webp" width="620px" />
</div>

<p>
我们只关注 makechan 就好了，因为 makechan64 只是做了 size 检查，底层还是调用 makechan 实现的。makechan 的目标就是生成 hchan 对象。<br>
</p>

<p>
那么，接下来，就让我们来看一下 makechan 的主要逻辑。主要的逻辑我都加上了注释，它会根据 chan 的容量的大小和元素的类型不同，初始化不同的存储空间：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">makechan</span>(<span style="color: #8787d7;">t</span> *<span style="color: #df005f; font-weight: bold;">chantype</span>, <span style="color: #8787d7;">size</span> <span style="color: #df005f; font-weight: bold;">int</span>) *<span style="color: #df005f; font-weight: bold;">hchan</span> {
    <span style="color: #8787d7;">elem</span> := t.elem

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#30053;&#21435;&#26816;&#26597;&#20195;&#30721;</span>
    <span style="color: #8787d7;">mem</span>, <span style="color: #8787d7;">overflow</span> := math.<span style="color: #d75fd7; font-weight: bold;">MulUintptr</span>(elem.size, <span style="color: #d75fd7; font-weight: bold;">uintptr</span>(size))

    <span style="color: #008787; background-color: #262626;">//</span>
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">hchan</span>
    <span style="color: #268bd2; font-weight: bold;">switch</span> {
    <span style="color: #268bd2; font-weight: bold;">case</span> mem == 0:
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">chan&#30340;size&#25110;&#32773;&#20803;&#32032;&#30340;size&#26159;0&#65292;&#19981;&#24517;&#21019;&#24314;buf</span>
        c = (*hchan)(<span style="color: #d75fd7; font-weight: bold;">mallocgc</span>(hchanSize, <span style="color: #d75fd7;">nil</span>, <span style="color: #d75fd7;">true</span>))
        c.buf = c.<span style="color: #d75fd7; font-weight: bold;">raceaddr</span>()
    <span style="color: #268bd2; font-weight: bold;">case</span> elem.ptrdata == 0:
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20803;&#32032;&#19981;&#26159;&#25351;&#38024;&#65292;&#20998;&#37197;&#19968;&#22359;&#36830;&#32493;&#30340;&#20869;&#23384;&#32473;hchan&#25968;&#25454;&#32467;&#26500;&#21644;buf</span>
        c = (*hchan)(<span style="color: #d75fd7; font-weight: bold;">mallocgc</span>(hchanSize+mem, <span style="color: #d75fd7;">nil</span>, <span style="color: #d75fd7;">true</span>))
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">hchan&#25968;&#25454;&#32467;&#26500;&#21518;&#38754;&#32039;&#25509;&#30528;&#23601;&#26159;buf</span>
        c.buf = <span style="color: #d75fd7; font-weight: bold;">add</span>(unsafe.<span style="color: #d75fd7; font-weight: bold;">Pointer</span>(c), hchanSize)
    <span style="color: #268bd2; font-weight: bold;">default</span>:
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20803;&#32032;&#21253;&#21547;&#25351;&#38024;&#65292;&#37027;&#20040;&#21333;&#29420;&#20998;&#37197;buf</span>
        c = <span style="color: #268bd2;">new</span>(<span style="color: #df005f; font-weight: bold;">hchan</span>)
        c.buf = <span style="color: #d75fd7; font-weight: bold;">mallocgc</span>(mem, elem, <span style="color: #d75fd7;">true</span>)
    }

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20803;&#32032;&#22823;&#23567;&#12289;&#31867;&#22411;&#12289;&#23481;&#37327;&#37117;&#35760;&#24405;&#19979;&#26469;</span>
    c.elemsize = <span style="color: #d75fd7; font-weight: bold;">uint16</span>(elem.size)
    c.elemtype = elem
    c.dataqsiz = <span style="color: #d75fd7; font-weight: bold;">uint</span>(size)
    <span style="color: #d75fd7; font-weight: bold;">lockInit</span>(&amp;c.lock, lockRankHchan)

    <span style="color: #268bd2; font-weight: bold;">return</span> c
}
</pre>
</div>

<p>
最终，针对不同的容量和元素类型，这段代码分配了不同的对象来初始化 hchan 对象的字段，返回 hchan 对象。<br>
</p>
</div>
</div>
<div id="outline-container-org6f7a85b" class="outline-3">
<h3 id="org6f7a85b">send</h3>
<div class="outline-text-3" id="text-org6f7a85b">
<p>
Go 在编译发送数据给 chan 的时候，会把 send 语句转换成 chansend1 函数，chansend1 函数会调用 chansend，我们分段学习它的逻辑：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">chansend1</span>(<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">hchan</span>, <span style="color: #8787d7;">elem</span> <span style="color: #df005f; font-weight: bold;">unsafe.Pointer</span>) {
    <span style="color: #d75fd7; font-weight: bold;">chansend</span>(c, elem, <span style="color: #d75fd7;">true</span>, <span style="color: #d75fd7; font-weight: bold;">getcallerpc</span>())
}
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">chansend</span>(<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">hchan</span>, <span style="color: #8787d7;">ep</span> <span style="color: #df005f; font-weight: bold;">unsafe.Pointer</span>, <span style="color: #8787d7;">block</span> <span style="color: #df005f; font-weight: bold;">bool</span>, <span style="color: #8787d7;">callerpc</span> <span style="color: #df005f; font-weight: bold;">uintptr</span>) <span style="color: #df005f; font-weight: bold;">bool</span> {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#31532;&#19968;&#37096;&#20998;</span>
    <span style="color: #268bd2; font-weight: bold;">if</span> c == <span style="color: #d75fd7;">nil</span> {
        <span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #d75fd7;">!</span>block {
            <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">false</span>
        }
        <span style="color: #d75fd7; font-weight: bold;">gopark</span>(<span style="color: #d75fd7;">nil</span>, <span style="color: #d75fd7;">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, 2)
        <span style="color: #d75fd7; font-weight: bold;">throw</span>(<span style="color: #2aa198;">"unreachable"</span>)
    }
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">......</span>
}
</pre>
</div>

<p>
最开始，第一部分是进行判断：如果 chan 是 nil 的话，就把调用者 goroutine park（阻塞休眠）， 调用者就永远被阻塞住了，所以，第 11 行是不可能执行到的代码。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#31532;&#20108;&#37096;&#20998;&#65292;&#22914;&#26524;chan&#27809;&#26377;&#34987;close,&#24182;&#19988;chan&#28385;&#20102;&#65292;&#30452;&#25509;&#36820;&#22238;</span>
    <span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #d75fd7;">!</span>block &amp;&amp; c.closed == 0 &amp;&amp; <span style="color: #d75fd7; font-weight: bold;">full</span>(c) {
        <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">false</span>
}
</pre>
</div>

<p>
第二部分的逻辑是当你往一个已经满了的 chan 实例发送数据时，并且想不阻塞当前调用，那么这里的逻辑是直接返回。chansend1 方法在调用 chansend 的时候设置了阻塞参数，所以不会执行到第二部分的分支里。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#31532;&#19977;&#37096;&#20998;&#65292;chan&#24050;&#32463;&#34987;close&#30340;&#24773;&#26223;</span>
<span style="color: #d75fd7; font-weight: bold;">lock</span>(&amp;c.lock) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#24320;&#22987;&#21152;&#38145;</span>
<span style="color: #268bd2; font-weight: bold;">if</span> c.closed != 0 {
    <span style="color: #d75fd7; font-weight: bold;">unlock</span>(&amp;c.lock)
    <span style="color: #268bd2;">panic</span>(<span style="color: #d75fd7; font-weight: bold;">plainError</span>(<span style="color: #2aa198;">"send on closed channel"</span>))
}
</pre>
</div>

<p>
第三部分显示的是，如果 chan 已经被 close 了，再往里面发送数据的话会 panic。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#31532;&#22235;&#37096;&#20998;&#65292;&#20174;&#25509;&#25910;&#38431;&#21015;&#20013;&#20986;&#38431;&#19968;&#20010;&#31561;&#24453;&#30340;receiver</span>
<span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #8787d7;">sg</span> := c.recvq.<span style="color: #d75fd7; font-weight: bold;">dequeue</span>(); sg != <span style="color: #d75fd7;">nil</span> {
    <span style="color: #d75fd7; font-weight: bold;">send</span>(c, sg, ep, <span style="color: #268bd2; font-weight: bold;">func</span>() { <span style="color: #d75fd7; font-weight: bold;">unlock</span>(&amp;c.lock) }, 3)
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">true</span>
}
</pre>
</div>

<p>
第四部分，如果等待队列中有等待的 receiver，那么这段代码就把它从队列中弹出，然后直接把数据交给它（通过 memmove(dst, src, t.size)），而不需要放入到 buf 中，速度可以更快一些。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#31532;&#20116;&#37096;&#20998;&#65292;buf&#36824;&#27809;&#28385;</span>
<span style="color: #268bd2; font-weight: bold;">if</span> c.qcount &lt; c.dataqsiz {
    <span style="color: #8787d7;">qp</span> := <span style="color: #d75fd7; font-weight: bold;">chanbuf</span>(c, c.sendx)
    <span style="color: #268bd2; font-weight: bold;">if</span> raceenabled {
        <span style="color: #d75fd7; font-weight: bold;">raceacquire</span>(qp)
        <span style="color: #d75fd7; font-weight: bold;">racerelease</span>(qp)
    }
    <span style="color: #d75fd7; font-weight: bold;">typedmemmove</span>(c.elemtype, qp, ep)
    c.sendx++
    <span style="color: #268bd2; font-weight: bold;">if</span> c.sendx == c.dataqsiz {
        c.sendx = 0
    }
    c.qcount++
    <span style="color: #d75fd7; font-weight: bold;">unlock</span>(&amp;c.lock)
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">true</span>
}
</pre>
</div>

<p>
第五部分说明当前没有 receiver，需要把数据放入到 buf 中，放入之后，就成功返回了。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#31532;&#20845;&#37096;&#20998;&#65292;buf&#28385;&#12290;</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">chansend1&#19981;&#20250;&#36827;&#20837;if&#22359;&#37324;&#65292;&#22240;&#20026;chansend1&#30340;block=true</span>
<span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #d75fd7;">!</span>block {
    <span style="color: #d75fd7; font-weight: bold;">unlock</span>(&amp;c.lock)
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">false</span>
}
......
</pre>
</div>

<p>
第六部分是处理 buf 满的情况。如果 buf 满了，发送者的 goroutine 就会加入到发送者的等待队列中，直到被唤醒。这个时候，数据或者被取走了，或者 chan 被 close 了。<br>
</p>
</div>
</div>
<div id="outline-container-orgfc59460" class="outline-3">
<h3 id="orgfc59460">recv</h3>
<div class="outline-text-3" id="text-orgfc59460">
<p>
在处理从 chan 中接收数据时，Go 会把代码转换成 chanrecv1 函数，如果要返回两个返回值，会转换成 chanrecv2，chanrecv1 函数和 chanrecv2 会调用 chanrecv。我们分段学习它的逻辑：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">chanrecv1</span>(<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">hchan</span>, <span style="color: #8787d7;">elem</span> <span style="color: #df005f; font-weight: bold;">unsafe.Pointer</span>) {
    <span style="color: #d75fd7; font-weight: bold;">chanrecv</span>(c, elem, <span style="color: #d75fd7;">true</span>)
}
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">chanrecv2</span>(<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">hchan</span>, <span style="color: #8787d7;">elem</span> <span style="color: #df005f; font-weight: bold;">unsafe.Pointer</span>) (<span style="color: #8787d7;">received</span> <span style="color: #df005f; font-weight: bold;">bool</span>) {
    _, received = <span style="color: #d75fd7; font-weight: bold;">chanrecv</span>(c, elem, <span style="color: #d75fd7;">true</span>)
    <span style="color: #268bd2; font-weight: bold;">return</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">chanrecv</span>(<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">hchan</span>, <span style="color: #8787d7;">ep</span> <span style="color: #df005f; font-weight: bold;">unsafe.Pointer</span>, <span style="color: #8787d7;">block</span> <span style="color: #df005f; font-weight: bold;">bool</span>) (<span style="color: #8787d7;">selected</span>, <span style="color: #8787d7;">received</span> <span style="color: #df005f; font-weight: bold;">bool</span>) {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#31532;&#19968;&#37096;&#20998;&#65292;chan&#20026;nil</span>
    <span style="color: #268bd2; font-weight: bold;">if</span> c == <span style="color: #d75fd7;">nil</span> {
        <span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #d75fd7;">!</span>block {
            <span style="color: #268bd2; font-weight: bold;">return</span>
        }
        <span style="color: #d75fd7; font-weight: bold;">gopark</span>(<span style="color: #d75fd7;">nil</span>, <span style="color: #d75fd7;">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, 2)
        <span style="color: #d75fd7; font-weight: bold;">throw</span>(<span style="color: #2aa198;">"unreachable"</span>)
    }
</pre>
</div>

<p>
chanrecv1 和 chanrecv2 传入的 block 参数的值是 true，都是阻塞方式，所以我们分析 chanrecv 的实现的时候，不考虑 block=false 的情况。<br>
</p>

<p>
第一部分是 chan 为 nil 的情况。和 send 一样，从 nil chan 中接收（读取、获取）数据时，调用者会被永远阻塞。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#31532;&#20108;&#37096;&#20998;, block=false&#19988;c&#20026;&#31354;</span>
<span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #d75fd7;">!</span>block &amp;&amp; <span style="color: #d75fd7; font-weight: bold;">empty</span>(c) {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">......</span>
}
</pre>
</div>

<p>
第二部分你可以直接忽略，因为不是我们这次要分析的场景。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21152;&#38145;&#65292;&#36820;&#22238;&#26102;&#37322;&#25918;&#38145;</span>
<span style="color: #d75fd7; font-weight: bold;">lock</span>(&amp;c.lock)
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#31532;&#19977;&#37096;&#20998;&#65292;c&#24050;&#32463;&#34987;close,&#19988;chan&#20026;&#31354;empty</span>
<span style="color: #268bd2; font-weight: bold;">if</span> c.closed != 0 &amp;&amp; c.qcount == 0 {
    <span style="color: #d75fd7; font-weight: bold;">unlock</span>(&amp;c.lock)
    <span style="color: #268bd2; font-weight: bold;">if</span> ep != <span style="color: #d75fd7;">nil</span> {
        <span style="color: #d75fd7; font-weight: bold;">typedmemclr</span>(c.elemtype, ep)
    }
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">true</span>, <span style="color: #d75fd7;">false</span>
}
</pre>
</div>

<p>
第三部分是 chan 已经被 close 的情况。如果 chan 已经被 close 了，并且队列中没有缓存的元素，那么返回 true、false。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#31532;&#22235;&#37096;&#20998;&#65292;&#22914;&#26524;sendq&#38431;&#21015;&#20013;&#26377;&#31561;&#24453;&#21457;&#36865;&#30340;sender</span>
<span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #8787d7;">sg</span> := c.sendq.<span style="color: #d75fd7; font-weight: bold;">dequeue</span>(); sg != <span style="color: #d75fd7;">nil</span> {
    <span style="color: #d75fd7; font-weight: bold;">recv</span>(c, sg, ep, <span style="color: #268bd2; font-weight: bold;">func</span>() { <span style="color: #d75fd7; font-weight: bold;">unlock</span>(&amp;c.lock) }, 3)
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">true</span>, <span style="color: #d75fd7;">true</span>
}
</pre>
</div>

<p>
第四部分是处理 buf 满的情况。这个时候，如果是 unbuffer 的 chan，就直接将 sender 的数据复制给 receiver，否则就从队列头部读取一个值，并把这个 sender 的值加入到队列尾部。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#31532;&#20116;&#37096;&#20998;, &#27809;&#26377;&#31561;&#24453;&#30340;sender, buf&#20013;&#26377;&#25968;&#25454;</span>
<span style="color: #268bd2; font-weight: bold;">if</span> c.qcount &gt; 0 {
    <span style="color: #8787d7;">qp</span> := <span style="color: #d75fd7; font-weight: bold;">chanbuf</span>(c, c.recvx)
    <span style="color: #268bd2; font-weight: bold;">if</span> ep != <span style="color: #d75fd7;">nil</span> {
        <span style="color: #d75fd7; font-weight: bold;">typedmemmove</span>(c.elemtype, ep, qp)
    }
    <span style="color: #d75fd7; font-weight: bold;">typedmemclr</span>(c.elemtype, qp)
    c.recvx++
    <span style="color: #268bd2; font-weight: bold;">if</span> c.recvx == c.dataqsiz {
        c.recvx = 0
    }
    c.qcount--
    <span style="color: #d75fd7; font-weight: bold;">unlock</span>(&amp;c.lock)
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">true</span>, <span style="color: #d75fd7;">true</span>
}

<span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #d75fd7;">!</span>block {
    <span style="color: #d75fd7; font-weight: bold;">unlock</span>(&amp;c.lock)
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">false</span>, <span style="color: #d75fd7;">false</span>
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#31532;&#20845;&#37096;&#20998;&#65292; buf&#20013;&#27809;&#26377;&#20803;&#32032;&#65292;&#38459;&#22622;</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">......</span>
</pre>
</div>

<p>
第五部分是处理没有等待的 sender 的情况。这个是和 chansend 共用一把大锁，所以不会有并发的问题。如果 buf 有元素，就取出一个元素给 receiver。<br>
</p>

<p>
第六部分是处理 buf 中没有元素的情况。如果没有元素，那么当前的 receiver 就会被阻塞，直到它从 sender 中接收了数据，或者是 chan 被 close，才返回。<br>
</p>
</div>
</div>
<div id="outline-container-org540e14e" class="outline-3">
<h3 id="org540e14e">close</h3>
<div class="outline-text-3" id="text-org540e14e">
<p>
通过 close 函数，可以把 chan 关闭，编译器会替换成 closechan 方法的调用。<br>
</p>

<p>
下面的代码是 close chan 的主要逻辑。如果 chan 为 nil，close 会 panic；如果 chan 已经 closed，再次 close 也会 panic。否则的话，如果 chan 不为 nil，chan 也没有 closed，就把等待队列中的 sender（writer）和 receiver（reader）从队列中全部移除并唤醒。<br>
</p>

<p>
下面的代码就是 close chan 的逻辑:<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">closechan</span>(<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">hchan</span>) {
    <span style="color: #268bd2; font-weight: bold;">if</span> c == <span style="color: #d75fd7;">nil</span> { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">chan&#20026;nil, panic</span>
        <span style="color: #268bd2;">panic</span>(<span style="color: #d75fd7; font-weight: bold;">plainError</span>(<span style="color: #2aa198;">"close of nil channel"</span>))
    }

    <span style="color: #d75fd7; font-weight: bold;">lock</span>(&amp;c.lock)
    <span style="color: #268bd2; font-weight: bold;">if</span> c.closed != 0 {<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">chan&#24050;&#32463;closed, panic</span>
        <span style="color: #d75fd7; font-weight: bold;">unlock</span>(&amp;c.lock)
        <span style="color: #268bd2;">panic</span>(<span style="color: #d75fd7; font-weight: bold;">plainError</span>(<span style="color: #2aa198;">"close of closed channel"</span>))
    }

    c.closed = 1  

    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">glist</span> <span style="color: #df005f; font-weight: bold;">gList</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#37322;&#25918;&#25152;&#26377;&#30340;reader</span>
    <span style="color: #268bd2; font-weight: bold;">for</span> {
        <span style="color: #8787d7;">sg</span> := c.recvq.<span style="color: #d75fd7; font-weight: bold;">dequeue</span>()
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">......</span>
        <span style="color: #8787d7;">gp</span> := sg.g
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">......</span>
        glist.<span style="color: #d75fd7; font-weight: bold;">push</span>(gp)
    }

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#37322;&#25918;&#25152;&#26377;&#30340;writer (&#23427;&#20204;&#20250;panic)</span>
    <span style="color: #268bd2; font-weight: bold;">for</span> {
        <span style="color: #8787d7;">sg</span> := c.sendq.<span style="color: #d75fd7; font-weight: bold;">dequeue</span>()
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">......</span>
        <span style="color: #8787d7;">gp</span> := sg.g
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">......</span>
        glist.<span style="color: #d75fd7; font-weight: bold;">push</span>(gp)
    }
    <span style="color: #d75fd7; font-weight: bold;">unlock</span>(&amp;c.lock)

    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #d75fd7;">!</span>glist.<span style="color: #d75fd7; font-weight: bold;">empty</span>() {
        <span style="color: #8787d7;">gp</span> := glist.<span style="color: #d75fd7; font-weight: bold;">pop</span>()
        gp.schedlink = 0
        <span style="color: #d75fd7; font-weight: bold;">goready</span>(gp, 3)
    }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf72db6d" class="outline-2">
<h2 id="orgf72db6d">使用 Channel 容易犯的错误</h2>
<div class="outline-text-2" id="text-orgf72db6d">
<p>
根据 2019 年第一篇全面分析 Go 并发 Bug 的<a href="https://songlh.github.io/paper/go-study.pdf">论文</a>，那些知名的 Go 项目中使用 Channel 所犯的 Bug 反而比传统的并发原语的 Bug 还要多。主要有两个原因：一个是，Channel 的概念还比较新，程序员还不能很好地掌握相应的使用方法和最佳实践；第二个是，Channel 有时候比传统的并发原语更复杂，使用起来很容易顾此失彼。<br>
</p>

<p>
<span class="underline">使用 Channel 最常见的错误是 panic 和 goroutine 泄漏。</span><br>
</p>

<p>
首先，我们来总结下会 panic 的情况，总共有 3 种：<br>
</p>

<ol class="org-ol">
<li>close 为 nil 的 chan；<br></li>
<li>send 已经 close 的 chan；<br></li>
<li>close 已经 close 的 chan；<br></li>
</ol>

<p>
goroutine 泄漏的问题也很常见，下面的代码也是一个实际项目中的例子：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">process</span>(<span style="color: #8787d7;">timeout</span> <span style="color: #df005f; font-weight: bold;">time.Duration</span>) <span style="color: #df005f; font-weight: bold;">bool</span> {
    <span style="color: #8787d7;">ch</span> := <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">bool</span>)

    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#27169;&#25311;&#22788;&#29702;&#32791;&#26102;&#30340;&#19994;&#21153;</span>
        time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>((timeout + time.Second))
        ch &lt;- <span style="color: #d75fd7;">true</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">block</span>
        fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"exit goroutine"</span>)
    }()
    <span style="color: #268bd2; font-weight: bold;">select</span> {
    <span style="color: #268bd2; font-weight: bold;">case</span> <span style="color: #8787d7;">result</span> := &lt;-ch:
        <span style="color: #268bd2; font-weight: bold;">return</span> result
    <span style="color: #268bd2; font-weight: bold;">case</span> &lt;-time.<span style="color: #d75fd7; font-weight: bold;">After</span>(timeout):
        <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">false</span>
    }
}
</pre>
</div>

<p>
在这个例子中，process 函数会启动一个 goroutine，去处理需要长时间处理的业务，处理完之后，会发送 true 到 chan 中，目的是通知其它等待的 goroutine，可以继续处理了。<br>
</p>

<p>
我们来看一下第 10 行到第 15 行，主 goroutine 接收到任务处理完成的通知，或者超时后就返回了。这段代码有问题吗？<br>
</p>

<p>
如果发生超时，process 函数就返回了，这就会导致 unbuffered 的 chan 从来就没有被读取。我们知道，unbuffered chan 必须等 reader 和 writer 都准备好了才能交流，否则就会阻塞。超时导致未读，结果就是子 goroutine 就阻塞在第 7 行永远结束不了，进而导致 goroutine 泄漏。<br>
</p>

<p>
解决这个 Bug 的办法很简单，就是将 unbuffered chan 改成容量为 1 的 chan，这样第 7 行就不会被阻塞了。<br>
</p>

<p>
Go 的开发者极力推荐使用 Channel，不过，这两年，大家意识到，Channel 并不是处理并发问题的“银弹”，有时候使用并发原语更简单，而且不容易出错。所以，我给你提供一套选择的方法:<br>
</p>

<ol class="org-ol">
<li>共享资源的并发访问使用传统并发原语；<br></li>
<li>复杂的任务编排和消息传递使用 Channel；<br></li>
<li>消息通知机制使用 Channel，除非只想 signal 一个 goroutine，才使用 Cond；<br></li>
<li>简单等待所有任务的完成用 WaitGroup，也有 Channel 的推崇者用 Channel，都可以；<br></li>
<li>需要和 Select 语句结合，使用 Channel；<br></li>
<li>需要和超时配合时，使用 Channel 和 Context。<br></li>
</ol>
</div>
</div>
<div id="outline-container-org40a8397" class="outline-2">
<h2 id="org40a8397">总结</h2>
<div class="outline-text-2" id="text-org40a8397">
<p>
chan 的值和状态有多种情况，而不同的操作（send、recv、close）又可能得到不同的结果，这是使用 chan 类型时经常让人困惑的地方。<br>
</p>

<p>
为了帮助你快速地了解不同状态下各种操作的结果，我总结了一个表格，你一定要特别关注下那些 panic 的情况，另外还要掌握那些会 block 的场景，它们是导致死锁或者 goroutine 泄露的罪魁祸首。<br>
</p>

<p>
还有一个值得注意的点是，只要一个 chan 还有未读的数据，即使把它 close 掉，你还是可以继续把这些未读的数据消费完，之后才是读取零值数据。<br>
</p>

<div class="div-center">
	<img src="./images/Go-并发编程-Channel_不同状态下各种操作结果.webp" />
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-07-01 Fri 11:09</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
