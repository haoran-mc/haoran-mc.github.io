<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-06-09 Thu 11:42 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>乘法逆元</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="static/MathJax/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div id="content">
<h1 class="title">乘法逆元</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org14de1aa">乘法逆元证明</a></li>
<li><a href="#org9c3ddd4">求解逆元</a>
<ul>
<li><a href="#orga586f79">费马小定理</a>
<ul>
<li><a href="#orgf7ec39e">使用费马小定理求解逆元</a></li>
</ul>
</li>
<li><a href="#orgbe930a3">扩展欧几里得算法求逆元</a>
<ul>
<li><a href="#org31148a4">解方程 ax + by = gcd(a, b)</a></li>
<li><a href="#org58ba0c0">逆元的求解</a></li>
</ul>
</li>
<li><a href="#org1872b75">递推打表求乘法逆元</a></li>
<li><a href="#org023c543">公式计算逆元</a></li>
<li><a href="#org4a64dec">逆元刷题总结</a></li>
</ul>
</li>
<li><a href="#org48cf166">求解二元一次方程组</a></li>
</ul>
</div>
</div>

<div id="outline-container-org14de1aa" class="outline-2">
<h2 id="org14de1aa">乘法逆元证明</h2>
<div class="outline-text-2" id="text-org14de1aa">
<p>
(a + b) % p  = (a % p + b % p) % p<br>
(a - b) % p  = (a % p - b % p) % p<br>
(a * b) % p  = (a % p * b % p) % p<br>
<span class="underline">(a / b) % p != (a % p / b % p) % p</span><br>
</p>

<blockquote>
<p>
数学家们无法忍受除法求模时不能满足分配律，于是定义了 <b>乘法逆元</b><br>
</p>
</blockquote>

<dl class="org-dl">
<dt>定义</dt><dd>若在 <code>(mod p)</code> 的意义下，对于一个整数 \(a\)，有 \(a \cdot x \equiv 1(mod p)\)，即 \((a \times x - 1) \% p = 0\) 那么这个整数 x 即为 a 的乘法逆元，同时 a 也为 x 的乘法逆元；<br></dd>
<dt>充要条件</dt><dd>a 存在模 p 的乘法逆元的充要条件是 <b>gcd(a, p) = 1</b> , 即 a 与 p 互质；<br></dd>
<dt>应用</dt><dd>求 (a / b) % p 等同于 a * (b的逆元) % p；<br></dd>
</dl>

<br/>

<hr>

<br/>

<p>
真的会一直存在 \((a / b) \% p = (a \cdot b的逆元) \% p\) 吗？<br>
</p>

<p>
证明:<br>
</p>

<ul class="org-ul">
<li>假设1：\((a / b) \% p = z\)；<br></li>
<li>假设2：\(b\) 的逆元是\(x\)，根据定义有 \(b \cdot x \equiv 1(mod p)\)；<br></li>
</ul>

<p>
若想证明 \((a / b) \% p = (a \cdot inv(b)) \% p\)（我们用 inv(b) 表示 b 的逆元），即要证明 \((a \cdot x) \% p = z\)；<br>
</p>

<ul class="org-ul">
<li>\((a / b) \% p = z\)，两边同乘 \(b\)<br></li>
<li>\(a \% p = (z \cdot b) \% p\)，两边同乘 \(x\)<br></li>
<li>\((a \% p) \cdot x = ((z \cdot b) \% p) \cdot x \Rightarrow a \% p \cdot x = (z \cdot b) \% p \cdot x\)<br></li>
<li>由于模运算优先级与乘运算优先级相等，则有 \(a \cdot x \% p = z \cdot b \cdot x \% p \Rightarrow (a \cdot x) \% p = (z \cdot b \cdot x) \% p\)<br></li>
<li>由于乘法取模满足分配律，则有 \((a \cdot x) \% p = (z \cdot b \cdot x) \% p\) <br>
<ul class="org-ul">
<li>\(\Rightarrow (a \cdot x) \% p = (z \cdot (b \cdot x)) \% p\)<br></li>
<li>\(\Rightarrow (a \cdot x) \% p = [(z \% p) \cdot ((b \cdot x) \% p)] \% p\)<br></li>
</ul></li>
<li>而 \(x\) 是 \(b\) 的乘法逆元，根据定义有 \(b \cdot x \equiv 1(mod p)\)<br></li>
<li>所以 \((a \cdot x) \% p = [(z \% p) \cdot 1] \% p\)<br>
<ul class="org-ul">
<li>\(\Rightarrow (a \cdot x) \% p = z \% p\)<br></li>
</ul></li>
<li>根据假设1，\(z < p\)<br></li>
<li>所以 \((a \cdot x) \% p = z\)<br></li>
</ul>

<p>
得证：\((a / b) \% p = (a \cdot inv(b)) \% p\)<br>
</p>
</div>
</div>
<div id="outline-container-org9c3ddd4" class="outline-2">
<h2 id="org9c3ddd4">求解逆元</h2>
<div class="outline-text-2" id="text-org9c3ddd4">
<p>
求解逆元的方法有很多，费马小定理(p 为质数)，扩展欧几里得算法，线性递推&#x2026;&#x2026;<br>
</p>
</div>
<div id="outline-container-orga586f79" class="outline-3">
<h3 id="orga586f79">费马小定理</h3>
<div class="outline-text-3" id="text-orga586f79">
<p>
<b>费马小定理</b> ：假如a是一个整数，p是一个质数，那么<br>
</p>
<ol class="org-ol">
<li>如果b是p的倍数，\(b^p \equiv b(mod p)\)<br></li>
<li>如果b不是p的倍数，\(b^{p-1} \equiv 1(mod p)\)<br></li>

<li value="同余式">\(a \equiv b(mod p)\) 表示a和b对模p同余，即正整数\(a - b\)能被\(p\)整除，\((a - b) \% p = 0\)<br></li>
<li value="证明">略<br></li>
</ol>
</div>
<div id="outline-container-orgf7ec39e" class="outline-4">
<h4 id="orgf7ec39e">使用费马小定理求解逆元</h4>
<div class="outline-text-4" id="text-orgf7ec39e">
<p>
使用费马小定理求解逆元时，要求\(p\)为质数，且\(b\)不能为\(p\)的倍数，所以使用费马小定理的第二条：如果\(b\)不是\(p\)的倍数，\(b^{p - 1} \equiv 1(mod p)\)，所以\(b \times b^{p - 2} \equiv 1(mod p)\)，\(b^{p - 2}\)是\(b\)的逆元。那么使用快速幂求出\(b^{p - 2}\)即求出在 \((mod p)\) 的意义下，\(b\) 的乘法逆元<br>
输入\(119\)，求出结果为\(19326\)，所以当求\(1 / 119) \% 99991\)时，可以转化为\((1 \times 19326) \% 99991\)<br>
</p>
</div>
</div>
</div>
<div id="outline-container-orgbe930a3" class="outline-3">
<h3 id="orgbe930a3">扩展欧几里得算法求逆元</h3>
<div class="outline-text-3" id="text-orgbe930a3">
</div>
<div id="outline-container-org31148a4" class="outline-4">
<h4 id="org31148a4">解方程 ax + by = gcd(a, b)</h4>
<div class="outline-text-4" id="text-org31148a4">
<p>
在欧几里得算法中通过定理 \(gcd(a, b) = gcd(b, a \% b)\)，我们使用递归求得 \(a\) 与 \(b\) 的最大公约数，在递归边界当\(b = 0\)时，\(a = gcd(a, b)\)，此时显然有\(a \times 1 + b \times 0 = gcd\)。对于这样的一个式子，我们能否对它进行推广呢？<br>
</p>
<ul class="org-ul">
<li>在递归的其中一步，通过相关定理(此处不叙述)可知 \(ax_1 + by_1 = gcd(a, b)\) 中解 \(x_1、y_1\) 一定存在<br></li>
<li>下一步计算 \(gcd(b, a \% b)\) 时，又有 \(bx_2 + (a \% b)y_2 = gcd(b, a \% b)\) 成立<br></li>
<li>而 \(gcd(a, b) = gcd(b, a\%b)\)<br></li>
<li>所以 \(ax_1 + by_1 = bx_2 + (a \% b)y_2\) 成立，这样我们就发现 \(x_1、x_2、y_1、y_2\) 之间存在关系<br></li>
<li>\(a \% b = a - (a/b) \times b\) 成立（想一想为什么?）<br></li>
<li>代入得 \(ax_1 + by_1 = bx_2 + (a - (a/b) \times b)y_2\)<br></li>
<li>整理得 \(ax_1 + by_1 = ay_2 + b(x_2 - (a/b)y_2)\)<br></li>
<li>由于对于递归过程中任一步都满足，对比两式，可得递归表达式<br>
\[x_1 = y_2 \\y_1 = x_2 - (a / b)y_2\]<br></li>
<li>已知递归边界 \(a \times 1 + b \times 0 = gcd\)，递归表达式，能够递归得到 \(ax + by = gcd(a, b)\) 的 <b>其中一个解</b><br></li>
</ul>
</div>
</div>
<div id="outline-container-org58ba0c0" class="outline-4">
<h4 id="org58ba0c0">逆元的求解</h4>
<div class="outline-text-4" id="text-org58ba0c0">
<ul class="org-ul">
<li>由定义知，求 \(a\) 模 \(m\) 的逆元，就是求解同余式 \(ax \equiv 1(mod m)\)<br></li>
<li>\(ax \equiv 1(mod m)\)<br></li>
<li>\((ax - 1) \% m = 0\)<br></li>
<li>存在一个整数z满足 \(ax - 1 = mz\)<br></li>
<li>\(ax - mz = 1\)<br></li>
<li>存在 \(y = -z\) 使得 \(ax + my = 1\)<br></li>
<li>所以求 \(a\) 模 \(m\) 的逆元，就是求解同余式 \(ax \equiv 1(mod m)\)，也就是求方程 \(ax + my = 1\) 的解，并且在实际使用中，一般把x的最小正整数解称为 \(a\) 模 \(m\) 的逆元。<br></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org1872b75" class="outline-3">
<h3 id="org1872b75">递推打表求乘法逆元</h3>
<div class="outline-text-3" id="text-org1872b75">
<dl class="org-dl">
<dt>目的</dt><dd>得到在(mod m)的意义下的[2, n)区间内每个数分别对应的逆元<br></dd>
</dl>

<p>
推导出递推表达式：<br>
</p>
<ul class="org-ul">
<li>任取一个同余式 \(ax \equiv c(mod m)\) 消去 \(a\) 与 \(c\)，得到 \(x\) 关于 \(m\) 的式子即为递推表达式<br></li>
<li>对于这个同余式，一定存在一个数 \(y\) 使得 \(ax - c = my\)<br></li>
<li>根据定义 \(c \times (c的逆元) \equiv 1(mod m)\)<br></li>
<li>我们把 \(c\) 的逆元放在 \(inv\) 数组里，所以 \(c \times inv[c] \equiv 1(mod m)\)<br></li>
<li>将 \(c\) 替换为 \(ax - my\)，\((ax - my) \times inv[c] \equiv 1(mod m)\)<br></li>
<li>\(ax \times inv[c] - my \times inv[c] \equiv 1(mod m)\)<br>
<ul class="org-ul">
<li>由于 \(my \% m = 0\)<br></li>
<li>而原式等价于 \((ax \times inv[c]) \% m - (my \times inv[c]) \% m = 1\)<br></li>
<li>所以等价于 \((ax \times inv[c]) \% m = 1\)<br></li>
</ul></li>
<li>所以 \(ax \times inv[c] \equiv 1(mod m)\)<br>
<ul class="org-ul">
<li>在 \(ax - c = my 中，a = my / x；-c = my \% x\)<br></li>
</ul></li>
<li>\(my / x \times x \times inv[-my \% x] \equiv 1(mod m)\)<br></li>
<li>对于任意的 \(y\) 都满足此式，不妨取 \(y = -1\)<br></li>
<li>\(-m / x \times inv[m \% x] \times x \equiv 1(mod m)\)<br></li>
<li>在 \((mod m)\)的意义下，\(-m / x \times inv[m \% x]\) 是 \(x\) 的逆元<br></li>
<li>为保证求得结果都为正数，\((m - m / x) \times inv[m \% x]\)<br></li>
<li>所以在 \((mod m)\) 的意义下，\((m - m / x) \times inv[m \% x]\) 是 \(x\) 在区间 \([0, m)\) 内的逆元<br></li>
</ul>
</div>
</div>
<div id="outline-container-org023c543" class="outline-3">
<h3 id="org023c543">公式计算逆元</h3>
<div class="outline-text-3" id="text-org023c543">
<p>
最常见的就是扩展欧几里得，如果是素数，还可以用费马小定理。<br>
但是你会发现费马小定理和扩展欧几里得算法求逆元是有局限性的，它们都会要求与互素<br>
实际上我们还有一种通用的求逆元方法，适合所有情况<br>
</p>

<p>
引用<br>
假设 \(x\) 是 \(a\) 对于 \(b\) 的乘法逆元，则有 \(a \times x = 1 mod b\), 即 \(x\) 是方程 \(a \times x + b \times y = 1\) 的一个整数解<br>
但是形如 \(a \times x + b \times y\) 的最小正整数为 \(gcd(a,b)\)<br>
此结论可以通过扩展欧几里得算法（EEA）的正确性得到<br>
而1又是最小的非零自然数，所以只有当 \(gcd(a, b) = 1\) 时，\(a\) 才有对于 \(b\) 的乘法逆元<br>
</p>

<p>
附个小插曲：<br>
从小学奥数学到就知道一个整数 \(n \% 3 = n 各个数位上的和 \%3\)，但是一直不知道怎么来的<br>
在学习模的性质时候才看到，发现数学太奇妙了<br>
简而言之，就是10的n次幂，模，3 ，999&#x2026;999, 这几个东西就可以证明出来啦！<br>
</p>
</div>
</div>
<div id="outline-container-org4a64dec" class="outline-3">
<h3 id="org4a64dec">逆元刷题总结</h3>
<div class="outline-text-3" id="text-org4a64dec">
<p>
(a + b) % p  = (a % p + b % p) % p<br>
(a - b) % p  = (a % p - b % p) % p<br>
(a * b) % p  = (a % p * b % p) % p<br>
(a / b) % p != (a % p / b % p) % p<br>
</p>

<p>
除除法外，其他基本运算进行模运算时都满足分配律，所以在进行一些较难的分式取模时需要求逆元，可以先化简，然后求逆元取模<br>
</p>

<ul class="org-ul">
<li>求\((1 - (1 / n)^m) mod 1e9 + 7\)的值<br></li>
<li>\(1 - \frac{1}{n^m}\)<br>
<ul class="org-ul">
<li>\(\frac{n^m - 1}{n^m}\) 不应该这样求，如果这样的话，就蛮麻烦，直接算就好<br></li>
</ul></li>
<li><code>const int mod = 1e9 + 7</code><br></li>
<li>\((1 - \frac{1}{n^m}) \% mod\)<br></li>
<li>\((1 \% mod - \frac{1}{n^m} \% mod + mod) \% mod\)<br></li>
<li>\((1 - (\frac{1}{n} + \frac{1}{n} + \dots + \frac{1}{n}) \% mod + mod) \% mod\)<br></li>
<li>\((1 - (\frac{1}{n} \% mod + \frac{1}{n} \% mod + \dots + \frac{1}{n} \% mod) + mod) \% mod\)<br></li>
<li>\((1 - (inv(n) + inv(n) + \dots + inv(n)) \% mod + mod) \% mod\)<br></li>
<li>\((1 - (inv(n) ^ m) \% mod + mod) \% mod\)<br>
<ul class="org-ul">
<li>\((1 - binaryPow(inv(n), m) % mod + mod) % mod\)<br></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org48cf166" class="outline-2">
<h2 id="org48cf166">求解二元一次方程组</h2>
</div>
</div>
</body>
</html>
