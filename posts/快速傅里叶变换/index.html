<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>快速傅里叶变换 | Notes</title>
<meta name="keywords" content="algorithm, math" />
<meta name="description" content="快速傅里叶变换 快速傅里叶变换是什么？ 快速傅里叶变换是一种能够在 $O(nlogn)$ 的时间内计算离散福利也变换的算法，在算法竞赛中常用于快速计算多项式乘法。
多项式乘法 对于两个多项式 $A(x) = a_0 &#43; a_1x &#43; a_2x^2 &#43; \cdots &#43; a_nx^n, B(x) = b_0 &#43; b_1x &#43; b_2x^2 &#43; \cdots &#43; b_nx^n$ ，求出 $C(x) = A(x) \times B(x)$ ，使用朴素算法的时间复杂度为 $O(n^2)$
for (int i = 0; i &lt; n; &#43;&#43;i) for (int j = 0; j &lt; n; &#43;&#43;j) c[i &#43; j] &#43;= a[i] * b[j]; 如何加速多项式的乘法呢？
多项式的两种表示方法 多项式有两种表示方法：1. 系数表示法 2. 点值表示法
多项式由系数表示法转为点值表示法的过程，就称为DFT；把一个多项式的点值表示法转化为系数表示法的过程，称为IDFT，FFT就是通过取某些特殊的x的点值来加速DFT和IDFT的过程。
系数表示法 对于一个 ${n}$ 维的多项式A(x)，它的系数 $(a_0, a_1, a_2, \cdots a_n)$ 能够唯一的表示这个多项式。">
<meta name="author" content="">
<link rel="canonical" href="http://example.org/posts/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.9f1d947375927e9847272b1f4e9be81336f539e513bf04d52cade31f81cad1af.css" integrity="sha256-nx2Uc3WSfphHJysfTpvoEzb1OeUTvwTVLK3jH4HK0a8=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="http://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="快速傅里叶变换" />
<meta property="og:description" content="快速傅里叶变换 快速傅里叶变换是什么？ 快速傅里叶变换是一种能够在 $O(nlogn)$ 的时间内计算离散福利也变换的算法，在算法竞赛中常用于快速计算多项式乘法。
多项式乘法 对于两个多项式 $A(x) = a_0 &#43; a_1x &#43; a_2x^2 &#43; \cdots &#43; a_nx^n, B(x) = b_0 &#43; b_1x &#43; b_2x^2 &#43; \cdots &#43; b_nx^n$ ，求出 $C(x) = A(x) \times B(x)$ ，使用朴素算法的时间复杂度为 $O(n^2)$
for (int i = 0; i &lt; n; &#43;&#43;i) for (int j = 0; j &lt; n; &#43;&#43;j) c[i &#43; j] &#43;= a[i] * b[j]; 如何加速多项式的乘法呢？
多项式的两种表示方法 多项式有两种表示方法：1. 系数表示法 2. 点值表示法
多项式由系数表示法转为点值表示法的过程，就称为DFT；把一个多项式的点值表示法转化为系数表示法的过程，称为IDFT，FFT就是通过取某些特殊的x的点值来加速DFT和IDFT的过程。
系数表示法 对于一个 ${n}$ 维的多项式A(x)，它的系数 $(a_0, a_1, a_2, \cdots a_n)$ 能够唯一的表示这个多项式。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-18T13:08:42&#43;08:00" />
<meta property="article:modified_time" content="2021-09-18T13:08:42&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="快速傅里叶变换"/>
<meta name="twitter:description" content="快速傅里叶变换 快速傅里叶变换是什么？ 快速傅里叶变换是一种能够在 $O(nlogn)$ 的时间内计算离散福利也变换的算法，在算法竞赛中常用于快速计算多项式乘法。
多项式乘法 对于两个多项式 $A(x) = a_0 &#43; a_1x &#43; a_2x^2 &#43; \cdots &#43; a_nx^n, B(x) = b_0 &#43; b_1x &#43; b_2x^2 &#43; \cdots &#43; b_nx^n$ ，求出 $C(x) = A(x) \times B(x)$ ，使用朴素算法的时间复杂度为 $O(n^2)$
for (int i = 0; i &lt; n; &#43;&#43;i) for (int j = 0; j &lt; n; &#43;&#43;j) c[i &#43; j] &#43;= a[i] * b[j]; 如何加速多项式的乘法呢？
多项式的两种表示方法 多项式有两种表示方法：1. 系数表示法 2. 点值表示法
多项式由系数表示法转为点值表示法的过程，就称为DFT；把一个多项式的点值表示法转化为系数表示法的过程，称为IDFT，FFT就是通过取某些特殊的x的点值来加速DFT和IDFT的过程。
系数表示法 对于一个 ${n}$ 维的多项式A(x)，它的系数 $(a_0, a_1, a_2, \cdots a_n)$ 能够唯一的表示这个多项式。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://example.org/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "快速傅里叶变换",
      "item": "http://example.org/posts/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "快速傅里叶变换",
  "name": "快速傅里叶变换",
  "description": "快速傅里叶变换 快速傅里叶变换是什么？ 快速傅里叶变换是一种能够在 $O(nlogn)$ 的时间内计算离散福利也变换的算法，在算法竞赛中常用于快速计算多项式乘法。\n多项式乘法 对于两个多项式 $A(x) = a_0 + a_1x + a_2x^2 + \\cdots + a_nx^n, B(x) = b_0 + b_1x + b_2x^2 + \\cdots + b_nx^n$ ，求出 $C(x) = A(x) \\times B(x)$ ，使用朴素算法的时间复杂度为 $O(n^2)$\nfor (int i = 0; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; n; ++j) c[i + j] += a[i] * b[j]; 如何加速多项式的乘法呢？\n多项式的两种表示方法 多项式有两种表示方法：1. 系数表示法 2. 点值表示法\n多项式由系数表示法转为点值表示法的过程，就称为DFT；把一个多项式的点值表示法转化为系数表示法的过程，称为IDFT，FFT就是通过取某些特殊的x的点值来加速DFT和IDFT的过程。\n系数表示法 对于一个 ${n}$ 维的多项式A(x)，它的系数 $(a_0, a_1, a_2, \\cdots a_n)$ 能够唯一的表示这个多项式。",
  "keywords": [
    "algorithm", "math"
  ],
  "articleBody": "快速傅里叶变换 快速傅里叶变换是什么？ 快速傅里叶变换是一种能够在 $O(nlogn)$ 的时间内计算离散福利也变换的算法，在算法竞赛中常用于快速计算多项式乘法。\n多项式乘法 对于两个多项式 $A(x) = a_0 + a_1x + a_2x^2 + \\cdots + a_nx^n, B(x) = b_0 + b_1x + b_2x^2 + \\cdots + b_nx^n$ ，求出 $C(x) = A(x) \\times B(x)$ ，使用朴素算法的时间复杂度为 $O(n^2)$\nfor (int i = 0; i  n; ++i) for (int j = 0; j  n; ++j) c[i + j] += a[i] * b[j]; 如何加速多项式的乘法呢？\n多项式的两种表示方法 多项式有两种表示方法：1. 系数表示法 2. 点值表示法\n多项式由系数表示法转为点值表示法的过程，就称为DFT；把一个多项式的点值表示法转化为系数表示法的过程，称为IDFT，FFT就是通过取某些特殊的x的点值来加速DFT和IDFT的过程。\n系数表示法 对于一个 ${n}$ 维的多项式A(x)，它的系数 $(a_0, a_1, a_2, \\cdots a_n)$ 能够唯一的表示这个多项式。\n点值表示法 对于一个 ${n}$ 维的多项式A(x)，带入 ${n+1}$ 个自变量 $(x_0, x_1, x_2, \\cdots x_n) (\\forall i,j \\in [0, n], i \\neq j, x_i \\neq x_j)$ 的值，得到的这 ${n+1}$ 个点也能够唯一确定这个多项式。\n 证明： 假设：不能够唯一确定这个多项式，即，虽然有 $A(x_i) = B(x_i) (\\forall i \\in [0, n])$，但 $B(x) \\neq A(x)$ 则令 $C(x) = A(x) - B(x)$，有 $C(x_i) = 0 (\\forall i \\in [0, n])$，这与代数基本定理(一个 ${n}$ 次多项式有且仅有 ${n}$ 个根相矛盾，假设不成立，则这 ${n+1}$ 个点能够唯一的确定这个多项式。\n 容易知道我们能够在 $O(n)$ 的时间内计算出 $C(x)$ 在这 $n + 1$ 个位置的值\n// x[]中存放的是这n + 1个自变量的取值 for (int i = 0; i  n; ++i) { c[i] = a[x[i]] * b[x[i]]; } 既然点值表达式能够较快的算出两个多项式的乘积，那么我们能否在点值表达式与系数表达式之间建立联系，这样我们就能够在得到两个多项式的系数表达式后，转化为点值表达式，然后求出两个多项式的乘积，最后转化回系数表达式。\n快速傅里叶变换！！！\n但在学习快速傅里叶变换之前，我们需要知道一些复数的知识。\n复数中的单位根 就是一些特殊的复数\n离散傅里叶变换 离散傅里叶变换使用分治求 $x = \\omega_n^k$ 的时候， $A(x) \\times B(x)$ 的值，它的分治思想体现在将多项式分为奇次项与偶次项处理。\n对于多项式 $A(x)$ ，其系数向量为 $(a_0, a_1, a_2, … a_{n-1})$ 。我们将n次单位根的0 ~ n-1次幂分别带入 $A(x)$ 得到其点值向量 $(A(\\omega_{n}^{0}), A(\\omega_{n}^{1}), A(\\omega_{n}^{2}), …, A(\\omega_{n}^{n-1}))$ 的过程就是离散傅里叶变换。\n如果朴素带入，时间复杂度是 $O(n^2)$ 的，所以我们必须要利用到单位根 $\\omega$ 的特殊性质。\n对于 $A(x) = a_0 + a_1 \\cdots x + a_2 \\cdots x^2 + … + a_{n-1} \\cdots x^{n-1}$\n将其按照奇偶分组\n$A(x) = (a_0 + a_2 \\cdots x^2 + a_4 \\cdots x^4 + … + a_{n-2} \\cdots x^{n-2}) + (a_1 \\cdots x^1 + a_3 \\cdots x^3 + a_5 \\cdots x^5 + … + a_{n-1} \\cdots x^{n-1})$\n$A(x) = (a_0 + a_2 \\cdots x^2 + a_4 \\cdots x^4 + … + a_{n-2} \\cdots x^{n-2}) + x \\cdots (a_1 + a_3 \\cdots x^2 + a_5 \\cdots x^4 + … + a_{n-1} \\cdots x^{n-2})$\n令\n$A1(x) = a_0 + a_2 \\cdots x + a_4 \\cdots x^2 + … + a_{n-2} \\cdots x^{ \\frac{n-2}{2}}$\n$A2(x) = a_1 + a_3 \\cdots x + a_5 \\cdots x^2 + … + a_{n-1} \\cdots x^{ \\frac{n-2}{2}}$\n则可得到\n$A(x) = A1(x) + x \\cdots A2(x^2)$\n$A1(x)$ 和 $A2(x)$ 都是 $A(x)$ 一半的规模，可以转化为子问题递归求解\n离散傅里叶反变换 通过点值表达式求出系数表达式，这个过程称为离散傅里叶反变换\n不证了，不证了，留着以后证明吧~\n直接给出结论，离散傅里叶反变换所需要的操作和离散傅里叶变换一样，只是带入的值 $\\omega_N^{-k}$ 是离散傅里叶变换带入值的共轭复数\nFFT代码 #include #include #include using namespace std; const int maxn = 1  10; const double PI = acos(-1.0); int a[maxn], b[maxn]; struct Complex { double r, i; Complex() {} Complex(double _r, double _i) : r (_r), i (_i) {} inline void real(const double\u0026 x) {r = x;} inline double real() {return r;} inline Complex operator + (const Complex\u0026 rhs) const { return Complex (r + rhs.r, i + rhs.i) ; } inline Complex operator - (const Complex\u0026 rhs) const { return Complex (r - rhs.r, i - rhs.i); } inline Complex operator * (const Complex\u0026 rhs) const { return Complex (r*rhs.r - i*rhs.i, r*rhs.i + i*rhs.r); } inline void operator /= (const double\u0026 x) { r /= x, i /= x ; } inline void operator *= (const Complex\u0026 rhs) { *this = Complex (r*rhs.r - i*rhs.i, r*rhs.i + i*rhs.r); } inline void operator += (const Complex\u0026 rhs) { r += rhs.r, i += rhs.i; } inline Complex conj() { return Complex (r, -i) ; } }; struct FastFourierTransform { Complex omega[maxn], omegaInverse[maxn]; void init(const int\u0026 n) { for (int i = 0; i  n; ++i) { omega[i] = Complex(cos(2*PI / n*i), sin(2*PI / n*i)); omegaInverse[i] = omega[i].conj(); } } void transform(Complex *a, const int\u0026 n, const Complex* omega) { for (int i = 0, j = 0; i  n; ++i) { if (i  j) swap(a[i], a[j]); for (int l = n  1; (j ^= l)  l; l = 1); } for (int l = 2; l  n; l  1) { int m = l / 2; for (Complex *p = a; p != a + n; p += l) for (int i = 0; i  m; ++i) { Complex t = omega[n / l * i] * p [m + i]; p[m + i] = p[i] - t; p[i] += t; } } } void dft(Complex *a, const int\u0026 n) { transform(a, n, omega); } void idft(Complex *a, const int\u0026 n) { transform(a, n, omegaInverse); for (int i = 0; i  n; ++i) a[i] /= n; } } fft; int main() { /* * 这是两个多项式的系数： * A(x) = 5 + 2x + 3x^2 * B(x) = 2 + 6x + x^2 * 下面的len1，len2分别是两个多项式最大项的最高次幂+1 * FFT中len一定要是2^k这种形式，否则在进行分治时会左右不均失败 */ a[0] = 5; a[1] = 2; a[2] = 3; b[0] = 2; b[1] = 6; b[2] = 1; int len1 = 3, len2 = 3; int len = 1; while (len  len1 * 2 || len  len2 * 2) len  1; fft.init(len); // 初始化\\omega  Complex x1[maxn], x2[maxn]; // 存储两个多项式的系数  for (int i = 0; i  len; ++i) { x1[i].r = a[i]; x1[i].i = 0.0; x2[i].r = b[i]; x2[i].i = 0.0; } fft.dft(x1, len); fft.dft(x2, len); for (int i = 0; i  len; ++i) x1[i] = x1[i] * x2[i]; fft.idft(x1, len); int res[maxn]; for (int i = 0; i  len; ++i) res[i] = (int)(x1[i].r + 0.5); while (len \u0026\u0026 res[len-1] == 0) --len; for (int i = 0; i  len; ++i) printf(\"%d \", res[i]); puts(\"\"); return 0; } ",
  "wordCount" : "862",
  "inLanguage": "en",
  "datePublished": "2021-09-18T13:08:42+08:00",
  "dateModified": "2021-09-18T13:08:42+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://example.org/posts/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes",
    "logo": {
      "@type": "ImageObject",
      "url": "http://example.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://example.org/" accesskey="h" title="Notes (Alt + H)">Notes</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      快速傅里叶变换
    </h1>
    <div class="post-meta">September 18, 2021
</div>
  </header> 
  <div class="post-content"><h1 id="快速傅里叶变换">快速傅里叶变换<a hidden class="anchor" aria-hidden="true" href="#快速傅里叶变换">#</a></h1>
<h2 id="快速傅里叶变换是什么">快速傅里叶变换是什么？<a hidden class="anchor" aria-hidden="true" href="#快速傅里叶变换是什么">#</a></h2>
<p>快速傅里叶变换是一种能够在 $O(nlogn)$ 的时间内计算离散福利也变换的算法，在算法竞赛中常用于快速计算多项式乘法。</p>
<h2 id="多项式乘法">多项式乘法<a hidden class="anchor" aria-hidden="true" href="#多项式乘法">#</a></h2>
<p>对于两个多项式 $A(x) = a_0 + a_1x + a_2x^2 + \cdots + a_nx^n, B(x) = b_0 + b_1x + b_2x^2 + \cdots + b_nx^n$ ，求出 $C(x) = A(x) \times B(x)$ ，使用朴素算法的时间复杂度为 $O(n^2)$</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) 
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>j)
        c[i <span style="color:#f92672">+</span> j] <span style="color:#f92672">+=</span> a[i] <span style="color:#f92672">*</span> b[j];
</code></pre></div><p>如何加速多项式的乘法呢？</p>
<h2 id="多项式的两种表示方法">多项式的两种表示方法<a hidden class="anchor" aria-hidden="true" href="#多项式的两种表示方法">#</a></h2>
<p>多项式有两种表示方法：1. 系数表示法 2. 点值表示法</p>
<p>多项式由系数表示法转为点值表示法的过程，就称为DFT；把一个多项式的点值表示法转化为系数表示法的过程，称为IDFT，FFT就是通过取某些特殊的x的点值来加速DFT和IDFT的过程。</p>
<h3 id="系数表示法">系数表示法<a hidden class="anchor" aria-hidden="true" href="#系数表示法">#</a></h3>
<p>对于一个 ${n}$ 维的多项式A(x)，它的系数 $(a_0, a_1, a_2, \cdots a_n)$ 能够唯一的表示这个多项式。</p>
<h3 id="点值表示法">点值表示法<a hidden class="anchor" aria-hidden="true" href="#点值表示法">#</a></h3>
<p>对于一个 ${n}$ 维的多项式A(x)，带入 ${n+1}$ 个自变量 $(x_0, x_1, x_2, \cdots x_n) (\forall i,j \in [0, n], i \neq j, x_i \neq x_j)$ 的值，得到的这 ${n+1}$ 个点也能够唯一确定这个多项式。</p>
<blockquote>
<p>证明：
假设：不能够唯一确定这个多项式，即，虽然有 $A(x_i) = B(x_i) (\forall i \in [0, n])$，但 $B(x) \neq A(x)$
则令 $C(x) = A(x) - B(x)$，有 $C(x_i) = 0 (\forall i \in [0, n])$，这与代数基本定理(一个 ${n}$ 次多项式有且仅有 ${n}$ 个根相矛盾，假设不成立，则这 ${n+1}$ 个点能够唯一的确定这个多项式。</p>
</blockquote>
<p>容易知道我们能够在 $O(n)$ 的时间内计算出 $C(x)$ 在这 $n + 1$ 个位置的值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// x[]中存放的是这n + 1个自变量的取值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> n; <span style="color:#f92672">++</span>i) {
    c[i] <span style="color:#f92672">=</span> a[x[i]] <span style="color:#f92672">*</span> b[x[i]];
}
</code></pre></div><p>既然点值表达式能够较快的算出两个多项式的乘积，那么我们能否在点值表达式与系数表达式之间建立联系，这样我们就能够在得到两个多项式的系数表达式后，转化为点值表达式，然后求出两个多项式的乘积，最后转化回系数表达式。</p>
<p><em>快速傅里叶变换！！！</em></p>
<p>但在学习快速傅里叶变换之前，我们需要知道一些复数的知识。</p>
<h2 id="复数中的单位根">复数中的单位根<a hidden class="anchor" aria-hidden="true" href="#复数中的单位根">#</a></h2>
<p>就是一些特殊的复数</p>
<h2 id="离散傅里叶变换">离散傅里叶变换<a hidden class="anchor" aria-hidden="true" href="#离散傅里叶变换">#</a></h2>
<p>离散傅里叶变换使用分治求 $x = \omega_n^k$ 的时候， $A(x) \times B(x)$ 的值，它的分治思想体现在将多项式分为奇次项与偶次项处理。</p>
<p>对于多项式 $A(x)$ ，其系数向量为 $(a_0, a_1, a_2, &hellip; a_{n-1})$ 。我们将n次单位根的0 ~ n-1次幂分别带入 $A(x)$ 得到其点值向量 $(A(\omega_{n}^{0}), A(\omega_{n}^{1}), A(\omega_{n}^{2}), &hellip;, A(\omega_{n}^{n-1}))$ 的过程就是离散傅里叶变换。</p>
<p>如果朴素带入，时间复杂度是 $O(n^2)$ 的，所以我们必须要利用到单位根 $\omega$ 的特殊性质。</p>
<p>对于 $A(x) = a_0 + a_1 \cdots x + a_2 \cdots x^2 + &hellip; + a_{n-1} \cdots x^{n-1}$</p>
<p>将其按照奇偶分组</p>
<p>$A(x) = (a_0 + a_2 \cdots x^2 + a_4 \cdots x^4 + &hellip; + a_{n-2} \cdots x^{n-2}) + (a_1 \cdots x^1 + a_3 \cdots x^3 + a_5 \cdots x^5 + &hellip; + a_{n-1} \cdots x^{n-1})$</p>
<p>$A(x) = (a_0 + a_2 \cdots x^2 + a_4 \cdots x^4 + &hellip; + a_{n-2} \cdots x^{n-2}) + x \cdots (a_1 + a_3 \cdots x^2 + a_5 \cdots x^4 + &hellip; + a_{n-1} \cdots x^{n-2})$</p>
<p>令</p>
<p>$A1(x) = a_0 + a_2 \cdots x + a_4 \cdots x^2 + &hellip; + a_{n-2} \cdots x^{ \frac{n-2}{2}}$</p>
<p>$A2(x) = a_1 + a_3 \cdots x + a_5 \cdots x^2 + &hellip; + a_{n-1} \cdots x^{ \frac{n-2}{2}}$</p>
<p>则可得到</p>
<p>$A(x) = A1(x) + x \cdots A2(x^2)$</p>
<p>$A1(x)$ 和 $A2(x)$ 都是 $A(x)$ 一半的规模，可以转化为子问题递归求解</p>
<h2 id="离散傅里叶反变换">离散傅里叶反变换<a hidden class="anchor" aria-hidden="true" href="#离散傅里叶反变换">#</a></h2>
<p>通过点值表达式求出系数表达式，这个过程称为离散傅里叶反变换</p>
<p>不证了，不证了，留着以后证明吧~</p>
<p>直接给出结论，离散傅里叶反变换所需要的操作和离散傅里叶变换一样，只是带入的值 $\omega_N^{-k}$ 是离散傅里叶变换带入值的共轭复数</p>
<h2 id="fft代码">FFT代码<a hidden class="anchor" aria-hidden="true" href="#fft代码">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> maxn <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">10</span>;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">double</span> PI <span style="color:#f92672">=</span> acos(<span style="color:#f92672">-</span><span style="color:#ae81ff">1.0</span>);
<span style="color:#66d9ef">int</span> a[maxn], b[maxn];

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Complex</span> {
    <span style="color:#66d9ef">double</span> r, i;
    Complex() {}
    Complex(<span style="color:#66d9ef">double</span> _r, <span style="color:#66d9ef">double</span> _i) <span style="color:#f92672">:</span> r (_r), i (_i) {}
    <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">real</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">&amp;</span> x) {r <span style="color:#f92672">=</span> x;}
    <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">real</span>() {<span style="color:#66d9ef">return</span> r;}
    <span style="color:#66d9ef">inline</span> Complex <span style="color:#66d9ef">operator</span> <span style="color:#f92672">+</span> (<span style="color:#66d9ef">const</span> Complex<span style="color:#f92672">&amp;</span> rhs) <span style="color:#66d9ef">const</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Complex</span> (r <span style="color:#f92672">+</span> rhs.r, i <span style="color:#f92672">+</span> rhs.i) ;
    }
    <span style="color:#66d9ef">inline</span> Complex <span style="color:#66d9ef">operator</span> <span style="color:#f92672">-</span> (<span style="color:#66d9ef">const</span> Complex<span style="color:#f92672">&amp;</span> rhs) <span style="color:#66d9ef">const</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Complex</span> (r <span style="color:#f92672">-</span> rhs.r, i <span style="color:#f92672">-</span> rhs.i);
    }
    <span style="color:#66d9ef">inline</span> Complex <span style="color:#66d9ef">operator</span> <span style="color:#f92672">*</span> (<span style="color:#66d9ef">const</span> Complex<span style="color:#f92672">&amp;</span> rhs) <span style="color:#66d9ef">const</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Complex</span> (r<span style="color:#f92672">*</span>rhs.r <span style="color:#f92672">-</span> i<span style="color:#f92672">*</span>rhs.i, r<span style="color:#f92672">*</span>rhs.i <span style="color:#f92672">+</span> i<span style="color:#f92672">*</span>rhs.r);
    }
    <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">/=</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">&amp;</span> x) {
        r <span style="color:#f92672">/=</span> x, i <span style="color:#f92672">/=</span> x ;
    }
    <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">*=</span> (<span style="color:#66d9ef">const</span> Complex<span style="color:#f92672">&amp;</span> rhs) {
        <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span> <span style="color:#f92672">=</span> Complex (r<span style="color:#f92672">*</span>rhs.r <span style="color:#f92672">-</span> i<span style="color:#f92672">*</span>rhs.i, r<span style="color:#f92672">*</span>rhs.i <span style="color:#f92672">+</span> i<span style="color:#f92672">*</span>rhs.r);
    }
    <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">+=</span> (<span style="color:#66d9ef">const</span> Complex<span style="color:#f92672">&amp;</span> rhs) {
        r <span style="color:#f92672">+=</span> rhs.r, i <span style="color:#f92672">+=</span> rhs.i;
    }
    <span style="color:#66d9ef">inline</span> Complex <span style="color:#a6e22e">conj</span>() {
        <span style="color:#66d9ef">return</span> Complex (r, <span style="color:#f92672">-</span>i) ;
    }
};

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">FastFourierTransform</span> {
    Complex omega[maxn], omegaInverse[maxn];

    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> n) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
            omega[i] <span style="color:#f92672">=</span> Complex(cos(<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>PI <span style="color:#f92672">/</span> n<span style="color:#f92672">*</span>i), sin(<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>PI <span style="color:#f92672">/</span> n<span style="color:#f92672">*</span>i));
            omegaInverse[i] <span style="color:#f92672">=</span> omega[i].conj();
        }
    }

    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">transform</span>(Complex <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> n, <span style="color:#66d9ef">const</span> Complex<span style="color:#f92672">*</span> omega) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&gt;</span> j)
                swap(a[i], a[j]);
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> n <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>; (j <span style="color:#f92672">^=</span> l) <span style="color:#f92672">&lt;</span> l; l <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>);
        }

        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; l <span style="color:#f92672">&lt;=</span> n; l <span style="color:#f92672">&lt;&lt;=</span> <span style="color:#ae81ff">1</span>) {
            <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> l <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
            <span style="color:#66d9ef">for</span> (Complex <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> a; p <span style="color:#f92672">!=</span> a <span style="color:#f92672">+</span> n; p <span style="color:#f92672">+=</span> l)
                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; <span style="color:#f92672">++</span>i) {
                    Complex t <span style="color:#f92672">=</span> omega[n <span style="color:#f92672">/</span> l <span style="color:#f92672">*</span> i] <span style="color:#f92672">*</span> p [m <span style="color:#f92672">+</span> i];
                    p[m <span style="color:#f92672">+</span> i] <span style="color:#f92672">=</span> p[i] <span style="color:#f92672">-</span> t;
                    p[i] <span style="color:#f92672">+=</span> t;
                }
        }
    }

    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dft</span>(Complex <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> n) {
        transform(a, n, omega);
    }

    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">idft</span>(Complex <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> n) {
        transform(a, n, omegaInverse);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i)
            a[i] <span style="color:#f92672">/=</span> n;
    }
} fft;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">/*
</span><span style="color:#75715e">     * 这是两个多项式的系数：
</span><span style="color:#75715e">     * A(x) = 5 + 2x + 3x^2
</span><span style="color:#75715e">     * B(x) = 2 + 6x + x^2   
</span><span style="color:#75715e">     * 下面的len1，len2分别是两个多项式最大项的最高次幂+1
</span><span style="color:#75715e">     * FFT中len一定要是2^k这种形式，否则在进行分治时会左右不均失败
</span><span style="color:#75715e">     */</span>
    a[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>; a[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; a[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
    b[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; b[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>; b[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">int</span> len1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>, len2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
    <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span> (len <span style="color:#f92672">&lt;</span> len1 <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">||</span> len <span style="color:#f92672">&lt;</span> len2 <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>)
        len <span style="color:#f92672">&lt;&lt;=</span> <span style="color:#ae81ff">1</span>;
    fft.init(len);   <span style="color:#75715e">// 初始化\omega
</span><span style="color:#75715e"></span>
    Complex x1[maxn], x2[maxn];   <span style="color:#75715e">// 存储两个多项式的系数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> len; <span style="color:#f92672">++</span>i) {
        x1[i].r <span style="color:#f92672">=</span> a[i]; x1[i].i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
        x2[i].r <span style="color:#f92672">=</span> b[i]; x2[i].i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
    }
    fft.dft(x1, len); fft.dft(x2, len);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> len; <span style="color:#f92672">++</span>i)
        x1[i] <span style="color:#f92672">=</span> x1[i] <span style="color:#f92672">*</span> x2[i];
    fft.idft(x1, len);

    <span style="color:#66d9ef">int</span> res[maxn];
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> len; <span style="color:#f92672">++</span>i) 
        res[i] <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>)(x1[i].r <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5</span>);
    <span style="color:#66d9ef">while</span> (len <span style="color:#f92672">&amp;&amp;</span> res[len<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) 
        <span style="color:#f92672">--</span>len;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> len; <span style="color:#f92672">++</span>i)
        printf(<span style="color:#e6db74">&#34;%d &#34;</span>, res[i]);
    puts(<span style="color:#e6db74">&#34;&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://example.org/tags/algorithm/">algorithm</a></li>
      <li><a href="http://example.org/tags/math/">math</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="http://example.org/">Notes</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
