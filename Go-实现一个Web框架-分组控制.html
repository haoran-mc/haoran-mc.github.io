<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-12-25 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>分组控制</title>
<meta name="author" content="L.M.haoran" />
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved." />
<meta name="generator" content="Org Mode" />
<link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
           <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
           <script type="module" src="static/js/main.js" defer></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">分组控制</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org31fb1ea">分组的意义</a></li>
<li><a href="#org8a1ffdb">分组嵌套</a></li>
<li><a href="#org8083dba">使用 Demo</a></li>
</ul>
</div>
</div>

<div id="outline-container-org31fb1ea" class="outline-2">
<h2 id="org31fb1ea">分组的意义</h2>
<div class="outline-text-2" id="text-org31fb1ea">
<p>
分组控制（Group Control）是 Web 框架应提供的基础功能之一。所谓分组，是指路由的分组。如果没有路由分组，我们需要针对每一个路由进行控制。但是真实的业务场景中，往往某一组路由需要相似的处理。例如：<br>
</p>

<ul class="org-ul">
<li>以 <code>/post</code> 开头的路由匿名可访问。<br></li>
<li>以 <code>/admin</code> 开头的路由需要鉴权。<br></li>
<li>以 <code>/api</code> 开头的路由是 RESTful 接口，可以对接第三方平台，需要三方平台鉴权。<br></li>
</ul>

<p>
大部分情况下的路由分组，是以相同的前缀来区分的。因此，我们今天实现的分组控制也是以前缀来区分，并且支持分组的嵌套。例如 <code>/post</code> 是一个分组， <code>/post/a</code> 和 <code>/post/b</code> 可以是该分组下的子分组。作用在 <code>/post</code> 分组上的中间件（middleware），也都会作用在子分组，子分组还可以应用自己特有的中间件。<br>
</p>

<p>
中间件可以给框架提供无限的扩展能力，应用在分组上，可以使得分组控制的收益更为明显，而不是共享相同的路由前缀这么简单。例如 <code>/admin</code> 的分组，可以应用鉴权中间件； <code>/</code> 分组应用日志中间件， <code>/</code> 是默认的最顶层的分组，也就意味着给所有的路由，即整个框架增加了记录日志的能力。<br>
</p>

<p>
提供扩展能力支持中间件的内容，我们将在下一节当中介绍。<br>
</p>
</div>
</div>
<div id="outline-container-org8a1ffdb" class="outline-2">
<h2 id="org8a1ffdb">分组嵌套</h2>
<div class="outline-text-2" id="text-org8a1ffdb">
<p>
一个 Group 对象需要具备哪些属性呢？首先是前缀（prefix），比如/，或者/api；要支持分组嵌套，那么需要知道当前分组的父亲（parent）是谁；当然了，按照我们一开始的分析，中间件是应用在分组上的，那还需要存储应用在该分组上的中间件（middlewares）。还记得，我们之前调用函数(*Engine).addRoute()来映射所有的路由规则和 Handler 。如果 Group 对象需要直接映射路由规则的话，比如我们想在使用框架时，这么调用：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #6a1868;">r</span> := gee.<span style="color: #a626a4;">New</span>()
<span style="color: #6a1868;">v1</span> := r.<span style="color: #a626a4;">Group</span>(<span style="color: #50a14f;">"/v1"</span>)
v1.<span style="color: #a626a4;">GET</span>(<span style="color: #50a14f;">"/"</span>, <span style="color: #e45649;">func</span>(<span style="color: #6a1868;">c</span> *<span style="color: #986801;">gee.Context</span>) {
    c.<span style="color: #a626a4;">HTML</span>(http.StatusOK, <span style="color: #50a14f;">"&lt;h1&gt;Hello Gee&lt;/h1&gt;"</span>)
})
</pre>
</div>

<p>
那么Group对象，还需要有访问Router的能力，为了方便，我们可以在Group中，保存一个指针，指向Engine，整个框架的所有资源都是由Engine统一协调的，那么就可以通过Engine间接地访问各种接口了。<br>
</p>

<p>
所以，最后的 Group 的定义是这样的：<br>
</p>

<div class="org-src-container">
<pre class="src src-go">RouterGroup <span style="color: #e45649;">struct</span> {
    prefix      <span style="color: #986801;">string</span>
    middlewares []<span style="color: #986801;">HandlerFunc</span> <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">support middleware</span>
    parent      *<span style="color: #986801;">RouterGroup</span>  <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">support nesting</span>
    engine      *<span style="color: #986801;">Engine</span>       <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">all groups share a Engine instance</span>
}
</pre>
</div>

<p>
我们还可以进一步地抽象，将 <code>Engine</code> 作为最顶层的分组，也就是说 <code>Engine</code> 拥有 <code>RouterGroup</code> 所有的能力。<br>
</p>

<div class="org-src-container">
<pre class="src src-go">Engine <span style="color: #e45649;">struct</span> {
    *RouterGroup
    router *<span style="color: #986801;">router</span>
    groups []*<span style="color: #986801;">RouterGroup</span> <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">store all groups</span>
}
</pre>
</div>

<p>
那我们就可以将和路由有关的函数，都交给 <code>RouterGroup</code> 实现了。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">New is the constructor of gee.Engine</span>
<span style="color: #e45649;">func</span> <span style="color: #a626a4;">New</span>() *<span style="color: #986801;">Engine</span> {
    <span style="color: #6a1868;">engine</span> := &amp;<span style="color: #986801;">Engine</span>{<span style="color: #b751b6;">router</span>: <span style="color: #a626a4;">newRouter</span>()}
    engine.RouterGroup = &amp;<span style="color: #986801;">RouterGroup</span>{<span style="color: #b751b6;">engine</span>: engine}
    engine.groups = []*<span style="color: #986801;">RouterGroup</span>{engine.RouterGroup}
    <span style="color: #e45649;">return</span> engine
}

<span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">Group is defined to create a new RouterGroup</span>
<span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">remember all groups share the same Engine instance</span>
<span style="color: #e45649;">func</span> (<span style="color: #6a1868;">group</span> *<span style="color: #986801;">RouterGroup</span>) <span style="color: #a626a4;">Group</span>(<span style="color: #6a1868;">prefix</span> <span style="color: #986801;">string</span>) *<span style="color: #986801;">RouterGroup</span> {
    <span style="color: #6a1868;">engine</span> := group.engine
    <span style="color: #6a1868;">newGroup</span> := &amp;<span style="color: #986801;">RouterGroup</span>{
        <span style="color: #b751b6;">prefix</span>: group.prefix + prefix,
        <span style="color: #b751b6;">parent</span>: group,
        <span style="color: #b751b6;">engine</span>: engine,
    }
    engine.groups = <span style="color: #a626a4;">append</span>(engine.groups, newGroup)
    <span style="color: #e45649;">return</span> newGroup
}

<span style="color: #e45649;">func</span> (<span style="color: #6a1868;">group</span> *<span style="color: #986801;">RouterGroup</span>) <span style="color: #a626a4;">addRoute</span>(<span style="color: #6a1868;">method</span> <span style="color: #986801;">string</span>, <span style="color: #6a1868;">comp</span> <span style="color: #986801;">string</span>, <span style="color: #6a1868;">handler</span> <span style="color: #986801;">HandlerFunc</span>) {
    <span style="color: #6a1868;">pattern</span> := group.prefix + comp
    log.<span style="color: #a626a4;">Printf</span>(<span style="color: #50a14f;">"Route %4s - %s"</span>, method, pattern)
    group.engine.router.<span style="color: #a626a4;">addRoute</span>(method, pattern, handler)
}

<span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">GET defines the method to add GET request</span>
<span style="color: #e45649;">func</span> (<span style="color: #6a1868;">group</span> *<span style="color: #986801;">RouterGroup</span>) <span style="color: #a626a4;">GET</span>(<span style="color: #6a1868;">pattern</span> <span style="color: #986801;">string</span>, <span style="color: #6a1868;">handler</span> <span style="color: #986801;">HandlerFunc</span>) {
    group.<span style="color: #a626a4;">addRoute</span>(<span style="color: #50a14f;">"GET"</span>, pattern, handler)
}

<span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">POST defines the method to add POST request</span>
<span style="color: #e45649;">func</span> (<span style="color: #6a1868;">group</span> *<span style="color: #986801;">RouterGroup</span>) <span style="color: #a626a4;">POST</span>(<span style="color: #6a1868;">pattern</span> <span style="color: #986801;">string</span>, <span style="color: #6a1868;">handler</span> <span style="color: #986801;">HandlerFunc</span>) {
    group.<span style="color: #a626a4;">addRoute</span>(<span style="color: #50a14f;">"POST"</span>, pattern, handler)
}
</pre>
</div>

<p>
可以仔细观察下 <code>addRoute</code> 函数，调用了 <code>group.engine.router.addRoute</code> 来实现了路由的映射。由于 <code>Engine</code> 从某种意义上继承了 <code>RouterGroup</code> 的所有属性和方法，因为 <code>(*Engine).engine</code> 是指向自己的。这样实现，我们既可以像原来一样添加路由，也可以通过分组添加路由。<br>
</p>
</div>
</div>
<div id="outline-container-org8083dba" class="outline-2">
<h2 id="org8083dba">使用 Demo</h2>
<div class="outline-text-2" id="text-org8083dba">
<p>
测试框架的 Demo 就可以这样写了：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #e45649;">func</span> <span style="color: #a626a4;">main</span>() {
    <span style="color: #6a1868;">r</span> := gee.<span style="color: #a626a4;">New</span>()
    r.<span style="color: #a626a4;">GET</span>(<span style="color: #50a14f;">"/index"</span>, <span style="color: #e45649;">func</span>(<span style="color: #6a1868;">c</span> *<span style="color: #986801;">gee.Context</span>) {
        c.<span style="color: #a626a4;">HTML</span>(http.StatusOK, <span style="color: #50a14f;">"&lt;h1&gt;index page&lt;/h1&gt;"</span>)
    })
    <span style="color: #6a1868;">v1</span> := r.<span style="color: #a626a4;">Group</span>(<span style="color: #50a14f;">"/v1"</span>)
    {
        v1.<span style="color: #a626a4;">GET</span>(<span style="color: #50a14f;">"/"</span>, <span style="color: #e45649;">func</span>(<span style="color: #6a1868;">c</span> *<span style="color: #986801;">gee.Context</span>) {
            c.<span style="color: #a626a4;">HTML</span>(http.StatusOK, <span style="color: #50a14f;">"&lt;h1&gt;hello gee&lt;/h1&gt;"</span>)
        })

        v1.<span style="color: #a626a4;">GET</span>(<span style="color: #50a14f;">"/hello"</span>, <span style="color: #e45649;">func</span>(<span style="color: #6a1868;">c</span> *<span style="color: #986801;">gee.Context</span>) {
            <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">expect /hello?name=haoran</span>
            c.<span style="color: #a626a4;">String</span>(http.StatusOK, <span style="color: #50a14f;">"hello %s, you're at %s\n"</span>, c.<span style="color: #a626a4;">Query</span>(<span style="color: #50a14f;">"name"</span>), c.Path)
        })
    }
    <span style="color: #6a1868;">v2</span> := r.<span style="color: #a626a4;">Group</span>(<span style="color: #50a14f;">"/v2"</span>)
    {
        v2.<span style="color: #a626a4;">GET</span>(<span style="color: #50a14f;">"/hello/:name"</span>, <span style="color: #e45649;">func</span>(<span style="color: #6a1868;">c</span> *<span style="color: #986801;">gee.Context</span>) {
            <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">expect /hello/haoran</span>
            c.<span style="color: #a626a4;">String</span>(http.StatusOK, <span style="color: #50a14f;">"hello %s, you're at %s\n"</span>, c.<span style="color: #a626a4;">Param</span>(<span style="color: #50a14f;">"name"</span>), c.Path)
        })
        v2.<span style="color: #a626a4;">POST</span>(<span style="color: #50a14f;">"/login"</span>, <span style="color: #e45649;">func</span>(<span style="color: #6a1868;">c</span> *<span style="color: #986801;">gee.Context</span>) {
            c.<span style="color: #a626a4;">JSON</span>(http.StatusOK, <span style="color: #986801;">gee.H</span>{
                <span style="color: #50a14f;">"username"</span>: c.<span style="color: #a626a4;">PostForm</span>(<span style="color: #50a14f;">"username"</span>),
                <span style="color: #50a14f;">"password"</span>: c.<span style="color: #a626a4;">PostForm</span>(<span style="color: #50a14f;">"password"</span>),
            })
        })

    }

    r.<span style="color: #a626a4;">Run</span>(<span style="color: #50a14f;">":9999"</span>)
}
</pre>
</div>

<p>
通过 curl 简单测试：<br>
</p>

<pre class="example" id="org0e9522e">
$ curl "http://localhost:9999/v1/hello?name=haoran"
hello haoran, you're at /v1/hello

$ curl "http://localhost:9999/v2/hello/haoran"
hello haoran, you're at /hello/haoran
</pre>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-12-25</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
