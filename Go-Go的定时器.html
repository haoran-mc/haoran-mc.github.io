<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2023-01-12 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Go的定时器</title>
<meta name="author" content="Haoran Liu" />
<meta name="description" content="Copyright © 2022, Haoran Liu, all rights reserved." />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="static/css/org.css"/>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Go的定时器</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org1591428">Timer 是什么？</a></li>
<li><a href="#orgfa99d7f">Timer 如何使用？</a>
<ul>
<li><a href="#orgeda49c8">基本使用</a></li>
<li><a href="#org85eeb0d">Timer 延时使用</a></li>
<li><a href="#orgd36f8db">停止定时器</a></li>
<li><a href="#org140c38c">重置定时器</a></li>
</ul>
</li>
<li><a href="#org19a4d68">Ticker 是什么？</a></li>
<li><a href="#org842e02e">Ticker 如何使用？</a>
<ul>
<li><a href="#orgcdfff28">简单使用 Ticker</a></li>
<li><a href="#org81cf511">通用版本的 demo</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org1591428" class="outline-2">
<h2 id="org1591428">Timer 是什么？</h2>
</div>
<div id="outline-container-orgfa99d7f" class="outline-2">
<h2 id="orgfa99d7f">Timer 如何使用？</h2>
<div class="outline-text-2" id="text-orgfa99d7f">
<p>
简单看看 Timer 对应的数据结构<br>
</p>

<p>
位置在： <code>src/time/sleep.go:Timer</code><br>
</p>

<p>
Timer 代表一次定时，时间到来后只发生一个事件。只发生一次，这里尤为重要。<br>
</p>

<p>
Timer 对外仅暴露一个通道，指定的时间到了，就会往该通道中写入系统时间，时间到了就触发一次事件，只会触发一次，因为时间只会到一次。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #b294bb;">type</span> <span style="color: #f0c674;">Timer</span> <span style="color: #b294bb;">struct</span> {
    C &lt;-<span style="color: #b294bb;">chan</span> <span style="color: #f0c674;">Time</span>
    r <span style="color: #f0c674;">runtimeTimer</span>
}
</pre>
</div>
</div>
<div id="outline-container-orgeda49c8" class="outline-3">
<h3 id="orgeda49c8">基本使用</h3>
<div class="outline-text-3" id="text-orgeda49c8">
<p>
设置一个 1s 的定时器，这个定时器只会触发一次。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #b294bb;">func</span> <span style="color: #81a2be;">NewTimer</span>(<span style="color: #cc6666;">d</span> <span style="color: #f0c674;">Duration</span>) <span style="color: #f0c674;">Timer</span>
</pre>
</div>

<p>
指定一个时间即可创建一个 Timer，Timer 一经创建便开始计时，不需要额外的启动命令：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #b294bb;">func</span> <span style="color: #81a2be;">main</span>() {
    <span style="color: #5a5b5a;">// </span><span style="color: #5a5b5a;">&#21019;&#24314;&#19968;&#20010; Timer</span>
    <span style="color: #cc6666;">myT</span> := time.<span style="color: #81a2be;">NewTimer</span>(1 * time.Second)
    <span style="color: #5a5b5a;">// </span><span style="color: #5a5b5a;">&#20174;&#36890;&#36947;&#20013;&#35835;&#21462;&#25968;&#25454;&#65292;&#33509;&#35835;&#21462;&#24471;&#21040;&#65292;&#35828;&#26126;&#26102;&#38388;&#21040;&#20102;</span>
    &lt;- myT.C
    fmt.<span style="color: #81a2be;">Println</span>(<span style="color: #b5bd68;">"1s &#26102;&#38388;&#21040;"</span>)

    <span style="color: #b294bb;">for</span> {}
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org85eeb0d" class="outline-3">
<h3 id="org85eeb0d">Timer 延时使用</h3>
<div class="outline-text-3" id="text-org85eeb0d">
<p>
设置一个 1 秒的定时，再延时 2 秒。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #b294bb;">func</span> <span style="color: #81a2be;">main</span>() {
    <span style="color: #5a5b5a;">// </span><span style="color: #5a5b5a;">&#21019;&#24314;&#19968;&#20010; Timer</span>
    <span style="color: #cc6666;">myT</span> := time.<span style="color: #81a2be;">NewTimer</span>(1 * time.Second)
    &lt;- myT.C
    fmt.<span style="color: #81a2be;">Println</span>(<span style="color: #b5bd68;">"1s &#26102;&#38388;&#21040; "</span>,time.<span style="color: #81a2be;">Now</span>().<span style="color: #81a2be;">Unix</span>())

    <span style="color: #5a5b5a;">// </span><span style="color: #5a5b5a;">&#24310;&#26102; 2 &#31186;</span>
    &lt;-time.<span style="color: #81a2be;">After</span>(2 * time.Second)
    fmt.<span style="color: #81a2be;">Println</span>(<span style="color: #b5bd68;">" 2 s &#26102;&#38388;&#21040; "</span>,time.<span style="color: #81a2be;">Now</span>().<span style="color: #81a2be;">Unix</span>())

    <span style="color: #b294bb;">for</span> {}
}
</pre>
</div>

<p>
运行代码执行效果如下：<br>
</p>

<pre class="example" id="orgdc770b1">
1s 时间到  1624757781
2s 时间到  1624757783
</pre>

<p>
GO 还提供了一个函数 <code>AfterFunc</code><br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #b294bb;">func</span> <span style="color: #81a2be;">AfterFunc</span>(<span style="color: #cc6666;">d</span> <span style="color: #f0c674;">Duration</span>, <span style="color: #cc6666;">f</span> <span style="color: #b294bb;">func</span>()) *<span style="color: #f0c674;">Timer</span>
</pre>
</div>

<p>
也是可以做到延迟的效果，更好的是，延迟了之后，能够执行我们填入的函数。<br>
</p>
</div>
</div>
<div id="outline-container-orgd36f8db" class="outline-3">
<h3 id="orgd36f8db">停止定时器</h3>
<div class="outline-text-3" id="text-orgd36f8db">
<p>
Timer 创建后可以随时停止，可以使用 <code>time.Stop()</code> 停止定时器：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #b294bb;">func</span> (<span style="color: #cc6666;">t</span> *<span style="color: #f0c674;">Timer</span>) <span style="color: #81a2be;">Stop</span>() <span style="color: #f0c674;">bool</span>
</pre>
</div>

<p>
Stop() 函数返回值是 bool：<br>
</p>

<ul class="org-ul">
<li>true: 定时器超时前停止，后续不会再有事件发送了<br></li>
<li>false: 定时器是在超时后，停止的<br></li>
</ul>

<p>
定时器是在超时后停止的，写一个demo ， 设置 1s 的定时器。若在到了 1s，则进行打印，说明已经超时；若没有到 1s，通道就已经关闭了，则未超时。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #b294bb;">func</span> <span style="color: #81a2be;">testChannelTimeout</span>(<span style="color: #cc6666;">conn</span> <span style="color: #b294bb;">chan</span> <span style="color: #f0c674;">int</span>) <span style="color: #f0c674;">bool</span> {
    <span style="color: #5a5b5a;">// </span><span style="color: #5a5b5a;">&#35774;&#32622; 1 &#31186;&#30340;&#23450;&#26102;&#22120;&#65292;&#33509;&#22312;&#21040;&#20102;1s&#65292;&#21017;&#36827;&#34892;&#25171;&#21360;&#65292;&#35828;&#26126;&#24050;&#32463;&#36229;&#26102;</span>
    <span style="color: #cc6666;">timer</span> := time.<span style="color: #81a2be;">NewTimer</span>(1 * time.Second)

    <span style="color: #b294bb;">select</span> {
    <span style="color: #b294bb;">case</span> &lt;-conn:
        <span style="color: #b294bb;">if</span> (timer.<span style="color: #81a2be;">Stop</span>()){
            fmt.<span style="color: #81a2be;">Println</span>(<span style="color: #b5bd68;">"timer.Stop()"</span>)
        }
        <span style="color: #b294bb;">return</span> <span style="color: #de935f;">true</span>
    <span style="color: #b294bb;">case</span> &lt;-timer.C: <span style="color: #5a5b5a;">// </span><span style="color: #5a5b5a;">timer &#36890;&#36947;&#36229;&#26102;</span>
        fmt.<span style="color: #81a2be;">Println</span>(<span style="color: #b5bd68;">"timer Channel timeout!"</span>)
        <span style="color: #b294bb;">return</span> <span style="color: #de935f;">false</span>
    }
}

<span style="color: #b294bb;">func</span> <span style="color: #81a2be;">main</span>() {

    <span style="color: #cc6666;">ch</span> := <span style="color: #81a2be;">make</span>(<span style="color: #b294bb;">chan</span> <span style="color: #f0c674;">int</span>, 1)
    <span style="color: #5a5b5a;">// </span><span style="color: #5a5b5a;">&#33509;&#25171;&#24320;&#22914;&#19979;&#35821;&#21477;&#65292;&#21017;&#21487;&#20197;&#27491;&#24120;&#20851;&#38381;&#23450;&#26102;&#22120;</span>
    <span style="color: #5a5b5a;">// </span><span style="color: #5a5b5a;">&#33509;&#27880;&#37322;&#22914;&#19979;&#35821;&#21477;&#65292;&#21017;&#20851;&#38381;&#23450;&#26102;&#22120;&#36229;&#26102;</span>
    <span style="color: #5a5b5a;">//</span><span style="color: #5a5b5a;">ch &lt;- 1</span>
    <span style="color: #b294bb;">go</span> <span style="color: #81a2be;">testChannelTimeout</span>(ch)

    <span style="color: #b294bb;">for</span> {}
}
</pre>
</div>

<p>
上述代码中，是否关闭定时器超时，跟另外一个辅助通道息息相关。若打开如下语句，则可以正常关闭定时器；若注释如下语句，则关闭定时器超时。<br>
</p>

<div class="org-src-container">
<pre class="src src-go">ch &lt;- 1
</pre>
</div>
</div>
</div>
<div id="outline-container-org140c38c" class="outline-3">
<h3 id="org140c38c">重置定时器</h3>
<div class="outline-text-3" id="text-org140c38c">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #b294bb;">func</span> <span style="color: #81a2be;">main</span>() {
    <span style="color: #5a5b5a;">// </span><span style="color: #5a5b5a;">&#21019;&#24314;&#19968;&#20010; Timer&#65292;&#23450;&#26102; 7s</span>
    fmt.<span style="color: #81a2be;">Println</span>(<span style="color: #b5bd68;">" &#24320;&#22987; "</span>, time.<span style="color: #81a2be;">Now</span>().<span style="color: #81a2be;">Unix</span>())
    <span style="color: #cc6666;">myT</span> := time.<span style="color: #81a2be;">NewTimer</span>(7 * time.Second)
    <span style="color: #5a5b5a;">// </span><span style="color: #5a5b5a;">&#37325;&#32622;&#23450;&#26102;&#22120;&#20026; 1s</span>
    myT.<span style="color: #81a2be;">Reset</span>(1 * time.Second)
    &lt;-myT.C
    fmt.<span style="color: #81a2be;">Println</span>(<span style="color: #b5bd68;">"1s &#26102;&#38388;&#21040; "</span>, time.<span style="color: #81a2be;">Now</span>().<span style="color: #81a2be;">Unix</span>())

    <span style="color: #b294bb;">for</span> {}
}
</pre>
</div>

<p>
运行上述代码后，效果如下：<br>
</p>

<pre class="example" id="org4da22ba">
开始  1624759572
1s 时间到  1624759573
</pre>

<p>
上述 Timer 都是触发一次，生效一次，这样并不能满足所有场景，例如周期性定时执行的场景就不满足了。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org19a4d68" class="outline-2">
<h2 id="org19a4d68">Ticker 是什么？</h2>
</div>
<div id="outline-container-org842e02e" class="outline-2">
<h2 id="org842e02e">Ticker 如何使用？</h2>
<div class="outline-text-2" id="text-org842e02e">
<p>
位置在： <code>src/time/tick.go:Timer</code><br>
</p>

<p>
<code>type Ticker struct</code> 和 <code>type Timer struct</code> 一模一样：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #5a5b5a;">// </span><span style="color: #5a5b5a;">A Ticker holds a channel that delivers ``ticks'' of a clock</span>
<span style="color: #5a5b5a;">// </span><span style="color: #5a5b5a;">at intervals.</span>
<span style="color: #b294bb;">type</span> <span style="color: #f0c674;">Ticker</span> <span style="color: #b294bb;">struct</span> {
    C &lt;-<span style="color: #b294bb;">chan</span> <span style="color: #f0c674;">Time</span> <span style="color: #5a5b5a;">// </span><span style="color: #5a5b5a;">The channel on which the ticks are delivered.</span>
    r <span style="color: #f0c674;">runtimeTimer</span>
}
</pre>
</div>

<p>
关于创建定时器和关闭定时器和上述的 Timer 方法类似<br>
</p>

<ul class="org-ul">
<li><p>
创建 Ticker 定时器（强调：这是一个周期性的定时器）<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #b294bb;">func</span> <span style="color: #81a2be;">NewTicker</span>(<span style="color: #cc6666;">d</span> <span style="color: #f0c674;">Duration</span>) *<span style="color: #f0c674;">Ticker</span>
</pre>
</div></li>

<li><p>
关闭 Ticker 定时器<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #b294bb;">func</span> (<span style="color: #cc6666;">t</span> *<span style="color: #f0c674;">Ticker</span>) <span style="color: #81a2be;">Stop</span>()
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-orgcdfff28" class="outline-3">
<h3 id="orgcdfff28">简单使用 Ticker</h3>
<div class="outline-text-3" id="text-orgcdfff28">
<p>
设置 2 秒的 周期性定时器 Ticker<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #cc6666;">ticker</span> := time.<span style="color: #81a2be;">NewTicker</span>(2 * time.Second)
<span style="color: #b294bb;">defer</span> ticker.<span style="color: #81a2be;">Stop</span>()

<span style="color: #5a5b5a;">// </span><span style="color: #5a5b5a;">&#33509;&#36890;&#36947;&#20026;&#31354;&#65292;&#21017;&#38459;&#22622;</span>
<span style="color: #5a5b5a;">// </span><span style="color: #5a5b5a;">&#33509;&#36890;&#36947;&#26377;&#25968;&#25454;&#65292;&#21017;&#35835;&#21462;</span>
<span style="color: #5a5b5a;">// </span><span style="color: #5a5b5a;">&#33509;&#36890;&#36947;&#20851;&#38381;&#65292;&#21017;&#36864;&#20986;</span>
<span style="color: #b294bb;">for</span> <span style="color: #b294bb;">range</span> ticker.C {
    fmt.<span style="color: #81a2be;">Println</span>(<span style="color: #b5bd68;">"ticker ticker ticker ..."</span>)
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org81cf511" class="outline-3">
<h3 id="org81cf511">通用版本的 demo</h3>
<div class="outline-text-3" id="text-org81cf511">
<p>
周期性的执行任务，我们可以灵活设置时间，和具体处理的任务。<br>
</p>

<ul class="org-ul">
<li>封装 Ticker 的调用<br></li>
</ul>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #5a5b5a;">// </span><span style="color: #5a5b5a;">&#23450;&#20041;&#20989;&#25968;&#31867;&#22411;</span>
<span style="color: #b294bb;">type</span> <span style="color: #f0c674;">Fn</span> <span style="color: #b294bb;">func</span>() <span style="color: #f0c674;">error</span>

<span style="color: #5a5b5a;">// </span><span style="color: #5a5b5a;">&#23450;&#26102;&#22120;&#20013;&#30340;&#25104;&#21592;</span>
<span style="color: #b294bb;">type</span> <span style="color: #f0c674;">MyTicker</span> <span style="color: #b294bb;">struct</span> {
    MyTick *<span style="color: #f0c674;">time.Ticker</span>
    Runner <span style="color: #f0c674;">Fn</span>
}

<span style="color: #b294bb;">func</span> <span style="color: #81a2be;">NewMyTick</span>(<span style="color: #cc6666;">interval</span> <span style="color: #f0c674;">int</span>, <span style="color: #cc6666;">f</span> <span style="color: #f0c674;">Fn</span>) *<span style="color: #f0c674;">MyTicker</span> {
    <span style="color: #b294bb;">return</span> &amp;<span style="color: #f0c674;">MyTicker</span>{
        <span style="color: #de935f;">MyTick</span>: time.<span style="color: #81a2be;">NewTicker</span>(time.<span style="color: #81a2be;">Duration</span>(interval) * time.Second),
        <span style="color: #de935f;">Runner</span>: f,
    }
}

<span style="color: #5a5b5a;">// </span><span style="color: #5a5b5a;">&#21551;&#21160;&#23450;&#26102;&#22120;&#38656;&#35201;&#25191;&#34892;&#30340;&#20219;&#21153;</span>
<span style="color: #b294bb;">func</span> (<span style="color: #cc6666;">t</span> *<span style="color: #f0c674;">MyTicker</span>) <span style="color: #81a2be;">Start</span>() {
    <span style="color: #b294bb;">for</span> {
        <span style="color: #b294bb;">select</span> {
        <span style="color: #b294bb;">case</span> &lt;-t.MyTick.C:
            t.<span style="color: #81a2be;">Runner</span>()
        }
    }
}

<span style="color: #b294bb;">func</span> <span style="color: #81a2be;">testPrint</span>(){
    fmt.<span style="color: #81a2be;">Println</span>(<span style="color: #b5bd68;">" &#28404;&#31572; 1 &#27425;"</span>)
}

<span style="color: #b294bb;">func</span> <span style="color: #81a2be;">main</span>() {
    <span style="color: #cc6666;">t</span> := <span style="color: #81a2be;">NewMyTick</span>( 1 ,testPrint)
    t.<span style="color: #81a2be;">Start</span>()
}
</pre>
</div>

<p>
执行上述代码，运行效果：<br>
</p>

<pre class="example" id="orgd3f76fe">
滴答 1 次
滴答 1 次
滴答 1 次
...
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-11-27 01:11 Sun</p>
<p class="author">Author: Haoran Liu</p>
<p class="date">Created: 2023-01-12</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
