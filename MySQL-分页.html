<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-03-25 Fri 21:11 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>MYSQL-分页</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">MYSQL-分页</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org395b08a">分页</a>
<ul>
<li><a href="#org9a34ce1">性能优化</a>
<ul>
<li><a href="#org11344a6">执行器自动优化</a></li>
<li><a href="#org3483560">主动优化执行计划</a>
<ul>
<li><a href="#org81c1199">加排序索引</a></li>
<li><a href="#org42fb419">偏移量较大时，使用索引</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org395b08a" class="outline-2">
<h2 id="org395b08a">分页</h2>
<div class="outline-text-2" id="text-org395b08a">
<blockquote>
<p>
分页常适用于性能优化，如以下场景：<br>
</p>
<ul class="org-ul">
<li>业务只需要获取部分数据，如top 10，此时查询所有数据到客户端，浪费数据库磁盘IO/网络IO、应用内存<br></li>
<li>数据量太大，传输时间可能过长甚至中断、查询到客户端内存开销巨大，每次只查询较小数量的行，分多次查询<br></li>
</ul>
</blockquote>

<p>
MySQL 中使用 <code>limit</code> 实现分页查询。<br>
</p>

<pre class="example">
select * from table limit {[offset,] row_count | row_count OFFSET offset}
</pre>

<p>
limit 可接受 1 或 2 个参数，参数必须是非负数。<br>
</p>

<p>
注意！第一行的偏移量为 0，而不是 1。<br>
</p>

<dl class="org-dl">
<dt><code>limit offset, row_count</code></dt><dd>从指定偏移位置开始返回，一共返回 row_count 行，例如： <code>select * from tbl limit 5, 10</code> ，表示从第 6 行还是返回，一共返回 10 行。<br></dd>

<dt><code>LIMIT row_count OFFSET offset</code></dt><dd><code>limit 10 offset 5</code> 等价于 <code>limit 5, 10</code> 。<br></dd>

<dt><code>select Sno, Grade from SC where Cno='3' order by Grade desc limit 50, 10;</code></dt><dd>查询选修了 3 号课程的学生的学号及其成绩，分页查询，当前是第 51 页，当前页有 10 人，查询结果按分数的降序排序。<br></dd>
</dl>
</div>
<div id="outline-container-org9a34ce1" class="outline-3">
<h3 id="org9a34ce1">性能优化</h3>
<div class="outline-text-3" id="text-org9a34ce1">
</div>
<div id="outline-container-org11344a6" class="outline-4">
<h4 id="org11344a6">执行器自动优化</h4>
<div class="outline-text-4" id="text-org11344a6">
<p>
MySQL执行器会自动优化含LIMIT的语句，包括但不限于如下情况：<br>
</p>

<ul class="org-ul">
<li>limit较少行时，可能会直接进行全表扫描、而不走索引<br></li>
<li><p>
limit和order by、group by、distinct同时使用时，排序/聚合后的行数，一旦达到limit的row_count，排序/聚合就会停止。<br>
</p>

<pre class="example">
因为这个特性，如果多个行的排序列值相同，那么使用LIMIT时其返回的顺序可能不同。
</pre></li>

<li>limit 0会快速返回一个空结果集<br></li>
<li>MySQL一旦向客户端发送了所需的行数，它将立即终止查询<br></li>
</ul>
</div>
</div>
<div id="outline-container-org3483560" class="outline-4">
<h4 id="org3483560">主动优化执行计划</h4>
<div class="outline-text-4" id="text-org3483560">
</div>
<div id="outline-container-org81c1199" class="outline-5">
<h5 id="org81c1199">加排序索引</h5>
<div class="outline-text-5" id="text-org81c1199">
<p>
limit 和 order by 同时使用的概率非常高。如果排序列有索引，结合limit找到所需行数会立刻返回的特性，查询效率非常高<br>
</p>

<p>
例：<br>
</p>

<div class="org-src-container">
<pre class="src src-sql"><span style="color: #268bd2; font-weight: bold;">SELECT</span> * <span style="color: #268bd2; font-weight: bold;">FROM</span> tbl <span style="color: #268bd2; font-weight: bold;">WHERE</span> rid = 123 <span style="color: #268bd2; font-weight: bold;">ORDER</span> <span style="color: #268bd2; font-weight: bold;">BY</span> id <span style="color: #268bd2; font-weight: bold;">LIMIT</span> 50, 10
</pre>
</div>

<p>
建议增加rid、id的联合索引（rid在前，这样索引会先匹配rid、然后再按id的顺序获取数据）。<br>
</p>
</div>
</div>
<div id="outline-container-org42fb419" class="outline-5">
<h5 id="org42fb419">偏移量较大时，使用索引</h5>
<div class="outline-text-5" id="text-org42fb419">
<p>
偏移量较大时，MySQL需要扫描过偏移量之前的所有行，然后再读取所需行返回，磁盘IO(随机IO)很多。因此分页查询越往后越慢。<br>
</p>

<p>
如：<br>
</p>

<div class="org-src-container">
<pre class="src src-sql"><span style="color: #268bd2; font-weight: bold;">SELECT</span> * <span style="color: #268bd2; font-weight: bold;">FROM</span> tbl <span style="color: #268bd2; font-weight: bold;">WHERE</span> rid = 123 <span style="color: #268bd2; font-weight: bold;">ORDER</span> <span style="color: #268bd2; font-weight: bold;">BY</span> id <span style="color: #268bd2; font-weight: bold;">LIMIT</span> 100000, 10
</pre>
</div>

<p>
实际上只需要10行数据，但是要在磁盘中遍历100000行后，才真正开始获取数据。<br>
</p>

<p>
该情况可通过子查询优化：<br>
</p>

<div class="org-src-container">
<pre class="src src-sql"><span style="color: #268bd2; font-weight: bold;">SELECT</span> * <span style="color: #268bd2; font-weight: bold;">FROM</span> 
  (<span style="color: #268bd2; font-weight: bold;">SELECT</span> id <span style="color: #268bd2; font-weight: bold;">FROM</span> tbl <span style="color: #268bd2; font-weight: bold;">WHERE</span> rid = 123 <span style="color: #268bd2; font-weight: bold;">ORDER</span> <span style="color: #268bd2; font-weight: bold;">BY</span> id <span style="color: #268bd2; font-weight: bold;">LIMIT</span> 100000, 10) temp 
  <span style="color: #268bd2; font-weight: bold;">LEFT</span> <span style="color: #268bd2; font-weight: bold;">JOIN</span> tbl t <span style="color: #268bd2; font-weight: bold;">ON</span> temp.id = t.id
</pre>
</div>

<p>
通过子查询，可以直接在索引中获取到匹配行的主键。MySQL的索引是B+树，本身有序、并且节点中存放了主键，所以检索效率非常高。<br>
</p>

<p>
这是索引覆盖的一个特例。当explain时extra中出现using index时，即表示实现了索引覆盖。<br>
</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-03-14 19:03 Mon</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-03-25 Fri 21:11</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
