<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-07-01 Fri 10:01 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Go 并发编程 - atomic</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">Go 并发编程 - atomic</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org8b76ab6">原子操作的基础知识</a></li>
<li><a href="#org7700427">atomic 原子操作的应用场景</a></li>
<li><a href="#orgfee429b">atomic 提供的方法</a>
<ul>
<li><a href="#org6128a11">Add</a></li>
<li><a href="#org4fae130">CAS（CompareAndSwap）</a></li>
<li><a href="#org73f6cbd">Load</a></li>
<li><a href="#org656b7db">Store</a></li>
<li><a href="#org1da545c">Value 类型</a></li>
</ul>
</li>
<li><a href="#org33dc91d">第三方库的扩展</a></li>
<li><a href="#org86f201c">使用 atomic 实现 Lock-Free queue</a></li>
<li><a href="#org88b27a2">总结</a></li>
</ul>
</div>
</div>

<div id="outline-container-org8b76ab6" class="outline-2">
<h2 id="org8b76ab6">原子操作的基础知识</h2>
<div class="outline-text-2" id="text-org8b76ab6">
<p>
Package sync/atomic 实现了同步算法底层的原子的内存操作原语，我们把它叫做原子操作原语，它提供了一些实现原子操作的方法。<br>
</p>

<p>
之所以叫原子操作，是因为一个原子在执行的时候，其它线程不会看到执行一半的操作结果。在其它线程看来，原子操作要么执行完了，要么还没有执行，就像一个最小的粒子 - 原子一样，不可分割。<br>
</p>

<p>
CPU 提供了基础的原子操作，不过，不同架构的系统的原子操作是不一样的。<br>
</p>

<p>
对于单处理器单核系统来说，如果一个操作是由一个 CPU 指令来实现的，那么它就是原子操作，比如它的 XCHG 和 INC 等指令。如果操作是基于多条指令来实现的，那么，执行的过程中可能会被中断，并执行上下文切换，这样的话，原子性的保证就被打破了，因为这个时候，操作可能只执行了一半。<br>
</p>

<p>
在多处理器多核系统中，原子操作的实现就比较复杂了。<br>
</p>

<p>
由于 cache 的存在，单个核上的单个指令进行原子操作的时候，你要确保其它处理器或者核不访问此原子操作的地址，或者是确保其它处理器或者核总是访问原子操作之后的最新的值。x86 架构中提供了指令前缀 LOCK，LOCK 保证了指令（比如 LOCK CMPXCHG op1、op2）不会受其它处理器或 CPU 核的影响，有些指令（比如 XCHG）本身就提供 Lock 的机制。不同的 CPU 架构提供的原子操作指令的方式也是不同的，比如对于多核的 MIPS 和 ARM，提供了 LL/SC（Load Link/Store Conditional）指令，可以帮助实现原子操作（ARMLL/SC 指令 LDREX 和 STREX）。<br>
</p>

<p>
因为不同的 CPU 架构甚至不同的版本提供的原子操作的指令是不同的，所以，要用一种编程语言实现支持不同架构的原子操作是相当有难度的。不过，还好这些都不需要你操心，因为 Go 提供了一个通用的原子操作的 API，将更底层的不同的架构下的实现封装成 atomic 包，提供了修改类型的原子操作（<a href="https://preshing.com/20150402/you-can-do-any-kind-of-atomic-read-modify-write-operation/">atomic read-modify-write</a>，RMW）和加载存储类型的原子操作（<a href="https://preshing.com/20130618/atomic-vs-non-atomic-operations/">Load 和 Store</a>）的 API，稍后我会一一介绍。<br>
</p>

<p>
有的代码也会因为架构的不同而不同。有时看起来貌似一个操作是原子操作，但实际上，对于不同的架构来说，情况是不一样的。比如下面的代码的第 4 行，是将一个 64 位的值赋值给变量 i：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">const</span> <span style="color: #d75fd7;">x</span> <span style="color: #df005f; font-weight: bold;">int64</span> = 1 + 1&lt;&lt;33

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">i</span> = x
    _ = i
}
</pre>
</div>

<p>
如果你使用 GOARCH=386 的架构去编译这段代码，那么，第 5 行其实是被拆成了两个指令，分别操作低 32 位和高 32 位（使用 GOARCH=386 go tool compile -N -l test.go；GOARCH=386 go tool objdump -gnu test.o 反编译试试）：<br>
</p>

<div class="div-center">
	<img src="./images/Go-并发编程-atomic01.webp" />
</div>

<p>
如果 GOARCH=amd64 的架构去编译这段代码，那么，第 5 行其中的赋值操作其实是一条指令：<br>
</p>

<div class="div-center">
	<img src="./images/Go-并发编程-atomic02.webp" />
</div>

<p>
所以，如果要想保证原子操作，切记一定要使用 atomic 提供的方法。<br>
</p>

<p>
好了，了解了什么是原子操作以及不同系统的不同原子操作，接下来介绍下 atomic 原子操作的应用场景。<br>
</p>
</div>
</div>
<div id="outline-container-org7700427" class="outline-2">
<h2 id="org7700427">atomic 原子操作的应用场景</h2>
<div class="outline-text-2" id="text-org7700427">
<p>
开篇我说过，使用 atomic 的一些方法，我们可以实现更底层的一些优化。如果使用 Mutex 等并发原语进行这些优化，虽然可以解决问题，但是这些并发原语的实现逻辑比较复杂，对性能还是有一定的影响的。<br>
</p>

<p>
举个例子：假设你想在程序中使用一个标志（flag，比如一个 bool 类型的变量），来标识一个定时任务是否已经启动执行了，你会怎么做呢？<br>
</p>

<p>
我们先来看看加锁的方法。如果使用 Mutex 和 RWMutex，在读取和设置这个标志的时候加锁，是可以做到互斥的、保证同一时刻只有一个定时任务在执行的，所以使用 Mutex 或者 RWMutex 是一种解决方案。<br>
</p>

<p>
其实，这个场景中的问题不涉及到对资源复杂的竞争逻辑，只是会并发地读写这个标志，这类场景就适合使用 atomic 的原子操作。具体怎么做呢？你可以使用一个 uint32 类型的变量，如果这个变量的值是 0，就标识没有任务在执行，如果它的值是 1，就标识已经有任务在完成了。你看，是不是很简单呢？<br>
</p>

<p>
再来看一个例子。假设你在开发应用程序的时候，需要从配置服务器中读取一个节点的配置信息。而且，在这个节点的配置发生变更的时候，你需要重新从配置服务器中拉取一份新的配置并更新。你的程序中可能有多个 goroutine 都依赖这份配置，涉及到对这个配置对象的并发读写，你可以使用读写锁实现对配置对象的保护。在大部分情况下，你也可以利用 atomic 实现配置对象的更新和加载。<br>
</p>

<p>
分析到这里，可以看到，这两个例子都可以使用基本并发原语来实现的，只不过，我们不需要这些基本并发原语里面的复杂逻辑，而是只需要其中的简单原子操作，所以，这些场景可以直接使用 atomic 包中的方法去实现。<br>
</p>

<p>
<b>有时候，你也可以使用 atomic 实现自己定义的基本并发原语</b> ，比如 Go issue 有人提议的 CondMutex、Mutex.LockContext、WaitGroup.Go 等，我们可以使用 atomic 或者基于它的更高一级的并发原语去实现。我先前讲的几种基本并发原语的底层（比如 Mutex），就是基于通过 atomic 的方法实现的。<br>
</p>

<p>
除此之外，atomic 原子操作还是实现 lock-free 数据结构的基石。<br>
</p>

<p>
在实现 lock-free 的数据结构时，我们可以不使用互斥锁，这样就不会让线程因为等待互斥锁而阻塞休眠，而是让线程保持继续处理的状态。另外，不使用互斥锁的话，lock-free 的数据结构还可以提供并发的性能。<br>
</p>

<p>
不过，lock-free 的数据结构实现起来比较复杂，需要考虑的东西很多，有兴趣的同学可以看一位微软专家写的一篇经验分享：Lockless Programming Considerations for Xbox 360 and Microsoft Windows，这里我们不细谈了。不过，这节课的最后我会带你开发一个 lock-free 的 queue，来学习下使用 atomic 操作实现 lock-free 数据结构的方法，你可以拿它和使用互斥锁实现的 queue 做性能对比，看看在性能上是否有所提升。<br>
</p>

<p>
看到这里，你是不是觉得 atomic 非常重要呢？不过，要想能够灵活地应用 atomic，我们首先得知道 atomic 提供的所有方法。<br>
</p>
</div>
</div>
<div id="outline-container-orgfee429b" class="outline-2">
<h2 id="orgfee429b">atomic 提供的方法</h2>
<div class="outline-text-2" id="text-orgfee429b">
<p>
atomic 为了支持 int32、int64、uint32、uint64、uintptr、Pointer（Add 方法不支持）类型，分别提供了 AddXXX、CompareAndSwapXXX、SwapXXX、LoadXXX、StoreXXX 等方法。不过，你也不要担心，你只要记住了一种数据类型的方法的意义，其它数据类型的方法也是一样的。<br>
</p>

<p>
关于 atomic，还有一个地方你一定要记住，atomic 操作的对象是一个地址， <b>你需要把可寻址的变量的地址作为参数传递给方法，而不是把变量的值传递给方法</b> 。<br>
</p>
</div>
<div id="outline-container-org6128a11" class="outline-3">
<h3 id="org6128a11">Add</h3>
<div class="outline-text-3" id="text-org6128a11">
<p>
首先，我们来看 Add 方法的签名：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">AddInt32</span>(<span style="color: #8787d7;">addr</span> *<span style="color: #df005f; font-weight: bold;">int32</span>, <span style="color: #8787d7;">delta</span> <span style="color: #df005f; font-weight: bold;">int32</span>) (<span style="color: #8787d7;">new</span> <span style="color: #df005f; font-weight: bold;">int32</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">AddInt64</span>(<span style="color: #8787d7;">addr</span> *<span style="color: #df005f; font-weight: bold;">int64</span>, <span style="color: #8787d7;">delta</span> <span style="color: #df005f; font-weight: bold;">int64</span>) (<span style="color: #8787d7;">new</span> <span style="color: #df005f; font-weight: bold;">int64</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">AddUint32</span>(<span style="color: #8787d7;">addr</span> *<span style="color: #df005f; font-weight: bold;">uint32</span>, <span style="color: #8787d7;">delta</span> <span style="color: #df005f; font-weight: bold;">uint32</span>) (<span style="color: #8787d7;">new</span> <span style="color: #df005f; font-weight: bold;">uint32</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">Adduint64</span>(<span style="color: #8787d7;">addr</span> *<span style="color: #df005f; font-weight: bold;">uint64</span>, <span style="color: #8787d7;">delta</span> <span style="color: #df005f; font-weight: bold;">uint64</span>) (<span style="color: #8787d7;">new</span> <span style="color: #df005f; font-weight: bold;">uint64</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">AddUintptr</span>(<span style="color: #8787d7;">addr</span> *<span style="color: #df005f; font-weight: bold;">uintptr</span>, <span style="color: #8787d7;">delta</span> <span style="color: #df005f; font-weight: bold;">uintptr</span>) (<span style="color: #8787d7;">new</span> <span style="color: #df005f; font-weight: bold;">uintptr</span>)
</pre>
</div>

<p>
其实，Add 方法就是给第一个参数地址中的值增加一个 delta 值。<br>
</p>

<p>
对于有符号的整数来说，delta 可以是一个负数，相当于减去一个值。对于无符号的整数和 uinptr 类型来说，怎么实现减去一个值呢？毕竟，atomic 并没有提供单独的减法操作。<br>
</p>

<p>
这个时候，你可以利用计算机补码的规则，把减法变成加法。以 uint32 类型为例：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #d75fd7; font-weight: bold;">AddUint32</span>(&amp;x, ^<span style="color: #d75fd7; font-weight: bold;">uint32</span>(c-1)).
</pre>
</div>

<p>
如果是对 uint64 的值进行操作，那么，就把上面的代码中的 uint32 替换成 uint64。<br>
</p>

<p>
尤其是减 1 这种特殊的操作，我们可以简化为：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #d75fd7; font-weight: bold;">AddUint32</span>(&amp;x, ^<span style="color: #d75fd7; font-weight: bold;">uint32</span>(0))
</pre>
</div>
</div>
</div>
<div id="outline-container-org4fae130" class="outline-3">
<h3 id="org4fae130">CAS（CompareAndSwap）</h3>
<div class="outline-text-3" id="text-org4fae130">
<p>
以 int32 为例，我们学习一下 CAS 提供的功能。在 CAS 的方法签名中，需要提供要操作的地址、原数据值、新值，如下所示：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">CompareAndSwapInt32</span>(<span style="color: #8787d7;">addr</span> *<span style="color: #df005f; font-weight: bold;">int32</span>, <span style="color: #8787d7;">old</span>, <span style="color: #8787d7;">new</span> <span style="color: #df005f; font-weight: bold;">int32</span>) (<span style="color: #8787d7;">swapped</span> <span style="color: #df005f; font-weight: bold;">bool</span>)
</pre>
</div>

<p>
这个方法会比较当前 addr 地址里的值是不是 old，如果不等于 old，就返回 false；如果等于 old，就把此地址的值替换成 new 值，返回 true。这就相当于“判断相等才替换”。<br>
</p>

<p>
如果使用伪代码来表示这个原子操作，代码如下：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">if</span> *addr == old {
    *addr = new
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">true</span>
}
<span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">false</span>
</pre>
</div>

<p>
它支持的类型和方法如图所示：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">CompareAndswapInt32</span>(<span style="color: #8787d7;">addr</span> *<span style="color: #df005f; font-weight: bold;">int32</span>, <span style="color: #8787d7;">old</span>, <span style="color: #8787d7;">new</span> <span style="color: #df005f; font-weight: bold;">int32</span>) (<span style="color: #8787d7;">swapped</span> <span style="color: #df005f; font-weight: bold;">bool</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">CompareAndswapInt64</span>(<span style="color: #8787d7;">addr</span> *<span style="color: #df005f; font-weight: bold;">int64</span>, <span style="color: #8787d7;">old</span>, <span style="color: #8787d7;">new</span> <span style="color: #df005f; font-weight: bold;">int64</span>)(swapped <span style="color: #df005f; font-weight: bold;">bool</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">compareAndswapPointer</span>(<span style="color: #8787d7;">addr</span> *<span style="color: #df005f; font-weight: bold;">unsafe.Pointer</span>, <span style="color: #8787d7;">old</span>, <span style="color: #8787d7;">new</span> <span style="color: #df005f; font-weight: bold;">unsafe.Pointer</span>) (<span style="color: #8787d7;">swapped</span> <span style="color: #df005f; font-weight: bold;">bool</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">CompareAndswapUint32</span>(<span style="color: #8787d7;">addr</span> *<span style="color: #df005f; font-weight: bold;">uint32</span>, <span style="color: #8787d7;">old</span>, <span style="color: #8787d7;">new</span> <span style="color: #df005f; font-weight: bold;">uint32</span>) (<span style="color: #8787d7;">swapped</span> <span style="color: #df005f; font-weight: bold;">bool</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">CompareAndSwapuint64</span>(<span style="color: #8787d7;">addr</span> *<span style="color: #df005f; font-weight: bold;">uint64</span>, <span style="color: #8787d7;">old</span>, <span style="color: #8787d7;">new</span> <span style="color: #df005f; font-weight: bold;">uint64</span>) (<span style="color: #8787d7;">swapped</span> <span style="color: #df005f; font-weight: bold;">bool</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">compareAndswapuintptr</span>(<span style="color: #8787d7;">addr</span> *<span style="color: #df005f; font-weight: bold;">uintptr</span>, <span style="color: #8787d7;">old</span>, <span style="color: #8787d7;">new</span> <span style="color: #df005f; font-weight: bold;">uintptr</span>) (<span style="color: #8787d7;">swapped</span> <span style="color: #df005f; font-weight: bold;">bool</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-org73f6cbd" class="outline-3">
<h3 id="org73f6cbd">Load</h3>
<div class="outline-text-3" id="text-org73f6cbd">
<p>
Load 方法会取出 addr 地址中的值，即使在多处理器、多核、有 CPU cache 的情况下，这个操作也能保证 Load 是一个原子操作。<br>
</p>

<p>
它支持的数据类型和方法如图所示：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">LoadInt32</span>(<span style="color: #8787d7;">addr</span> *<span style="color: #df005f; font-weight: bold;">int32</span>) (<span style="color: #8787d7;">val</span> <span style="color: #df005f; font-weight: bold;">int32</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">LoadInt64</span>(<span style="color: #8787d7;">addr</span> *<span style="color: #df005f; font-weight: bold;">int64</span>) (<span style="color: #8787d7;">val</span> <span style="color: #df005f; font-weight: bold;">int64</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">LoadPointer</span>(<span style="color: #8787d7;">addr</span> *<span style="color: #df005f; font-weight: bold;">unsafe.Pointer</span>) (<span style="color: #8787d7;">val</span> <span style="color: #df005f; font-weight: bold;">unsafe.Pointer</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">LoadUint32</span>(<span style="color: #8787d7;">addr</span> *<span style="color: #df005f; font-weight: bold;">uint32</span>) (<span style="color: #8787d7;">val</span> <span style="color: #df005f; font-weight: bold;">uint32</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">LoadUint64</span>(<span style="color: #8787d7;">addr</span> *<span style="color: #df005f; font-weight: bold;">uint64</span>) (<span style="color: #8787d7;">val</span> <span style="color: #df005f; font-weight: bold;">uint64</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">LoadUintptr</span>(<span style="color: #8787d7;">addr</span> *<span style="color: #df005f; font-weight: bold;">uintptr</span>) (<span style="color: #8787d7;">val</span> <span style="color: #df005f; font-weight: bold;">uintptr</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-org656b7db" class="outline-3">
<h3 id="org656b7db">Store</h3>
<div class="outline-text-3" id="text-org656b7db">
<p>
Store 方法会把一个值存入到指定的 addr 地址中，即使在多处理器、多核、有 CPU cache 的情况下，这个操作也能保证 Store 是一个原子操作。别的 goroutine 通过 Load 读取出来，不会看到存取了一半的值。<br>
</p>

<p>
它支持的数据类型和方法如图所示：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">Storelnt32</span>(<span style="color: #8787d7;">addr</span> *<span style="color: #df005f; font-weight: bold;">int32</span>, <span style="color: #8787d7;">val</span> <span style="color: #df005f; font-weight: bold;">int32</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">storelnt64</span>(<span style="color: #8787d7;">addr</span> *<span style="color: #df005f; font-weight: bold;">int64</span>, <span style="color: #8787d7;">val</span> <span style="color: #df005f; font-weight: bold;">int64</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">StorePointer</span>(<span style="color: #8787d7;">addr</span> *<span style="color: #df005f; font-weight: bold;">unsafe.Pointer</span>, <span style="color: #8787d7;">val</span> <span style="color: #df005f; font-weight: bold;">unsafe.Pointer</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">StoreUint32</span>(<span style="color: #8787d7;">addr</span> *<span style="color: #df005f; font-weight: bold;">uint32</span>, <span style="color: #8787d7;">val</span> <span style="color: #df005f; font-weight: bold;">uint32</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">StoreUint64</span>(<span style="color: #8787d7;">addr</span> *<span style="color: #df005f; font-weight: bold;">uint64</span>, <span style="color: #8787d7;">val</span> <span style="color: #df005f; font-weight: bold;">uint64</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">storeuintptr</span>(<span style="color: #8787d7;">addr</span> *<span style="color: #df005f; font-weight: bold;">uintptr</span>, <span style="color: #8787d7;">val</span> <span style="color: #df005f; font-weight: bold;">uintptr</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-org1da545c" class="outline-3">
<h3 id="org1da545c">Value 类型</h3>
<div class="outline-text-3" id="text-org1da545c">
<p>
刚刚说的都是一些比较常见的类型，其实，atomic 还提供了一个特殊的类型：Value。它可以原子地存取对象类型，但也只能存取，不能 CAS 和 Swap，常常用在配置变更等场景中。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Value</span>
     <span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">v</span> *<span style="color: #df005f; font-weight: bold;">Value</span>) <span style="color: #d75fd7; font-weight: bold;">Load</span>() (<span style="color: #8787d7;">x</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{})
     <span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">v</span> *<span style="color: #df005f; font-weight: bold;">Value</span>) <span style="color: #d75fd7; font-weight: bold;">store</span>(<span style="color: #8787d7;">x</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{})
</pre>
</div>

<p>
接下来，我以一个配置变更的例子，来演示 Value 类型的使用。这里定义了一个 Value 类型的变量 config， 用来存储配置信息。<br>
</p>

<p>
首先，我们启动一个 goroutine，然后让它随机 sleep 一段时间，之后就变更一下配置，并通过我们前面学到的 Cond 并发原语，通知其它的 reader 去加载新的配置。<br>
</p>

<p>
接下来，我们启动一个 goroutine 等待配置变更的信号，一旦有变更，它就会加载最新的配置<br>
</p>

<p>
通过这个例子，你可以了解到 Value 的 Store/Load 方法的使用，因为它只有这两个方法，只要掌握了它们的使用，你就完全掌握了 Value 类型。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Config</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    NodeName <span style="color: #df005f; font-weight: bold;">string</span>
    Addr     <span style="color: #df005f; font-weight: bold;">string</span>
    Count    <span style="color: #df005f; font-weight: bold;">int32</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">loadNewConfig</span>() <span style="color: #df005f; font-weight: bold;">Config</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #df005f; font-weight: bold;">Config</span>{
        <span style="color: #d75fd7;">NodeName</span>: <span style="color: #2aa198;">"&#21271;&#20140;"</span>,
        <span style="color: #d75fd7;">Addr</span>:     <span style="color: #2aa198;">"10.77.95.27"</span>,
        <span style="color: #d75fd7;">Count</span>:    rand.<span style="color: #d75fd7; font-weight: bold;">Int31</span>(),
    }
}
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">config</span> <span style="color: #df005f; font-weight: bold;">atomic.Value</span>
    config.<span style="color: #d75fd7; font-weight: bold;">Store</span>(<span style="color: #d75fd7; font-weight: bold;">loadNewConfig</span>())
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">cond</span> = sync.<span style="color: #d75fd7; font-weight: bold;">NewCond</span>(&amp;<span style="color: #df005f; font-weight: bold;">sync.Mutex</span>{})

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35774;&#32622;&#26032;&#30340;config</span>
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
        <span style="color: #268bd2; font-weight: bold;">for</span> {
            time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(time.<span style="color: #d75fd7; font-weight: bold;">Duration</span>(5+rand.<span style="color: #d75fd7; font-weight: bold;">Int63n</span>(5)) * time.Second)
            config.<span style="color: #d75fd7; font-weight: bold;">Store</span>(<span style="color: #d75fd7; font-weight: bold;">loadNewConfig</span>())
            cond.<span style="color: #d75fd7; font-weight: bold;">Broadcast</span>() <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36890;&#30693;&#31561;&#24453;&#30528;&#37197;&#32622;&#24050;&#21464;&#26356;</span>
        }
    }()

    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
        <span style="color: #268bd2; font-weight: bold;">for</span> {
            cond.L.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
            cond.<span style="color: #d75fd7; font-weight: bold;">Wait</span>()                 <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#31561;&#24453;&#21464;&#26356;&#20449;&#21495;</span>
            <span style="color: #8787d7;">c</span> := config.<span style="color: #d75fd7; font-weight: bold;">Load</span>().(<span style="color: #df005f; font-weight: bold;">Config</span>) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35835;&#21462;&#26032;&#30340;&#37197;&#32622;</span>
            fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"new config: %+v\n"</span>, c)
            cond.L.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
        }
    }()

    <span style="color: #268bd2; font-weight: bold;">select</span> {}
}
</pre>
</div>

<p>
好了，关于标准库的 atomic 提供的方法，到这里我们就学完了。事实上，atomic 包提供了非常好的支持各种平台的一致性的 API，绝大部分项目都是直接使用它。接下来，我再给你介绍一下第三方库，帮助你稍微开拓一下思维。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org33dc91d" class="outline-2">
<h2 id="org33dc91d">第三方库的扩展</h2>
<div class="outline-text-2" id="text-org33dc91d">
<p>
其实，atomic 的 API 已经算是很简单的了，它提供了包一级的函数，可以对几种类型的数据执行原子操作。<br>
</p>

<p>
不过有一点让人觉得不爽的是，或者是让熟悉面向对象编程的程序员不爽的是，函数调用有一点点麻烦。所以，有些人就对这些函数做了进一步的包装，跟 atomic 中的 Value 类型类似，这些类型也提供了面向对象的使用方式，比如关注度比较高的 <a href="https://github.com/uber-go/atomic">uber-go/atomic</a>，它定义和封装了几种与常见类型相对应的原子操作类型，这些类型提供了原子操作的方法。这些类型包括 Bool、Duration、Error、Float64、Int32、Int64、String、Uint32、Uint64 等。<br>
</p>

<p>
比如 Bool 类型，提供了 CAS、Store、Swap、Toggle 等原子方法，还提供 String、MarshalJSON、UnmarshalJSON 等辅助方法，确实是一个精心设计的 atomic 扩展库。关于这些方法，你一看名字就能猜出来它们的功能，我就不多说了。<br>
</p>

<p>
其它的数据类型也和 Bool 类型相似，使用起来就像面向对象的编程一样，你可以看下下面的这段代码。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">running</span> <span style="color: #df005f; font-weight: bold;">atomic.Bool</span>
running.<span style="color: #d75fd7; font-weight: bold;">Store</span>(<span style="color: #d75fd7;">true</span>)
running.<span style="color: #d75fd7; font-weight: bold;">Toggle</span>()
fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(running.<span style="color: #d75fd7; font-weight: bold;">Load</span>()) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">false</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org86f201c" class="outline-2">
<h2 id="org86f201c">使用 atomic 实现 Lock-Free queue</h2>
<div class="outline-text-2" id="text-org86f201c">
<p>
atomic 常常用来实现 Lock-Free 的数据结构，这次我会给你展示一个 Lock-Free queue 的实现。<br>
</p>

<p>
Lock-Free queue 最出名的就是 Maged M. Michael 和 Michael L. Scott 1996 年发表的 <a href="https://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf">论文</a> 中的算法，算法比较简单，容易实现，伪代码的每一行都提供了注释，我就不在这里贴出伪代码了，因为我们使用 Go 实现这个数据结构的代码几乎和伪代码一样：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> queue
<span style="color: #268bd2; font-weight: bold;">import</span> (
    <span style="color: #2aa198;">"sync/atomic"</span>
    <span style="color: #2aa198;">"unsafe"</span>
)
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">lock-free&#30340;queue</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">LKQueue</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    head <span style="color: #df005f; font-weight: bold;">unsafe.Pointer</span>
    tail <span style="color: #df005f; font-weight: bold;">unsafe.Pointer</span>
}
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36890;&#36807;&#38142;&#34920;&#23454;&#29616;&#65292;&#36825;&#20010;&#25968;&#25454;&#32467;&#26500;&#20195;&#34920;&#38142;&#34920;&#20013;&#30340;&#33410;&#28857;</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">node</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    value <span style="color: #268bd2; font-weight: bold;">interface</span>{}
    next  <span style="color: #df005f; font-weight: bold;">unsafe.Pointer</span>
}
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">NewLKQueue</span>() *<span style="color: #df005f; font-weight: bold;">LKQueue</span> {
    <span style="color: #8787d7;">n</span> := unsafe.<span style="color: #d75fd7; font-weight: bold;">Pointer</span>(&amp;<span style="color: #df005f; font-weight: bold;">node</span>{})
    <span style="color: #268bd2; font-weight: bold;">return</span> &amp;<span style="color: #df005f; font-weight: bold;">LKQueue</span>{<span style="color: #d75fd7;">head</span>: n, <span style="color: #d75fd7;">tail</span>: n}
}
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20837;&#38431;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">q</span> *<span style="color: #df005f; font-weight: bold;">LKQueue</span>) <span style="color: #d75fd7; font-weight: bold;">Enqueue</span>(<span style="color: #8787d7;">v</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{}) {
    <span style="color: #8787d7;">n</span> := &amp;<span style="color: #df005f; font-weight: bold;">node</span>{<span style="color: #d75fd7;">value</span>: v}
    <span style="color: #268bd2; font-weight: bold;">for</span> {
        <span style="color: #8787d7;">tail</span> := <span style="color: #d75fd7; font-weight: bold;">load</span>(&amp;q.tail)
        <span style="color: #8787d7;">next</span> := <span style="color: #d75fd7; font-weight: bold;">load</span>(&amp;tail.next)
        <span style="color: #268bd2; font-weight: bold;">if</span> tail == <span style="color: #d75fd7; font-weight: bold;">load</span>(&amp;q.tail) { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#23614;&#36824;&#26159;&#23614;</span>
            <span style="color: #268bd2; font-weight: bold;">if</span> next == <span style="color: #d75fd7;">nil</span> { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36824;&#27809;&#26377;&#26032;&#25968;&#25454;&#20837;&#38431;</span>
                <span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #d75fd7; font-weight: bold;">cas</span>(&amp;tail.next, next, n) { <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#22686;&#21152;&#21040;&#38431;&#23614;</span>
                    <span style="color: #d75fd7; font-weight: bold;">cas</span>(&amp;q.tail, tail, n) <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#20837;&#38431;&#25104;&#21151;&#65292;&#31227;&#21160;&#23614;&#24052;&#25351;&#38024;</span>
                    <span style="color: #268bd2; font-weight: bold;">return</span>
                }
            } <span style="color: #268bd2; font-weight: bold;">else</span> { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#24050;&#26377;&#26032;&#25968;&#25454;&#21152;&#21040;&#38431;&#21015;&#21518;&#38754;&#65292;&#38656;&#35201;&#31227;&#21160;&#23614;&#25351;&#38024;</span>
                <span style="color: #d75fd7; font-weight: bold;">cas</span>(&amp;q.tail, tail, next)
            }
        }
    }
}
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20986;&#38431;&#65292;&#27809;&#26377;&#20803;&#32032;&#21017;&#36820;&#22238;nil</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">q</span> *<span style="color: #df005f; font-weight: bold;">LKQueue</span>) <span style="color: #d75fd7; font-weight: bold;">Dequeue</span>() <span style="color: #268bd2; font-weight: bold;">interface</span>{} {
    <span style="color: #268bd2; font-weight: bold;">for</span> {
        <span style="color: #8787d7;">head</span> := <span style="color: #d75fd7; font-weight: bold;">load</span>(&amp;q.head)
        <span style="color: #8787d7;">tail</span> := <span style="color: #d75fd7; font-weight: bold;">load</span>(&amp;q.tail)
        <span style="color: #8787d7;">next</span> := <span style="color: #d75fd7; font-weight: bold;">load</span>(&amp;head.next)
        <span style="color: #268bd2; font-weight: bold;">if</span> head == <span style="color: #d75fd7; font-weight: bold;">load</span>(&amp;q.head) { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">head&#36824;&#26159;&#37027;&#20010;head</span>
            <span style="color: #268bd2; font-weight: bold;">if</span> head == tail { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">head&#21644;tail&#19968;&#26679;</span>
                <span style="color: #268bd2; font-weight: bold;">if</span> next == <span style="color: #d75fd7;">nil</span> { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35828;&#26126;&#26159;&#31354;&#38431;&#21015;</span>
                    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">nil</span>
                }
                <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21482;&#26159;&#23614;&#25351;&#38024;&#36824;&#27809;&#26377;&#35843;&#25972;&#65292;&#23581;&#35797;&#35843;&#25972;&#23427;&#25351;&#21521;&#19979;&#19968;&#20010;</span>
                <span style="color: #d75fd7; font-weight: bold;">cas</span>(&amp;q.tail, tail, next)
            } <span style="color: #268bd2; font-weight: bold;">else</span> {
                <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35835;&#21462;&#20986;&#38431;&#30340;&#25968;&#25454;</span>
                <span style="color: #8787d7;">v</span> := next.value
                <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#26082;&#28982;&#35201;&#20986;&#38431;&#20102;&#65292;&#22836;&#25351;&#38024;&#31227;&#21160;&#21040;&#19979;&#19968;&#20010;</span>
                <span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #d75fd7; font-weight: bold;">cas</span>(&amp;q.head, head, next) {
                    <span style="color: #268bd2; font-weight: bold;">return</span> v <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Dequeue is done.  return</span>
                }
            }
        }
    }
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#23558;unsafe.Pointer&#21407;&#23376;&#21152;&#36733;&#36716;&#25442;&#25104;node</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">load</span>(<span style="color: #8787d7;">p</span> *<span style="color: #df005f; font-weight: bold;">unsafe.Pointer</span>) (<span style="color: #8787d7;">n</span> *<span style="color: #df005f; font-weight: bold;">node</span>) {
    <span style="color: #268bd2; font-weight: bold;">return</span> (*node)(atomic.<span style="color: #d75fd7; font-weight: bold;">LoadPointer</span>(p))
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#23553;&#35013;CAS,&#36991;&#20813;&#30452;&#25509;&#23558;*node&#36716;&#25442;&#25104;unsafe.Pointer</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">cas</span>(<span style="color: #8787d7;">p</span> *<span style="color: #df005f; font-weight: bold;">unsafe.Pointer</span>, <span style="color: #8787d7;">old</span>, <span style="color: #8787d7;">new</span> *<span style="color: #df005f; font-weight: bold;">node</span>) (<span style="color: #8787d7;">ok</span> <span style="color: #df005f; font-weight: bold;">bool</span>) {
    <span style="color: #268bd2; font-weight: bold;">return</span> atomic.<span style="color: #d75fd7; font-weight: bold;">CompareAndSwapPointer</span>(
        p, unsafe.<span style="color: #d75fd7; font-weight: bold;">Pointer</span>(old), unsafe.<span style="color: #d75fd7; font-weight: bold;">Pointer</span>(new))
}   
</pre>
</div>

<p>
这个 lock-free 的实现使用了一个辅助头指针（head），头指针不包含有意义的数据，只是一个辅助的节点，这样的话，出队入队中的节点会更简单。<br>
</p>

<p>
入队的时候，通过 CAS 操作将一个元素添加到队尾，并且移动尾指针。<br>
</p>

<p>
出队的时候移除一个节点，并通过 CAS 操作移动 head 指针，同时在必要的时候移动尾指针。<br>
</p>
</div>
</div>
<div id="outline-container-org88b27a2" class="outline-2">
<h2 id="org88b27a2">总结</h2>
<div class="outline-text-2" id="text-org88b27a2">
<p>
好了，我们来小结一下。这节课，我们学习了 atomic 的基本使用方法，以及它提供的几种方法，包括 Add、CAS、Swap、Load、Store、Value 类型。除此之外，我还介绍了一些第三方库，并且带你实现了 Lock-free queue。到这里，相信你已经掌握了 atomic 提供的各种方法，并且能够应用到实践中了。<br>
</p>

<p>
最后，我还想和你讨论一个额外的问题：对一个地址的赋值是原子操作吗？<br>
</p>

<p>
这是一个很有趣的问题，如果是原子操作，还要 atomic 包干什么？官方的文档中并没有特意的介绍，不过，在一些 issue 或者论坛中，每当有人谈到这个问题时，总是会被建议用 atomic 包。<br>
</p>

<p>
<a href="https://dave.cheney.net/2018/01/06/if-aligned-memory-writes-are-atomic-why-do-we-need-the-sync-atomic-package">Dave Cheney</a> 就谈到过这个问题，讲得非常好。我来给你总结一下他讲的知识点，这样你就比较容易理解使用 atomic 和直接内存操作的区别了。<br>
</p>

<p>
在现在的系统中，write 的地址基本上都是对齐的（aligned）。 比如，32 位的操作系统、CPU 以及编译器，write 的地址总是 4 的倍数，64 位的系统总是 8 的倍数（还记得 WaitGroup 针对 64 位系统和 32 位系统对 state1 的字段不同的处理吗）。对齐地址的写，不会导致其他人看到只写了一半的数据，因为它通过一个指令就可以实现对地址的操作。如果地址不是对齐的话，那么，处理器就需要分成两个指令去处理，如果执行了一个指令，其它人就会看到更新了一半的错误的数据，这被称做撕裂写（torn write） 。所以，你可以认为赋值操作是一个原子操作，这个“原子操作”可以认为是保证数据的完整性。<br>
</p>

<p>
但是，对于现代的多处理多核的系统来说，由于 cache、指令重排，可见性等问题，我们对原子操作的意义有了更多的追求。在多核系统中，一个核对地址的值的更改，在更新到主内存中之前，是在多级缓存中存放的。这时，多个核看到的数据可能是不一样的，其它的核可能还没有看到更新的数据，还在使用旧的数据。<br>
</p>

<p>
多处理器多核心系统为了处理这类问题，使用了一种叫做内存屏障（memory fence 或 memory barrier）的方式。一个写内存屏障会告诉处理器，必须要等到它管道中的未完成的操作（特别是写操作）都被刷新到内存中，再进行操作。此操作还会让相关的处理器的 CPU 缓存失效，以便让它们从主存中拉取最新的值。<br>
</p>

<p>
atomic 包提供的方法会提供内存屏障的功能，所以，atomic 不仅仅可以保证赋值的数据完整性，还能保证数据的可见性，一旦一个核更新了该地址的值，其它处理器总是能读取到它的最新值。但是，需要注意的是，因为需要处理器之间保证数据的一致性，atomic 的操作也是会降低性能的。<br>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-07-01 Fri 10:01</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
