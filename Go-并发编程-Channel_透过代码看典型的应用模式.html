<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-07-03 Sun 20:05 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Go 并发编程 - Channel: 透过代码看典型的应用模式</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">Go 并发编程 - Channel: 透过代码看典型的应用模式</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org008e658">引言</a></li>
<li><a href="#org3d7f3fd">使用反射操作 Channel</a></li>
<li><a href="#org628e53e">经典的应用场景</a>
<ul>
<li><a href="#org28fef14">消息交流</a></li>
<li><a href="#org60ca4e4">数据传递</a></li>
<li><a href="#orgeebeabb">信号通知</a></li>
<li><a href="#org87e348b">锁</a></li>
<li><a href="#orgd780e68">任务编排</a>
<ul>
<li><a href="#org6eb1122">Or-Done 模式</a></li>
<li><a href="#orgecef1ec">扇入模式</a></li>
<li><a href="#org0d399ce">扇出模式</a></li>
<li><a href="#org009f362">Stream</a></li>
<li><a href="#orgcd35508">map-reduce</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2a09584">总结</a></li>
</ul>
</div>
</div>

<div id="outline-container-org008e658" class="outline-2">
<h2 id="org008e658">引言</h2>
<div class="outline-text-2" id="text-org008e658">
<p>
通过反射的方式执行 select 语句，在处理很多的 case clause，尤其是不定长的 case clause 的时候，非常有用。而且，在后面介绍任务编排的实现时，我也会采用这种方法，所以，我们先学习下 Channel 的反射用法。<br>
</p>
</div>
</div>
<div id="outline-container-org3d7f3fd" class="outline-2">
<h2 id="org3d7f3fd">使用反射操作 Channel</h2>
<div class="outline-text-2" id="text-org3d7f3fd">
<p>
select 语句可以处理 chan 的 send 和 recv，send 和 recv 都可以作为 case clause。如果我们同时处理两个 chan，就可以写成下面的样子：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">select</span> {
<span style="color: #268bd2; font-weight: bold;">case</span> <span style="color: #8787d7;">v</span> := &lt;-ch1:
        fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(v)
<span style="color: #268bd2; font-weight: bold;">case</span> <span style="color: #8787d7;">v</span> := &lt;-ch2:
        fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(v)
}   
</pre>
</div>

<p>
如果需要处理三个 chan，你就可以再添加一个 case clause，用它来处理第三个 chan。可是，如果要处理 100 个 chan 呢？一万个 chan 呢？<br>
</p>

<p>
或者是，chan 的数量在编译的时候是不定的，在运行的时候需要处理一个 slice of chan，这个时候，也没有办法在编译前写成字面意义的 select。那该怎么办？<br>
</p>

<p>
这个时候，就要“祭”出我们的反射大法了。<br>
</p>

<p>
通过 reflect.Select 函数，你可以将一组运行时的 case clause 传入，当作参数执行。Go 的 select 是伪随机的，它可以在执行的 case 中随机选择一个 case，并把选择的这个 case 的索引（chosen）返回，如果没有可用的 case 返回，会返回一个 bool 类型的返回值，这个返回值用来表示是否有 case 成功被选择。如果是 recv case，还会返回接收的元素。Select 的方法签名如下：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">Select</span>(<span style="color: #8787d7;">cases</span> []<span style="color: #df005f; font-weight: bold;">SelectCase</span>) (<span style="color: #8787d7;">chosen</span> <span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #8787d7;">recv</span> <span style="color: #df005f; font-weight: bold;">Value</span>, <span style="color: #8787d7;">recvOK</span> <span style="color: #df005f; font-weight: bold;">bool</span>)   
</pre>
</div>

<p>
下面借助一个例子来演示一下，动态处理两个 chan 的情形。因为这样的方式可以动态处理 case 数据，所以，你可以传入几百几千几万的 chan，这就解决了不能动态处理 n 个 chan 的问题。<br>
</p>

<p>
首先，createCases 函数分别为每个 chan 生成了 recv case 和 send case，并返回一个 reflect.SelectCase 数组。<br>
</p>

<p>
然后，通过一个循环 10 次的 for 循环执行 reflect.Select，这个方法会从 cases 中选择一个 case 执行。第一次肯定是 send case，因为此时 chan 还没有元素，recv 还不可用。等 chan 中有了数据以后，recv case 就可以被选择了。这样，你就可以处理不定数量的 chan 了。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">ch1</span> = <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">int</span>, 10)
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">ch2</span> = <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">int</span>, 10)

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21019;&#24314;SelectCase</span>
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">cases</span> = <span style="color: #d75fd7; font-weight: bold;">createCases</span>(ch1, ch2)

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#25191;&#34892;10&#27425;select</span>
    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := 0; i &lt; 10; i++ {
        <span style="color: #8787d7;">chosen</span>, <span style="color: #8787d7;">recv</span>, <span style="color: #8787d7;">ok</span> := reflect.<span style="color: #d75fd7; font-weight: bold;">Select</span>(cases)
        <span style="color: #268bd2; font-weight: bold;">if</span> recv.<span style="color: #d75fd7; font-weight: bold;">IsValid</span>() { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">recv case</span>
            fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"recv:"</span>, cases[chosen].Dir, recv, ok)
        } <span style="color: #268bd2; font-weight: bold;">else</span> { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">send case</span>
            fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"send:"</span>, cases[chosen].Dir, ok)
        }
    }
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">createCases</span>(<span style="color: #8787d7;">chs</span> ...<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">int</span>) []<span style="color: #df005f; font-weight: bold;">reflect.SelectCase</span> {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">cases</span> []<span style="color: #df005f; font-weight: bold;">reflect.SelectCase</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21019;&#24314;recv case</span>
    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">_</span>, <span style="color: #8787d7;">ch</span> := <span style="color: #268bd2; font-weight: bold;">range</span> chs {
        cases = <span style="color: #268bd2;">append</span>(cases, <span style="color: #df005f; font-weight: bold;">reflect.SelectCase</span>{
            <span style="color: #d75fd7;">Dir</span>:  reflect.SelectRecv,
            <span style="color: #d75fd7;">Chan</span>: reflect.<span style="color: #d75fd7; font-weight: bold;">ValueOf</span>(ch),
        })
    }

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21019;&#24314;send case</span>
    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span>, <span style="color: #8787d7;">ch</span> := <span style="color: #268bd2; font-weight: bold;">range</span> chs {
        <span style="color: #8787d7;">v</span> := reflect.<span style="color: #d75fd7; font-weight: bold;">ValueOf</span>(i)
        cases = <span style="color: #268bd2;">append</span>(cases, <span style="color: #df005f; font-weight: bold;">reflect.SelectCase</span>{
            <span style="color: #d75fd7;">Dir</span>:  reflect.SelectSend,
            <span style="color: #d75fd7;">Chan</span>: reflect.<span style="color: #d75fd7; font-weight: bold;">ValueOf</span>(ch),
            <span style="color: #d75fd7;">Send</span>: v,
        })
    }

    <span style="color: #268bd2; font-weight: bold;">return</span> cases
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org628e53e" class="outline-2">
<h2 id="org628e53e">经典的应用场景</h2>
<div class="outline-text-2" id="text-org628e53e">
</div>
<div id="outline-container-org28fef14" class="outline-3">
<h3 id="org28fef14">消息交流</h3>
<div class="outline-text-3" id="text-org28fef14">
<p>
从 chan 的内部实现看，它是以一个循环队列的方式存放数据，所以，它有时候也会被当成线程安全的队列和 buffer 使用。一个 goroutine 可以安全地往 Channel 中塞数据，另外一个 goroutine 可以安全地从 Channel 中读取数据，goroutine 就可以安全地实现信息交流了。<br>
</p>

<p>
我们来看几个例子。<br>
</p>

<p>
第一个例子是 worker 池的例子。Marcio Castilho 在 <a href="http://marcio.io/2015/07/handling-1-million-requests-per-minute-with-golang/">使用 Go 每分钟处理百万请求</a> 这篇文章中，就介绍了他们应对大并发请求的设计。他们将用户的请求放在一个 chan Job 中，这个 chan Job 就相当于一个待处理任务队列。除此之外，还有一个 chan chan Job 队列，用来存放可以处理任务的 worker 的缓存队列。<br>
</p>

<p>
dispatcher 会把待处理任务队列中的任务放到一个可用的缓存队列中，worker 会一直处理它的缓存队列。通过使用 Channel，实现了一个 worker 池的任务处理中心，并且解耦了前端 HTTP 请求处理和后端任务处理的逻辑。<br>
</p>

<p>
我在讲 Pool 的时候，提到了一些第三方实现的 worker 池，它们全部都是通过 Channel 实现的，这是 Channel 的一个常见的应用场景。worker 池的生产者和消费者的消息交流都是通过 Channel 实现的。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">node</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    propc      <span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">msgWithResult</span>
    recvc      <span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">pb.Message</span>
    confc      <span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">pb.ConfChangeV2</span>
    confstatec <span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">pb.ConfState</span>
    readyc     <span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">Ready</span>
    advancec   <span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}
    tickc      <span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}
    done       <span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}
    stop       <span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}
    status     <span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">chan</span> Status

    rn *<span style="color: #df005f; font-weight: bold;">RawNode</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org60ca4e4" class="outline-3">
<h3 id="org60ca4e4">数据传递</h3>
<div class="outline-text-3" id="text-org60ca4e4">
<p>
“击鼓传花”的游戏很多人都玩过，花从一个人手中传给另外一个人，就有点类似流水线的操作。这个花就是数据，花在游戏者之间流转，这就类似编程中的数据传递。<br>
</p>

<blockquote>
<p>
有 4 个 goroutine，编号为 1、2、3、4。每秒钟会有一个 goroutine 打印出它自己的编号，要求你编写程序，让输出的编号总是按照 1、2、3、4、1、2、3、4……这个顺序打印出来。<br>
</p>
</blockquote>

<p>
为了实现顺序的数据传递，我们可以定义一个令牌的变量，谁得到令牌，谁就可以打印一次自己的编号，同时将令牌传递给下一个 goroutine，我们尝试使用 chan 来实现，可以看下下面的代码。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Token</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">newWorker</span>(<span style="color: #8787d7;">id</span> <span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #8787d7;">ch</span> <span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">Token</span>, <span style="color: #8787d7;">nextCh</span> <span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">Token</span>) {
    <span style="color: #268bd2; font-weight: bold;">for</span> {
        <span style="color: #8787d7;">token</span> := &lt;-ch         <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21462;&#24471;&#20196;&#29260;</span>
        fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(id + 1)   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">id&#20174;1&#24320;&#22987;</span>
        time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(time.Second)
        nextCh &lt;- token
    }
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">chs</span> := []<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">Token</span>{
        <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">Token</span>),
        <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">Token</span>),
        <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">Token</span>),
        <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">Token</span>),
    }

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21019;&#24314;4&#20010;worker</span>
    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := 0; i &lt; 4; i++ {
        <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #d75fd7; font-weight: bold;">newWorker</span>(i, chs[i], chs[(i+1)%4])
    }

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#39318;&#20808;&#25226;&#20196;&#29260;&#20132;&#32473;&#31532;&#19968;&#20010;worker</span>
    chs[0] &lt;- <span style="color: #268bd2; font-weight: bold;">struct</span>{}{}

    <span style="color: #268bd2; font-weight: bold;">select</span> {}
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgeebeabb" class="outline-3">
<h3 id="orgeebeabb">信号通知</h3>
<div class="outline-text-3" id="text-orgeebeabb">
<p>
chan 类型有这样一个特点：chan 如果为空，那么，receiver 接收数据的时候就会阻塞等待，直到 chan 被关闭或者有新的数据到来。利用这个机制，我们可以实现 wait/notify 的设计模式。<br>
</p>

<p>
传统的并发原语 Cond 也能实现这个功能。但是，Cond 使用起来比较复杂，容易出错，而使用 chan 实现 wait/notify 模式，就方便多了。<br>
</p>

<p>
除了正常的业务处理时的 wait/notify，我们经常碰到的一个场景，就是程序关闭的时候，我们需要在退出之前做一些清理（doCleanup 方法）的动作。这个时候，我们经常要使用 chan。<br>
</p>

<p>
比如，使用 chan 实现程序的 graceful shutdown，在退出之前执行一些连接关闭、文件 close、缓存落盘等一些动作。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">...... // &#25191;&#34892;&#19994;&#21153;&#22788;&#29702;</span>
    }()

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22788;&#29702;CTRL+C&#31561;&#20013;&#26029;&#20449;&#21495;</span>
    <span style="color: #8787d7;">termChan</span> := <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">os.Signal</span>)
    signal.<span style="color: #d75fd7; font-weight: bold;">Notify</span>(termChan, syscall.SIGINT, syscall.SIGTERM)
    &lt;-termChan 

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#25191;&#34892;&#36864;&#20986;&#20043;&#21069;&#30340;&#28165;&#29702;&#21160;&#20316;</span>
    <span style="color: #d75fd7; font-weight: bold;">doCleanup</span>()

    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"&#20248;&#38597;&#36864;&#20986;"</span>)
}
</pre>
</div>

<p>
有时候，doCleanup 可能是一个很耗时的操作，比如十几分钟才能完成，如果程序退出需要等待这么长时间，用户是不能接受的，所以，在实践中，我们需要设置一个最长的等待时间。只要超过了这个时间，程序就不再等待，可以直接退出。所以，退出的时候分为两个阶段：<br>
</p>

<ul class="org-ul">
<li>closing，代表程序退出，但是清理工作还没做；<br></li>
<li>closed，代表清理工作已经做完；<br></li>
</ul>

<p>
所以，上面的例子可以改写如下：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">closing</span> = <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{})
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">closed</span> = <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{})

    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#27169;&#25311;&#19994;&#21153;&#22788;&#29702;</span>
        <span style="color: #268bd2; font-weight: bold;">for</span> {
            <span style="color: #268bd2; font-weight: bold;">select</span> {
            <span style="color: #268bd2; font-weight: bold;">case</span> &lt;-closing:
                <span style="color: #268bd2; font-weight: bold;">return</span>
            <span style="color: #268bd2; font-weight: bold;">default</span>:
                <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">....... &#19994;&#21153;&#35745;&#31639;</span>
                time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(100 * time.Millisecond)
            }
        }
    }()

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22788;&#29702;CTRL+C&#31561;&#20013;&#26029;&#20449;&#21495;</span>
    <span style="color: #8787d7;">termChan</span> := <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #df005f; font-weight: bold;">os.Signal</span>)
    signal.<span style="color: #d75fd7; font-weight: bold;">Notify</span>(termChan, syscall.SIGINT, syscall.SIGTERM)
    &lt;-termChan

    <span style="color: #268bd2;">close</span>(closing)
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#25191;&#34892;&#36864;&#20986;&#20043;&#21069;&#30340;&#28165;&#29702;&#21160;&#20316;</span>
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #d75fd7; font-weight: bold;">doCleanup</span>(closed)

    <span style="color: #268bd2; font-weight: bold;">select</span> {
    <span style="color: #268bd2; font-weight: bold;">case</span> &lt;-closed:
    <span style="color: #268bd2; font-weight: bold;">case</span> &lt;-time.<span style="color: #d75fd7; font-weight: bold;">After</span>(time.Second):
        fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"&#28165;&#29702;&#36229;&#26102;&#65292;&#19981;&#31561;&#20102;"</span>)
    }
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"&#20248;&#38597;&#36864;&#20986;"</span>)
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">doCleanup</span>(<span style="color: #8787d7;">closed</span> <span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}) {
    time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>((time.Minute))
    <span style="color: #268bd2;">close</span>(closed)
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org87e348b" class="outline-3">
<h3 id="org87e348b">锁</h3>
<div class="outline-text-3" id="text-org87e348b">
<p>
使用 chan 也可以实现互斥锁。<br>
</p>

<p>
在 chan 的内部实现中，就有一把互斥锁保护着它的所有字段。从外在表现上，chan 的发送和接收之间也存在着 happens-before 的关系，保证元素放进去之后，receiver 才能读取到（关于 happends-before 的关系，是指事件发生的先后顺序关系）。<br>
</p>

<p>
要想使用 chan 实现互斥锁，至少有两种方式。一种方式是先初始化一个 capacity 等于 1 的 Channel，然后再放入一个元素。这个元素就代表锁，谁取得了这个元素，就相当于获取了这把锁。另一种方式是，先初始化一个 capacity 等于 1 的 Channel，它的“空槽”代表锁，谁能成功地把元素发送到这个 Channel，谁就获取了这把锁。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20351;&#29992;chan&#23454;&#29616;&#20114;&#26021;&#38145;</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Mutex</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    ch <span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20351;&#29992;&#38145;&#38656;&#35201;&#21021;&#22987;&#21270;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">NewMutex</span>() *<span style="color: #df005f; font-weight: bold;">Mutex</span> {
    <span style="color: #8787d7;">mu</span> := &amp;<span style="color: #df005f; font-weight: bold;">Mutex</span>{<span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}, 1)}
    mu.ch &lt;- <span style="color: #268bd2; font-weight: bold;">struct</span>{}{}
    <span style="color: #268bd2; font-weight: bold;">return</span> mu
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35831;&#27714;&#38145;&#65292;&#30452;&#21040;&#33719;&#21462;&#21040;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">m</span> *<span style="color: #df005f; font-weight: bold;">Mutex</span>) <span style="color: #d75fd7; font-weight: bold;">Lock</span>() {
    &lt;-m.ch
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35299;&#38145;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">m</span> *<span style="color: #df005f; font-weight: bold;">Mutex</span>) <span style="color: #d75fd7; font-weight: bold;">Unlock</span>() {
    <span style="color: #268bd2; font-weight: bold;">select</span> {
    <span style="color: #268bd2; font-weight: bold;">case</span> m.ch &lt;- <span style="color: #268bd2; font-weight: bold;">struct</span>{}{}:
    <span style="color: #268bd2; font-weight: bold;">default</span>:
        <span style="color: #268bd2;">panic</span>(<span style="color: #2aa198;">"unlock of unlocked mutex"</span>)
    }
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#23581;&#35797;&#33719;&#21462;&#38145;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">m</span> *<span style="color: #df005f; font-weight: bold;">Mutex</span>) <span style="color: #d75fd7; font-weight: bold;">TryLock</span>() <span style="color: #df005f; font-weight: bold;">bool</span> {
    <span style="color: #268bd2; font-weight: bold;">select</span> {
    <span style="color: #268bd2; font-weight: bold;">case</span> &lt;-m.ch:
        <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">true</span>
    <span style="color: #268bd2; font-weight: bold;">default</span>:
    }
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">false</span>
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21152;&#20837;&#19968;&#20010;&#36229;&#26102;&#30340;&#35774;&#32622;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">m</span> *<span style="color: #df005f; font-weight: bold;">Mutex</span>) <span style="color: #d75fd7; font-weight: bold;">LockTimeout</span>(<span style="color: #8787d7;">timeout</span> <span style="color: #df005f; font-weight: bold;">time.Duration</span>) <span style="color: #df005f; font-weight: bold;">bool</span> {
    <span style="color: #8787d7;">timer</span> := time.<span style="color: #d75fd7; font-weight: bold;">NewTimer</span>(timeout)
    <span style="color: #268bd2; font-weight: bold;">select</span> {
    <span style="color: #268bd2; font-weight: bold;">case</span> &lt;-m.ch:
        timer.<span style="color: #d75fd7; font-weight: bold;">Stop</span>()
        <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">true</span>
    <span style="color: #268bd2; font-weight: bold;">case</span> &lt;-timer.C:
    }
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">false</span>
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#38145;&#26159;&#21542;&#24050;&#34987;&#25345;&#26377;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">m</span> *<span style="color: #df005f; font-weight: bold;">Mutex</span>) <span style="color: #d75fd7; font-weight: bold;">IsLocked</span>() <span style="color: #df005f; font-weight: bold;">bool</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #268bd2;">len</span>(m.ch) == 0
}


<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">m</span> := <span style="color: #d75fd7; font-weight: bold;">NewMutex</span>()
    <span style="color: #8787d7;">ok</span> := m.<span style="color: #d75fd7; font-weight: bold;">TryLock</span>()
    fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"locked v %v\n"</span>, ok)
    ok = m.<span style="color: #d75fd7; font-weight: bold;">TryLock</span>()
    fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"locked %v\n"</span>, ok)
}
</pre>
</div>

<p>
你可以用 buffer 等于 1 的 chan 实现互斥锁，在初始化这个锁的时候往 Channel 中先塞入一个元素，谁把这个元素取走，谁就获取了这把锁，把元素放回去，就是释放了锁。元素在放回到 chan 之前，不会有 goroutine 能从 chan 中取出元素的，这就保证了互斥性。<br>
</p>

<p>
在这段代码中，还有一点需要我们注意下：利用 select+chan 的方式，很容易实现 TryLock、Timeout 的功能。具体来说就是，在 select 语句中，我们可以使用 default 实现 TryLock，使用一个 Timer 来实现 Timeout 的功能。<br>
</p>
</div>
</div>
<div id="outline-container-orgd780e68" class="outline-3">
<h3 id="orgd780e68">任务编排</h3>
<div class="outline-text-3" id="text-orgd780e68">
<p>
前面所说的消息交流的场景是一个特殊的任务编排的场景，这个“击鼓传花”的模式也被称为流水线模式。<br>
</p>

<p>
我们可以利用 WaitGroup 实现等待模式：启动一组 goroutine 执行任务，然后等待这些任务都完成。其实，我们也可以使用 chan 实现 WaitGroup 的功能。这个比较简单，我就不举例子了，接下来我介绍几种更复杂的编排模式。<br>
</p>

<p>
这里的编排既指安排 goroutine 按照指定的顺序执行，也指多个 chan 按照指定的方式组合处理的方式。goroutine 的编排类似“击鼓传花”的例子，我们通过编排数据在 chan 之间的流转，就可以控制 goroutine 的执行。接下来重点介绍下多个 chan 的编排方式，总共 5 种，分别是 Or-Done 模式、扇入模式、扇出模式、Stream 和 map-reduce。<br>
</p>
</div>
<div id="outline-container-org6eb1122" class="outline-4">
<h4 id="org6eb1122">Or-Done 模式</h4>
<div class="outline-text-4" id="text-org6eb1122">
<p>
首先来看 Or-Done 模式。Or-Done 模式是信号通知模式中更宽泛的一种模式。这里提到了“信号通知模式”。<br>
</p>

<p>
我们会使用“信号通知”实现某个任务执行完成后的通知机制，在实现时，我们为这个任务定义一个类型为 chan struct{}类型的 done 变量，等任务结束后，我们就可以 close 这个变量，然后，其它 receiver 就会收到这个通知。<br>
</p>

<p>
这是有一个任务的情况，如果有多个任务，只要有任意一个任务执行完，我们就想获得这个信号，这就是 Or-Done 模式。<br>
</p>

<p>
比如，你发送同一个请求到多个微服务节点，只要任意一个微服务节点返回结果，就算成功，这个时候，就可以参考下面的实现：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">or</span>(<span style="color: #8787d7;">channels</span> ...&lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{}) &lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{} {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#29305;&#27530;&#24773;&#20917;&#65292;&#21482;&#26377;&#38646;&#20010;&#25110;&#32773;1&#20010;chan</span>
    <span style="color: #268bd2; font-weight: bold;">switch</span> <span style="color: #268bd2;">len</span>(channels) {
    <span style="color: #268bd2; font-weight: bold;">case</span> 0:
        <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">nil</span>
    <span style="color: #268bd2; font-weight: bold;">case</span> 1:
        <span style="color: #268bd2; font-weight: bold;">return</span> channels[0]
    }

    <span style="color: #8787d7;">orDone</span> := <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{})
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
        <span style="color: #268bd2; font-weight: bold;">defer</span> <span style="color: #268bd2;">close</span>(orDone)

        <span style="color: #268bd2; font-weight: bold;">switch</span> <span style="color: #268bd2;">len</span>(channels) {
        <span style="color: #268bd2; font-weight: bold;">case</span> 2: <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">2&#20010;&#20063;&#26159;&#19968;&#31181;&#29305;&#27530;&#24773;&#20917;</span>
            <span style="color: #268bd2; font-weight: bold;">select</span> {
            <span style="color: #268bd2; font-weight: bold;">case</span> &lt;-channels[0]:
            <span style="color: #268bd2; font-weight: bold;">case</span> &lt;-channels[1]:
            }
        <span style="color: #268bd2; font-weight: bold;">default</span>: <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#36229;&#36807;&#20004;&#20010;&#65292;&#20108;&#20998;&#27861;&#36882;&#24402;&#22788;&#29702;</span>
            <span style="color: #8787d7;">m</span> := <span style="color: #268bd2;">len</span>(channels) / 2
            <span style="color: #268bd2; font-weight: bold;">select</span> {
            <span style="color: #268bd2; font-weight: bold;">case</span> &lt;-<span style="color: #d75fd7; font-weight: bold;">or</span>(channels[:m]...):
            <span style="color: #268bd2; font-weight: bold;">case</span> &lt;-<span style="color: #d75fd7; font-weight: bold;">or</span>(channels[m:]...):
            }
        }
    }()

    <span style="color: #268bd2; font-weight: bold;">return</span> orDone
}
</pre>
</div>

<p>
我们可以写一个测试程序测试它：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">sig</span>(<span style="color: #8787d7;">after</span> <span style="color: #df005f; font-weight: bold;">time.Duration</span>) &lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{} {
    <span style="color: #8787d7;">c</span> := <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{})
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
        <span style="color: #268bd2; font-weight: bold;">defer</span> <span style="color: #268bd2;">close</span>(c)
        time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(after)
    }()
    <span style="color: #268bd2; font-weight: bold;">return</span> c
}


<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">start</span> := time.<span style="color: #d75fd7; font-weight: bold;">Now</span>()

    &lt;-<span style="color: #d75fd7; font-weight: bold;">or</span>(
        <span style="color: #d75fd7; font-weight: bold;">sig</span>(10*time.Second),
        <span style="color: #d75fd7; font-weight: bold;">sig</span>(20*time.Second),
        <span style="color: #d75fd7; font-weight: bold;">sig</span>(30*time.Second),
        <span style="color: #d75fd7; font-weight: bold;">sig</span>(40*time.Second),
        <span style="color: #d75fd7; font-weight: bold;">sig</span>(50*time.Second),
        <span style="color: #d75fd7; font-weight: bold;">sig</span>(01*time.Minute),
    )

    fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"done after %v"</span>, time.<span style="color: #d75fd7; font-weight: bold;">Since</span>(start))
}
</pre>
</div>

<p>
这里的实现使用了一个巧妙的方式， <b>当 chan 的数量大于 2 时，使用递归的方式等待信号</b> 。<br>
</p>

<p>
在 chan 数量比较多的情况下，递归并不是一个很好的解决方式，根据这一讲最开始介绍的反射的方法，我们也可以实现 Or-Done 模式：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">or</span>(<span style="color: #8787d7;">channels</span> ...&lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{}) &lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{} {
    <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#29305;&#27530;&#24773;&#20917;&#65292;&#21482;&#26377;0&#20010;&#25110;&#32773;1&#20010;</span>
    <span style="color: #268bd2; font-weight: bold;">switch</span> <span style="color: #268bd2;">len</span>(channels) {
    <span style="color: #268bd2; font-weight: bold;">case</span> 0:
        <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">nil</span>
    <span style="color: #268bd2; font-weight: bold;">case</span> 1:
        <span style="color: #268bd2; font-weight: bold;">return</span> channels[0]
    }

    <span style="color: #8787d7;">orDone</span> := <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{})
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
        <span style="color: #268bd2; font-weight: bold;">defer</span> <span style="color: #268bd2;">close</span>(orDone)
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21033;&#29992;&#21453;&#23556;&#26500;&#24314;SelectCase</span>
        <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">cases</span> []<span style="color: #df005f; font-weight: bold;">reflect.SelectCase</span>
        <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">_</span>, <span style="color: #8787d7;">c</span> := <span style="color: #268bd2; font-weight: bold;">range</span> channels {
            cases = <span style="color: #268bd2;">append</span>(cases, <span style="color: #df005f; font-weight: bold;">reflect.SelectCase</span>{
                <span style="color: #d75fd7;">Dir</span>:  reflect.SelectRecv,
                <span style="color: #d75fd7;">Chan</span>: reflect.<span style="color: #d75fd7; font-weight: bold;">ValueOf</span>(c),
            })
        }

        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#38543;&#26426;&#36873;&#25321;&#19968;&#20010;&#21487;&#29992;&#30340;case</span>
        reflect.<span style="color: #d75fd7; font-weight: bold;">Select</span>(cases)
    }()


    <span style="color: #268bd2; font-weight: bold;">return</span> orDone
}
</pre>
</div>

<p>
这是递归和反射两种方法实现 Or-Done 模式的代码。反射方式避免了深层递归的情况，可以处理有大量 chan 的情况。其实最笨的一种方法就是为每一个 Channel 启动一个 goroutine，不过这会启动非常多的 goroutine，太多的 goroutine 会影响性能，所以不太常用。你只要知道这种用法就行了，不用重点掌握。<br>
</p>
</div>
</div>
<div id="outline-container-orgecef1ec" class="outline-4">
<h4 id="orgecef1ec">扇入模式</h4>
<div class="outline-text-4" id="text-orgecef1ec">
<p>
扇入借鉴了数字电路的概念，它定义了单个逻辑门能够接受的数字信号输入最大量的术语。一个逻辑门可以有多个输入，一个输出。<br>
</p>

<p>
在软件工程中，模块的扇入是指有多少个上级模块调用它。而对于我们这里的 Channel 扇入模式来说，就是指有多个源 Channel 输入、一个目的 Channel 输出的情况。扇入比就是源 Channel 数量比 1。<br>
</p>

<p>
每个源 Channel 的元素都会发送给目标 Channel，相当于目标 Channel 的 receiver 只需要监听目标 Channel，就可以接收所有发送给源 Channel 的数据。<br>
</p>

<p>
扇入模式也可以使用反射、递归，或者是用最笨的每个 goroutine 处理一个 Channel 的方式来实现。<br>
</p>

<p>
这里我列举下递归和反射的方式，帮你加深一下对这个技巧的理解。<br>
</p>

<p>
反射的代码比较简短，易于理解，主要就是构造出 SelectCase slice，然后传递给 reflect.Select 语句。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">fanInReflect</span>(<span style="color: #8787d7;">chans</span> ...&lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{}) &lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{} {
    <span style="color: #8787d7;">out</span> := <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{})
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
        <span style="color: #268bd2; font-weight: bold;">defer</span> <span style="color: #268bd2;">close</span>(out)
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#26500;&#36896;SelectCase slice</span>
        <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">cases</span> []<span style="color: #df005f; font-weight: bold;">reflect.SelectCase</span>
        <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">_</span>, <span style="color: #8787d7;">c</span> := <span style="color: #268bd2; font-weight: bold;">range</span> chans {
            cases = <span style="color: #268bd2;">append</span>(cases, <span style="color: #df005f; font-weight: bold;">reflect.SelectCase</span>{
                <span style="color: #d75fd7;">Dir</span>:  reflect.SelectRecv,
                <span style="color: #d75fd7;">Chan</span>: reflect.<span style="color: #d75fd7; font-weight: bold;">ValueOf</span>(c),
            })
        }

        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#24490;&#29615;&#65292;&#20174;cases&#20013;&#36873;&#25321;&#19968;&#20010;&#21487;&#29992;&#30340;</span>
        <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #268bd2;">len</span>(cases) &gt; 0 {
            <span style="color: #8787d7;">i</span>, <span style="color: #8787d7;">v</span>, <span style="color: #8787d7;">ok</span> := reflect.<span style="color: #d75fd7; font-weight: bold;">Select</span>(cases)
            <span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #d75fd7;">!</span>ok { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#27492;channel&#24050;&#32463;close</span>
                cases = <span style="color: #268bd2;">append</span>(cases[:i], cases[i+1:]...)
                <span style="color: #268bd2; font-weight: bold;">continue</span>
            }
            out &lt;- v.<span style="color: #d75fd7; font-weight: bold;">Interface</span>()
        }
    }()
    <span style="color: #268bd2; font-weight: bold;">return</span> out
}
</pre>
</div>

<p>
递归模式也是在 Channel 大于 2 时，采用二分法递归 merge。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">fanInRec</span>(<span style="color: #8787d7;">chans</span> ...&lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{}) &lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{} {
    <span style="color: #268bd2; font-weight: bold;">switch</span> <span style="color: #268bd2;">len</span>(chans) {
    <span style="color: #268bd2; font-weight: bold;">case</span> 0:
        <span style="color: #8787d7;">c</span> := <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{})
        <span style="color: #268bd2;">close</span>(c)
        <span style="color: #268bd2; font-weight: bold;">return</span> c
    <span style="color: #268bd2; font-weight: bold;">case</span> 1:
        <span style="color: #268bd2; font-weight: bold;">return</span> chans[0]
    <span style="color: #268bd2; font-weight: bold;">case</span> 2:
        <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7; font-weight: bold;">mergeTwo</span>(chans[0], chans[1])
    <span style="color: #268bd2; font-weight: bold;">default</span>:
        <span style="color: #8787d7;">m</span> := <span style="color: #268bd2;">len</span>(chans) / 2
        <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7; font-weight: bold;">mergeTwo</span>(
            <span style="color: #d75fd7; font-weight: bold;">fanInRec</span>(chans[:m]...),
            <span style="color: #d75fd7; font-weight: bold;">fanInRec</span>(chans[m:]...))
    }
}
</pre>
</div>

<p>
这里有一个 mergeTwo 的方法，是将两个 Channel 合并成一个 Channel，是扇入形式的一种特例（只处理两个 Channel）。 下面我来借助一段代码帮你理解下这个方法。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">mergeTwo</span>(<span style="color: #8787d7;">a</span>, <span style="color: #8787d7;">b</span> &lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{}) &lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{} {
    <span style="color: #8787d7;">c</span> := <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{})
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
        <span style="color: #268bd2; font-weight: bold;">defer</span> <span style="color: #268bd2;">close</span>(c)
        <span style="color: #268bd2; font-weight: bold;">for</span> a != <span style="color: #d75fd7;">nil</span> || b != <span style="color: #d75fd7;">nil</span> { <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#21482;&#35201;&#36824;&#26377;&#21487;&#35835;&#30340;chan</span>
            <span style="color: #268bd2; font-weight: bold;">select</span> {
            <span style="color: #268bd2; font-weight: bold;">case</span> <span style="color: #8787d7;">v</span>, <span style="color: #8787d7;">ok</span> := &lt;-a:
                <span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #d75fd7;">!</span>ok { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">a &#24050;&#20851;&#38381;&#65292;&#35774;&#32622;&#20026;nil</span>
                    a = <span style="color: #d75fd7;">nil</span>
                    <span style="color: #268bd2; font-weight: bold;">continue</span>
                }
                c &lt;- v
            <span style="color: #268bd2; font-weight: bold;">case</span> <span style="color: #8787d7;">v</span>, <span style="color: #8787d7;">ok</span> := &lt;-b:
                <span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #d75fd7;">!</span>ok { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">b &#24050;&#20851;&#38381;&#65292;&#35774;&#32622;&#20026;nil</span>
                    b = <span style="color: #d75fd7;">nil</span>
                    <span style="color: #268bd2; font-weight: bold;">continue</span>
                }
                c &lt;- v
            }
        }
    }()
    <span style="color: #268bd2; font-weight: bold;">return</span> c
}   
</pre>
</div>
</div>
</div>
<div id="outline-container-org0d399ce" class="outline-4">
<h4 id="org0d399ce">扇出模式</h4>
<div class="outline-text-4" id="text-org0d399ce">
<p>
有扇入模式，就有扇出模式，扇出模式是和扇入模式相反的。<br>
</p>

<p>
扇出模式只有一个输入源 Channel，有多个目标 Channel，扇出比就是 1 比目标 Channel 数的值，经常用在设计模式中的观察者模式中（观察者设计模式定义了对象间的一种一对多的组合关系。这样一来，一个对象的状态发生变化时，所有依赖于它的对象都会得到通知并自动刷新）。在观察者模式中，数据变动后，多个观察者都会收到这个变更信号。<br>
</p>

<p>
下面是一个扇出模式的实现。从源 Channel 取出一个数据后，依次发送给目标 Channel。在发送给目标 Channel 的时候，可以同步发送，也可以异步发送：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">fanOut</span>(<span style="color: #8787d7;">ch</span> &lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{}, <span style="color: #8787d7;">out</span> []<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{}, <span style="color: #8787d7;">async</span> <span style="color: #df005f; font-weight: bold;">bool</span>) {
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
        <span style="color: #268bd2; font-weight: bold;">defer</span> <span style="color: #268bd2; font-weight: bold;">func</span>() { <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#36864;&#20986;&#26102;&#20851;&#38381;&#25152;&#26377;&#30340;&#36755;&#20986;chan</span>
            <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := 0; i &lt; <span style="color: #268bd2;">len</span>(out); i++ {
                <span style="color: #268bd2;">close</span>(out[i])
            }
        }()

        <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">v</span> := <span style="color: #268bd2; font-weight: bold;">range</span> ch { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20174;&#36755;&#20837;chan&#20013;&#35835;&#21462;&#25968;&#25454;</span>
            <span style="color: #8787d7;">v</span> := v
            <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := 0; i &lt; <span style="color: #268bd2;">len</span>(out); i++ {
                <span style="color: #8787d7;">i</span> := i
                <span style="color: #268bd2; font-weight: bold;">if</span> async { <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#24322;&#27493;</span>
                    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
                        out[i] &lt;- v <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#25918;&#20837;&#21040;&#36755;&#20986;chan&#20013;,&#24322;&#27493;&#26041;&#24335;</span>
                    }()
                } <span style="color: #268bd2; font-weight: bold;">else</span> {
                    out[i] &lt;- v <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#25918;&#20837;&#21040;&#36755;&#20986;chan&#20013;&#65292;&#21516;&#27493;&#26041;&#24335;</span>
                }
            }
        }
    }()
}
</pre>
</div>

<p>
你也可以尝试使用反射的方式来实现，我就不列相关代码了，希望你课后可以自己思考下。<br>
</p>
</div>
</div>
<div id="outline-container-org009f362" class="outline-4">
<h4 id="org009f362">Stream</h4>
<div class="outline-text-4" id="text-org009f362">
<p>
这里我来介绍一种把 Channel 当作流式管道使用的方式，也就是把 Channel 看作流（Stream），提供跳过几个元素，或者是只取其中的几个元素等方法。<br>
</p>

<p>
首先，我们提供创建流的方法。这个方法把一个数据 slice 转换成流：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">asStream</span>(<span style="color: #8787d7;">done</span> &lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}, <span style="color: #8787d7;">values</span> ...<span style="color: #268bd2; font-weight: bold;">interface</span>{}) &lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{} {
    <span style="color: #8787d7;">s</span> := <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{}) <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#21019;&#24314;&#19968;&#20010;unbuffered&#30340;channel</span>
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21551;&#21160;&#19968;&#20010;goroutine&#65292;&#24448;s&#20013;&#22622;&#25968;&#25454;</span>
        <span style="color: #268bd2; font-weight: bold;">defer</span> <span style="color: #268bd2;">close</span>(s) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36864;&#20986;&#26102;&#20851;&#38381;chan</span>
        <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">_</span>, <span style="color: #8787d7;">v</span> := <span style="color: #268bd2; font-weight: bold;">range</span> values { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36941;&#21382;&#25968;&#32452;</span>
            <span style="color: #268bd2; font-weight: bold;">select</span> {
            <span style="color: #268bd2; font-weight: bold;">case</span> &lt;-done:
                <span style="color: #268bd2; font-weight: bold;">return</span>
            <span style="color: #268bd2; font-weight: bold;">case</span> s &lt;- v: <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#23558;&#25968;&#32452;&#20803;&#32032;&#22622;&#20837;&#21040;chan&#20013;</span>
            }
        }
    }()
    <span style="color: #268bd2; font-weight: bold;">return</span> s
}
</pre>
</div>

<p>
流创建好以后，该咋处理呢？下面我再给你介绍下实现流的方法。<br>
</p>

<ul class="org-ul">
<li>takeN：只取流中的前 n 个数据；<br></li>
<li>takeFn：筛选流中的数据，只保留满足条件的数据；<br></li>
<li>takeWhile：只取前面满足条件的数据，一旦不满足条件，就不再取；<br></li>
<li>skipN：跳过流中前几个数据；<br></li>
<li>skipFn：跳过满足条件的数据；<br></li>
<li>skipWhile：跳过前面满足条件的数据，一旦不满足条件，当前这个元素和以后的元素都会输出给 Channel 的 receiver。<br></li>
</ul>

<p>
这些方法的实现很类似，我们以 takeN 为例来具体解释一下。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">takeN</span>(<span style="color: #8787d7;">done</span> &lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}, <span style="color: #8787d7;">valueStream</span> &lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{}, <span style="color: #8787d7;">num</span> <span style="color: #df005f; font-weight: bold;">int</span>) &lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{} {
    <span style="color: #8787d7;">takeStream</span> := <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{}) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21019;&#24314;&#36755;&#20986;&#27969;</span>
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
        <span style="color: #268bd2; font-weight: bold;">defer</span> <span style="color: #268bd2;">close</span>(takeStream)
        <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := 0; i &lt; num; i++ { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21482;&#35835;&#21462;&#21069;num&#20010;&#20803;&#32032;</span>
            <span style="color: #268bd2; font-weight: bold;">select</span> {
            <span style="color: #268bd2; font-weight: bold;">case</span> &lt;-done:
                <span style="color: #268bd2; font-weight: bold;">return</span>
            <span style="color: #268bd2; font-weight: bold;">case</span> takeStream &lt;- &lt;-valueStream: <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#20174;&#36755;&#20837;&#27969;&#20013;&#35835;&#21462;&#20803;&#32032;</span>
            }
        }
    }()
    <span style="color: #268bd2; font-weight: bold;">return</span> takeStream
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcd35508" class="outline-4">
<h4 id="orgcd35508">map-reduce</h4>
<div class="outline-text-4" id="text-orgcd35508">
<p>
map-reduce 是一种处理数据的方式，最早是由 Google 公司研究提出的一种面向大规模数据处理的并行计算模型和方法，开源的版本是 hadoop，前几年比较火。<br>
</p>

<p>
不过，我要讲的并不是分布式的 map-reduce，而是单机单进程的 map-reduce 方法。<br>
</p>

<p>
map-reduce 分为两个步骤，第一步是映射（map），处理队列中的数据，第二步是规约（reduce），把列表中的每一个元素按照一定的处理方式处理成结果，放入到结果队列中。<br>
</p>

<p>
就像做汉堡一样，map 就是单独处理每一种食材，reduce 就是从每一份食材中取一部分，做成一个汉堡。<br>
</p>

<p>
我们先来看下 map 函数的处理逻辑：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">mapChan</span>(<span style="color: #8787d7;">in</span> &lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{}, <span style="color: #8787d7;">fn</span> <span style="color: #268bd2; font-weight: bold;">func</span>(<span style="color: #268bd2; font-weight: bold;">interface</span>{}) <span style="color: #268bd2; font-weight: bold;">interface</span>{}) &lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{} {
    <span style="color: #8787d7;">out</span> := <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{}) <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#21019;&#24314;&#19968;&#20010;&#36755;&#20986;chan</span>
    <span style="color: #268bd2; font-weight: bold;">if</span> in == <span style="color: #d75fd7;">nil</span> { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#24322;&#24120;&#26816;&#26597;</span>
        <span style="color: #268bd2;">close</span>(out)
        <span style="color: #268bd2; font-weight: bold;">return</span> out
    }

    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21551;&#21160;&#19968;&#20010;goroutine,&#23454;&#29616;map&#30340;&#20027;&#35201;&#36923;&#36753;</span>
        <span style="color: #268bd2; font-weight: bold;">defer</span> <span style="color: #268bd2;">close</span>(out)
        <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">v</span> := <span style="color: #268bd2; font-weight: bold;">range</span> in { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20174;&#36755;&#20837;chan&#35835;&#21462;&#25968;&#25454;&#65292;&#25191;&#34892;&#19994;&#21153;&#25805;&#20316;&#65292;&#20063;&#23601;&#26159;map&#25805;&#20316;</span>
            out &lt;- <span style="color: #d75fd7; font-weight: bold;">fn</span>(v)
        }
    }()

    <span style="color: #268bd2; font-weight: bold;">return</span> out
}
</pre>
</div>

<p>
reduce 函数的处理逻辑如下：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">reduce</span>(<span style="color: #8787d7;">in</span> &lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{}, <span style="color: #8787d7;">fn</span> <span style="color: #268bd2; font-weight: bold;">func</span>(<span style="color: #8787d7;">r</span>, <span style="color: #8787d7;">v</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{}) <span style="color: #268bd2; font-weight: bold;">interface</span>{}) <span style="color: #268bd2; font-weight: bold;">interface</span>{} {
    <span style="color: #268bd2; font-weight: bold;">if</span> in == <span style="color: #d75fd7;">nil</span> { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#24322;&#24120;&#26816;&#26597;</span>
        <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">nil</span>
    }

    <span style="color: #8787d7;">out</span> := &lt;-in <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20808;&#35835;&#21462;&#31532;&#19968;&#20010;&#20803;&#32032;</span>
    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">v</span> := <span style="color: #268bd2; font-weight: bold;">range</span> in { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#23454;&#29616;reduce&#30340;&#20027;&#35201;&#36923;&#36753;</span>
        out = <span style="color: #d75fd7; font-weight: bold;">fn</span>(out, v)
    }

    <span style="color: #268bd2; font-weight: bold;">return</span> out
}
</pre>
</div>

<p>
我们可以写一个程序，这个程序使用 map-reduce 模式处理一组整数，map 函数就是为每个整数乘以 10，reduce 函数就是把 map 处理的结果累加起来：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#29983;&#25104;&#19968;&#20010;&#25968;&#25454;&#27969;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">asStream</span>(<span style="color: #8787d7;">done</span> &lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}) &lt;-<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{} {
    <span style="color: #8787d7;">s</span> := <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">chan</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{})
    <span style="color: #8787d7;">values</span> := []<span style="color: #df005f; font-weight: bold;">int</span>{1, 2, 3, 4, 5}
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
        <span style="color: #268bd2; font-weight: bold;">defer</span> <span style="color: #268bd2;">close</span>(s)
        <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">_</span>, <span style="color: #8787d7;">v</span> := <span style="color: #268bd2; font-weight: bold;">range</span> values { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20174;&#25968;&#32452;&#29983;&#25104;</span>
            <span style="color: #268bd2; font-weight: bold;">select</span> {
            <span style="color: #268bd2; font-weight: bold;">case</span> &lt;-done:
                <span style="color: #268bd2; font-weight: bold;">return</span>
            <span style="color: #268bd2; font-weight: bold;">case</span> s &lt;- v:
            }
        }
    }()
    <span style="color: #268bd2; font-weight: bold;">return</span> s
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">in</span> := <span style="color: #d75fd7; font-weight: bold;">asStream</span>(<span style="color: #d75fd7;">nil</span>)

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">map&#25805;&#20316;: &#20056;&#20197;10</span>
    <span style="color: #8787d7;">mapFn</span> := <span style="color: #268bd2; font-weight: bold;">func</span>(<span style="color: #8787d7;">v</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{}) <span style="color: #268bd2; font-weight: bold;">interface</span>{} {
        <span style="color: #268bd2; font-weight: bold;">return</span> v.(<span style="color: #df005f; font-weight: bold;">int</span>) * 10
    }

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">reduce&#25805;&#20316;: &#23545;map&#30340;&#32467;&#26524;&#36827;&#34892;&#32047;&#21152;</span>
    <span style="color: #8787d7;">reduceFn</span> := <span style="color: #268bd2; font-weight: bold;">func</span>(<span style="color: #8787d7;">r</span>, <span style="color: #8787d7;">v</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{}) <span style="color: #268bd2; font-weight: bold;">interface</span>{} {
        <span style="color: #268bd2; font-weight: bold;">return</span> r.(<span style="color: #df005f; font-weight: bold;">int</span>) + v.(<span style="color: #df005f; font-weight: bold;">int</span>)
    }

    <span style="color: #8787d7;">sum</span> := <span style="color: #d75fd7; font-weight: bold;">reduce</span>(<span style="color: #d75fd7; font-weight: bold;">mapChan</span>(in, mapFn), reduceFn) <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#36820;&#22238;&#32047;&#21152;&#32467;&#26524;</span>
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(sum)
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org2a09584" class="outline-2">
<h2 id="org2a09584">总结</h2>
<div class="outline-text-2" id="text-org2a09584">
<p>
这节课，我借助代码示例，带你学习了 Channel 的应用场景和应用模式。这几种模式不是我们学习的终点，而是学习的起点。掌握了这几种模式之后，我们可以延伸出更多的模式。<br>
</p>

<p>
虽然 Channel 最初是基于 CSP 设计的用于 goroutine 之间的消息传递的一种数据类型，但是，除了消息传递这个功能之外，大家居然还演化出了各式各样的应用模式。我不确定 Go 的创始人在设计这个类型的时候，有没有想到这一点，但是，我确实被各位大牛利用 Channel 的各种点子折服了，比如有人实现了一个基于 TCP 网络的分布式的 Channel。<br>
</p>

<p>
在使用 Go 开发程序的时候，你也不妨多考虑考虑是否能够使用 chan 类型，看看你是不是也能创造出别具一格的应用模式。<br>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-07-03 Sun 20:05</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
