<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-11-06 Sat 17:43 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>前缀函数与KMP算法</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">前缀函数与KMP算法</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org7d71ce4">前缀函数定义</a></li>
<li><a href="#org5c0fe5f">计算前缀函数</a>
<ul>
<li><a href="#org19a2e32">朴素求法</a></li>
<li><a href="#org935e527">优化</a></li>
<li><a href="#org33a7b9d">简单解释一下为什么可以这样优化</a></li>
<li><a href="#org360986d">最终算法</a></li>
</ul>
</li>
<li><a href="#orgc32492e">Knuth-Morris-Pratt 算法</a></li>
</ul>
</div>
</div>

<div id="outline-container-org7d71ce4" class="outline-2">
<h2 id="org7d71ce4">前缀函数定义</h2>
<div class="outline-text-2" id="text-org7d71ce4">
<p>
给定一个长度为 \(n\) 的字符串 \(s\)，其前缀函数被定义为一个长度为 \(n\) 的数组 \(next\)，其中 \(next[i]\) 的定义是：<br>
</p>

<ol class="org-ol">
<li>如果子串 \(s[0 \dots i]\) 有一对相等的真前缀与真后缀：\(s[0 \dots k - 1]\) 和 \(s[i - (k - 1) \dots i]\)，那么 \(next[i]\) 就是这个相等的真前缀的长度，也就是 \(next[i] = k\)；<br></li>
<li>如果不止有一对相等的，那么 \(next[i]\) 就是其中最长的那一对的长度；<br></li>
<li>如果没有相等的，那么 \(next[i] = 0\)；<br></li>
</ol>

<p>
简单来说 \(next[i]\) 就是，子串 \(s[0 \dots i]\) 最长的相等的真前缀和真后缀的长度。<br>
</p>

<p>
用数学语言描述：\(next[i] = \max \limits_{k = 0 \dots i}{k : s[0 \dots k - 1] = s[i - (k - 1) \dots i]}\)<br>
</p>

<p>
举例说明，对于字符串 <code>ABABC</code> ：<br>
</p>
<ul class="org-ul">
<li>\(next[0] = 0\)，因为 <code>A</code> 没有真前缀和真后缀<br></li>
<li>\(next[1] = 0\)，因为 <code>AB</code> 无相等的真前缀和真后缀<br></li>
<li>\(next[2] = 1\)，因为 <code>ABA</code> 有一对相等的真前缀和真后缀： <code>A</code> ，长度为 \(1\)<br></li>
<li>\(next[3] = 2\)，因为 <code>ABAB</code> 相等的真前缀和真后缀只有： <code>AB</code> ，长度为 \(2\)<br></li>
<li>\(next[4] = 0\)，因为 <code>ABABC</code> 没有相等的真前缀和真后缀<br></li>
</ul>
</div>
</div>
<div id="outline-container-org5c0fe5f" class="outline-2">
<h2 id="org5c0fe5f">计算前缀函数</h2>
<div class="outline-text-2" id="text-org5c0fe5f">
</div>
<div id="outline-container-org19a2e32" class="outline-3">
<h3 id="org19a2e32">朴素求法</h3>
<div class="outline-text-3" id="text-org19a2e32">
<p>
遍历字符串，每次计算当前的前缀函数值 \(next[i]\) 时，令变量 \(j\) 从最大的真前缀开始尝试，如果当前长度下真前缀和真后缀不相等，则令 \(j\) 自减 \(1\)，继续匹配，直到找到最长相等的真前缀和真后缀，如果 \(j = 0\) 并且仍没有匹配成功，\(next[i] = 0\)。<br>
</p>
</div>
</div>
<div id="outline-container-org935e527" class="outline-3">
<h3 id="org935e527">优化</h3>
<div class="outline-text-3" id="text-org935e527">
<blockquote>
<p>
相邻的前缀函数值至多增加 \(1\)<br>
</p>
</blockquote>

<p>
假如现在要获取字符串 <code>ABAABAABAABA</code> 的前缀函数，且我们已经得到了前面 \(11\) 个子串的前缀函数值：\(next[] = \{0, 0, 1, 1, 2, 3, 4, 5, 6, 7, 8, ?\}\)，接下来需要得到子串长度为 \(12\) 的前缀值：<br>
</p>

<p>
先看子串长度为 \(11\) 的最长的相等真前后缀：也就是下图中分别用绿色下划线和橘色下划线标出的子串，在判断长度为 \(12\) 的子串的最长相等真前后缀时，不需要再重新遍历，由于相邻的前缀函数值至多增加 \(1\)，所以先判断绿色下划线标出的子串下一个位置是否等于橘色下划线标出的子串下一个位置是否相等，也就是判断 \(s[j]\) 是否等于 \(s[i]\)，如果相等那么子串长度为 \(12\) 的最长相等真前后缀就是 \(next[11] = next[10] + 1 = 9\)。<br>
</p>

<img src="./images/KMP01.png" />

<p>
如果不相等呢？我们现在把最后一个字符换成 <code>C</code> ，接着讨论：<br>
</p>

<img src="./images/KMP02.png" />

<p>
现在 \(s[j] != s[i]\)，令 \(j = next[j - 1]\)，然后接着匹配，为什么呢？我们来看看 \(j = next[j - 1] = 5\) 之后箭头的变化：<br>
</p>

<img src="./images/KMP03.png" />

<p>
发现，\(j\) 前面的子串和 \(i\) 前面的一段子串能够匹配，如果 \(s[j] == s[i]\)，那么 \(next[i] = next[j - 1] + 1\)，如果 \(s[j] != s[j]\)，继续 \(j = next[j - 1]\)，直到匹配成功，或者 \(next[i] = 0\)。<br>
</p>
</div>
</div>
<div id="outline-container-org33a7b9d" class="outline-3">
<h3 id="org33a7b9d">简单解释一下为什么可以这样优化</h3>
<div class="outline-text-3" id="text-org33a7b9d">
<p>
首先相邻的前缀函数值至多增加 \(1\)，这句不需要证明了，仔细想一下就能知道，所以需要 \(next[i]\) 尽可能大，必然要求后缀新增的 \(s[i]\) 也与前缀新增的字符匹配，即 \(s[i] = s[next[i - 1]]\)，如果匹配，\(next[i] = next[i - 1] + 1\)；<br>
</p>

<p>
如果不匹配，我们希望找到对于子串 \(s[0 \dots i - 1]\)，仅次于 \(next[i - 1]\) 的第二长度 \(j\)，使得在位置 \(i - 1\) 的前缀性质仍得以保持，也即 \(s[0 \dots j - 1] = s[i - j \dots i - 1]\)：<br>
</p>

<p>
\[\overbrace{\underbrace{s_0 ~ s_1}_j ~ s_2 ~ s_3}^{next[i - 1]} ~ \dots ~ \overbrace{s_{i-3} ~ \underbrace{s_{i-2} ~ s_{i-1}}_j}^{next[i - 1]} ~ s{i}\]<br>
</p>

<p>
如果我们找到这样的长度 \(j\)，那么仅需要再次比较 \(s[i]\) 与 \(s[j]\)。如果它们相等，那么就有 \(next[i] = j + 1\)，否则我们需要找到子串 \(s[0 \dots i]\) 中仅次于 \(j\) 的第二长度 \(j^{(2)}\)，使得前缀性质得以保持，如此反复，直到 \(j = 0\)。如果 \(s[i] != s[0]\)，则 \(next[i] = 0\)。<br>
</p>

<p>
观察上图发现，因为 \(s[0 \dots next[i - 1] - 1] = s[i - next[i - 1] \dots i - 1]\)，所以 \(s[0 \dots i - 1]\) 的第二长度 \(j\) 有这样的性质：\(s[0 \dots j - 1] = s[i - j \dots i - 1] = s[next[i - 1] - j \dots next[i - 1] - 1]\)<br>
</p>

<p>
也就是说 \(j\) 等价于子串 \(s[next[i - 1] - 1]\) 的前缀函数值，即 \(j = next[next[i - 1] - 1]\)，同理，次于 \(j\) 的第二长度等价于 \(s[j - 1]\) 的前缀函数值，\(j^{(2)} = next[j - 1]\)<br>
</p>

<p>
关于 \(j\) 的状态转移方程：\(j^{(n)} = next[j^{(n - 1)} - 1], (j^{(n - 1)} > 0)\)<br>
</p>
</div>
</div>
<div id="outline-container-org360986d" class="outline-3">
<h3 id="org360986d">最终算法</h3>
<div class="outline-text-3" id="text-org360986d">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #AFAFAF;">void</span> <span style="color: #AFAFAF;">prefix_table</span>(<span style="color: #AFAFAF;">char</span> <span style="color: #AFAFAF;">pattern</span>[]) {
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">n</span> = strlen(pattern);
    <span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">i</span> = <span style="color: #009F9F;">1</span>; i &lt; n; ++ i) {
        <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">j</span> = ne[i - <span style="color: #009F9F;">1</span>];
        <span style="color: #BD93F9;">while</span> (j &gt; <span style="color: #009F9F;">0</span> &amp;&amp; pattern[i] != pattern[j])
            j = ne[j - <span style="color: #009F9F;">1</span>];
        <span style="color: #BD93F9;">if</span> (pattern[i] == pattern[j])
            j ++ ;
        ne[i] = j;
    }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc32492e" class="outline-2">
<h2 id="orgc32492e">Knuth-Morris-Pratt 算法</h2>
<div class="outline-text-2" id="text-orgc32492e">
<p>
该算法由 Knuth、Pratt 和 Morris 在 1977 年共同发布，简称 KMP 算法，<br>
</p>

<p>
给出一个文本串 \(text\) 与一个模式串 \(pattern\)，我们可以将其拼接在一起 \(pattern + "_" + text\)，其中 <code>_</code> 是两个串中都没出现的字符。再使用上面的求前缀函数的算法，如果某个位置的前缀值是 \(len(pattern)\)，那么说明找到了一个 \(pattern\)。<br>
</p>

<p>
如果没有说明有什么字符是不包含的，那就把判断条件改为当 \(j\) 到 \(len(pattern)\) 时发现模式串。<br>
</p>
</div>
</div>
</div>
</body>
</html>
