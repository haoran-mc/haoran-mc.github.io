<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-01-10 Mon 22:29 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>文件</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">文件</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgf77a446">文件类型指针</a></li>
<li><a href="#org8f341c1">文件的使用方式</a></li>
<li><a href="#orgb3db30f">常用函数</a>
<ul>
<li><a href="#org5badfda">fopen :: 打开指定文件，返回FILE类型指针</a></li>
<li><a href="#org7fc489b">fclose :: 关闭FILE指针指向的文件</a></li>
<li><a href="#org143ce6e">fread :: 将fp指向的文件的内容写入指定的buffer中</a></li>
<li><a href="#org7a409bd">fwrite :: 将buffer中的数据写入fp指向的文件</a></li>
<li><a href="#org232d497">fscanf :: 格式化写入文件，%d, %c&#x2026;&#x2026;</a></li>
<li><a href="#orga9835d4">fprintf :: 格式化从文件读出，%d, %c&#x2026;&#x2026;</a></li>
<li><a href="#org988aaec">fgets :: 从文件中读取字符串并存入str中</a></li>
<li><a href="#orge91137f">fputs :: 将字符串输出到fp指向的文件中</a></li>
<li><a href="#orgd0c503d">fgetc :: 从文件中读取一个字符</a></li>
<li><a href="#org3e5a900">fputc :: 向文件中写入一个字符</a></li>
</ul>
</li>
<li><a href="#org73e6aa7">文件读写</a>
<ul>
<li><a href="#org44c97ac">关闭文件</a></li>
<li><a href="#org0b52596">写入文件</a></li>
<li><a href="#orgcd37189">读取文件</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgf77a446" class="outline-2">
<h2 id="orgf77a446">文件类型指针</h2>
</div>
<div id="outline-container-org8f341c1" class="outline-2">
<h2 id="org8f341c1">文件的使用方式</h2>
<div class="outline-text-2" id="text-org8f341c1">
<p>
您可以使用 fopen( ) 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：<br>
<code>FILE *fopen( const char * filename, const char * mode );</code><br>
在这里，filename 是字符串，用来命名文件，访问模式 mode 的值可以是下列值中的一个：<br>
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">模式</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">r</td>
<td class="org-left">打开一个已有的文本文件，允许读取文件</td>
</tr>

<tr>
<td class="org-left">w</td>
<td class="org-left">打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入</td>
</tr>

<tr>
<td class="org-left">a</td>
<td class="org-left">打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容</td>
</tr>

<tr>
<td class="org-left">r+</td>
<td class="org-left">打开一个文本文件，允许读写文件</td>
</tr>

<tr>
<td class="org-left">w+</td>
<td class="org-left">打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件</td>
</tr>

<tr>
<td class="org-left">a+</td>
<td class="org-left">打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式</td>
</tr>
</tbody>
</table>

<p>
如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式："rb", "wb", "ab", "rb+", "r+b", "wb+", "w+b", "ab+", "a+b"<br>
</p>
</div>
</div>
<div id="outline-container-orgb3db30f" class="outline-2">
<h2 id="orgb3db30f">常用函数</h2>
<div class="outline-text-2" id="text-orgb3db30f">
</div>
<div id="outline-container-org5badfda" class="outline-3">
<h3 id="org5badfda">fopen :: 打开指定文件，返回FILE类型指针</h3>
<div class="outline-text-3" id="text-org5badfda">
<p>
fopen(文件路径, 文件使用方式);<br>
</p>

<p>
fopen 打开指定文件，放回一个指向 FILE 类型的指针，无论使用哪种方式，当文件打开时出现了错误，fopen 都将放回 NULL。<br>
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #AFAFAF;">FILE</span> *<span style="color: #AFAFAF;">fp</span>;
fp = fopen(<span style="color: #FC9F4E;">"C:\\in.txt"</span>, <span style="color: #FC9F4E;">"r"</span>);
</pre>
</div>
</div>
</div>
<div id="outline-container-org7fc489b" class="outline-3">
<h3 id="org7fc489b">fclose :: 关闭FILE指针指向的文件</h3>
<div class="outline-text-3" id="text-org7fc489b">
<p>
fclose(文件指针);<br>
</p>

<p>
若文件关闭成功则返回0，否则返回非0。<br>
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #AFAFAF;">fclose</span>(fp);
</pre>
</div>
</div>
</div>
<div id="outline-container-org143ce6e" class="outline-3">
<h3 id="org143ce6e">fread :: 将fp指向的文件的内容写入指定的buffer中</h3>
<div class="outline-text-3" id="text-org143ce6e">
<p>
unsigned int fread(void *buffer, unsigned int size, unsigned int count, FILE *fp);<br>
</p>

<p>
fread(内存首地址，数据块大小，数据块个数，文件指针);<br>
</p>

<p>
从fp所指向的文件中读取数据块并存储到 buffer 所指向的内存中，buffer 是待读入数据块存储的起始地址，size 是每个数据块的大小，count 是最多允许读取的数据块个数，函数返回的是实际读入的数据块个数。<br>
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #AFAFAF;">char</span> <span style="color: #AFAFAF;">str</span>[<span style="color: #009F9F;">20</span>];
<span style="color: #AFAFAF;">fread</span>(str, <span style="color: #BD93F9;">sizeof</span>(<span style="color: #AFAFAF;">char</span>), <span style="color: #009F9F;">4</span>, fp);
</pre>
</div>
</div>
</div>
<div id="outline-container-org7a409bd" class="outline-3">
<h3 id="org7a409bd">fwrite :: 将buffer中的数据写入fp指向的文件</h3>
<div class="outline-text-3" id="text-org7a409bd">
<p>
unsigned int fwrite(const void *buffer, unsigned int size, unsigned int count, FILE *fp);<br>
</p>

<p>
fwrite(内存首地址，数据块大小，数据块个数，文件指针);<br>
</p>

<p>
将 buffer 指向的内存中的数据块写入 fp 所指的文件，buffer 是待输出数据块的起始地址，size 是每个数据块的大小，count 是最多允许写入的数据块个数（每个数据块size个字节），函数返回的是实际写入的数据块个数。<br>
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #AFAFAF;">char</span> <span style="color: #AFAFAF;">str</span>[<span style="color: #009F9F;">20</span>] = <span style="color: #FC9F4E;">"text"</span>;
<span style="color: #AFAFAF;">fwrite</span>(str, <span style="color: #BD93F9;">sizeof</span>(<span style="color: #AFAFAF;">char</span>), <span style="color: #009F9F;">4</span>, fp);
</pre>
</div>
</div>
</div>
<div id="outline-container-org232d497" class="outline-3">
<h3 id="org232d497">fscanf :: 格式化写入文件，%d, %c&#x2026;&#x2026;</h3>
<div class="outline-text-3" id="text-org232d497">
<p>
int fscanf (FILE *fp, const char *format, &#x2026;);<br>
</p>

<p>
fscanf(文件指针, 格式字符, 输入列表);<br>
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #AFAFAF;">fscanf</span>(fp, <span style="color: #FC9F4E;">"%d %c"</span>, &amp;a, &amp;c);
</pre>
</div>
</div>
</div>
<div id="outline-container-orga9835d4" class="outline-3">
<h3 id="orga9835d4">fprintf :: 格式化从文件读出，%d, %c&#x2026;&#x2026;</h3>
<div class="outline-text-3" id="text-orga9835d4">
<p>
int fprintf(FILE *fp, const char *format, &#x2026;);<br>
</p>

<p>
fprintf(文件指针，格式字符，输出列表);<br>
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #AFAFAF;">char</span> <span style="color: #AFAFAF;">c</span> = <span style="color: #FC9F4E;">'a'</span>;
<span style="color: #AFAFAF;">fprintf</span>(fp, <span style="color: #FC9F4E;">"%c"</span>, c);
</pre>
</div>
</div>
</div>
<div id="outline-container-org988aaec" class="outline-3">
<h3 id="org988aaec">fgets :: 从文件中读取字符串并存入str中</h3>
<div class="outline-text-3" id="text-org988aaec">
<p>
char *fgets(char *str, int n, FILE *fp);<br>
</p>

<p>
从 fp 所指的文件中读取字符串并在字符串末尾添加 '\0', 然后存入 str，最多读 n - 1 个字符，当读到回车换行符，到达文件尾或读满 n - 1 个字符时，就停止读取。<br>
</p>

<p>
返回该字符串的首地址，读取失败就返回 NULL。<br>
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #AFAFAF;">char</span> <span style="color: #AFAFAF;">str</span>[<span style="color: #009F9F;">20</span>];
<span style="color: #AFAFAF;">fgets</span>(str, <span style="color: #009F9F;">20</span>, fp);
</pre>
</div>
</div>
</div>
<div id="outline-container-orge91137f" class="outline-3">
<h3 id="orge91137f">fputs :: 将字符串输出到fp指向的文件中</h3>
<div class="outline-text-3" id="text-orge91137f">
<p>
fputs(const char *str, FILE *fp);<br>
</p>

<p>
将字符串输出到 fp 所指的文件中，fputs 不会在写入文件的字符串末尾加上换行符。<br>
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #AFAFAF;">char</span> <span style="color: #AFAFAF;">str</span>[<span style="color: #009F9F;">20</span>] = <span style="color: #FC9F4E;">"abc"</span>;
<span style="color: #AFAFAF;">fputs</span>(str, fp);
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd0c503d" class="outline-3">
<h3 id="orgd0c503d">fgetc :: 从文件中读取一个字符</h3>
<div class="outline-text-3" id="text-orgd0c503d">
<p>
int fgetc(FILE *fp);<br>
</p>

<p>
从文件中读取一个字符，如果读取成功，则返回该字符；若读取不成功则放回 EOF（EOF 是一个符号常量，stdio.h 中定义为 -1）。<br>
</p>
</div>
</div>
<div id="outline-container-org3e5a900" class="outline-3">
<h3 id="org3e5a900">fputc :: 向文件中写入一个字符</h3>
<div class="outline-text-3" id="text-org3e5a900">
<p>
int fputc(int c, FILE *fp);<br>
</p>

<p>
将字符 c 写到文件中，若写入错误返回 EOF，否则返回字符 c。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org73e6aa7" class="outline-2">
<h2 id="org73e6aa7">文件读写</h2>
<div class="outline-text-2" id="text-org73e6aa7">
<p>
一个文件，无论它是文本文件还是二进制文件，都是代表了一系列的字节。C 语言不仅提供了访问顶层的函数，也提供了底层（OS）调用来处理存储设备上的文件。本章将讲解文件管理的重要调用<br>
</p>
</div>
<div id="outline-container-org44c97ac" class="outline-3">
<h3 id="org44c97ac">关闭文件</h3>
<div class="outline-text-3" id="text-org44c97ac">
<p>
为了关闭文件，请使用 fclose( ) 函数。函数的原型如下：<br>
</p>

<p>
<code>int fclose( FILE *fp );</code><br>
</p>

<p>
如果成功关闭文件，fclose( ) 函数返回零，如果关闭文件时发生错误，函数返回 EOF。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 stdio.h 中的常量<br>
</p>

<p>
C 标准库提供了各种函数来按字符或者以固定长度字符串的形式读写文件<br>
</p>
</div>
</div>
<div id="outline-container-org0b52596" class="outline-3">
<h3 id="org0b52596">写入文件</h3>
<div class="outline-text-3" id="text-org0b52596">
<p>
下面是把字符写入到流中的最简单的函数：<br>
<code>int fputc( int c, FILE *fp );</code><br>
</p>

<p>
函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF。您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中：<br>
<code>int fputs( const char *s, FILE *fp );</code><br>
</p>

<p>
函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF<br>
<code>也可以使用 int fprintf(FILE *fp,const char *format, ...)</code> 函数把一个字符串写入到文件中<br>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #009F9F;">#include</span> <span style="color: #FC9F4E;">&lt;stdio.h&gt;</span>

<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">main</span>() {
    <span style="color: #AFAFAF;">FILE</span> *<span style="color: #AFAFAF;">fp</span> = <span style="color: #009F9F;">NULL</span>;

    fp = fopen(<span style="color: #FC9F4E;">"/tmp/test.txt"</span>, <span style="color: #FC9F4E;">"w+"</span>);
    fprintf(fp, <span style="color: #FC9F4E;">"This is testing for fprintf...\n"</span>);
    fputs(<span style="color: #FC9F4E;">"This is testing for fputs...\n"</span>, fp);
    fclose(fp);
}
</pre>
</div>
<p>
当上面的代码被编译和执行时，它会在 /tmp 目录中创建一个新的文件 test.txt，并使用两个不同的函数写入两行<br>
</p>
</div>
</div>
<div id="outline-container-orgcd37189" class="outline-3">
<h3 id="orgcd37189">读取文件</h3>
<div class="outline-text-3" id="text-orgcd37189">
<p>
下面是从文件读取单个字符的最简单的函数：<br>
<code>int fgetc( FILE * fp );</code><br>
fgetc()函数从fp所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 EOF<br>
</p>

<p>
下面的函数允许您从流中读取一个字符串：<br>
<code>char *fgets( char *buf, int n, FILE *fp );</code><br>
函数fgets()从fp所指向的输入流中读取n-1个字符。它会把读取的字符串复制到缓冲区buff，并在最后追加一个null字符来终止字符串<br>
如果这个函数在读取最后一个字符之前就遇到一个换行符'\n'或文件的末尾EOF，则只会返回读取到的字符，包括换行符<br>
</p>

<p>
<code>也可以使用 int fscanf(FILE *fp, const char *format, ...)</code> 函数来从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取<br>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #009F9F;">#include</span> <span style="color: #FC9F4E;">&lt;stdio.h&gt;</span>

<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">main</span>() {
    <span style="color: #AFAFAF;">FILE</span> *<span style="color: #AFAFAF;">fp</span> = <span style="color: #009F9F;">NULL</span>;
    <span style="color: #AFAFAF;">char</span> <span style="color: #AFAFAF;">buff</span>[<span style="color: #009F9F;">255</span>];

    fp = fopen(<span style="color: #FC9F4E;">"/tmp/test.txt"</span>, <span style="color: #FC9F4E;">"r"</span>);
    fscanf(fp, <span style="color: #FC9F4E;">"%s"</span>, buff);
    printf(<span style="color: #FC9F4E;">"1: %s\n"</span>, buff );

    fgets(buff, <span style="color: #009F9F;">255</span>, (<span style="color: #AFAFAF;">FILE</span>*)fp);
    printf(<span style="color: #FC9F4E;">"2: %s\n"</span>, buff );

    fgets(buff, <span style="color: #009F9F;">255</span>, (<span style="color: #AFAFAF;">FILE</span>*)fp);
    printf(<span style="color: #FC9F4E;">"3: %s\n"</span>, buff );
    fclose(fp);
}
</pre>
</div>

<p>
当上面的代码被编译和执行时，它会读取上一部分创建的文件，产生下列结果：<br>
</p>

<pre class="example" id="org0a8f334">
1: This
2: is testing for fprintf...
3: This is testing for fputs...
</pre>

<p>
首先，fscanf() 方法只读取了This，因为它在后边遇到了一个空格。其次调用fgets()读取剩余的部分，直到行尾。最后调用fgets()完整地读取第二行<br>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2021-05-26 16:05 三</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-01-10 Mon 22:29</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
