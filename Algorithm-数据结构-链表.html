<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-12-01 Wed 15:02 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>链表</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran &lt;haoran.mc@outlook.com&gt;">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">链表</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org38ae985">链表</a></li>
<li><a href="#org67811a8">链表分类</a>
<ul>
<li><a href="#org7633d25">动态链表</a></li>
<li><a href="#org064ab34">静态链表</a></li>
</ul>
</li>
<li><a href="#org850316a">单链表</a>
<ul>
<li><a href="#orgb0f5902">邻接表</a>
<ul>
<li><a href="#orge6cd561">链式前向星</a></li>
</ul>
</li>
<li><a href="#orgfdfb51b">逆序单链表</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org38ae985" class="outline-2">
<h2 id="org38ae985">链表</h2>
<div class="outline-text-2" id="text-org38ae985">
<p>
链表可以通过指针+结构体实现，但在算法竞赛中，通常使用数组模拟<br>
堆栈，队列也是优先用数组模拟，STL虽好，但不宜重度依赖<br>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #BD93F9;">struct</span> <span style="color: #AFAFAF;">Node</span> {
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">val</span>;
    <span style="color: #AFAFAF;">Node</span> *<span style="color: #AFAFAF;">nxet</span>;
};
</pre>
</div>
<ol class="org-ol">
<li>效率，使用指针时，每次都要new一个新的结点，这个太慢了<br></li>
<li>如果是预先创建好结点，那就和数组模拟没有差别<br></li>
</ol>
</div>
</div>
<div id="outline-container-org67811a8" class="outline-2">
<h2 id="org67811a8">链表分类</h2>
<div class="outline-text-2" id="text-org67811a8">
</div>
<div id="outline-container-org7633d25" class="outline-3">
<h3 id="org7633d25">动态链表</h3>
<div class="outline-text-3" id="text-org7633d25">
<ul class="org-ul">
<li>链表的内存空间<br>
<ul class="org-ul">
<li>为链表结点分配内存空间<br></li>
<li>内存泄漏<br></li>
<li>内存释放<br></li>
</ul></li>
<li>创建动态链表<br>
<ul class="org-ul">
<li>遍历链表<br></li>
<li>链表的插入<br></li>
<li>链表的删除<br></li>
</ul></li>
</ul>

<p>
建立链表的算法为：<br>
</p>
<ol class="org-ol">
<li>生成一个结点并输入数据，如果数据域非空，则使头指针指向该结点，指针域置空。<br></li>
<li>生成新结点并输入数据，然后将该结点插入链表。<br></li>
<li>重复步骤(2)直到结束输入。<br></li>
<li>将尾结点的指针域置空。<br></li>
</ol>
</div>
</div>
<div id="outline-container-org064ab34" class="outline-3">
<h3 id="org064ab34">静态链表</h3>
<div class="outline-text-3" id="text-org064ab34">
<div class="org-src-container">
<pre class="src src-C++">&#21407;&#29702;&#65306;hash
<span style="color: #BD93F9;">struct</span> Node {
    <span style="color: #BD93F9;">typedef</span> <span style="color: #AFAFAF;">data</span>;
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">next</span>;
} node[<span style="color: #009F9F;">1000</span>];

node[<span style="color: #009F9F;">0</span>].next = <span style="color: #009F9F;">1</span>;
node[<span style="color: #009F9F;">1</span>].next = <span style="color: #009F9F;">2</span>;
node[<span style="color: #009F9F;">2</span>].next = <span style="color: #009F9F;">3</span>;
node[<span style="color: #009F9F;">3</span>].next = <span style="color: #009F9F;">4</span>;
node[<span style="color: #009F9F;">4</span>].next = <span style="color: #009F9F;">5</span>;
node[<span style="color: #009F9F;">5</span>].next = <span style="color: #009F9F;">6</span>;
node[<span style="color: #009F9F;">6</span>].next = <span style="color: #009F9F;">7</span>;
node[<span style="color: #009F9F;">7</span>].next = <span style="color: #009F9F;">8</span>;
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org850316a" class="outline-2">
<h2 id="org850316a">单链表</h2>
<div class="outline-text-2" id="text-org850316a">
</div>
<div id="outline-container-orgb0f5902" class="outline-3">
<h3 id="orgb0f5902">邻接表</h3>
<div class="outline-text-3" id="text-orgb0f5902">
</div>
<div id="outline-container-orge6cd561" class="outline-4">
<h4 id="orge6cd561">链式前向星</h4>
<div class="outline-text-4" id="text-orge6cd561">
<p>
邻接表的改进方法，用邻接表非常节省空间，然而如果空间及其紧张，可以使用邻接表的改进方法-链式前向星。<br>
</p>

<p>
它是空间效率最高的存储方法，因为它用静态数组模拟邻接表，没有任何浪费。<br>
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #7c7c7c; font-style: italic;">// </span><span style="color: #7c7c7c; font-style: italic;">&#36825;&#31181;&#30340;&#37051;&#25509;&#34920;&#21644;&#19968;&#33324;&#30340;&#37051;&#25509;&#34920;&#19981;&#19968;&#26679;&#65292;&#36825;&#20010;&#26159;&#25353;&#36755;&#20837;&#30340;&#20498;&#24207;&#23384;&#20648;&#30340;</span>
<span style="color: #7c7c7c; font-style: italic;">// </span><span style="color: #7c7c7c; font-style: italic;">&#22914;&#26524;&#20174;head[x]&#24320;&#22987;&#25628;&#32034;&#65292;&#24471;&#21040;&#30340;&#26159;&#26368;&#21518;&#19968;&#27425;&#21152;&#20837;&#21040;&#38142;&#34920;x&#30340;&#36793;tot</span>
<span style="color: #7c7c7c; font-style: italic;">// </span><span style="color: #7c7c7c; font-style: italic;">vert[tot]&#65292;edge[tot]&#23384;&#20648;&#30340;&#26159;&#19982;x&#30456;&#36830;&#30340;&#33410;&#28857;&#21644;&#26435;&#20540;&#65292;&#28982;&#21518;&#36827;&#34892;&#25805;&#20316;</span>
<span style="color: #7c7c7c; font-style: italic;">// </span><span style="color: #7c7c7c; font-style: italic;">i = next[i]&#65292;&#27492;&#26102;i&#26159;x&#32467;&#28857;&#19978;&#19968;&#27425;&#28155;&#21152;&#30340;&#36793;&#65292;&#25152;&#20197;&#26159;&#20498;&#24207;&#25171;&#21360;</span>
<span style="color: #7c7c7c; font-style: italic;">//</span><span style="color: #7c7c7c; font-style: italic;">&#21152;&#20837;&#26377;&#21521;&#36793;(x, y)&#65292;&#26435;&#20540;&#20026;z</span>
<span style="color: #AFAFAF;">void</span> <span style="color: #AFAFAF;">add</span>(<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">x</span>, <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">y</span>, <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">z</span>) {
    vert[++tot] = y;
    edge[tot]   = z;
    next[tot]   = head[x];
    head[x] = tot;
}
<span style="color: #7c7c7c; font-style: italic;">//</span><span style="color: #7c7c7c; font-style: italic;">&#35775;&#38382;&#20174;x&#20986;&#21457;&#30340;&#25152;&#26377;&#36793;</span>
<span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">i</span> = head[x]; i; i = next[i]) {
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">y</span> = vert[i];
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">z</span> = edge[i];
    printf(<span style="color: #FC9F4E;">"%d %d %d\n"</span>, x, y, z);
}
</pre>
</div>
<p>
上面的代码片段用数组模拟链表的方式存储了一张带权有向图的邻接表结构。<br>
</p>

<p>
对于无向图，使用"成对变换"的位运算性质，如果 \(vert[i]\) 是第 \(i\) 条边的终点，那么 \(vert[i xor 1]\) 就是第 \(i\) 条边的起点。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-orgfdfb51b" class="outline-3">
<h3 id="orgfdfb51b">逆序单链表</h3>
<div class="outline-text-3" id="text-orgfdfb51b">
<ul class="org-ul">
<li>逆序链表递归<br></li>
<li>逆序链表迭代<br></li>
</ul>
</div>
</div>
</div>
</div>
</body>
</html>
