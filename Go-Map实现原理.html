<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-04-17 Sun 14:32 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>MAP实现原理</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">MAP实现原理</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org52c7245">什么是 map</a>
<ul>
<li><a href="#org91fedb9">key value 存储</a></li>
<li><a href="#org0d487c8">hash 冲突</a></li>
</ul>
</li>
<li><a href="#orgc1e5793">go 中 map 的使用</a></li>
<li><a href="#org4bf16b7">go 中 map 的实现原理</a></li>
</ul>
</div>
</div>

<div id="outline-container-org52c7245" class="outline-2">
<h2 id="org52c7245">什么是 map</h2>
<div class="outline-text-2" id="text-org52c7245">
</div>
<div id="outline-container-org91fedb9" class="outline-3">
<h3 id="org91fedb9">key value 存储</h3>
<div class="outline-text-3" id="text-org91fedb9">
<p>
Map 是一种通过 key 来获取 value 的数据结构，其底层存储方式为数组，在存储时 key 不能重复，当 key 重复时，value 进行覆盖，我们通过 key 进行 hash 运算（可以简单理解为把 key 转化为一个整形数字）然后对数组的长度取余，得到 key 存储在数组的哪个下标位置，最后将 key 和 value 组装为一个结构体，放入数组下标处，看下图：<br>
</p>

<div class="org-src-container">
<pre class="src src-go">length = <span style="color: #268bd2;">len</span>(array) = 4

hashkey1 = <span style="color: #d75fd7; font-weight: bold;">hash</span>(<span style="color: #2aa198;">"xiaoming"</span>)    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20551;&#35774;&#36825;&#20010; hash &#20989;&#25968;&#36816;&#31639;&#24471;&#21040;&#30340;&#32467;&#26524;&#26159; 4</span>
index1 = hashkey1 % length     <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">index1 = 0</span>

hashkey2 = <span style="color: #d75fd7; font-weight: bold;">hash</span>(<span style="color: #2aa198;">"xiaoli"</span>)      <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20551;&#35774;&#36825;&#20010; hash &#20989;&#25968;&#36816;&#31639;&#24471;&#21040;&#30340;&#32467;&#26524;&#26159; 6</span>
index2 = hashkey2 % length     <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">index2 = 2</span>
</pre>
</div>

<img src="./images/go_map_哈希.png" />
</div>
</div>
<div id="outline-container-org0d487c8" class="outline-3">
<h3 id="org0d487c8">hash 冲突</h3>
<div class="outline-text-3" id="text-org0d487c8">
<p>
如上图所示，数组一个下标处只能存储一个元素，也就是说一个数组下标只能存储一对 (key，value), hashkey(xiaoming)=4 占用了下标 0 的位置，假设我们遇到另一个 key，hashkey(xiaowang) 也是 4，这就是 hash 冲突（不同的 key经过 hash 之后得到的值一样），那么 key=xiaowang 的怎么存储？hash 冲突的常见解决方法：<br>
</p>

<ul class="org-ul">
<li><p>
<b>开放定址法</b> ：也就是说当我们存储一个 (key，value) 时，发现 hashkey(key) 的下标已经被别 key 占用，那我们在这个数组空间中重新找一个没被占用的存储这个冲突的 key，那么没被占用的有很多，找哪个好呢？常见的有 <span class="underline">线性探测法，线性补偿探测法，随机探测法</span> ，这里我们主要说一下线性探测法：<br>
</p>

<p>
<b>线性探测</b> ，字面意思就是按照顺序来，从冲突的下标处开始往后探测，到达数组末尾时，从数组开始处探测，直到找到一个空位置存储这个 key，当数组都找不到的情况下会扩容（事实上当数组容量快满的时候就会扩容了）；查找某一个 key 的时候，找到 key 对应的下标，比较 key 是否相等，如果相等直接取出来，否则按照顺序探测直到碰到一个空位置，说明 key 不存在。<br>
</p></li>

<li><b>拉链法</b> ：何为拉链，简单理解为链表，当 key 的 hash 冲突时，我们 <span class="underline">在冲突位置的元素上形成一个链表</span> ，通过指针互连接，当查找时，发现 key 冲突，顺着链表一直往下找，直到链表的尾节点，找不到则返回空。<br></li>
</ul>

<p>
开放定址（线性探测）和拉链的优缺点：<br>
</p>
<ul class="org-ul">
<li>由上面可以看出拉链法比线性探测处理简单<br></li>
<li>线性探测查找是会比拉链法查找更消耗时间<br></li>
<li>线性探测会更加容易导致扩容，而拉链不会<br></li>
<li>拉链存储了指针，所以空间上会比线性探测占用多一点<br></li>
<li>拉链是动态申请存储空间的，所以更适合链长不确定的<br></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgc1e5793" class="outline-2">
<h2 id="orgc1e5793">go 中 map 的使用</h2>
<div class="outline-text-2" id="text-orgc1e5793">
<p>
直接用代码描述，直观，简单，易理解<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#30452;&#25509;&#21019;&#24314;&#21021;&#22987;&#21270;&#19968;&#20010; map</span>
<span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">mapInit</span> = <span style="color: #268bd2; font-weight: bold;">map</span>[<span style="color: #df005f; font-weight: bold;">string</span>]<span style="color: #df005f; font-weight: bold;">string</span> {<span style="color: #2aa198;">"xiaoli"</span>:<span style="color: #2aa198;">"&#28246;&#21335;"</span>, <span style="color: #2aa198;">"xiaoliu"</span>:<span style="color: #2aa198;">"&#22825;&#27941;"</span>}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22768;&#26126;&#19968;&#20010; map &#31867;&#22411;&#21464;&#37327;</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">map &#30340; key &#30340;&#31867;&#22411;&#26159; string&#65307;value &#30340;&#31867;&#22411;&#26159; string</span>
<span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">mapTemp</span> <span style="color: #268bd2; font-weight: bold;">map</span>[<span style="color: #df005f; font-weight: bold;">string</span>]<span style="color: #df005f; font-weight: bold;">string</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20351;&#29992; make &#20989;&#25968;&#21021;&#22987;&#21270;&#36825;&#20010;&#21464;&#37327;&#65292;&#24182;&#25351;&#23450;&#22823;&#23567;&#65288;&#20063;&#21487;&#20197;&#19981;&#25351;&#23450;&#65289;</span>
mapTemp = <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">map</span>[<span style="color: #df005f; font-weight: bold;">string</span>]<span style="color: #df005f; font-weight: bold;">string</span>, 10)

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#23384;&#20648; (key, value)</span>
mapTemp[<span style="color: #2aa198;">"xiaoming"</span>] = <span style="color: #2aa198;">"&#21271;&#20140;"</span>
mapTemp[<span style="color: #2aa198;">"xiaowang"</span>] = <span style="color: #2aa198;">"&#27827;&#21271;"</span>

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#26681;&#25454; key &#33719;&#21462; value,</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22914;&#26524; key &#23384;&#22312;&#65292;&#21017; ok &#26159; true&#65292;&#21542;&#21017;&#26159; flase</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">v1 &#29992;&#26469;&#25509;&#25910; key &#23545;&#24212;&#30340; value&#65292;&#24403; ok &#26159; false &#26102;&#65292;v1 &#26159; nil</span>
<span style="color: #8787d7;">v1</span>, <span style="color: #8787d7;">ok</span> := mapTemp[<span style="color: #2aa198;">"xiaoming"</span>]
fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(ok, v1)

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#24403; key=xiaowang &#23384;&#22312;&#26102;&#25171;&#21360; value</span>
<span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #8787d7;">v2</span>, <span style="color: #8787d7;">ok</span> := mapTemp[<span style="color: #2aa198;">"xiaowang"</span>]; ok {
        fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(v2)
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36941;&#21382; map&#65292;&#25171;&#21360; key &#21644; value</span>
<span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">k</span>, <span style="color: #8787d7;">v</span> := <span style="color: #268bd2; font-weight: bold;">range</span> mapTemp {
        fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(k, v)
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21024;&#38500; map &#20013;&#30340; key</span>
<span style="color: #268bd2;">delete</span>(mapTemp, <span style="color: #2aa198;">"xiaoming"</span>)

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#33719;&#21462; map &#30340;&#22823;&#23567;</span>
<span style="color: #8787d7;">length</span> := <span style="color: #268bd2;">len</span>(mapTemp)
fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(length)
</pre>
</div>

<p>
看了上面的 map 创建，初始化，增删改查等操作，我们发现 go 的 api 其实挺简单易学的。<br>
</p>
</div>
</div>
<div id="outline-container-org4bf16b7" class="outline-2">
<h2 id="org4bf16b7">go 中 map 的实现原理</h2>
<div class="outline-text-2" id="text-org4bf16b7">
<p>
go 底层 <code>map</code> 到底怎么存储呢？ <code>map</code> 的源码位于 <code>src/runtime/map.go</code> 中，笔者 go 的版本是 1.12 在 go 中， <code>map</code> 同样也是数组存储的的，每个数组下标处存储的是一个 <code>bucket</code> ，这个 <code>bucket</code> 的类型见下面代码，每个 <code>bucket</code> 中可以存储 8 个 (k, v) 键值对，当每个 <code>bucket</code> 存储的 (k, v) 对到达 8 个之后，会通过 <code>overflow</code> 指针指向一个新的 <code>bucket</code> ，从而形成一个链表，看 <code>bmap</code> 的结构，我想大家应该很纳闷，没看见 (k, v) 的结构和 <code>overflow</code> 指针啊，事实上，这两个结构体并没有显示定义，是通过指针运算进行访问的。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">A bucket for a Go map.</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">bmap</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">tophash generally contains the top byte of the hash value</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">for each key in this bucket. If tophash[0] &lt; minTopHash,</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">tophash[0] is a bucket evacuation state instead.</span>
    tophash [bucketCnt]<span style="color: #df005f; font-weight: bold;">uint8</span>    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35760;&#24405;&#30528;&#27599;&#20010;key&#30340;&#39640;8&#20010;bits</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Followed by bucketCnt keys and then bucketCnt elems.</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #875f00; background-color: #262626;">NOTE</span><span style="color: #008787; background-color: #262626;">: packing all the keys together and then all the elems together makes the</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">code a bit more complicated than alternating key/elem/key/elem/... but it allows</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">us to eliminate padding which would be needed for, e.g., map[int64]int8.</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Followed by an overflow pointer.</span>
}
</pre>
</div>

<p>
看上面代码以及注释，我们能得到 <code>bucket</code> 中存储的 kv 是这样的，tophash 用来快速查找 key 值是否在该 <code>bucket</code> 中，而不同每次都通过真值进行比较；还有 kv 的存放，为什么不是 k1v1，k2v2&#x2026;.. 而是 k1k2&#x2026; v1v2&#x2026;，我们看上面的注释说的 <code>map[int64]int8</code> ，key 是 int64（8个字节），value 是 int8（一个字节），kv 的长度不同，如果按照 kv 格式存放，则考虑内存对齐 v 也会占用 int64，而按照后者存储时，8 个 v 刚好占用一个 int64，从这个就可以看出 go 的 <code>map</code> 设计之巧妙。<br>
</p>

<img src="./images/go_map_bucket.png" />

<p>
最后我们分析一下 go 的整体内存结构，阅读一下 <code>map</code> 存储的源码，如下图所示，当往 <code>map</code> 中存储一个 kv 对时，通过 k 获取 hash 值，hash 值的低八位和 <code>bucket</code> 数组长度取余，定位到在数组中的那个下标，hash 值的高八位存储在 <code>bucket</code> 中的 <code>tophash</code> 中，用来快速判断 key 是否存在，key 和 value 的具体值则通过指针运算存储，当一个 <code>bucket</code> 满时，通过 <code>overfolw</code> 指针链接到下一个 <code>bucket</code> 。<br>
</p>

<img src="./images/go_map_buckets.png" />

<p>
go 的 <code>map</code> 存储源码如下，省略了一些无关紧要的代码：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">mapassign</span>(<span style="color: #8787d7;">t</span> *<span style="color: #df005f; font-weight: bold;">maptype</span>, <span style="color: #8787d7;">h</span> *<span style="color: #df005f; font-weight: bold;">hmap</span>, <span style="color: #8787d7;">key</span> <span style="color: #df005f; font-weight: bold;">unsafe.Pointer</span>) <span style="color: #df005f; font-weight: bold;">unsafe.Pointer</span> {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#33719;&#21462; hash &#31639;&#27861;</span>
    <span style="color: #8787d7;">alg</span> := t.key.alg
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35745;&#31639; hash &#20540;</span>
    <span style="color: #8787d7;">hash</span> := alg.<span style="color: #d75fd7; font-weight: bold;">hash</span>(key, <span style="color: #d75fd7; font-weight: bold;">uintptr</span>(h.hash0))
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22914;&#26524; ~bucket~ &#25968;&#32452;&#19968;&#24320;&#22987;&#20026;&#31354;&#65292;&#21017;&#21021;&#22987;&#21270;</span>
    <span style="color: #268bd2; font-weight: bold;">if</span> h.buckets == <span style="color: #d75fd7;">nil</span> {
        h.buckets = <span style="color: #d75fd7; font-weight: bold;">newobject</span>(t.bucket)   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">newarray(t.bucket, 1)</span>
    }
<span style="color: #d75fd7;">again</span>:
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#23450;&#20301;&#23384;&#20648;&#22312;&#21738;&#19968;&#20010; bucket &#20013;</span>
    <span style="color: #8787d7;">bucket</span> := hash &amp; <span style="color: #d75fd7; font-weight: bold;">bucketMask</span>(h.B)
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#24471;&#21040; bucket &#30340;&#32467;&#26500;&#20307;</span>
    <span style="color: #8787d7;">b</span> := (*bmap)(unsafe.<span style="color: #d75fd7; font-weight: bold;">Pointer</span>(<span style="color: #d75fd7; font-weight: bold;">uintptr</span>(h.buckets) +bucket*<span style="color: #d75fd7; font-weight: bold;">uintptr</span>(t.bucketsize)))
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#33719;&#21462;&#39640;&#20843;&#20301; hash &#20540;</span>
    <span style="color: #8787d7;">top</span> := <span style="color: #d75fd7; font-weight: bold;">tophash</span>(hash)
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">inserti</span> *<span style="color: #df005f; font-weight: bold;">uint8</span>
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">insertk</span> <span style="color: #df005f; font-weight: bold;">unsafe.Pointer</span>
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">val</span> <span style="color: #df005f; font-weight: bold;">unsafe.Pointer</span>
<span style="color: #d75fd7;">bucketloop</span>:
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#27515;&#24490;&#29615;</span>
    <span style="color: #268bd2; font-weight: bold;">for</span> {
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#24490;&#29615; bucket &#20013;&#30340; tophash &#25968;&#32452;</span>
        <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := <span style="color: #d75fd7; font-weight: bold;">uintptr</span>(0); i &lt; bucketCnt; i++ {
            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22914;&#26524; hash &#19981;&#30456;&#31561;</span>
            <span style="color: #268bd2; font-weight: bold;">if</span> b.tophash[i] != top {
                <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21028;&#26029;&#26159;&#21542;&#20026;&#31354;&#65292;&#20026;&#31354;&#21017;&#25554;&#20837;</span>
                <span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #d75fd7; font-weight: bold;">isEmpty</span>(b.tophash[i]) &amp;&amp; inserti == <span style="color: #d75fd7;">nil</span> {
                    inserti = &amp;b.tophash[i]
                    insertk = <span style="color: #d75fd7; font-weight: bold;">add</span>(unsafe.<span style="color: #d75fd7; font-weight: bold;">Pointer</span>(b), dataOffset+i*<span style="color: #d75fd7; font-weight: bold;">uintptr</span>(t.keysize))
                    val = <span style="color: #d75fd7; font-weight: bold;">add</span>( unsafe.<span style="color: #d75fd7; font-weight: bold;">Pointer</span>(b), 
                        dataOffset+bucketCnt*<span style="color: #d75fd7; font-weight: bold;">uintptr</span>(t.keysize)+i*<span style="color: #d75fd7; font-weight: bold;">uintptr</span>(t.valuesize) )
                }
                <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#25554;&#20837;&#25104;&#21151;&#65292;&#32456;&#27490;&#26368;&#22806;&#23618;&#24490;&#29615;</span>
                <span style="color: #268bd2; font-weight: bold;">if</span> b.tophash[i] == emptyRest {
                    <span style="color: #268bd2; font-weight: bold;">break</span> <span style="color: #d75fd7;">bucketloop</span>
                }
                <span style="color: #268bd2; font-weight: bold;">continue</span>
            }
            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21040;&#36825;&#37324;&#35828;&#26126;&#39640;&#20843;&#20301; hash &#19968;&#26679;&#65292;&#33719;&#21462;&#24050;&#23384;&#22312;&#30340; key</span>
            <span style="color: #8787d7;">k</span> := <span style="color: #d75fd7; font-weight: bold;">add</span>(unsafe.<span style="color: #d75fd7; font-weight: bold;">Pointer</span>(b), dataOffset+i*<span style="color: #d75fd7; font-weight: bold;">uintptr</span>(t.keysize))
            <span style="color: #268bd2; font-weight: bold;">if</span> t.<span style="color: #d75fd7; font-weight: bold;">indirectkey</span>() {
                k = *((*unsafe.Pointer)(k))
            }
            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21028;&#26029;&#20004;&#20010; key &#26159;&#21542;&#30456;&#31561;&#65292;&#19981;&#30456;&#31561;&#23601;&#24490;&#29615;&#19979;&#19968;&#20010;</span>
            <span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #d75fd7;">!</span>alg.<span style="color: #d75fd7; font-weight: bold;">equal</span>(key, k) {
                <span style="color: #268bd2; font-weight: bold;">continue</span>
            }
            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22914;&#26524;&#30456;&#31561;&#21017;&#26356;&#26032;</span>
            <span style="color: #268bd2; font-weight: bold;">if</span> t.<span style="color: #d75fd7; font-weight: bold;">needkeyupdate</span>() {
                <span style="color: #d75fd7; font-weight: bold;">typedmemmove</span>(t.key, k, key)
            }
            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#33719;&#21462;&#24050;&#23384;&#22312;&#30340; value</span>
            val = <span style="color: #d75fd7; font-weight: bold;">add</span>(unsafe.<span style="color: #d75fd7; font-weight: bold;">Pointer</span>(b), dataOffset+bucketCnt*<span style="color: #d75fd7; font-weight: bold;">uintptr</span>(t.keysize)+i*<span style="color: #d75fd7; font-weight: bold;">uintptr</span>(t.valuesize))
            <span style="color: #268bd2; font-weight: bold;">goto</span> <span style="color: #d75fd7;">done</span>
        }
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22914;&#26524;&#19978;&#19968;&#20010; bucket &#27809;&#33021;&#25554;&#20837;&#65292;&#21017;&#36890;&#36807; overflow &#33719;&#21462;&#38142;&#34920;&#19978;&#30340;&#19979;&#19968;&#20010; bucket</span>
        <span style="color: #8787d7;">ovf</span> := b.<span style="color: #d75fd7; font-weight: bold;">overflow</span>(t)
        <span style="color: #268bd2; font-weight: bold;">if</span> ovf == <span style="color: #d75fd7;">nil</span> {
            <span style="color: #268bd2; font-weight: bold;">break</span>
        }
        b = ovf
    }

    <span style="color: #268bd2; font-weight: bold;">if</span> inserti == <span style="color: #d75fd7;">nil</span> {
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">all current buckets are full, allocate a new one.</span>
        <span style="color: #8787d7;">newb</span> := h.<span style="color: #d75fd7; font-weight: bold;">newoverflow</span>(t, b)
        inserti = &amp;newb.tophash[0]
        insertk = <span style="color: #d75fd7; font-weight: bold;">add</span>(unsafe.<span style="color: #d75fd7; font-weight: bold;">Pointer</span>(newb), dataOffset)
        val = <span style="color: #d75fd7; font-weight: bold;">add</span>(insertk, bucketCnt*<span style="color: #d75fd7; font-weight: bold;">uintptr</span>(t.keysize))
    }

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">store new key/value at insert position</span>
    <span style="color: #268bd2; font-weight: bold;">if</span> t.<span style="color: #d75fd7; font-weight: bold;">indirectkey</span>() {
        <span style="color: #8787d7;">kmem</span> := <span style="color: #d75fd7; font-weight: bold;">newobject</span>(t.key)
        *(*unsafe.Pointer)(insertk) = kmem
        insertk = kmem
    }
    <span style="color: #268bd2; font-weight: bold;">if</span> t.<span style="color: #d75fd7; font-weight: bold;">indirectvalue</span>() {
        <span style="color: #8787d7;">vmem</span> := <span style="color: #d75fd7; font-weight: bold;">newobject</span>(t.elem)
        *(*unsafe.Pointer)(val) = vmem
    }
    <span style="color: #d75fd7; font-weight: bold;">typedmemmove</span>(t.key, insertk, key)
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#23558;&#39640;&#20843;&#20301; hash &#20540;&#23384;&#20648;</span>
    *inserti = top
    h.count++
    <span style="color: #268bd2; font-weight: bold;">return</span> val
}
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-02-11 00:02 Fri</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-04-17 Sun 14:32</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
