<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-03-27 Sun 17:26 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>GO语言的GPM调度器是什么</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">GO语言的GPM调度器是什么</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgc8066da">并发模型</a>
<ul>
<li><a href="#org4dcc322">CSP篇</a></li>
<li><a href="#orgee8e13f">GPM调度模型</a></li>
<li><a href="#orgb35e73f">Goroutine</a></li>
<li><a href="#orgc6eae07">Processor</a></li>
<li><a href="#orgc812ad1">三者的关系</a></li>
</ul>
</li>
<li><a href="#org02e1578">系统调用</a></li>
<li><a href="#orgf2b2ac2">sysmon</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgc8066da" class="outline-2">
<h2 id="orgc8066da">并发模型</h2>
<div class="outline-text-2" id="text-orgc8066da">
<p>
相信很多人都听说过Go语言天然支持高并发，原因是内部有协程（goroutine）加持，可以在一个进程中启动成千上万个协程。那么，它凭什么做到如此高的并发呢？那就需要先了解什么是并发模型。<br>
</p>

<p>
著名的 C++ 专家 Herb Sutter 曾经说过“免费的午餐已经终结”。为了让代码运行的更快，单纯依靠更快的硬件已经无法得到满足，我们需要利用多核来挖掘并行的价值，而并发模型的目的就是来告诉你不同执行实体之间是如何协作的。<br>
</p>

<p>
当然，不同的并发模型的协作方式也不尽相同，常见的并发模型有七种：<br>
</p>

<ul class="org-ul">
<li>线程与锁<br></li>
<li>函数式编程<br></li>
<li>Clojure之道<br></li>
<li>actor<br></li>
<li>通讯顺序进程（CSP）<br></li>
<li>数据级并行<br></li>
<li>Lambda架构<br></li>
</ul>

<p>
而今天，我们只讲与Go语言相关的并发模型CSP，感兴趣的同学可以自行查阅书籍《七周七并发模型》。<br>
</p>
</div>
<div id="outline-container-org4dcc322" class="outline-3">
<h3 id="org4dcc322">CSP篇</h3>
<div class="outline-text-3" id="text-org4dcc322">
<p>
CSP，全称Communicating Sequential Processes，意为通讯顺序进程，它是七大并发模型中的一种，它的核心观念是将两个并发执行的实体通过通道channel连接起来，所有的消息都通过channel传输。其实CSP概念早在1978年就被东尼·霍尔提出，由于近来Go语言的兴起，CSP又火了起来。<br>
</p>

<p>
那么CSP与Go语言有什么关系呢？接下来我们来看Go语言对CSP并发模型的实现——GPM调度模型。<br>
</p>
</div>
</div>
<div id="outline-container-orgee8e13f" class="outline-3">
<h3 id="orgee8e13f">GPM调度模型</h3>
<div class="outline-text-3" id="text-orgee8e13f">
<p>
GPM代表了三个角色，分别是Goroutine、Processor、Machine。<br>
</p>

<img src="./images/GPM的三个角色.jpg" width="650px" />

<ul class="org-ul">
<li>Goroutine：就是咱们常用的用go关键字创建的执行体，它对应一个结构体g，结构体里保存了goroutine的堆栈信息<br></li>
<li>Machine：表示操作系统的线程<br></li>
<li>Processor：表示处理器，有了它才能建立G、M的联系<br></li>
</ul>
</div>
</div>
<div id="outline-container-orgb35e73f" class="outline-3">
<h3 id="orgb35e73f">Goroutine</h3>
<div class="outline-text-3" id="text-orgb35e73f">
<p>
Goroutine就是代码中使用go关键词创建的执行单元，也是大家熟知的有"轻量级线程"之称的协程，协程是不为操作系统所知的，它由编程语言层面实现，上下文切换不需要经过内核态，再加上协程占用的内存空间极小，所以有着非常大的发展潜力。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {}()
</pre>
</div>

<p>
复制代码在Go语言中，Goroutine由一个名为runtime.go的结构体表示，该结构体非常复杂，有40多个成员变量，主要存储执行栈、状态、当前占用的线程、调度相关的数据。还有玩大家很想获取的goroutine标识，但是很抱歉，官方考虑到Go语言的发展，设置成私有了，不给你调用😏。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">g</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    stack <span style="color: #268bd2; font-weight: bold;">struct</span> {
        lo <span style="color: #df005f; font-weight: bold;">uintptr</span>
        hi <span style="color: #df005f; font-weight: bold;">uintptr</span>
    }                           <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#26632;&#20869;&#23384;&#65306;[stack.lo, stack.hi)</span>
    stackguard0 <span style="color: #df005f; font-weight: bold;">uintptr</span>
    stackguard1 <span style="color: #df005f; font-weight: bold;">uintptr</span>

    _panic       *<span style="color: #df005f; font-weight: bold;">_panic</span>
    _defer       *<span style="color: #df005f; font-weight: bold;">_defer</span>
    m            *<span style="color: #df005f; font-weight: bold;">m</span>             <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#24403;&#21069;&#30340; m</span>
    sched        <span style="color: #df005f; font-weight: bold;">gobuf</span>
    stktopsp     <span style="color: #df005f; font-weight: bold;">uintptr</span>        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#26399;&#26395; sp &#20301;&#20110;&#26632;&#39030;&#65292;&#29992;&#20110;&#22238;&#28335;&#26816;&#26597;</span>
    param        <span style="color: #df005f; font-weight: bold;">unsafe.Pointer</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">wakeup &#21796;&#37266;&#26102;&#20505;&#20256;&#36882;&#30340;&#21442;&#25968;</span>
    atomicstatus <span style="color: #df005f; font-weight: bold;">uint32</span>
    goid         <span style="color: #df005f; font-weight: bold;">int64</span>
    preempt      <span style="color: #df005f; font-weight: bold;">bool</span>           <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#25250;&#21344;&#20449;&#21495;&#65292;stackguard0 = stackpreempt &#30340;&#21103;&#26412;</span>
    timer        *<span style="color: #df005f; font-weight: bold;">timer</span>         <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20026; time.Sleep &#32531;&#23384;&#30340;&#35745;&#26102;&#22120;</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">...</span>
}
</pre>
</div>

<p>
Goroutine调度相关的数据存储在sched，在协程切换、恢复上下文的时候用到。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">gobuf</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    sp   <span style="color: #df005f; font-weight: bold;">uintptr</span>
    pc   <span style="color: #df005f; font-weight: bold;">uintptr</span>
    g    <span style="color: #df005f; font-weight: bold;">guintptr</span>
    ret  <span style="color: #df005f; font-weight: bold;">sys.Uintreg</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">...</span>
}
</pre>
</div>

<p>
M就是对应操作系统的线程，最多会有GOMAXPROCS个活跃线程能够正常运行，默认情况下GOMAXPROCS被设置为内核数，假如有四个内核，那么默认就创建四个线程，每一个线程对应一个runtime.m结构体。线程数等于CPU个数的原因是，每个线程分配到一个CPU上就不至于出现线程的上下文切换，可以保证系统开销降到最低。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">m</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    g0   *<span style="color: #df005f; font-weight: bold;">g</span> 
    curg *<span style="color: #df005f; font-weight: bold;">g</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">...</span>
}
</pre>
</div>

<p>
M里面存了两个比较重要的东西，一个是g0，一个是curg。<br>
</p>

<ul class="org-ul">
<li>g0：会深度参与运行时的调度过程，比如goroutine的创建、内存分配等<br></li>
<li>curg：代表当前正在线程上执行的goroutine。<br></li>
</ul>

<p>
刚才说P是负责M与G的关联，所以M里面还要存储与P相关的数据。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">m</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">...</span>
    p             <span style="color: #df005f; font-weight: bold;">puintptr</span>
    nextp         <span style="color: #df005f; font-weight: bold;">puintptr</span>
    oldp          <span style="color: #df005f; font-weight: bold;">puintptr</span>
}
</pre>
</div>

<ul class="org-ul">
<li>p：正在运行代码的处理器<br></li>
<li>nextp：暂存的处理器<br></li>
<li>oldp：系统调用之前的线程的处理器<br></li>
</ul>
</div>
</div>
<div id="outline-container-orgc6eae07" class="outline-3">
<h3 id="orgc6eae07">Processor</h3>
<div class="outline-text-3" id="text-orgc6eae07">
<p>
Proccessor负责Machine与Goroutine的连接，它能提供线程需要的上下文环境，也能分配G到它应该去的线程上执行，有了它，每个G都能得到合理的调用，每个线程都不再浑水摸鱼，真是居家必备之良品。<br>
</p>

<p>
同样的，处理器的数量也是默认按照GOMAXPROCS来设置的，与线程的数量一一对应。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">p</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    m           <span style="color: #df005f; font-weight: bold;">muintptr</span>

    runqhead <span style="color: #df005f; font-weight: bold;">uint32</span>
    runqtail <span style="color: #df005f; font-weight: bold;">uint32</span>
    runq     [256]<span style="color: #df005f; font-weight: bold;">guintptr</span>
    runnext <span style="color: #df005f; font-weight: bold;">guintptr</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">...</span>
}
</pre>
</div>

<p>
结构体P中存储了性能追踪、垃圾回收、计时器等相关的字段外，还存储了处理器的待运行队列，队列中存储的是待执行的Goroutine列表。<br>
</p>
</div>
</div>
<div id="outline-container-orgc812ad1" class="outline-3">
<h3 id="orgc812ad1">三者的关系</h3>
<div class="outline-text-3" id="text-orgc812ad1">
<p>
首先，默认启动四个线程四个处理器，然后互相绑定。<br>
</p>

<img src="./images/默认启动四个线程四个处理器.jpg" width="650px" />

<p>
这个时候，一个Goroutine结构体被创建，在进行函数体地址、参数起始地址、参数长度等信息以及调度相关属性更新之后，它就要进到一个处理器的队列等待发车。<br>
</p>

<img src="./images/Goroutine结构体被创建.jpg" width="650px" />

<p>
啥，又创建了一个G？那就轮流往其他P里面放呗，相信你排队取号的时候看到其他窗口没人排队也会过去的。<br>
</p>

<img src="./images/继续存放Goroutine.jpg" width="650px" />

<p>
假如有很多G，都塞满了怎么办呢？那就不把G塞到处理器的私有队列里了，而是把它塞到全局队列里（候车大厅）。<br>
</p>

<img src="./images/将Goroutine放入全局队列.jpg" width="650px" />

<p>
除了往里塞之外，M这边还要疯狂往外取，首先去处理器的私有队列里取G执行，如果取完的话就去全局队列取，如果全局队列里也没有的话，就去其他处理器队列里偷，哇，这么饥渴，简直是恶魔啊！<br>
</p>

<img src="./images/M在私有队列与全局队列中取G.jpg" width="650px" />

<p>
如果哪里都没找到要执行的G呢？那M就会因为太失望和P断开关系，然后去睡觉（idle）了。<br>
</p>

<img src="./images/M找不到G沉睡.jpg" width="650px" />

<p>
那如果两个Goroutine正在通过channel做一些恩恩爱爱的事阻塞住了怎么办，难道M要等他们完事了再继续执行？显然不会，M并不稀罕这对Go男女，而会转身去找别的G执行。<br>
</p>

<img src="./images/M再寻其他的空闲G执行.jpg" width="650px" />
</div>
</div>
</div>
<div id="outline-container-org02e1578" class="outline-2">
<h2 id="org02e1578">系统调用</h2>
<div class="outline-text-2" id="text-org02e1578">
<p>
如果G进行了系统调用syscall，M也会跟着进入系统调用状态，那么这个P留在这里就浪费了，怎么办呢？这点精妙之处在于，P不会傻傻的等待G和M系统调用完成，而会去找其他比较闲的M执行其他的G。<br>
</p>

<img src="./images/G进行系统调用.jpg" width="650px" />

<p>
当G完成了系统调用，因为要继续往下执行，所以必须要再找一个空闲的处理器发车。<br>
</p>

<img src="./images/G完成系统调用后找空闲处理器继续执行.jpg" width="650px" />

<p>
如果没有空闲的处理器了，那就只能把G放回全局队列当中等待分配。<br>
</p>

<img src="./images/无空闲处理器放入全局队列等待.jpg" width="650px" />
</div>
</div>
<div id="outline-container-orgf2b2ac2" class="outline-2">
<h2 id="orgf2b2ac2">sysmon</h2>
<div class="outline-text-2" id="text-orgf2b2ac2">
<p>
sysmon是我们的保洁阿姨，它是一个M，又叫监控线程，不需要P就可以独立运行，每20us~10ms会被唤醒一次出来打扫卫生，主要工作就是回收垃圾、回收长时间系统调度阻塞的P、向长时间运行的G发出抢占调度等等。<br>
</p>

<div class="reference">
<ul style="list-style: none;">
<li><a href="https://juejin.im/post/5e999ead518825739b2d44d7" target="_blank">Go语言的GPM调度器是什么？</a></li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-02-19 18:02 Sat</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-03-27 Sun 17:26</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
