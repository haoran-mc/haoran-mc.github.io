<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-11-22 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>GO语言的GPM调度器是什么</title>
<meta name="author" content="L.M.haoran" />
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved." />
<meta name="generator" content="Org Mode" />
<link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
           <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
           <script type="module" src="static/js/main.js" defer></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">GO语言的GPM调度器是什么</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgf70de7b">并发模型</a>
<ul>
<li><a href="#org52d6864">CSP篇</a></li>
<li><a href="#org582b64e">GPM调度模型</a></li>
<li><a href="#org73deb7b">Goroutine</a></li>
<li><a href="#orgea2fc37">Processor</a></li>
<li><a href="#org59267f5">三者的关系</a></li>
</ul>
</li>
<li><a href="#org0385417">系统调用</a></li>
<li><a href="#org90e3c35">sysmon</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgf70de7b" class="outline-2">
<h2 id="orgf70de7b">并发模型</h2>
<div class="outline-text-2" id="text-orgf70de7b">
<p>
相信很多人都听说过 Go 语言天然支持高并发，原因是内部有协程（goroutine）加持，可以在一个进程中启动成千上万个协程。那么，它凭什么做到如此高的并发呢？那就需要先了解什么是并发模型。<br>
</p>

<p>
著名的 C++ 专家 Herb Sutter 曾经说过“免费的午餐已经终结”。为了让代码运行的更快，单纯依靠更快的硬件已经无法得到满足，我们需要利用多核来挖掘并行的价值，而并发模型的目的就是来告诉你不同执行实体之间是如何协作的。<br>
</p>

<p>
当然，不同的并发模型的协作方式也不尽相同，常见的并发模型有七种：<br>
</p>

<ul class="org-ul">
<li>线程与锁<br></li>
<li>函数式编程<br></li>
<li>Clojure之道<br></li>
<li>actor<br></li>
<li>通讯顺序进程（CSP）<br></li>
<li>数据级并行<br></li>
<li><p>
Lambda架构<br>
</p>

<p>
而今天，我们只讲与 Go 语言相关的并发模型 CSP，感兴趣的同学可以自行查阅书籍《七周七并发模型》。<br>
</p></li>
</ul>
</div>
<div id="outline-container-org52d6864" class="outline-3">
<h3 id="org52d6864">CSP篇</h3>
<div class="outline-text-3" id="text-org52d6864">
<p>
CSP，全称 Communicating Sequential Processes，意为通讯顺序进程，它是七大并发模型中的一种，它的核心观念是将两个并发执行的实体通过通道 <verbatim>channel</verbatim> 连接起来，所有的消息都通过 <verbatim>channel</verbatim> 传输。其实 CSP 概念早在1978年就被东尼·霍尔提出，由于近来 Go 语言的兴起，CSP 又火了起来。<br>
</p>

<p>
那么 CSP 与 Go 语言有什么关系呢？接下来我们来看 Go 语言对 CSP 并发模型的实现——GPM调度模型。<br>
</p>
</div>
</div>
<div id="outline-container-org582b64e" class="outline-3">
<h3 id="org582b64e">GPM调度模型</h3>
<div class="outline-text-3" id="text-org582b64e">
<p>
GPM 代表了三个角色，分别是 <verbatim>Goroutine</verbatim> 、 <verbatim>Processor</verbatim> 、 <verbatim>Machine</verbatim> 。<br>
</p>

<img src="./images/GPM的三个角色.jpg" width="650px" />

<ul class="org-ul">
<li>Goroutine：就是咱们常用的用 <code>go</code> 关键字创建的执行体，它对应一个结构体 <verbatim>g</verbatim> ，结构体里保存了 goroutine 的堆栈信息<br></li>
<li>Machine：表示操作系统的 <b>线程</b><br></li>
<li>Processor：表示 <b>处理器</b> ，有了它才能建立 G、M 的联系<br></li>
</ul>
</div>
</div>
<div id="outline-container-org73deb7b" class="outline-3">
<h3 id="org73deb7b">Goroutine</h3>
<div class="outline-text-3" id="text-org73deb7b">
<p>
Goroutine 就是代码中使用 <code>go</code> 关键词创建的执行单元，也是大家熟知的有 <span class="underline">"轻量级线程"之称的协程</span> ， <span class="underline">协程是不为操作系统所知的，它由编程语言层面实现</span> ，上下文切换不需要经过内核态，再加上协程占用的内存空间极小，所以有着非常大的发展潜力。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #fb4934;">go</span> <span style="color: #fb4934;">func</span>() {}()
</pre>
</div>

<p>
复制代码在 Go 语言中，Goroutine 由一个名为 <verbatim>runtime.go</verbatim> 的结构体表示，该结构体非常复杂，有40多个成员变量，主要存储执行栈、状态、当前占用的线程、调度相关的数据。还有大家很想获取的 goroutine 标识，但是很抱歉，官方考虑到 Go 语言的发展，设置成私有了，不给你调用😏。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #fb4934;">type</span> <span style="color: #fabd2f;">g</span> <span style="color: #fb4934;">struct</span> {
    stack <span style="color: #fb4934;">struct</span> {
        lo <span style="color: #fabd2f;">uintptr</span>
        hi <span style="color: #fabd2f;">uintptr</span>
    }                           <span style="color: #928374;">// </span><span style="color: #928374;">&#26632;&#20869;&#23384;&#65306;[stack.lo, stack.hi)</span>
    stackguard0 <span style="color: #fabd2f;">uintptr</span>
    stackguard1 <span style="color: #fabd2f;">uintptr</span>

    _panic       *<span style="color: #fabd2f;">_panic</span>
    _defer       *<span style="color: #fabd2f;">_defer</span>
    m            *<span style="color: #fabd2f;">m</span>             <span style="color: #928374;">// </span><span style="color: #928374;">&#24403;&#21069;&#30340; m</span>
    sched        <span style="color: #fabd2f;">gobuf</span>
    stktopsp     <span style="color: #fabd2f;">uintptr</span>        <span style="color: #928374;">// </span><span style="color: #928374;">&#26399;&#26395; sp &#20301;&#20110;&#26632;&#39030;&#65292;&#29992;&#20110;&#22238;&#28335;&#26816;&#26597;</span>
    param        <span style="color: #fabd2f;">unsafe.Pointer</span> <span style="color: #928374;">// </span><span style="color: #928374;">wakeup &#21796;&#37266;&#26102;&#20505;&#20256;&#36882;&#30340;&#21442;&#25968;</span>
    atomicstatus <span style="color: #fabd2f;">uint32</span>
    goid         <span style="color: #fabd2f;">int64</span>
    preempt      <span style="color: #fabd2f;">bool</span>           <span style="color: #928374;">// </span><span style="color: #928374;">&#25250;&#21344;&#20449;&#21495;&#65292;stackguard0 = stackpreempt &#30340;&#21103;&#26412;</span>
    timer        *<span style="color: #fabd2f;">timer</span>         <span style="color: #928374;">// </span><span style="color: #928374;">&#20026; time.Sleep &#32531;&#23384;&#30340;&#35745;&#26102;&#22120;</span>

    <span style="color: #928374;">// </span><span style="color: #928374;">...</span>
}
</pre>
</div>

<p>
Goroutine 调度相关的数据存储在 <code>sched</code> ，在协程切换、恢复上下文的时候用到。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #fb4934;">type</span> <span style="color: #fabd2f;">gobuf</span> <span style="color: #fb4934;">struct</span> {
    sp   <span style="color: #fabd2f;">uintptr</span>
    pc   <span style="color: #fabd2f;">uintptr</span>
    g    <span style="color: #fabd2f;">guintptr</span>
    ret  <span style="color: #fabd2f;">sys.Uintreg</span>
    <span style="color: #928374;">// </span><span style="color: #928374;">...</span>
}
</pre>
</div>

<p>
<span class="underline">M 就是对应操作系统的线程</span> ，最多会有 GOMAXPROCS 个活跃线程能够正常运行，默认情况下 GOMAXPROCS 被设置为内核数，假如有四个内核，那么默认就创建四个线程，每一个线程对应一个 <code>runtime.m</code> 结构体。 <span class="underline">线程数等于 CPU 个数的原因是，每个线程分配到一个 CPU 上就不至于出现线程的上下文切换，可以保证系统开销降到最低。</span><br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #fb4934;">type</span> <span style="color: #fabd2f;">m</span> <span style="color: #fb4934;">struct</span> {
    g0   *<span style="color: #fabd2f;">g</span>
    curg *<span style="color: #fabd2f;">g</span>
    <span style="color: #928374;">// </span><span style="color: #928374;">...</span>
}
</pre>
</div>

<p>
M 里面存了两个比较重要的东西，一个是 g0，一个是 curg。<br>
</p>

<ul class="org-ul">
<li>g0：会深度参与运行时的调度过程，比如 goroutine 的创建、内存分配等<br></li>
<li><p>
curg：代表当前正在线程上执行的 goroutine。<br>
</p>

<p>
刚才说 P 是负责 M 与 G 的关联，所以 M 里面还要存储与 P 相关的数据。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #fb4934;">type</span> <span style="color: #fabd2f;">m</span> <span style="color: #fb4934;">struct</span> {
    <span style="color: #928374;">// </span><span style="color: #928374;">...</span>
    p             <span style="color: #fabd2f;">puintptr</span>
    nextp         <span style="color: #fabd2f;">puintptr</span>
    oldp          <span style="color: #fabd2f;">puintptr</span>
}
</pre>
</div>

<ul class="org-ul">
<li>p：正在运行代码的处理器<br></li>
<li>nextp：暂存的处理器<br></li>
<li>oldp：系统调用之前的线程的处理器<br></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgea2fc37" class="outline-3">
<h3 id="orgea2fc37">Processor</h3>
<div class="outline-text-3" id="text-orgea2fc37">
<p>
Proccessor 负责 Machine 与 Goroutine 的连接，它能提供线程需要的上下文环境，也能分配 G 到它应该去的线程上执行，有了它，每个 G 都能得到合理的调用，每个线程都不再浑水摸鱼，真是居家必备之良品。<br>
</p>

<p>
同样的，处理器的数量也是默认按照 GOMAXPROCS 来设置的，与线程的数量一一对应。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #fb4934;">type</span> <span style="color: #fabd2f;">p</span> <span style="color: #fb4934;">struct</span> {
    m           <span style="color: #fabd2f;">muintptr</span>

    runqhead <span style="color: #fabd2f;">uint32</span>
    runqtail <span style="color: #fabd2f;">uint32</span>
    runq     [256]<span style="color: #fabd2f;">guintptr</span>
    runnext <span style="color: #fabd2f;">guintptr</span>
    <span style="color: #928374;">// </span><span style="color: #928374;">...</span>
}
</pre>
</div>

<p>
结构体 P 中存储了性能追踪、垃圾回收、计时器等相关的字段外，还存储了处理器的待运行队列，队列中存储的是待执行的 Goroutine 列表。<br>
</p>
</div>
</div>
<div id="outline-container-org59267f5" class="outline-3">
<h3 id="org59267f5">三者的关系</h3>
<div class="outline-text-3" id="text-org59267f5">
<p>
首先，默认启动四个线程四个处理器，然后互相绑定。<br>
</p>

<img src="./images/默认启动四个线程四个处理器.jpg" width="650px" />

<p>
这个时候，一个 Goroutine 结构体被创建，在进行函数体地址、参数起始地址、参数长度等信息以及调度相关属性更新之后，它就要进到一个处理器的队列等待发车。<br>
</p>

<img src="./images/Goroutine结构体被创建.jpg" width="650px" />

<p>
啥，又创建了一个 G？那就轮流往其他 P 里面放呗，相信你排队取号的时候看到其他窗口没人排队也会过去的。<br>
</p>

<img src="./images/继续存放Goroutine.jpg" width="650px" />

<p>
假如有很多 G，都塞满了怎么办呢？那就不把 G 塞到处理器的私有队列里了，而是把它塞到全局队列里（候车大厅）。<br>
</p>

<img src="./images/将Goroutine放入全局队列.jpg" width="650px" />

<p>
除了往里塞之外，M 这边还要疯狂往外取，首先去处理器的私有队列里取 G 执行，如果取完的话就去全局队列取，如果全局队列里也没有的话，就去其他处理器队列里偷，哇，这么饥渴，简直是恶魔啊！<br>
</p>

<img src="./images/M在私有队列与全局队列中取G.jpg" width="650px" />

<p>
如果哪里都没找到要执行的 G 呢？那 M 就会因为太失望和 P 断开关系，然后去睡觉（idle）了。<br>
</p>

<img src="./images/M找不到G沉睡.jpg" width="650px" />

<p>
那如果两个 Goroutine 正在通过 <code>channel</code> 做一些恩恩爱爱的事阻塞住了怎么办，难道 M 要等他们完事了再继续执行？显然不会，M 并不稀罕这对 Go 男女，而会转身去找别的 G 执行。<br>
</p>

<img src="./images/M再寻其他的空闲G执行.jpg" width="650px" />
</div>
</div>
</div>
<div id="outline-container-org0385417" class="outline-2">
<h2 id="org0385417">系统调用</h2>
<div class="outline-text-2" id="text-org0385417">
<p>
如果 G 进行了系统调用 <verbatim>syscall</verbatim> ，M也会跟着进入系统调用状态，那么这个 P 留在这里就浪费了，怎么办呢？这点精妙之处在于，P不会傻傻的等待 G 和 M 系统调用完成，而会去找其他比较闲的 M 执行其他的 G。<br>
</p>

<img src="./images/G进行系统调用.jpg" width="650px" />

<p>
当 G 完成了系统调用，因为要继续往下执行，所以必须要再找一个空闲的处理器发车。<br>
</p>

<img src="./images/G完成系统调用后找空闲处理器继续执行.jpg" width="650px" />

<p>
如果没有空闲的处理器了，那就只能把 G 放回全局队列当中等待分配。<br>
</p>

<img src="./images/无空闲处理器放入全局队列等待.jpg" width="650px" />
</div>
</div>
<div id="outline-container-org90e3c35" class="outline-2">
<h2 id="org90e3c35">sysmon</h2>
<div class="outline-text-2" id="text-org90e3c35">
<p>
<verbatim>sysmon</verbatim> 是我们的保洁阿姨，它是一个 M，又叫监控线程，不需要 P 就可以独立运行，每 20us~10ms 会被唤醒一次出来打扫卫生，主要工作就是回收垃圾、回收长时间系统调度阻塞的 P、向长时间运行的 G 发出抢占调度等等。<br>
</p>

<div class="reference">
    <ul style="list-style: none;">
        <li><a href="https://juejin.im/post/5e999ead518825739b2d44d7" target="_blank">Go语言的GPM调度器是什么？</a></li>
    </ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-02-19 18:02 Sat</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-11-22</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
