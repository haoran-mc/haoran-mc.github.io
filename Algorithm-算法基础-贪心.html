<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-11-03 Wed 21:50 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>贪心</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran &lt;haoran.mc@outlook.com&gt;">

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">贪心</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org7a4c885">区间贪心</a>
<ul>
<li><a href="#org5d5b304">一、区间选点</a></li>
<li><a href="#org6cb2c48">二、最大不相交区间数量</a></li>
<li><a href="#org8e0bf42">三、区间覆盖</a></li>
<li><a href="#org658a6b9">区间分组</a></li>
</ul>
</li>
<li><a href="#org745244a">哈夫曼编码</a>
<ul>
<li><a href="#org87177f3">合并果子</a></li>
</ul>
</li>
<li><a href="#orga458da2">排序不等式</a>
<ul>
<li><a href="#org11bceb9">排队打水</a></li>
</ul>
</li>
<li><a href="#orgf21446d">绝对值不等式</a>
<ul>
<li><a href="#org87f7d0b">货仓选址</a></li>
</ul>
</li>
<li><a href="#org0f92084">推公式</a>
<ul>
<li><a href="#org4c73396">耍杂技的牛</a></li>
<li><a href="#orgaf7290d">国王游戏</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org7a4c885" class="outline-2">
<h2 id="org7a4c885">区间贪心</h2>
<div class="outline-text-2" id="text-org7a4c885">
</div>
<div id="outline-container-org5d5b304" class="outline-3">
<h3 id="org5d5b304">一、区间选点</h3>
<div class="outline-text-3" id="text-org5d5b304">
<p>
给定 \(n\) 个闭区间 \([l_i, r_i]\)，请你在数轴上选择尽量少的点，使得每个区间至少包含一个选出的点，输出选择的点的最小数量，位于选择区间端点上的点也算作区间内。<br>
</p>

<p>
按左端点排序，左端点相等就排右端点，第一个点默认选择第一个区间的右端点，然后向后找第一个不包含这个点的区间，选择第二个点是这个区间的右端点&#x2026;&#x2026;<br>
</p>

<p>
也可以按右端点排序。<br>
</p>
</div>
</div>
<div id="outline-container-org6cb2c48" class="outline-3">
<h3 id="org6cb2c48">二、最大不相交区间数量</h3>
<div class="outline-text-3" id="text-org6cb2c48">
<p>
给定 \(n\) 个闭区间 \([l_i, r_i]\)，请你在数轴上选择若干个区间，使得选中的区间之间互不相交（包括端点），输出可选区间的最大数量。<br>
</p>

<p>
和上面区间选点的方法一样。<br>
</p>
</div>
</div>
<div id="outline-container-org8e0bf42" class="outline-3">
<h3 id="org8e0bf42">三、区间覆盖</h3>
<div class="outline-text-3" id="text-org8e0bf42">
<p>
给定 n 个闭区间 \([l_i, r_i]\) 以及一个线段区间 \([s, t]\)，请你选择尽量少的区间，将指定线段区间完全覆盖，输出最少区间数，如果无法完全覆盖则输出 \(-1\)。<br>
</p>

<ol class="org-ol">
<li>将所有区间按左端点从小到大排序<br></li>
<li>从前往后依次枚举每个区间，在所有能覆盖 \(start\) 的区间中，选择右端点最大的区间，然后将 \(start\) 更新成右端点的最大值。<br></li>
</ol>
</div>
</div>
<div id="outline-container-org658a6b9" class="outline-3">
<h3 id="org658a6b9">区间分组</h3>
<div class="outline-text-3" id="text-org658a6b9">
<p>
给定 \(n\) 个闭区间 \([l_i, r_i]\)，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小，输出最小组数。<br>
</p>

<ol class="org-ol">
<li>按左端点排序<br></li>
<li>从前往后处理每个区间<br></li>
<li>判断能否将其放到某个现有的组中，比较 \(l_i\) 与组的最右端点<br>
<ol class="org-ol">
<li>如果不存在这样的组，新建一个组，将这个区间放入<br></li>
<li>如果存在这样的组，放入，更新这个组的最右端点<br></li>
</ol></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org745244a" class="outline-2">
<h2 id="org745244a">哈夫曼编码</h2>
<div class="outline-text-2" id="text-org745244a">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">字符</th>
<th scope="col" class="org-right">A</th>
<th scope="col" class="org-right">B</th>
<th scope="col" class="org-right">C</th>
<th scope="col" class="org-right">D</th>
<th scope="col" class="org-right">E</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">频次</td>
<td class="org-right">3</td>
<td class="org-right">9</td>
<td class="org-right">6</td>
<td class="org-right">15</td>
<td class="org-right">19</td>
</tr>
</tbody>
</table>

<pre class="example" id="org418fe46">
(1)  3  9  6  15  19
.    A  B  C  D   E


(2)    9    9  15  19
.     / \
.    3   6  


(3)       18      15   19
.        /  \
.       9    9
.      / \
.     3   6


(4)        33          19
.         /  \
.       15    18
.            /  \
.           9    9
.          / \
.         3   6


(5)      52
.       /   \
.     19     33
.           /  \
.         15    18
.              /  \
.             9    9
.            / \
.           3   6


(6)         []
.          /   \
.        19     []
.              /  \
.            15    []
.                 /  \
.                []    9
.               /  \
.              3    6
</pre>
</div>
<div id="outline-container-org87177f3" class="outline-3">
<h3 id="org87177f3">合并果子</h3>
<div class="outline-text-3" id="text-org87177f3">
<p>
把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和，输出最小消耗的体力。<br>
</p>

<p>
每次合并最小重量的两堆果子。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-orga458da2" class="outline-2">
<h2 id="orga458da2">排序不等式</h2>
<div class="outline-text-2" id="text-orga458da2">
</div>
<div id="outline-container-org11bceb9" class="outline-3">
<h3 id="org11bceb9">排队打水</h3>
<div class="outline-text-3" id="text-org11bceb9">
<p>
有 \(n\) 个人排队到 \(1\) 个水龙头处打水，第 \(i\) 个人装满水桶所需时间是 \(t_i\)，请问如何安排他们的打水顺序才能使所有人的等待时间之和最小。<br>
</p>

<p>
从小到大排队，让最慢的人最后打水。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-orgf21446d" class="outline-2">
<h2 id="orgf21446d">绝对值不等式</h2>
<div class="outline-text-2" id="text-orgf21446d">
</div>
<div id="outline-container-org87f7d0b" class="outline-3">
<h3 id="org87f7d0b">货仓选址</h3>
<div class="outline-text-3" id="text-org87f7d0b">
<p>
在一条数轴上有 \(n\) 家商店，它们的坐标是 \(a_i\) 现在需要在数轴上建立一家货仓，货仓建在哪里可以使得货仓到每家商店的距离之和最小。<br>
</p>

<p>
中位数的位置。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org0f92084" class="outline-2">
<h2 id="org0f92084">推公式</h2>
<div class="outline-text-2" id="text-org0f92084">
</div>
<div id="outline-container-org4c73396" class="outline-3">
<h3 id="org4c73396">耍杂技的牛</h3>
<div class="outline-text-3" id="text-org4c73396">
<p>
农民约翰的 \(n\) 头奶牛（编号为 \(1, 2, \dots N\)）计划逃跑并加入马戏团，为此它们决定练习表演杂技。<br>
</p>

<p>
奶牛们不是非常有创意，只提出了一个杂技表演：<br>
</p>

<p>
叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。<br>
</p>

<p>
奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。<br>
</p>

<p>
这 \(n\) 头奶牛中的每一头都有着自己的重量 \(w_i\) 以及自己的强壮程度 \(s_i\)。<br>
</p>

<p>
一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。<br>
</p>

<p>
您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。<br>
</p>

<img src="./images/耍杂技的牛.png" width=25% height=25% />

<p>
判断交换第 \(i\) 头牛与 \(i + 1\) 头牛的位置之后有什么影响：<br>
</p>

<p>
交换前：<br>
</p>
<ul class="org-ul">
<li>第 \(i\) 头牛的危险系数：\(w_1 + w_2 + \dots + w_{i - 1} - s_i\)<br></li>
<li>第 \(i + 1\) 头牛的危险系数：\(w_1 + w_2 + \dots + w_i - s_{i + 1}\)<br></li>
</ul>

<p>
交换后：<br>
</p>
<ul class="org-ul">
<li>第 \(i\) 头牛的危险系数：\(w_1 + w_2 + \dots + w_{i - 1} + w_{i + 1} - s_i\)<br></li>
<li>第 \(i + 1\) 头牛的危险系数：\(w_1 + w_2 + \dots + w_{i - 1} - s_{i + 1}\)<br></li>
</ul>

<p>
由于是比较大小关系，所以减去相同项：<br>
</p>

<p>
交换前：<br>
</p>
<ul class="org-ul">
<li>第 \(i\) 头牛的危险系数：\(- s_i\)<br></li>
<li>第 \(i + 1\) 头牛的危险系数：\(w_i - s_{i + 1}\)<br></li>
</ul>

<p>
交换后：<br>
</p>
<ul class="org-ul">
<li>第 \(i\) 头牛的危险系数：\(w_{i + 1} - s_i\)<br></li>
<li>第 \(i + 1\) 头牛的危险系数：\(- s_{i + 1}\)<br></li>
</ul>

<p>
由于 \(- s_i < w_{i + 1} - s_i\)、\(w_i - s_{i + 1} > - s_{i + 1}\)。<br>
</p>

<p>
所以如果有：\(w_i + s_i > w_{i + 1} + s_{i + 1} \) 即 \(w_i - s_{i + 1} > w_{i + 1} - s_i\) 则 \(max(- s_i, w_i - s_{i + 1}) > max(w_{i + 1} - s_i, - s_{i + 1})\)。<br>
</p>

<p>
那么一定会有交换后的危险系数小于交换前的危险系数。<br>
</p>

<p>
所以我们按 \(w_i + s_i\) 从小到大排序，一定会得到最优解，因为如果 \(w_i + s_i > w_{i + 1} + s_{i + 1} \)，交换之后至少不会使答案变差。<br>
</p>
</div>
</div>
<div id="outline-container-orgaf7290d" class="outline-3">
<h3 id="orgaf7290d">国王游戏</h3>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2021-04-14 13:04 三</p>
<p class="author">Author: L.M.haoran &lt;haoran.mc@outlook.com&gt;</p>
<p class="date">Created: 2021-11-03 Wed 21:50</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
