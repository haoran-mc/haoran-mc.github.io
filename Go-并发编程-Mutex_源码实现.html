<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-05-12 Thu 20:46 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Mutex 的源码实现</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">Mutex 的源码实现</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org26c1837">引言</a></li>
<li><a href="#orgbd6cb01">第一阶段：初版的互斥锁</a></li>
<li><a href="#orgacc80a3">第二阶段：新协程也有机会更早申请到锁</a></li>
<li><a href="#org877e168">第三阶段：多次请求锁</a></li>
<li><a href="#org80e2745">第四阶段：解决饥饿</a></li>
<li><a href="#org97a4dd7">饥饿模式和正常模式</a></li>
<li><a href="#org314dac7">总结</a></li>
</ul>
</div>
</div>

<div id="outline-container-org26c1837" class="outline-2">
<h2 id="org26c1837">引言</h2>
<div class="outline-text-2" id="text-org26c1837">
<p>
<code>Mutex</code> 的使用很简单，但 Go 源码中 <code>Mutex</code> 的实现并不简单。如果你阅读 Go 标准库里 <code>Mutex</code> 的源代码，并且追溯 <code>Mutex</code> 的演进历史，会发现，从一个简单易于理解的互斥锁的实现，到一个非常复杂的数据结构，这是一个逐步完善的过程。Go 开发者们做了种种努力，精心设计。<br>
</p>

<p>
现在我们就从 <code>Mutex</code> 的一个简单实现开始，看看它是怎样逐步提升性能和公平性的。在这个过程中，我们可以学习如何逐步设计一个完善的同步原语，并能对复杂度、性能、结构设计的权衡考量有新的认识。经过这样一个学习，我们不仅能通透掌握 Mutex，更好地使用这个工具，同时，对我们自己设计并发数据接口也非常有帮助。<br>
</p>

<p>
“初版”的 <code>Mutex</code> 使用一个 <code>flag</code> 来表示锁是否被持有，实现比较简单；后来照顾到新来的 goroutine，所以会让新的 goroutine 也尽可能地先获取到锁，这是第二个阶段；接下来第三阶段，照顾新来的和被唤醒的 goroutine；但是这样会带来饥饿问题，所以目前又加入了饥饿的解决方案，也就是第四阶段。<br>
</p>
</div>
</div>
<div id="outline-container-orgbd6cb01" class="outline-2">
<h2 id="orgbd6cb01">第一阶段：初版的互斥锁</h2>
<div class="outline-text-2" id="text-orgbd6cb01">
<p>
我们先来看怎么实现一个最简单的互斥锁。在开始之前，你可以先想一想，如果是你，你会怎么设计呢？<br>
</p>

<p>
你可能会想到，可以通过一个 <code>flag</code> 变量，标记当前的锁是否被某个 goroutine 持有。如果这个 <code>flag</code> 的值是 1，就代表锁已经被持有，那么，其它竞争的 goroutine 只能等待；如果这个 <code>flag</code> 的值是 0，就可以通过 CAS（compare-and-swap，或者 compare-and-set）将这个 <code>flag</code> 设置为 1，标识锁被当前的这个 goroutine 持有了。<br>
</p>

<p>
实际上，Russ Cox 在 2008 年提交的第一版 <code>Mutex</code> 就是这样实现的。<br>
</p>

<div class="org-src-container">
<pre class="src src-go">
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">CAS&#25805;&#20316;&#65292;&#24403;&#26102;&#36824;&#27809;&#26377;&#25277;&#35937;&#20986;atomic&#21253;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">cas</span>(<span style="color: #8787d7;">val</span> *<span style="color: #df005f; font-weight: bold;">int32</span>, <span style="color: #8787d7;">old</span>, <span style="color: #8787d7;">new</span> <span style="color: #df005f; font-weight: bold;">int32</span>) <span style="color: #df005f; font-weight: bold;">bool</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">semacquire</span>(*<span style="color: #df005f; font-weight: bold;">int32</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">semrelease</span>(*<span style="color: #df005f; font-weight: bold;">int32</span>)
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20114;&#26021;&#38145;&#30340;&#32467;&#26500;&#65292;&#21253;&#21547;&#20004;&#20010;&#23383;&#27573;</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Mutex</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    key  <span style="color: #df005f; font-weight: bold;">int32</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#38145;&#26159;&#21542;&#34987;&#25345;&#26377;&#30340;&#26631;&#35782;</span>
    sema <span style="color: #df005f; font-weight: bold;">int32</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20449;&#21495;&#37327;&#19987;&#29992;&#65292;&#29992;&#20197;&#38459;&#22622;/&#21796;&#37266;goroutine</span>
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20445;&#35777;&#25104;&#21151;&#22312;val&#19978;&#22686;&#21152;delta&#30340;&#20540;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">xadd</span>(<span style="color: #8787d7;">val</span> *<span style="color: #df005f; font-weight: bold;">int32</span>, <span style="color: #8787d7;">delta</span> <span style="color: #df005f; font-weight: bold;">int32</span>) (<span style="color: #8787d7;">new</span> <span style="color: #df005f; font-weight: bold;">int32</span>) {
    <span style="color: #268bd2; font-weight: bold;">for</span> {
        <span style="color: #8787d7;">v</span> := *val
        <span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #d75fd7; font-weight: bold;">cas</span>(val, v, v+delta) {
            <span style="color: #268bd2; font-weight: bold;">return</span> v + delta
        }
    }
    <span style="color: #268bd2;">panic</span>(<span style="color: #2aa198;">"unreached"</span>)
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35831;&#27714;&#38145;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">m</span> *<span style="color: #df005f; font-weight: bold;">Mutex</span>) <span style="color: #d75fd7; font-weight: bold;">Lock</span>() {
    <span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #d75fd7; font-weight: bold;">xadd</span>(&amp;m.key, 1) == 1 { <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#26631;&#35782;&#21152;1&#65292;&#22914;&#26524;&#31561;&#20110;1&#65292;&#25104;&#21151;&#33719;&#21462;&#21040;&#38145;</span>
        <span style="color: #268bd2; font-weight: bold;">return</span>
    }
    <span style="color: #d75fd7; font-weight: bold;">semacquire</span>(&amp;m.sema) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21542;&#21017;&#38459;&#22622;&#31561;&#24453;</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">m</span> *<span style="color: #df005f; font-weight: bold;">Mutex</span>) <span style="color: #d75fd7; font-weight: bold;">Unlock</span>() {
    <span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #d75fd7; font-weight: bold;">xadd</span>(&amp;m.key, -1) == 0 { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#23558;&#26631;&#35782;&#20943;&#21435;1&#65292;&#22914;&#26524;&#31561;&#20110;0&#65292;&#21017;&#27809;&#26377;&#20854;&#23427;&#31561;&#24453;&#32773;</span>
        <span style="color: #268bd2; font-weight: bold;">return</span>
    }
    <span style="color: #d75fd7; font-weight: bold;">semrelease</span>(&amp;m.sema) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21796;&#37266;&#20854;&#23427;&#38459;&#22622;&#30340;goroutine</span>
}
</pre>
</div>

<p>
这里先简单补充介绍刚刚提到的 CAS：<br>
</p>

<p>
CAS 指令将 <b>给定的值（v）</b> 和 <b>一个内存地址中的值（val）</b> 进行比较，如果它们是同一个值，就使用新值（v+delta）替换内存地址中的值，这个操作是原子性的（CAS 操作竟然是原子性的，它是怎么实现的？）。那啥是原子性呢？如果你还不太理解这个概念，那么在这里只需要明确一点就行了，那就是原子性保证这个指令总是基于最新的值进行计算，如果同时有其它线程已经修改了这个值，那么，CAS 会返回失败。<br>
</p>

<p>
好了，我们继续来分析下刚才的这段代码。<br>
</p>

<p>
虽然当时的 Go 语法和现在的稍微有些不同，而且标准库的布局、实现和现在的也有很大的差异，但是，这些差异不会影响我们对代码的理解，因为最核心的结构体（struct）和函数、方法的定义几乎是一样的。<br>
</p>

<p>
<code>Mutex</code> 结构体包含两个字段：<br>
</p>

<ul class="org-ul">
<li><b>字段 key</b> ：是一个 <code>flag</code> ，用来标识这个排外锁是否被某个 goroutine 所持有，如果 <code>key</code> 大于等于 1，说明这个排外锁已经被持有；<br></li>
<li><b>字段 sema</b> ：是个 <b>信号量变量</b> ，用来控制等待 goroutine 的阻塞休眠和唤醒。<br></li>
</ul>

<div class="div-center">
	<img src="./images/Go-并发编程-初版Mutex.webp" width="620px" />
</div>

<p>
调用 <code>Lock</code> 请求锁的时候，通过 <code>xadd</code> 方法进行 CAS 操作（第 24 行）， <code>xadd</code> 方法通过循环执行 CAS 操作直到成功，保证对 key 加 1 的操作成功完成。如果比较幸运，锁没有被别的 goroutine 持有，那么， <code>Lock</code> 方法成功地将 key 设置为 1，这个 goroutine 就持有了这个锁；如果锁已经被别的 goroutine 持有了，那么，当前的 goroutine 会把 key 加 1，而且还会调用 <code>semacquire</code> 方法（第 27 行），使用信号量将自己休眠，等锁释放的时候，信号量会将它唤醒。<br>
</p>

<blockquote>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Count</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    number <span style="color: #df005f; font-weight: bold;">int</span>
    mu     <span style="color: #df005f; font-weight: bold;">Mutex</span>   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20351;&#29992;&#19978;&#25991;&#20013;&#23450;&#20041;&#30340; Mutex&#65292;&#32780;&#38750; sync &#21253;&#20013;&#30340; Mutex</span>
}

<span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">count</span> <span style="color: #df005f; font-weight: bold;">Count</span>

<span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := 0; i &lt; 10; i++ {
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
        <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">j</span> := 0; j &lt; 100000; j++ {
            count.mu.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
            count.number++
            count.mu.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
        }
    }()
}
</pre>
</div>

<p>
这里阻塞等待与唤醒起到什么作用？如果 goroutine01 对 <code>count</code> 使用 <code>count.mu.Lock()</code> 方法，然后呢？ <code>count.mu.key</code> 会使用 <code>xadd</code> 加一，加一这个过程是死循环操作，所以一定会成功，然后判断 <code>count.mu.key</code> 是否等于 1：<br>
</p>

<ul class="org-ul">
<li>如果 <code>count.mu.key == 1</code> ：说明 goroutine02、goroutine03、goroutine04 &#x2026; 都没有给 <code>count</code> 上锁，那么 goroutine01 上锁成功！然后我就可以进行 <code>count.number++</code> 了，达到了计数的功能。<br></li>
<li>如果 <code>count.mu.key != 1</code> ：说明 goroutine02、goroutine03、goroutine04 &#x2026; 至少有一个已经给 <code>count</code> 上锁，那么阻塞 goroutine01，通过 <code>count.mu.sema</code> 来阻塞，那么 goroutine01 就需要等待直到没有其他 goroutine 在使用 <code>count</code> ，也就是 <code>count.mu.key == 1</code> 的时候，进行 <code>count.number++</code> 。<br>
<ul class="org-ul">
<li>（我觉得阻塞函数 <code>seacquire</code> 里面也有死循环，会一直监视 <code>count.mu.sema</code> 的值，就像 <code>count.mu.key</code> 等于 1 那样，当 <code>count.mu.sema</code> 也等于某个值时，说明当前协程被可以被唤醒，请求锁成功）<br></li>
<li>（其他协程使用 <code>semrelease</code> 函数释放锁，这个 <code>semrelease</code> 函数里面的操作应该就是修改 <code>count.mu.sema</code> 的值，其他正在阻塞的协程可以被唤醒）<br></li>
</ul></li>
</ul>
</blockquote>

<p>
持有锁的 goroutine 调用 <code>Unlock</code> 释放锁时，它会将 <code>key</code> 减 1（第 31 行）。如果当前没有其它等待这个锁的 goroutine，这个方法就返回了。但是，如果还有等待此锁的其它 goroutine，那么，它会调用 <code>semrelease</code> 方法（第 34 行），利用信号量唤醒等待锁的其它 goroutine 中的一个。<br>
</p>

<p>
所以，到这里，我们就知道了，初版的 <code>Mutex</code> 利用 CAS 原子操作，对 <code>key</code> 这个标志量进行设置。 <code>key</code> 不仅仅标识了锁是否被 goroutine 所持有，还记录了当前持有和等待获取锁的 goroutine 的数量。<br>
</p>

<p>
<code>Mutex</code> 的整体设计非常简洁，学习起来一点也没有障碍。但是，注意，我要划重点了。<br>
</p>

<p>
<code>Unlock</code> 方法可以 <span class="underline">被任意的 goroutine 调用释放锁，即使是没持有这个互斥锁的 goroutine</span> ，也可以进行这个操作。这是因为， <code>Mutex</code> 本身并没有包含持有这把锁的 goroutine 的信息，所以， <code>Unlock</code> 也不会对此进行检查。 <code>Mutex</code> 的这个设计一直保持至今。<br>
</p>

<p>
这就带来了一个有趣而危险的功能。为什么这么说呢？<br>
</p>

<p>
其它 goroutine 可以强制释放锁，这是一个非常危险的操作，因为在临界区的 goroutine 可能不知道锁已经被释放了，还会继续执行临界区的业务操作，这可能会带来意想不到的结果，因为这个 goroutine 还以为自己持有锁呢，有可能导致 data race 问题。<br>
</p>

<p>
所以，我们在使用 <code>Mutex</code> 的时候，必须要保证 goroutine 尽可能不去释放自己未持有的锁，一定要遵循 <b>谁申请，谁释放</b> 的原则。在真实的实践中，我们使用互斥锁的时候，很少在一个方法中单独申请锁，而在另外一个方法中单独释放锁，一般都会在同一个方法中获取锁和释放锁。<br>
</p>

<p>
如果你接触过其它语言（比如 Java 语言）的互斥锁的实现，就会发现这一点和其它语言的互斥锁不同。<br>
</p>

<p>
以前，我们经常会基于性能的考虑，及时释放掉锁，所以在一些 if-else 分支中加上释放锁的代码，代码看起来很臃肿。而且，在重构的时候，也很容易因为误删或者是漏掉而出现死锁的现象。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Foo</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    mu    <span style="color: #df005f; font-weight: bold;">sync.Mutex</span>
    count <span style="color: #df005f; font-weight: bold;">int</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">f</span> *<span style="color: #df005f; font-weight: bold;">Foo</span>) <span style="color: #d75fd7; font-weight: bold;">Bar</span>() {
    f.mu.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()

    <span style="color: #268bd2; font-weight: bold;">if</span> f.count &lt; 1000 {
        f.count += 3
        f.mu.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>() <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#27492;&#22788;&#37322;&#25918;&#38145;</span>
        <span style="color: #268bd2; font-weight: bold;">return</span>
    }

    f.count++
    f.mu.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>() <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#27492;&#22788;&#37322;&#25918;&#38145;</span>
    <span style="color: #268bd2; font-weight: bold;">return</span>
}
</pre>
</div>

<p>
从 1.14 版本起，Go 对 <code>defer</code> 做了优化，采用更有效的内联方式，取代之前的生成 <code>defer</code> 对象到 <code>defer chain</code> 中， <code>defer</code> 对耗时的影响微乎其微了，所以基本上修改成下面简洁的写法也没问题：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">f</span> *<span style="color: #df005f; font-weight: bold;">Foo</span>) <span style="color: #d75fd7; font-weight: bold;">Bar</span>() {
    f.mu.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
    <span style="color: #268bd2; font-weight: bold;">defer</span> f.mu.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()

    <span style="color: #268bd2; font-weight: bold;">if</span> f.count &lt; 1000 {
        f.count += 3
        <span style="color: #268bd2; font-weight: bold;">return</span>
    }

    f.count++
    <span style="color: #268bd2; font-weight: bold;">return</span>
}
</pre>
</div>

<p>
这样做的好处就是 Lock/Unlock 总是成对紧凑出现，不会遗漏或者多调用，代码更少。<br>
</p>

<p>
但是，如果临界区只是方法中的一部分，为了尽快释放锁，还是应该第一时间调用 <code>Unlock</code> ，而不是一直等到方法返回时才释放。<br>
</p>

<p>
初版的 <code>Mutex</code> 实现之后，Go 开发组又对 <code>Mutex</code> 做了一些微调，比如把字段类型变成了 <code>uint32</code> 类型；调用 <code>Unlock</code> 方法会做检查；使用 <code>atomic</code> 包的同步原语执行原子操作等等，这些小的改动，都不是核心功能，简单知道就可以。<br>
</p>

<p>
但是，初版的 <code>Mutex</code> 实现有一个问题：请求锁的 goroutine 会排队等待获取互斥锁。虽然这貌似很公平，但是从性能上来看，却不是最优的。因为如果我们能够把锁交给正在占用 CPU 时间片的 goroutine 的话，那就不需要做上下文的切换，在高并发的情况下，可能会有更好的性能。<br>
</p>

<p>
接下来，我们就继续探索 Go 开发者是怎么解决这个问题的。<br>
</p>
</div>
</div>
<div id="outline-container-orgacc80a3" class="outline-2">
<h2 id="orgacc80a3">第二阶段：新协程也有机会更早申请到锁</h2>
<div class="outline-text-2" id="text-orgacc80a3">
<p>
Go 开发者在 2011 年 6 月 30 日的 commit 中对 <code>Mutex</code> 做了一次大的调整，调整后的 <code>Mutex</code> 实现如下：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Mutex</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    state <span style="color: #df005f; font-weight: bold;">int32</span>
    sema  <span style="color: #df005f; font-weight: bold;">uint32</span>
}

<span style="color: #268bd2; font-weight: bold;">const</span> (
    <span style="color: #d75fd7;">mutexLocked</span> = 1 &lt;&lt; <span style="color: #d75fd7;">iota</span>   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">mutex is locked</span>
    <span style="color: #d75fd7;">mutexWoken</span>
    <span style="color: #d75fd7;">mutexWaiterShift</span> = <span style="color: #d75fd7;">iota</span>
)
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">1 2 2</span>
</pre>
</div>

<p>
虽然 <code>Mutex</code> 结构体还是包含两个字段，但是第一个字段已经改成了 <code>state</code> ，它的含义也不一样了。<br>
</p>

<div class="div-center">
	<img src="./images/Go-并发编程-Mutex_state字段.webp" width="620px" />
</div>

<p>
<code>state</code> 是一个复合型的字段，一个字段包含多个意义，这样可以通过尽可能少的内存来实现互斥锁。这个字段的第一位（最小的一位）来表示这个锁是否被持有，第二位代表是否有唤醒的 goroutine，剩余的位数代表的是等待此锁的 goroutine 数。所以， <code>state</code> 这一个字段被分成了三部分，代表三个数据。<br>
</p>

<p>
请求锁的方法 <code>Lock</code> 也变得复杂了。复杂之处不仅仅在于对字段 <code>state</code> 的操作难以理解，而且代码逻辑也变得相当复杂。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">m</span> *<span style="color: #df005f; font-weight: bold;">Mutex</span>) <span style="color: #d75fd7; font-weight: bold;">Lock</span>() {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Fast path: &#24184;&#36816; case&#65292;&#27809;&#26377;&#20854;&#20182; goroutine &#31561;&#24453;&#33719;&#21462;&#38145;&#65292;&#33021;&#22815;&#30452;&#25509;&#33719;&#21462;&#21040;&#38145;</span>
    <span style="color: #268bd2; font-weight: bold;">if</span> atomic.<span style="color: #d75fd7; font-weight: bold;">CompareAndSwapInt32</span>(&amp;m.state, 0, mutexLocked) {
        <span style="color: #268bd2; font-weight: bold;">return</span>
    }

    <span style="color: #8787d7;">awoke</span> := <span style="color: #d75fd7;">false</span>
    <span style="color: #268bd2; font-weight: bold;">for</span> {
        <span style="color: #8787d7;">old</span> := m.state              <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21407;&#20808;&#29366;&#24577;</span>
        <span style="color: #8787d7;">new</span> := old | mutexLocked    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21407;&#29366;&#24577;&#21152;&#38145; -&gt; &#26032;&#29366;&#24577;</span>
        <span style="color: #268bd2; font-weight: bold;">if</span> old&amp;mutexLocked != 0 {   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#24050;&#32463;&#26377; goroutine &#25345;&#26377;&#38145;&#20102;</span>
            new = old + 1&lt;&lt;mutexWaiterShift <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#31561;&#24453;&#32773;&#25968;&#37327;&#21152;&#19968;</span>
        }
        <span style="color: #268bd2; font-weight: bold;">if</span> awoke {
            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">goroutine &#26377;&#20004;&#31181;&#65306;&#26032;&#26469;&#30340; goroutine&#12289;&#34987;&#21796;&#37266;&#30340; goroutine</span>
            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36827;&#20837;&#36825;&#20010;&#20998;&#25903;&#30340; goroutine &#26159;&#34987;&#21796;&#37266;&#30340;&#65292;&#38656;&#35201;&#28165;&#38500;&#21796;&#37266;&#26631;&#24535;</span>
            new &amp;^= mutexWoken
        }
        <span style="color: #268bd2; font-weight: bold;">if</span> atomic.<span style="color: #d75fd7; font-weight: bold;">CompareAndSwapInt32</span>(&amp;m.state, old, new) {   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35774;&#32622;&#26032;&#29366;&#24577;</span>
            <span style="color: #268bd2; font-weight: bold;">if</span> old&amp;mutexLocked == 0 {    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#38145;&#27809;&#26377;&#34987;&#21035;&#30340; goroutine &#25345;&#26377;&#65292;&#26080;&#20027;&#29366;&#24577;</span>
                <span style="color: #268bd2; font-weight: bold;">break</span>   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36339;&#20986;&#65292;&#33719;&#21462;&#21040;&#38145;</span>
            }
            runtime.<span style="color: #d75fd7; font-weight: bold;">Semacquire</span>(&amp;m.sema)  <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35831;&#27714;&#20449;&#21495;&#37327;</span>
            awoke = <span style="color: #d75fd7;">true</span>   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#19978;&#38754;&#19968;&#34892;&#23558;&#24403;&#21069; goroutine &#20241;&#30496;&#65292;&#36208;&#21040;&#36825;&#27493;&#35828;&#26126;&#24403;&#21069; goroutine &#24050;&#32463;&#34987;&#21796;&#37266;&#65292;&#38656;&#35201;&#20351;&#29992; flag &#26631;&#35760;&#19968;&#19979;</span>
        }
    }
}
</pre>
</div>

<p>
首先是通过 CAS 检测 <code>state</code> 字段中的标志（第 3 行），如果没有 goroutine 持有锁，也没有等待持有锁的 gorutine，那么，当前的 goroutine 就很幸运，可以直接获得锁，这也是注释中的 Fast path 的意思。<br>
</p>

<p>
如果不够幸运， <code>state</code> 不是零值，那么就通过一个循环进行检查。 <code>for</code> 循环不断尝试获取锁，如果获取不到，就通过 <code>runtime.Semacquire(&amp;m.sema)</code> 休眠，休眠醒来之后 <code>awoke</code> 置为 <code>true</code> ，尝试争抢锁。<br>
</p>

<p>
代码中的第 10 行将当前的 <code>flag</code> 设置为加锁状态，如果能成功地通过 CAS 把这个新值赋予 <code>state</code> （第 19 行和第 20 行），就代表抢夺锁的操作成功了。<br>
</p>

<p>
不过，需要注意的是，如果成功地设置了 <code>state</code> 的值，但是之前的 <code>state</code> 是有锁的状态，那么， <code>state</code> 只是清除 <code>mutexWoken</code> 标志或者增加一个 <code>waiter</code> 而已。<br>
</p>

<p>
请求锁的 goroutine 有两类，一类是新来请求锁的 goroutine，另一类是被唤醒的等待请求锁的 goroutine；锁的状态也有两种：加锁和未加锁。<br>
</p>

<div class="div-center">
	<img src="./images/Go-并发编程-两类请求锁的goroutine.webp" width="620px" />
</div>

<p>
刚刚说的都是获取锁，接下来，我们再来看看释放锁。释放锁的 <code>Unlock</code> 方法也有些复杂，我们来看一下。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">m</span> *<span style="color: #df005f; font-weight: bold;">Mutex</span>) <span style="color: #d75fd7; font-weight: bold;">Unlock</span>() {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Fast path: drop lock bit.</span>
    <span style="color: #8787d7;">new</span> := atomic.<span style="color: #d75fd7; font-weight: bold;">AddInt32</span>(&amp;m.state, -mutexLocked)   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21435;&#25481;&#38145;&#26631;&#24535;</span>
    <span style="color: #268bd2; font-weight: bold;">if</span> (new+mutexLocked)&amp;mutexLocked == 0 {   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#26412;&#26469;&#23601;&#27809;&#26377;&#21152;&#38145;</span>
        <span style="color: #268bd2;">panic</span>(<span style="color: #2aa198;">"sync: unlock of unlocked mutex"</span>)
    }

    <span style="color: #8787d7;">old</span> := new
    <span style="color: #268bd2; font-weight: bold;">for</span> {
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#27809;&#26377;&#31561;&#24453;&#32773;&#65292;&#25110;&#32773;&#26377;&#21796;&#37266;&#30340; waiter</span>
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#25110;&#32773;&#22312;&#21435;&#25481;&#38145;&#30340;&#36825;&#30701;&#30701;&#20960;&#21477;&#30340;&#26102;&#38388;&#37324;&#65292;&#26377;&#26032;&#26469;&#30340; goroutinte &#25345;&#26377;&#20102;&#38145;</span>
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#37027;&#25105;&#20204;&#23601;&#19981;&#38656;&#35201;&#23558;&#21035;&#30340; goroutine &#21796;&#37266;&#20102;</span>
        <span style="color: #268bd2; font-weight: bold;">if</span> old&gt;&gt;mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken) != 0 {
            <span style="color: #268bd2; font-weight: bold;">return</span>
        }
        new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#26032;&#29366;&#24577;&#65292;&#20934;&#22791;&#21796;&#37266; goroutine&#65292;&#24182;&#35774;&#32622;&#21796;&#37266;&#26631;&#24535;</span>
        <span style="color: #268bd2; font-weight: bold;">if</span> atomic.<span style="color: #d75fd7; font-weight: bold;">CompareAndSwapInt32</span>(&amp;m.state, old, new) {
            runtime.<span style="color: #d75fd7; font-weight: bold;">Semrelease</span>(&amp;m.sema)
            <span style="color: #268bd2; font-weight: bold;">return</span>
        }
        old = m.state
    }
}
</pre>
</div>

<p>
第 3 行是尝试将持有锁的标识设置为未加锁的状态，这是通过减 1 而不是将标志位置零的方式实现。第 4 到 6 行还会检测原来锁的状态是否已经未加锁的状态，如果是 <code>Unlock</code> 一个未加锁的 <code>Mutex</code> 会直接 <code>panic</code> 。<br>
</p>

<p>
不过，即使将加锁置为未加锁的状态，这个方法也不能直接返回，还需要一些额外的操作，因为还可能有一些等待这个锁的 goroutine（有时候我也把它们称之为 waiter）需要通过信号量的方式唤醒它们中的一个。所以接下来的逻辑有两种情况。<br>
</p>

<ul class="org-ul">
<li>第一种情况，如果没有其它的 waiter，说明对这个锁的竞争的 goroutine 只有一个，那就可以直接返回了；如果这个时候有唤醒的 goroutine，或者是又被别人加了锁，那么，无需我们操劳，其它 goroutine 自己干得都很好，当前的这个 goroutine 就可以放心返回了。<br></li>
<li>第二种情况，如果有等待者，并且没有唤醒的 waiter，那就需要唤醒一个等待的 waiter。在唤醒之前，需要将 waiter 数量减 1，并且将 <code>mutexWoken</code> 标志设置上，这样， <code>Unlock</code> 就可以返回了。<br></li>
</ul>

<p>
相对于初版的设计，这次的改动主要就是，新来的 goroutine 也有机会先获取到锁，甚至一个 goroutine 可能连续获取到锁，打破了先来先得的逻辑。但是，代码复杂度也显而易见。<br>
</p>

<p>
虽然这一版的 <code>Mutex</code> 已经给新来请求锁的 goroutine 一些机会，让它参与竞争，没有空闲的锁或者竞争失败才加入到等待队列中。但是其实还可以进一步优化。我们接着往下看。<br>
</p>
</div>
</div>
<div id="outline-container-org877e168" class="outline-2">
<h2 id="org877e168">第三阶段：多次请求锁</h2>
<div class="outline-text-2" id="text-org877e168">
<p>
在 2015 年 2 月的改动中，如果新来的 goroutine 或者是被唤醒的 goroutine 首次获取不到锁，它们就会通过自旋（spin，通过循环不断尝试，spin 的逻辑是在 <a href="https://github.com/golang/go/blob/846dce9d05f19a1f53465e62a304dea21b99f910/src/runtime/proc.go#L5580">runtime</a> 实现的）的方式，尝试检查锁是否被释放。在尝试一定的自旋次数后，再执行原来的逻辑。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">m</span> *<span style="color: #df005f; font-weight: bold;">Mutex</span>) <span style="color: #d75fd7; font-weight: bold;">Lock</span>() {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Fast path: &#24184;&#36816;&#20043;&#36335;&#65292;&#27491;&#22909;&#33719;&#21462;&#21040;&#38145;</span>
    <span style="color: #268bd2; font-weight: bold;">if</span> atomic.<span style="color: #d75fd7; font-weight: bold;">CompareAndSwapInt32</span>(&amp;m.state, 0, mutexLocked) {
        <span style="color: #268bd2; font-weight: bold;">return</span>
    }

    <span style="color: #8787d7;">awoke</span> := <span style="color: #d75fd7;">false</span>
    <span style="color: #8787d7;">iter</span> := 0
    <span style="color: #268bd2; font-weight: bold;">for</span> {              <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#19981;&#31649;&#26159;&#26032;&#26469;&#30340;&#12289;&#36824;&#26159;&#34987;&#21796;&#37266;&#30340; goroutine&#65292;&#37117;&#19981;&#26029;&#23581;&#35797;&#35831;&#27714;&#38145;</span>
        <span style="color: #8787d7;">old</span> := m.state   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20808;&#20445;&#23384;&#24403;&#21069;&#38145;&#30340;&#29366;&#24577;</span>
        <span style="color: #8787d7;">new</span> := old | mutexLocked       <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#26032;&#29366;&#24577;&#35774;&#32622;&#21152;&#38145;&#26631;&#24535;</span>
        <span style="color: #268bd2; font-weight: bold;">if</span> old&amp;mutexLocked != 0 {      <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#38145;&#36824;&#27809;&#34987;&#37322;&#25918;</span>
            <span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #d75fd7; font-weight: bold;">runtime_canSpin</span>(iter) {   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36824;&#21487;&#20197;&#33258;&#26059;</span>
                <span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #d75fd7;">!</span>awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;
                    atomic.<span style="color: #d75fd7; font-weight: bold;">CompareAndSwapInt32</span>(&amp;m.state, old, old|mutexWoken) {
                    awoke = <span style="color: #d75fd7;">true</span>
                }
                <span style="color: #d75fd7; font-weight: bold;">runtime_doSpin</span>()
                iter++
                <span style="color: #268bd2; font-weight: bold;">continue</span>   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#33258;&#26059;&#65292;&#20877;&#27425;&#23581;&#35797;&#35831;&#27714;&#38145;</span>
            }
            new = old + 1&lt;&lt;mutexWaiterShift
        }
        <span style="color: #268bd2; font-weight: bold;">if</span> awoke {     <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21796;&#37266;&#29366;&#24577;</span>
            <span style="color: #268bd2; font-weight: bold;">if</span> new&amp;mutexWoken == 0 {
                <span style="color: #268bd2;">panic</span>(<span style="color: #2aa198;">"sync: inconsistent mutex state"</span>)
            }
            new &amp;^= mutexWoken   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#26032;&#29366;&#24577;&#28165;&#38500;&#21796;&#37266;&#26631;&#35760;</span>
        }
        <span style="color: #268bd2; font-weight: bold;">if</span> atomic.<span style="color: #d75fd7; font-weight: bold;">CompareAndSwapInt32</span>(&amp;m.state, old, new) {
            <span style="color: #268bd2; font-weight: bold;">if</span> old&amp;mutexLocked == 0 {   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#26087;&#29366;&#24577;&#38145;&#24050;&#37322;&#25918;&#65292;&#26032;&#29366;&#24577;&#25104;&#21151;&#25345;&#26377;&#20102;&#38145;&#65292;&#30452;&#25509;&#36820;&#22238;</span>
                <span style="color: #268bd2; font-weight: bold;">break</span>
            }
            <span style="color: #d75fd7; font-weight: bold;">runtime_Semacquire</span>(&amp;m.sema)   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#38459;&#22622;&#31561;&#24453;</span>
            awoke = <span style="color: #d75fd7;">true</span>   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#34987;&#21796;&#37266;</span>
            iter = 0
        }
    }
}
</pre>
</div>

<p>
这次的优化，增加了第 13 行到 21 行、第 25 行到第 27 行以及第 36 行。我来解释一下主要的逻辑，也就是第 13 行到 21 行。<br>
</p>

<p>
如果可以 spin 的话，第 9 行的 for 循环会重新检查锁是否释放。对于临界区代码执行非常短的场景来说，这是一个非常好的优化。因为临界区的代码耗时很短，锁很快就能释放，而抢夺锁的 goroutine 不用通过休眠唤醒方式等待调度，直接 spin 几次，可能就获得了锁。<br>
</p>
</div>
</div>
<div id="outline-container-org80e2745" class="outline-2">
<h2 id="org80e2745">第四阶段：解决饥饿</h2>
<div class="outline-text-2" id="text-org80e2745">
<p>
经过几次优化，Mutex 的代码越来越复杂，应对高并发争抢锁的场景也更加公平。但是因为新来的 goroutine 也参与竞争，有可能每次都会被新来的 goroutine 抢到获取锁的机会，在极端情况下，等待中的 goroutine 可能会一直获取不到锁，这就是 <b>饥饿问题</b> 。<br>
</p>

<p>
所以，2016 年 Go 1.9 中 Mutex 增加了饥饿模式，让锁变得更公平，不公平的等待时间限制在 1 毫秒，并且修复了一个大 Bug：总是把唤醒的 goroutine 放在等待队列的尾部，会导致更加不公平的等待时间。<br>
</p>

<p>
之后，2018 年，Go 开发者将 fast path 和 slow path 拆成独立的方法，以便内联，提高性能。2019 年也有一个 Mutex 的优化，虽然没有对 Mutex 做修改，但是，对于 Mutex 唤醒后持有锁的那个 waiter，调度器可以有更高的优先级去执行，这已经是很细致的性能优化了。<br>
</p>

<p>
为了避免代码过多，这里只列出当前的 Mutex 实现。<br>
</p>

<p>
当然，现在的 Mutex 代码已经复杂得接近不可读的状态了，而且代码也非常长，删减后占了几乎三页纸。但是，作为第一个要详细介绍的同步原语，我还是希望能更清楚地剖析 Mutex 的实现，向你展示它的演化和为了一个貌似很小的 feature 不得不将代码变得非常复杂的原因。<br>
</p>

<div class="div-center">
	<img src="./images/Go-并发编程-state字段添加饥饿标记.webp" width="620px" />
</div>

<p>
当然，你也可以暂时略过这一段，只需要记住，Mutex 绝不容忍一个 goroutine 被落下，永远没有机会获取锁。不抛弃不放弃是它的宗旨，而且它也尽可能地让等待较长的 goroutine 更有机会获取到锁。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Mutex</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    state <span style="color: #df005f; font-weight: bold;">int32</span>
    sema  <span style="color: #df005f; font-weight: bold;">uint32</span>
}

<span style="color: #268bd2; font-weight: bold;">const</span> (
    <span style="color: #d75fd7;">mutexLocked</span> = 1 &lt;&lt; <span style="color: #d75fd7;">iota</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">mutex is locked</span>
    <span style="color: #d75fd7;">mutexWoken</span>
    <span style="color: #d75fd7;">mutexStarving</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20174;state&#23383;&#27573;&#20013;&#20998;&#20986;&#19968;&#20010;&#39269;&#39295;&#26631;&#35760;</span>
    <span style="color: #d75fd7;">mutexWaiterShift</span> = <span style="color: #d75fd7;">iota</span>

    <span style="color: #d75fd7;">starvationThresholdNs</span> = 1e6
)

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">m</span> *<span style="color: #df005f; font-weight: bold;">Mutex</span>) <span style="color: #d75fd7; font-weight: bold;">Lock</span>() {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Fast path: &#24184;&#36816;&#20043;&#36335;&#65292;&#19968;&#19979;&#23601;&#33719;&#21462;&#21040;&#20102;&#38145;</span>
    <span style="color: #268bd2; font-weight: bold;">if</span> atomic.<span style="color: #d75fd7; font-weight: bold;">CompareAndSwapInt32</span>(&amp;m.state, 0, mutexLocked) {
        <span style="color: #268bd2; font-weight: bold;">return</span>
    }
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Slow path&#65306;&#32531;&#24930;&#20043;&#36335;&#65292;&#23581;&#35797;&#33258;&#26059;&#31454;&#20105;&#25110;&#39269;&#39295;&#29366;&#24577;&#19979;&#39269;&#39295;goroutine&#31454;&#20105;</span>
    m.<span style="color: #d75fd7; font-weight: bold;">lockSlow</span>()
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">m</span> *<span style="color: #df005f; font-weight: bold;">Mutex</span>) <span style="color: #d75fd7; font-weight: bold;">lockSlow</span>() {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">waitStartTime</span> <span style="color: #df005f; font-weight: bold;">int64</span>   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35831;&#27714;&#38145;&#30340;&#21021;&#22987;&#26102;&#38388;</span>
    <span style="color: #8787d7;">starving</span> := <span style="color: #d75fd7;">false</span>   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#27492; goroutine &#30340;&#39269;&#39295;&#26631;&#35760;</span>
    <span style="color: #8787d7;">awoke</span> := <span style="color: #d75fd7;">false</span>      <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21796;&#37266;&#26631;&#35760;</span>
    <span style="color: #8787d7;">iter</span> := 0           <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#33258;&#26059;&#27425;&#25968;</span>
    <span style="color: #8787d7;">old</span> := m.state      <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#24403;&#21069;&#30340;&#38145;&#30340;&#29366;&#24577;</span>
    <span style="color: #268bd2; font-weight: bold;">for</span> {
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#38145;&#26159;&#38750;&#39269;&#39295;&#29366;&#24577;&#65292;&#38145;&#36824;&#27809;&#34987;&#37322;&#25918;&#65292;&#23581;&#35797;&#33258;&#26059;</span>
        <span style="color: #268bd2; font-weight: bold;">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; <span style="color: #d75fd7; font-weight: bold;">runtime_canSpin</span>(iter) {
            <span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #d75fd7;">!</span>awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;
                atomic.<span style="color: #d75fd7; font-weight: bold;">CompareAndSwapInt32</span>(&amp;m.state, old, old|mutexWoken) {
                awoke = <span style="color: #d75fd7;">true</span>
            }
            <span style="color: #d75fd7; font-weight: bold;">runtime_doSpin</span>()
            iter++
            old = m.state   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20877;&#27425;&#33719;&#21462;&#38145;&#30340;&#29366;&#24577;&#65292;&#20043;&#21518;&#20250;&#26816;&#26597;&#26159;&#21542;&#38145;&#34987;&#37322;&#25918;&#20102;</span>
            <span style="color: #268bd2; font-weight: bold;">continue</span>
        }
        <span style="color: #8787d7;">new</span> := old
        <span style="color: #268bd2; font-weight: bold;">if</span> old&amp;mutexStarving == 0 {
            new |= mutexLocked   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#38750;&#39269;&#39295;&#29366;&#24577;&#65292;&#21152;&#38145;</span>
        }
        <span style="color: #268bd2; font-weight: bold;">if</span> old&amp;(mutexLocked|mutexStarving) != 0 {   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#38145;&#24050;&#32463;&#25345;&#26377;&#25110;&#32773;&#22788;&#20110;&#39269;&#39295;&#29366;&#24577;</span>
            new += 1 &lt;&lt; mutexWaiterShift   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">waiter &#25968;&#37327;&#21152; 1</span>
        }
        <span style="color: #268bd2; font-weight: bold;">if</span> starving &amp;&amp; old&amp;mutexLocked != 0 {
            new |= mutexStarving   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35774;&#32622;&#39269;&#39295;&#29366;&#24577;</span>
        }
        <span style="color: #268bd2; font-weight: bold;">if</span> awoke {
            <span style="color: #268bd2; font-weight: bold;">if</span> new&amp;mutexWoken == 0 {
                <span style="color: #d75fd7; font-weight: bold;">throw</span>(<span style="color: #2aa198;">"sync: inconsistent mutex state"</span>)
            }
            new &amp;^= mutexWoken   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#26032;&#29366;&#24577;&#28165;&#38500;&#21796;&#37266;&#26631;&#35760;</span>
        }
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#25104;&#21151;&#35774;&#32622;&#26032;&#29366;&#24577;</span>
        <span style="color: #268bd2; font-weight: bold;">if</span> atomic.<span style="color: #d75fd7; font-weight: bold;">CompareAndSwapInt32</span>(&amp;m.state, old, new) {
            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21407;&#26469;&#38145;&#30340;&#29366;&#24577;&#24050;&#37322;&#25918;&#65292;&#24182;&#19988;&#19981;&#26159;&#39269;&#39295;&#29366;&#24577;&#65292;&#27491;&#24120;&#35831;&#27714;&#21040;&#20102;&#38145;&#65292;&#36820;&#22238;</span>
            <span style="color: #268bd2; font-weight: bold;">if</span> old&amp;(mutexLocked|mutexStarving) == 0 {
                <span style="color: #268bd2; font-weight: bold;">break</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">locked the mutex with CAS</span>
            }
            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22788;&#29702;&#39269;&#39295;&#29366;&#24577;</span>

            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22914;&#26524;&#20197;&#21069;&#23601;&#22312;&#38431;&#21015;&#37324;&#38754;&#65292;&#21152;&#20837;&#21040;&#38431;&#21015;&#22836;</span>
            <span style="color: #8787d7;">queueLifo</span> := waitStartTime != 0
            <span style="color: #268bd2; font-weight: bold;">if</span> waitStartTime == 0 {
                waitStartTime = <span style="color: #d75fd7; font-weight: bold;">runtime_nanotime</span>()
            }
            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#38459;&#22622;&#31561;&#24453;</span>
            <span style="color: #d75fd7; font-weight: bold;">runtime_SemacquireMutex</span>(&amp;m.sema, queueLifo, 1)
            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21796;&#37266;&#20043;&#21518;&#26816;&#26597;&#38145;&#26159;&#21542;&#24212;&#35813;&#22788;&#20110;&#39269;&#39295;&#29366;&#24577;</span>
            starving = starving || <span style="color: #d75fd7; font-weight: bold;">runtime_nanotime</span>()-waitStartTime &gt; starvationThresholdNs
            old = m.state
            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22914;&#26524;&#38145;&#24050;&#32463;&#22788;&#20110;&#39269;&#39295;&#29366;&#24577;&#65292;&#30452;&#25509;&#25250;&#21040;&#38145;&#65292;&#36820;&#22238;</span>
            <span style="color: #268bd2; font-weight: bold;">if</span> old&amp;mutexStarving != 0 {
                <span style="color: #268bd2; font-weight: bold;">if</span> old&amp;(mutexLocked|mutexWoken) != 0 || old&gt;&gt;mutexWaiterShift == 0 {
                    <span style="color: #d75fd7; font-weight: bold;">throw</span>(<span style="color: #2aa198;">"sync: inconsistent mutex state"</span>)
                }
                <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#26377;&#28857;&#32469;&#65292;&#21152;&#38145;&#24182;&#19988;&#23558;waiter&#25968;&#20943;1</span>
                <span style="color: #8787d7;">delta</span> := <span style="color: #d75fd7; font-weight: bold;">int32</span>(mutexLocked - 1&lt;&lt;mutexWaiterShift)
                <span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #d75fd7;">!</span>starving || old&gt;&gt;mutexWaiterShift == 1 {
                    delta -= mutexStarving <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#26368;&#21518;&#19968;&#20010;waiter&#25110;&#32773;&#24050;&#32463;&#19981;&#39269;&#39295;&#20102;&#65292;&#28165;&#38500;&#39269;&#39295;&#26631;&#35760;</span>
                }
                atomic.<span style="color: #d75fd7; font-weight: bold;">AddInt32</span>(&amp;m.state, delta)
                <span style="color: #268bd2; font-weight: bold;">break</span>
            }
            awoke = <span style="color: #d75fd7;">true</span>
            iter = 0
        } <span style="color: #268bd2; font-weight: bold;">else</span> {
            old = m.state
        }
    }
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">m</span> *<span style="color: #df005f; font-weight: bold;">Mutex</span>) <span style="color: #d75fd7; font-weight: bold;">Unlock</span>() {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Fast path: drop lock bit.</span>
    <span style="color: #8787d7;">new</span> := atomic.<span style="color: #d75fd7; font-weight: bold;">AddInt32</span>(&amp;m.state, -mutexLocked)
    <span style="color: #268bd2; font-weight: bold;">if</span> new != 0 {
        m.<span style="color: #d75fd7; font-weight: bold;">unlockSlow</span>(new)
    }
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">m</span> *<span style="color: #df005f; font-weight: bold;">Mutex</span>) <span style="color: #d75fd7; font-weight: bold;">unlockSlow</span>(<span style="color: #8787d7;">new</span> <span style="color: #df005f; font-weight: bold;">int32</span>) {
    <span style="color: #268bd2; font-weight: bold;">if</span> (new+mutexLocked)&amp;mutexLocked == 0 {
        <span style="color: #d75fd7; font-weight: bold;">throw</span>(<span style="color: #2aa198;">"sync: unlock of unlocked mutex"</span>)
    }
    <span style="color: #268bd2; font-weight: bold;">if</span> new&amp;mutexStarving == 0 {
        <span style="color: #8787d7;">old</span> := new
        <span style="color: #268bd2; font-weight: bold;">for</span> {
            <span style="color: #268bd2; font-weight: bold;">if</span> old&gt;&gt;mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken|mutexStarving) != 0 {
                <span style="color: #268bd2; font-weight: bold;">return</span>
            }
            new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken
            <span style="color: #268bd2; font-weight: bold;">if</span> atomic.<span style="color: #d75fd7; font-weight: bold;">CompareAndSwapInt32</span>(&amp;m.state, old, new) {
                <span style="color: #d75fd7; font-weight: bold;">runtime_Semrelease</span>(&amp;m.sema, <span style="color: #d75fd7;">false</span>, 1)
                <span style="color: #268bd2; font-weight: bold;">return</span>
            }
            old = m.state
        }
    } <span style="color: #268bd2; font-weight: bold;">else</span> {
        <span style="color: #d75fd7; font-weight: bold;">runtime_Semrelease</span>(&amp;m.sema, <span style="color: #d75fd7;">true</span>, 1)
    }
}   
</pre>
</div>

<p>
跟之前的实现相比，当前的 <code>Mutex</code> 最重要的变化，就是增加饥饿模式。第 12 行将饥饿模式的最大等待时间阈值设置成了 1 毫秒，这就意味着，一旦等待者等待的时间超过了这个阈值， <code>Mutex</code> 的处理就有可能进入饥饿模式，优先让等待者先获取到锁，新来的同学主动谦让一下，给老同志一些机会。<br>
</p>

<p>
通过加入饥饿模式，可以避免把机会全都留给新来的 goroutine，保证了请求锁的 goroutine 获取锁的公平性，对于我们使用锁的业务代码来说，不会有业务一直等待锁不被处理。<br>
</p>
</div>
</div>
<div id="outline-container-org97a4dd7" class="outline-2">
<h2 id="org97a4dd7">饥饿模式和正常模式</h2>
<div class="outline-text-2" id="text-org97a4dd7">
<p>
<code>Mutex</code> 可能处于两种操作模式下：正常模式、饥饿模式。<br>
</p>

<p>
请求锁时调用的 <code>Lock</code> 方法中一开始是 fast path，这是一个幸运的场景，当前的 goroutine 幸运地获得了锁，没有竞争，直接返回，否则就进入了 <code>lockSlow</code> 方法。这样的设计，方便编译器对 <code>Lock</code> 方法进行内联（把 slow path 的内容提取成一个函数之后，就可以将原来的 Lock 函数变的特别小，这样当其他函数调用 <code>Lock</code> 的时候就可以直接将 <code>Lock</code> 内敛到自己的函数中），你也可以在程序开发中应用这个技巧。<br>
</p>

<p>
正常模式下，waiter 都是进入先入先出队列，被唤醒的 waiter 并不会直接持有锁，而是要和新来的 goroutine 进行竞争。新来的 goroutine 有先天的优势，它们正在 CPU 中运行，可能它们的数量还不少，所以，在高并发情况下，被唤醒的 waiter 可能比较悲剧地获取不到锁，这时，它会被插入到队列的前面。如果 waiter 获取不到锁的时间超过阈值 1 毫秒，那么，这个 Mutex 就进入到了饥饿模式。<br>
</p>

<p>
在饥饿模式下， <code>Mutex</code> 的拥有者将直接把锁交给队列最前面的 waiter。新来的 goroutine 不会尝试获取锁，即使看起来锁没有被持有，它也不会去抢，也不会 spin，它会乖乖地加入到等待队列的尾部。<br>
</p>

<p>
如果拥有 <code>Mutex</code> 的 waiter 发现下面两种情况的其中之一，它就会把这个 <code>Mutex</code> 转换成正常模式：<br>
</p>

<ul class="org-ul">
<li>此 waiter 已经是队列中的最后一个 waiter 了，没有其它的等待锁的 goroutine 了；<br></li>
<li>此 waiter 的等待时间小于 1 毫秒。<br></li>
</ul>

<p>
正常模式拥有更好的性能，因为即使有等待抢锁的 waiter，goroutine 也可以连续多次获取到锁。<br>
</p>

<p>
饥饿模式是对公平性和性能的一种平衡，它避免了某些 goroutine 长时间的等待锁。在饥饿模式下，优先对待的是那些一直在等待的 waiter。<br>
</p>

<p>
接下来，我们逐步分析下 <code>Mutex</code> 代码的关键行，彻底搞清楚饥饿模式的细节。<br>
</p>

<p>
先从请求锁（lockSlow）的逻辑看起：<br>
</p>

<p>
第 9 行对 state 字段又分出了一位，用来标记锁是否处于饥饿状态。现在一个 state 的字段被划分成了阻塞等待的 waiter 数量、饥饿标记、唤醒标记和持有锁的标记四个部分。<br>
</p>

<p>
第 25 行记录此 goroutine 请求锁的初始时间，第 26 行标记是否处于饥饿状态，第 27 行标记是否是唤醒的，第 28 行记录 spin 的次数。<br>
</p>

<p>
第 31 行到第 40 行和以前的逻辑类似，只不过加了一个不能是饥饿状态的逻辑。它会对正常状态抢夺锁的 goroutine 尝试 spin，和以前的目的一样，就是在临界区耗时很短的情况下提高性能。<br>
</p>

<p>
第 42 行到第 44 行，非饥饿状态下抢锁。怎么抢？就是要把 state 的锁的那一位，置为加锁状态，后续 CAS 如果成功就可能获取到了锁。<br>
</p>

<p>
第 46 行到第 48 行，如果锁已经被持有或者锁处于饥饿状态，我们最好的归宿就是等待，所以 waiter 的数量加 1。<br>
</p>

<p>
第 49 行到第 51 行，如果此 goroutine 已经处在饥饿状态，并且锁还被持有，那么，我们需要把此 Mutex 设置为饥饿状态。<br>
</p>

<p>
第 52 行到第 57 行，是清除 mutexWoken 标记，因为不管是获得了锁还是进入休眠，我们都需要清除 mutexWoken 标记。<br>
</p>

<p>
第 59 行就是尝试使用 CAS 设置 state。如果成功，第 61 行到第 63 行是检查原来的锁的状态是未加锁状态，并且也不是饥饿状态的话就成功获取了锁，返回。<br>
</p>

<p>
第 67 行判断是否第一次加入到 waiter 队列。到这里，你应该就能明白第 25 行为什么不对 waitStartTime 进行初始化了，我们需要利用它在这里进行条件判断。<br>
</p>

<p>
第 72 行将此 waiter 加入到队列，如果是首次，加入到队尾，先进先出。如果不是首次，那么加入到队首，这样等待最久的 goroutine 优先能够获取到锁。此 goroutine 会进行休眠。<br>
</p>

<p>
第 74 行判断此 goroutine 是否处于饥饿状态。注意，执行这一句的时候，它已经被唤醒了。<br>
</p>

<p>
第 77 行到第 88 行是对锁处于饥饿状态下的一些处理。<br>
</p>

<p>
第 82 行设置一个标志，这个标志稍后会用来加锁，而且还会将 waiter 数减 1。<br>
</p>

<p>
第 84 行，设置标志，在没有其它的 waiter 或者此 goroutine 等待还没超过 1 毫秒，则会将 Mutex 转为正常状态。<br>
</p>

<p>
第 86 行则是将这个标识应用到 state 字段上。<br>
</p>

<p>
释放锁（Unlock）时调用的 Unlock 的 fast path 不用多少，所以我们主要看 unlockSlow 方法就行。<br>
</p>

<p>
如果 Mutex 处于饥饿状态，第 123 行直接唤醒等待队列中的 waiter。<br>
</p>

<p>
如果 Mutex 处于正常状态，如果没有 waiter，或者已经有在处理的情况了，那么释放就好，不做额外的处理（第 112 行到第 114 行）。<br>
</p>

<p>
否则，waiter 数减 1，mutexWoken 标志设置上，通过 CAS 更新 state 的值（第 115 行到第 119 行）。<br>
</p>
</div>
</div>
<div id="outline-container-org314dac7" class="outline-2">
<h2 id="org314dac7">总结</h2>
<div class="outline-text-2" id="text-org314dac7">
<p>
<code>Mutex</code> 的设计也是从简单设计到复杂处理逐渐演变的。初版的 <code>Mutex</code> 设计非常简洁，充分展示了 Go 创始者的简单、简洁的设计哲学。但是，随着大家的使用，逐渐暴露出一些缺陷，为了弥补这些缺陷， <code>Mutex</code> 不得不越来越复杂。<br>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-05-10 17:05 Tue</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-05-12 Thu 20:46</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
