<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-06-04 Sat 18:18 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>LINUX-认识与学习BASH</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="static/MathJax/cdn.bootcdn.net/ajax/libs/mathjax/3.1.2/es5/tex-mml-chtml.min.js"></script>
</head>
<body>
<div id="content">
<h1 class="title">LINUX-认识与学习BASH</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org865a80d">什么是 shell</a></li>
<li><a href="#org2916012">常用的 shell</a></li>
<li><a href="#orgff9e048">Bash shell 的功能</a></li>
<li><a href="#org0463535">查询命令是否为 Bash 的内置命令：type</a></li>
<li><a href="#orgc4b50dd">shell 的变量功能</a>
<ul>
<li><a href="#orgb88a65d">变量的使用与设置</a></li>
<li><a href="#orga047fa9">环境变量</a>
<ul>
<li><a href="#org92c2cf9">查看环境变量</a></li>
<li><a href="#orgb7926c0">重要的环境变量</a>
<ul>
<li><a href="#orgf00e019">RANDOM</a></li>
<li><a href="#orgd3084a1">PS1</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org64d0e8b">与文件系统及程序的限制关系（ulimit）</a></li>
</ul>
</li>
<li><a href="#org426ec9c">命令别名与历史命令</a>
<ul>
<li><a href="#orga3ff633">命令别名设置：alias、unalias</a></li>
<li><a href="#orgf26065a">历史命令：history</a></li>
</ul>
</li>
<li><a href="#orgac866cf">Bash shell 的操作环境</a>
<ul>
<li><a href="#orga984ecd">路径与命令查找顺序</a></li>
<li><a href="#org56fa764">bash 的登录与欢迎信息</a></li>
<li><a href="#orgfc326f8">bash 的环境配置文件</a>
<ul>
<li><a href="#org0690a21">login 与 non-login shell</a></li>
<li><a href="#org481e76a">/etc/profile</a>
<ul>
<li><a href="#org6f37f82">/etc/profile.d/*sh</a></li>
<li><a href="#org5d08f3e">/etc/locale.conf</a></li>
<li><a href="#org713ebdc">/usr/share/bash-completion/completions/*</a></li>
</ul>
</li>
<li><a href="#org8a882c8">~/.bash_profile</a>
<ul>
<li><a href="#org1d96aae">source</a></li>
<li><a href="#org126af77">~/.bashrc</a></li>
</ul>
</li>
<li><a href="#org2126188">其他相关配置文件</a>
<ul>
<li><a href="#orgb75525e">/etc/man_db.conf</a></li>
<li><a href="#orgaa06588">~/.bash_history</a></li>
<li><a href="#orgcd1af0d">~/.bash_logout</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org63b48f9">终端的环境设置：stty、set</a></li>
<li><a href="#orgfe98862">通配符与特殊符号</a></li>
</ul>
</li>
<li><a href="#org921d96d">数据流重定向</a>
<ul>
<li><a href="#org5fe11c0">什么是数据流重定向</a>
<ul>
<li><a href="#org02bc802">standard output 与 standard error output</a></li>
<li><a href="#orge0c1bde">/dev/null 垃圾桶黑洞</a></li>
<li><a href="#org146f736">正确与错误数据同时写入一个文件</a></li>
<li><a href="#orgfd1ee97">standard input</a></li>
</ul>
</li>
<li><a href="#org7e92693">命令执行的判断依据：;、&amp;&amp;、||</a>
<ul>
<li><a href="#org83657e7">cmd; cmd（不考虑命令相关性的连续命令执行）</a></li>
<li><a href="#org961b003">$?（命令返回值）与 &amp;&amp; 与 ||</a></li>
<li><a href="#orga3e96df">判断式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3361f58">管道命令（pipe）</a>
<ul>
<li><a href="#orge8c6ef7">选取命令：cut、grep</a></li>
<li><a href="#org463a7db">排序命令：sort、wc、uniq</a></li>
<li><a href="#orgac53fec">双向重定向：tee</a></li>
<li><a href="#org656194c">字符转换命令：tr、col、join、paste、expand</a></li>
<li><a href="#org3008d6e">划分命令：split</a></li>
<li><a href="#org8bb79c2">参数代换：xargs</a></li>
<li><a href="#org63e0997">关于减号【-】的用途</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org865a80d" class="outline-2">
<h2 id="org865a80d">什么是 shell</h2>
<div class="outline-text-2" id="text-org865a80d">
<p>
shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。<br>
</p>
</div>
</div>
<div id="outline-container-org2916012" class="outline-2">
<h2 id="org2916012">常用的 shell</h2>
<div class="outline-text-2" id="text-org2916012">
<p>
/etc/shells 文件中列出了可以使用的 shell。<br>
</p>

<dl class="org-dl">
<dt>/bin/sh</dt><dd>已经被 /bin/bash 所替换<br></dd>
<dt>/bin/bash</dt><dd>Linux 默认的 shell<br></dd>
<dt>/bin/tcsh</dt><dd>整合 C Shell，提供更多的功能<br></dd>
<dt>/bin/csh</dt><dd>已经被 /bin/tcsh 所替换<br></dd>
</dl>
</div>
</div>
<div id="outline-container-orgff9e048" class="outline-2">
<h2 id="orgff9e048">Bash shell 的功能</h2>
<div class="outline-text-2" id="text-orgff9e048">
<ul class="org-ul">
<li><p>
历史命令（history）<br>
在命令行按【上下键】就可以找到前后一个输入的命令，在很多 Linux 发行版里，默认的命令条目可以到达 1000 个。<br>
</p>

<p>
这些命令记录在哪里？在家目录下的 .bash_history，不过 ~/.bash_history 记录的是前一次登录以前所执行过的命令，这一次登录执行的命令都被缓存在内存中，当你成功的注销系统后，该命令才会记录到 .bash_history 当中。<br>
</p></li>
<li>命令与文件补全功能<br>
<ul class="org-ul">
<li>[Tab] 接在一串命令的第一个字的后面，则为命令补全；<br></li>
<li>[Tab] 接在一串命令的第二个字的后面，则为文件补齐；<br></li>
<li>若安装 bash-completion 软件，则在某些命令后面使用 [Tab] 按键时，可以进行【选项/参数的补齐】功能；<br></li>
</ul></li>
<li>命令别名设置（alias）<br></li>
<li>任务管理、前台、后台控制（job control、foreground、background）<br>
使用前、后台的控制可以让工作进行的更为顺利！至于任务管理（jobs）的用途则更广， 可以让我们随时将工作丢到后台中执行！而不怕不小心使用了 [Ctrl] + c 来停掉该程序！此外，也可以在单一登陆的环境中，达到多任务的目的呢！<br></li>
<li>程序化脚本<br></li>
<li>通配符<br></li>
</ul>
</div>
</div>
<div id="outline-container-org0463535" class="outline-2">
<h2 id="org0463535">查询命令是否为 Bash 的内置命令：type</h2>
<div class="outline-text-2" id="text-org0463535">
<p>
<a href="Linux-常用命令.html#orgcc4098e">常用命令：type</a><br>
</p>
</div>
</div>
<div id="outline-container-orgc4b50dd" class="outline-2">
<h2 id="orgc4b50dd">shell 的变量功能</h2>
<div class="outline-text-2" id="text-orgc4b50dd">
</div>
<div id="outline-container-orgb88a65d" class="outline-3">
<h3 id="orgb88a65d">变量的使用与设置</h3>
<div class="outline-text-3" id="text-orgb88a65d">
<p>
<a href="Shell.html#orge227e56">shell：变量</a><br>
</p>
</div>
</div>
<div id="outline-container-orga047fa9" class="outline-3">
<h3 id="orga047fa9">环境变量</h3>
<div class="outline-text-3" id="text-orga047fa9">
<p>
环境变量可以帮我们达到很多功能，包括主文件夹的变换、提示字符的显示、可执行文件搜寻的路径等等， 那么，既然环境变量有那么多的功能，问一下，目前我的 shell 环境中， 有多少默认的环境变量？我们可以利用两个指令来查阅，分别是 <code>env</code> 与 <code>export</code> 呢！<br>
</p>
</div>
<div id="outline-container-org92c2cf9" class="outline-4">
<h4 id="org92c2cf9">查看环境变量</h4>
<div class="outline-text-4" id="text-org92c2cf9">
<div class="org-src-container">
<pre class="src src-bash">$ env         <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#26597;&#30475;&#29615;&#22659;&#21464;&#37327;</span>
$ set         <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#35266;&#23519;&#25152;&#26377;&#21464;&#37327;&#65306;&#29615;&#22659;&#21464;&#37327;&#19982;&#33258;&#23450;&#20041;&#21464;&#37327;</span>
$ export &#21464;&#37327;&#21517;&#31216;      <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33258;&#23450;&#20041;&#21464;&#37327;&#36716;&#25104;&#29615;&#22659;&#21464;&#37327;</span>
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#21487;&#20197;&#20351;&#29992; declare &#23558;&#29615;&#22659;&#21464;&#37327;&#36716;&#25104;&#33258;&#23450;&#20041;&#21464;&#37327;</span>
$ export      <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#26597;&#30475;&#29615;&#22659;&#21464;&#37327;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb7926c0" class="outline-4">
<h4 id="orgb7926c0">重要的环境变量</h4>
<div class="outline-text-4" id="text-orgb7926c0">
<dl class="org-dl">
<dt>HOME</dt><dd>用户的根目录；<br></dd>
<dt>SHELL</dt><dd>目前这个环境使用的 shell 是哪个程序；<br></dd>
<dt>MAIL</dt><dd>使用 mail 这个命令在收信时，系统会读取邮箱文件；<br></dd>
<dt>HISTSIZE</dt><dd>历史记录条数；<br></dd>
<dt>PATH</dt><dd>执行文件查找的路径，目录与目录中间以冒号分隔，由于文件的查找是依序由 PATH 的变量内的目录来查询的，所以目录的顺序也很重要；<br></dd>
<dt>LANG</dt><dd>语系数据；<br></dd>
<dt>OSTYPE、HOSTTYPE、MACHTYPE</dt><dd>主机硬件与核心的等级；<br></dd>
<dt>$</dt><dd>目前 shell 的进程号，即 PID（Process ID）；<br></dd>
<dt>?</dt><dd>上一个执行的命令的返回值，如果上一个执行的命令被成功执行了， <code>?</code> 这个特殊的变量就会赋值 0，否则返回错误代码，一般以非 0 的数值替换；<br></dd>
</dl>
</div>
<div id="outline-container-orgf00e019" class="outline-5">
<h5 id="orgf00e019">RANDOM</h5>
<div class="outline-text-5" id="text-orgf00e019">
<p>
随机数的变量，目前大多数的 Linux 发行版都会有随机数生成器，那就是 /dev/random 这个文件。 我们可以通过这个随机数文件相关的变量（$RANDOM）来随机取得随机数。在 BASH 的环境下，这个 RANDOM 变量的内容，介于 0~32767 之间，所以，你只要 echo $RANDOM 时，系统就会主动的随机取出一个介于 0~32767 的数值。万一我想要使用 0~9 之间的数值呢？利用 declare 宣告数值类型， 然后这样做就可以了：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">$ declare -i <span style="color: #8787d7;">number</span>=$<span style="color: #8787d7;">RANDOM</span>*10/32768; <span style="color: #268bd2;">echo</span> $<span style="color: #8787d7;">number</span>
8                     <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&lt;== &#27492;&#26102;&#20250;&#38543;&#26426;&#21462;&#20986; 0~9 &#20043;&#38388;&#30340;&#25968;&#20540;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd3084a1" class="outline-5">
<h5 id="orgd3084a1">PS1</h5>
<div class="outline-text-5" id="text-orgd3084a1">
<p>
命令提示字符：<br>
</p>

<ul class="org-ul">
<li>\d ：可显示出“星期 月 日”的日期格式，如："Mon Feb 2"；<br></li>
<li>\H ：完整的主机名称；<br></li>
<li>\h ：仅取主机名称在第一个小数点之前的名字；<br></li>
<li>\t ：显示时间，为 24 小时格式的“HH:MM:SS”；<br></li>
<li>\T ：显示时间，为 12 小时格式的“HH:MM:SS”；<br></li>
<li>\A ：显示时间，为 24 小时格式的“HH:MM”；<br></li>
<li>\@ ：显示时间，为 12 小时格式的“am/pm”样式；<br></li>
<li>\u ：目前使用者的帐号名称；<br></li>
<li>\v ：BASH 的版本信息，如鸟哥的测试主机版本为 4.2.46（1）-release，仅取“4.2”显示；<br></li>
<li>\w ：完整的工作目录名称，由根目录写起的目录名称，但主文件夹会以 ~ 取代；<br></li>
<li>\W ：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名；<br></li>
<li># ：下达的第几个指令；<br></li>
<li>$ ：提示字符，如果是 root 时，提示字符为 # ，否则就是 $；<br></li>
</ul>

<pre class="example">
CentOS 默认的 PS1 内容：
[\u@\h \W]$ 
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org64d0e8b" class="outline-3">
<h3 id="org64d0e8b">与文件系统及程序的限制关系（ulimit）</h3>
<div class="outline-text-3" id="text-org64d0e8b">
<p>
<a href="Linux-常用命令.html#orgca4e228">常用命令：ulimit</a><br>
</p>
</div>
</div>
</div>
<div id="outline-container-org426ec9c" class="outline-2">
<h2 id="org426ec9c">命令别名与历史命令</h2>
<div class="outline-text-2" id="text-org426ec9c">
</div>
<div id="outline-container-orga3ff633" class="outline-3">
<h3 id="orga3ff633">命令别名设置：alias、unalias<a id="orga8e3608"></a></h3>
<div class="outline-text-3" id="text-orga3ff633">
<p>
使用 alias 命令，不加任何参数可以查看目前有哪些命名。<br>
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #268bd2;">alias</span> <span style="color: #8787d7;">lm</span>=<span style="color: #2aa198;">'ls -al | more'</span>    <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#26597;&#35810;&#38544;&#34255;&#25991;&#20214;&#65292;&#19988;&#19981;&#24819;&#29992;&#40736;&#26631;&#19968;&#39029;&#19968;&#39029;&#30340;&#32763;&#30475;</span>
<span style="color: #268bd2;">alias</span> <span style="color: #8787d7;">rm</span>=<span style="color: #2aa198;">'rm -i'</span>            <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#27599;&#27425;&#21024;&#38500;&#21069;&#35810;&#38382;&#26159;&#21542;&#21024;&#38500;</span>
</pre>
</div>

<p>
使用 unalias 将别名删除。<br>
</p>
</div>
</div>
<div id="outline-container-orgf26065a" class="outline-3">
<h3 id="orgf26065a">历史命令：history<a id="orgd0534dc"></a></h3>
<div class="outline-text-3" id="text-orgf26065a">
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #268bd2;">history</span> [n]
<span style="color: #268bd2;">history</span> [-c]
<span style="color: #268bd2;">history</span> [-raw] histfiles
</pre>
</div>

<p>
选项与参数：<br>
</p>

<pre class="example">
n : 列出最近执行的 n 条命令
-c : 将新增的历史命令写入 histfiles 中，若没有加 histfiles，则默认写入 ~/.bash_history
-r : 将 history 的内容读到目前这个 shell 的 history 记录中
-w : 将目前的 history 记录内容写入 histfiles 中
</pre>

<p>
利用历史记录的功能来执行命令：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">$ !number      <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#25191;&#34892;&#31532;&#20960;&#26465;&#21629;&#20196;&#30340;&#24847;&#24605;</span>
$ !command     <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#30001;&#26368;&#36817;&#30340;&#21629;&#20196;&#21521;&#21069;&#26597;&#25214;&#12304;&#21629;&#20196;&#20018;&#24320;&#22836;&#20026; command&#12305;&#30340;&#37027;&#20010;&#21629;&#20196;&#65292;&#24182;&#25191;&#34892;</span>
$ !!           <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#25191;&#34892;&#19978;&#19968;&#20010;&#21629;&#20196;</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgac866cf" class="outline-2">
<h2 id="orgac866cf">Bash shell 的操作环境</h2>
<div class="outline-text-2" id="text-orgac866cf">
</div>
<div id="outline-container-orga984ecd" class="outline-3">
<h3 id="orga984ecd">路径与命令查找顺序</h3>
<div class="outline-text-3" id="text-orga984ecd">
<p>
命令的运行顺序：<br>
</p>

<ol class="org-ol">
<li>以相对/绝对路径执行指令，例如 "/bin/ls" 或 "./ls"；<br></li>
<li>由 alias 找到该指令来执行；<br></li>
<li>由 bash 内置的（builtin）指令来执行；<br></li>
<li>通过 $PATH 这个变量的顺序搜寻到的第一个指令来执行；<br></li>
</ol>
</div>
</div>
<div id="outline-container-org56fa764" class="outline-3">
<h3 id="org56fa764">bash 的登录与欢迎信息</h3>
<div class="outline-text-3" id="text-org56fa764">
<dl class="org-dl">
<dt>/etc/issue</dt><dd>本机的登录画面<br></dd>
<dt>/etc/issue.net</dt><dd>远程登录的登录画面<br></dd>
<dt>/etc/motd</dt><dd>欢迎信息<br></dd>
</dl>

<p>
issue 内的各代码意义：<br>
</p>

<ul class="org-ul">
<li>\d 本地端时间的日期；<br></li>
<li>\l 显示第几个终端机接口；<br></li>
<li>\m 显示硬件的等级（i386/i486/i586/i686&#x2026;）；<br></li>
<li>\n 显示主机的网络名称；<br></li>
<li>\O 显示 domain name；<br></li>
<li>\r 操作系统的版本（相当于 uname -r）<br></li>
<li>\t 显示本地端时间的时间；<br></li>
<li>&sect; 操作系统的名称；<br></li>
<li>\v 操作系统的版本；<br></li>
</ul>
</div>
</div>
<div id="outline-container-orgfc326f8" class="outline-3">
<h3 id="orgfc326f8">bash 的环境配置文件</h3>
<div class="outline-text-3" id="text-orgfc326f8">
</div>
<div id="outline-container-org0690a21" class="outline-4">
<h4 id="org0690a21">login 与 non-login shell</h4>
<div class="outline-text-4" id="text-org0690a21">
<ul class="org-ul">
<li>login shell：取得 bash 时需要完整的登录流程，就称为 login shell。举例来说，你要由 tty1 ~ tty6 登录，需要输入用户的账号与密码，此时取得的 bash 就称为【login shell】；<br></li>
<li>non-login shell：取得 bash 的方法不需要重复登录的操作<br>
<ul class="org-ul">
<li>以 X Window 登录 Linux 后，该 bash 的环境就称为 non-login shell；<br></li>
<li>再原本的 bash 环境下再次执行 bash 这个命令，同样的没有输入账号密码，那第二个 bash（子进程）也是 non-login shell；<br></li>
</ul></li>
</ul>

<p>
在这两个取得 bash 的情况中，读取的配置文件并不一样，一般来说，login shell 只会读取两个配置文件：<br>
</p>

<ol class="org-ol">
<li>/etc/profile：这是系统整体的设置，最好不要修改这个文件；<br></li>
<li>~/.bash_profile 或 ~/.bash_login 或 ~/.profile：属于用户个人设置，你要添加自己的数据，就写入这里；<br></li>
</ol>
</div>
</div>
<div id="outline-container-org481e76a" class="outline-4">
<h4 id="org481e76a">/etc/profile</h4>
<div class="outline-text-4" id="text-org481e76a">
<p>
该文件设置的变量主要有：<br>
</p>

<dl class="org-dl">
<dt>PATH</dt><dd>根据 UID 决定 PATH 变量要不要含有 sbin 的系统命令目录；<br></dd>
<dt>MAIL</dt><dd>根据账号设置用户的 mailbox 到 /var/spool/mail/账号名；<br></dd>
<dt>USER</dt><dd>根据用户的账号设置此变量内容；<br></dd>
<dt>HOSTNAME</dt><dd>根据主机的 hostname 命令决定；<br></dd>
<dt>HISTSIZE</dt><dd>历史命令记录条数；<br></dd>
<dt>umask</dt><dd>包括 root 默认为 022，而一般用户为 002 等；<br></dd>
</dl>

<p>
/etc/profile 不止会做这些事而已，他还会去调用外部文件：<br>
</p>
</div>
<div id="outline-container-org6f37f82" class="outline-5">
<h5 id="org6f37f82">/etc/profile.d/*sh</h5>
<div class="outline-text-5" id="text-org6f37f82">
<p>
/etc/profile.d/这个目录内且扩展名为 .sh 的文件都会被调用，这个目录下的文件规范了 bash 操作界面的颜色、语系、ll 与 ls 命令的别名、vi 的命令别名、which 的命令别名等。<br>
</p>

<p>
如果你需要帮所有用户设置一些共享的命令别名，可以在这个目录下自行建立扩展名为 .sh 的文件，并将数写入就好。<br>
</p>
</div>
</div>
<div id="outline-container-org5d08f3e" class="outline-5">
<h5 id="org5d08f3e">/etc/locale.conf</h5>
<div class="outline-text-5" id="text-org5d08f3e">
<p>
这个文件是由 /etc/profile.d/lang.sh 调用的，决定 bash 默认使用何种语系，文件中最重要的就是 Lang/LC_ALL 这个变量的设置。<br>
</p>
</div>
</div>
<div id="outline-container-org713ebdc" class="outline-5">
<h5 id="org713ebdc">/usr/share/bash-completion/completions/*</h5>
<div class="outline-text-5" id="text-org713ebdc">
<p>
命令补齐、文件名补齐、参数补全等，这个目录下的内容是由 /etc/profile.d/bash_completion.sh 文件加载的。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org8a882c8" class="outline-4">
<h4 id="org8a882c8">~/.bash_profile</h4>
<div class="outline-text-4" id="text-org8a882c8">
<p>
bash 在读完了整体环境设置的 /etc/profile 并借此调用其他配置文件后，接下来则是会读取使用者的个人配置文件。 在 login shell 的 bash 环境中，所读取的个人偏好配置文件其实主要有三个，依序分别是：<br>
</p>

<ol class="org-ol">
<li>~/.bash_profile<br></li>
<li>~/.bash_login<br></li>
<li>~/.profile<br></li>
</ol>

<p>
其实 bash 的 login shell 设置只会读取上面三个文件的其中一个， 而读取的顺序则是依照上面的顺序。<br>
</p>
</div>
<div id="outline-container-org1d96aae" class="outline-5">
<h5 id="org1d96aae">source</h5>
<div class="outline-text-5" id="text-org1d96aae">
<p>
由于/etc/profile与~/.bash_profile 都是在取得 login shell 的时候才会读取的配置文件，所以， 如果你将自己的偏好设置写入上述的文件后，通常都是得登出再登陆后，该设置才会生效。那么，能不能直接读取配置文件而不登出登陆呢？ 可以的！那就得要利用 source 这个指令了！<br>
</p>

<p>
利用 source 或小数点 （.） 都可以将配置文件的内容读进来目前的 shell 环境中！<br>
</p>
</div>
</div>
<div id="outline-container-org126af77" class="outline-5">
<h5 id="org126af77">~/.bashrc</h5>
<div class="outline-text-5" id="text-org126af77">
<p>
谈完了 login shell 后，那么 non-login shell 这种非登陆情况取得 bash 操作接口的环境配置文件又是什么？ 当你取得 non-login shell 时，该 bash 配置文件仅会读取 ~/.bashrc ！<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org2126188" class="outline-4">
<h4 id="org2126188">其他相关配置文件</h4>
<div class="outline-text-4" id="text-org2126188">
</div>
<div id="outline-container-orgb75525e" class="outline-5">
<h5 id="orgb75525e">/etc/man_db.conf</h5>
<div class="outline-text-5" id="text-orgb75525e">
<p>
规范了使用 man 的时候，man page 的路径到哪里去寻找。<br>
</p>

<p>
那么什么时候要来修改这个文件呢？如果你是以 tarball 的方式来安装你的数据，那么你的 man page 可能会放置在 /usr/local/softpackage/man 里头，那个 softpackage 是你的套件名称， 这个时候你就得以手动的方式将该路径加到 /etc/man_db.conf 里头，否则使用 man 的时候就会找不到相关的说明文档。<br>
</p>
</div>
</div>
<div id="outline-container-orgaa06588" class="outline-5">
<h5 id="orgaa06588">~/.bash_history</h5>
<div class="outline-text-5" id="text-orgaa06588">
<p>
我们执行的命令历史记录就在里面。<br>
</p>
</div>
</div>
<div id="outline-container-orgcd1af0d" class="outline-5">
<h5 id="orgcd1af0d">~/.bash_logout</h5>
<div class="outline-text-5" id="text-orgcd1af0d">
<p>
这个文件则记录了“当我登出 bash 后，系统再帮我做完什么动作后才离开”的意思。 你可以去读取一下这个文件的内容，默认的情况下，登出时， bash 只是帮我们清掉屏幕的讯息而已。不过，你也可以将一些备份或者是其他你认为重要的工作写在这个文件中 （例如清空暂存盘）， 那么当你离开 Linux 的时候，就可以解决一些烦人的事情！<br>
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org63b48f9" class="outline-3">
<h3 id="org63b48f9">终端的环境设置：stty、set</h3>
<div class="outline-text-3" id="text-org63b48f9">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">组合按键</th>
<th scope="col" class="org-left">执行结果</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Ctrl + C</td>
<td class="org-left">终止目前的命令</td>
</tr>

<tr>
<td class="org-left">Ctrl + D</td>
<td class="org-left">输入结束 （EOF），例如邮件结束的时候；</td>
</tr>

<tr>
<td class="org-left">Ctrl + M</td>
<td class="org-left">就是 Enter 啦！</td>
</tr>

<tr>
<td class="org-left">Ctrl + S</td>
<td class="org-left">暂停屏幕的输出</td>
</tr>

<tr>
<td class="org-left">Ctrl + Q</td>
<td class="org-left">恢复屏幕的输出</td>
</tr>

<tr>
<td class="org-left">Ctrl + U</td>
<td class="org-left">在提示字符下，将整列命令删除</td>
</tr>

<tr>
<td class="org-left">Ctrl + Z</td>
<td class="org-left">“暂停”目前的命令</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgfe98862" class="outline-3">
<h3 id="orgfe98862">通配符与特殊符号</h3>
<div class="outline-text-3" id="text-orgfe98862">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">符号</td>
<td class="org-left">意义</td>
</tr>

<tr>
<td class="org-left">*</td>
<td class="org-left">代表“ 0 个到无穷多个”任意字符</td>
</tr>

<tr>
<td class="org-left">?</td>
<td class="org-left">代表“一定有一个”任意字符</td>
</tr>

<tr>
<td class="org-left">[ ]</td>
<td class="org-left">同样代表“一定有一个在括号内”的字符（非任意字符）。例如 [abcd] 代表“一定有一个字符， 可能是 a, b, c, d 这四个任何一个”</td>
</tr>

<tr>
<td class="org-left">[ - ]</td>
<td class="org-left">若有减号在中括号内时，代表“在编码顺序内的所有字符”。例如 [0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的！</td>
</tr>

<tr>
<td class="org-left">[^]</td>
<td class="org-left">若中括号内的第一个字符为指数符号 （^） ，那表示“反向选择”，例如 [^abc] 代表一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思。</td>
</tr>
</tbody>
</table>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">符号</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">#</td>
<td class="org-left">注解符号：这个最常被使用在 script 当中，视为说明！在后的数据均不执行</td>
</tr>

<tr>
<td class="org-left">\</td>
<td class="org-left">跳脱符号：将“特殊字符或万用字符”还原成一般字符</td>
</tr>

<tr>
<td class="org-left">pipe</td>
<td class="org-left">管线 （pipe）：分隔两个管线命令的界定（后两节介绍）；</td>
</tr>

<tr>
<td class="org-left">;</td>
<td class="org-left">连续指令下达分隔符号：连续性命令的界定 （注意！与管线命令并不相同）</td>
</tr>

<tr>
<td class="org-left">~</td>
<td class="org-left">使用者的主文件夹</td>
</tr>

<tr>
<td class="org-left">$</td>
<td class="org-left">取用变量前置字符：亦即是变量之前需要加的变量取代值</td>
</tr>

<tr>
<td class="org-left">&amp;</td>
<td class="org-left">工作控制 （job control）：将指令变成背景下工作</td>
</tr>

<tr>
<td class="org-left">!</td>
<td class="org-left">逻辑运算意义上的“非” not 的意思！</td>
</tr>

<tr>
<td class="org-left">&gt;, &gt;&gt;</td>
<td class="org-left">数据流重导向：输出导向，分别是“取代”与“累加”</td>
</tr>

<tr>
<td class="org-left">&lt;, &lt;&lt;</td>
<td class="org-left">数据流重导向：输入导向 （这两个留待下节介绍）</td>
</tr>

<tr>
<td class="org-left">' '</td>
<td class="org-left">单引号，不具有变量置换的功能 （$ 变为纯文本）</td>
</tr>

<tr>
<td class="org-left">" "</td>
<td class="org-left">具有变量置换的功能！ （$ 可保留相关功能）</td>
</tr>

<tr>
<td class="org-left">``</td>
<td class="org-left">两个“ ` ”中间为可以先执行的指令，亦可使用 $（ ）</td>
</tr>

<tr>
<td class="org-left">（ ）</td>
<td class="org-left">在中间为子 shell 的起始与结束</td>
</tr>

<tr>
<td class="org-left">{ }</td>
<td class="org-left">在中间为命令区块的组合！</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-org921d96d" class="outline-2">
<h2 id="org921d96d">数据流重定向</h2>
<div class="outline-text-2" id="text-org921d96d">
</div>
<div id="outline-container-org5fe11c0" class="outline-3">
<h3 id="org5fe11c0">什么是数据流重定向</h3>
<div class="outline-text-3" id="text-org5fe11c0">
</div>
<div id="outline-container-org02bc802" class="outline-4">
<h4 id="org02bc802">standard output 与 standard error output</h4>
<div class="outline-text-4" id="text-org02bc802">
<p>
标准输出指的是“指令执行所回传的正确的讯息”，而标准错误输出可理解为“ 指令执行失败后，所回传的错误讯息”。<br>
</p>

<p>
数据流重导向可以将 standard output （简称 stdout） 与 standard error output （简称 stderr） 分别传送到其他的文件或设备去，而分别传送所用的特殊字符则如下所示：<br>
</p>

<ul class="org-ul">
<li>标准输入（stdin）：代码为 0，使用 &lt; 或 &lt;&lt; ；<br></li>
<li>标准输出（stdout）：代码为 1，使用 &gt; 或 &gt;&gt; ；<br></li>
<li>标准错误输出（stderr）：代码为 2，使用 2&gt; 或 2&gt;&gt;<br></li>

<li>1&gt; ：以覆盖的方法将【正确的数据】输出到指定的文件或设备上；<br></li>
<li>1&gt;&gt;：以累加的方法将【正确的数据】输出到指定的文件或设备上；<br></li>
<li>2&gt; ：以覆盖的方法将【错误的数据】输出到指定的文件或设备上；<br></li>
<li>2&gt;&gt;：以累加的方法将【错误的数据】输出到指定的文件或设备上；<br></li>
</ul>
</div>
</div>
<div id="outline-container-orge0c1bde" class="outline-4">
<h4 id="orge0c1bde">/dev/null 垃圾桶黑洞</h4>
<div class="outline-text-4" id="text-orge0c1bde">
<div class="org-src-container">
<pre class="src src-bash">$ find /home -name .bashrc 2&gt; /dev/null
</pre>
</div>

<p>
这个 /dev/null 可以吃掉任何导向这个设备的信息，这里 stderr 就被丢弃了。<br>
</p>
</div>
</div>
<div id="outline-container-org146f736" class="outline-4">
<h4 id="org146f736">正确与错误数据同时写入一个文件</h4>
<div class="outline-text-4" id="text-org146f736">
<div class="org-src-container">
<pre class="src src-bash">$ find /home -name .bashrc &gt; list 2&gt; list      <span style="color: #008787; background-color: #262626;">#  </span><span style="color: #008787; background-color: #262626;">&lt;== &#38169;&#35823;</span>
$ find /home -name .bashrc &gt; list 2&gt;&amp;1         <span style="color: #008787; background-color: #262626;">#  </span><span style="color: #008787; background-color: #262626;">&lt;== &#27491;&#30830;</span>
$ find /home -name .bashrc &amp;&gt; list             <span style="color: #008787; background-color: #262626;">#  </span><span style="color: #008787; background-color: #262626;">&lt;== &#27491;&#30830;</span>

$ echo <span style="color: #2aa198;">"error message"</span> 1&gt;&amp;2
$ echo <span style="color: #2aa198;">"error message"</span> 2&gt; /dev/null 1&gt;&amp;2
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfd1ee97" class="outline-4">
<h4 id="orgfd1ee97">standard input</h4>
<div class="outline-text-4" id="text-orgfd1ee97">
<p>
利用 cat 命令来建立一个文件的简单流程：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">$ cat &gt; catfile
testing
cat file test
&lt;== &#36825;&#37324;&#25353;&#19979; [ctrl]+d &#26469;&#36864;&#20986;

$ cat catfile
testing
cat file test
</pre>
</div>

<p>
由于加入 <code>&gt;</code> 在 cat 之后，所以这个 catfile 文件会被建立，而内容就是刚刚键盘上输入的那两行数据。<br>
</p>

<p>
那我能不能用纯文本文件替换键盘的输入？用 stdin 替换键盘的输入以建立新文件的简单流程：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">$ cat &gt; catfile &lt; ~/.bashrc
</pre>
</div>

<p>
其次是这个 <code>&lt;&lt;</code> 这个符号了，它代表的是【结束的输入字符】的意思：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">$ cat &gt; catfile &lt;&lt; <span style="color: #2aa198;">"eof"</span>
<span style="color: #2aa198;">&gt; This is a test</span>
<span style="color: #2aa198;">&gt; OK now stop</span>
<span style="color: #2aa198;">&gt; eof   &lt;== &#36755;&#20837;&#36825;&#20010;&#20851;&#38190;&#35789;&#65292;&#31435;&#21051;&#32467;&#26463;&#32780;&#19981;&#38656;&#35201;&#36755;&#20837; [ctrl]+d</span>

<span style="color: #2aa198;">$ cat catfile</span>
<span style="color: #2aa198;">This is a test</span>
<span style="color: #2aa198;">OK now stop</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org7e92693" class="outline-3">
<h3 id="org7e92693">命令执行的判断依据：;、&amp;&amp;、||</h3>
<div class="outline-text-3" id="text-org7e92693">
</div>
<div id="outline-container-org83657e7" class="outline-4">
<h4 id="org83657e7">cmd; cmd（不考虑命令相关性的连续命令执行）</h4>
<div class="outline-text-4" id="text-org83657e7">
<p>
关机的时候我希望可以先执行两次 sync 同步写入磁盘后才 shutdown 计算机：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">$ sync; sync; shutdown -h now
</pre>
</div>
</div>
</div>
<div id="outline-container-org961b003" class="outline-4">
<h4 id="org961b003">$?（命令返回值）与 &amp;&amp; 与 ||</h4>
<div class="outline-text-4" id="text-org961b003">
<ul class="org-ul">
<li>cmd1 &amp;&amp; cmd2<br>
<ol class="org-ol">
<li>若 cmd1 执行完毕且正确执行（$?=0），则开始执行 cmd2；<br></li>
<li>若 cmd1 执行完毕且为错误（$?≠0），则 cmd2 不执行；<br></li>
</ol></li>
<li>cmd1 || cmd2<br>
<ol class="org-ol">
<li>若 cmd1 执行完毕且正确执行（$?=0），则 cmd2 不执行；<br></li>
<li>若 cmd1 执行完毕且为错误（$?≠0），则开始执行 cmd2；<br></li>
</ol></li>
</ul>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#20351;&#29992; ls &#26597;&#30475;&#30446;&#24405; /tmp/abc &#26159;&#21542;&#23384;&#22312;&#65292;&#33509;&#23384;&#22312;&#21017;&#29992; touch &#24314;&#31435; /tmp/abc/hehe</span>
$ ls /tmp/abc &amp;&amp; touch /tmp/abc/hehe
ls: cannot access /tmp/abc: No such file or directory
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">ls &#25214;&#19981;&#21040;&#35813;&#30446;&#24405;&#65292;&#20294;&#27809;&#26377; touch &#30340;&#38169;&#35823;&#65292;&#35828;&#26126; touch &#24182;&#27809;&#26377;&#25191;&#34892;</span>

$ mkdir /tmp/abc
$ ls /tmp/abc &amp;&amp; touch /tmp/abc/hehe
</pre>
</div>

<p>
如果 /tmp/abc 不存在时，touch 就不会被执行，若 /tmp/abc 存在的话，那么 touch 就会开始执行。不过我们还是要手动建立目录，那能不能自动判断，如果没有该目录就创建这个目录？<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">$ ls /tmp/abc || mkdir /tmp/abc &amp;&amp; touch /tmp/abc/hehe
</pre>
</div>
</div>
</div>
<div id="outline-container-orga3e96df" class="outline-4">
<h4 id="orga3e96df">判断式</h4>
<div class="outline-text-4" id="text-orga3e96df">
<div class="org-src-container">
<pre class="src src-bash">command1 &amp;&amp; command2 || command3
</pre>
</div>

<p>
以 ls 测试 /tmp/abc 是否存在，若存在则显示 "exist"；若不存在，则显示 "not exist"<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">ls /tmp/abc &amp;&amp; <span style="color: #268bd2;">echo</span> <span style="color: #2aa198;">"exist"</span> || <span style="color: #268bd2;">echo</span> <span style="color: #2aa198;">"not exist"</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org3361f58" class="outline-2">
<h2 id="org3361f58">管道命令（pipe）</h2>
<div class="outline-text-2" id="text-org3361f58">
</div>
<div id="outline-container-orge8c6ef7" class="outline-3">
<h3 id="orge8c6ef7">选取命令：cut、grep</h3>
</div>
<div id="outline-container-org463a7db" class="outline-3">
<h3 id="org463a7db">排序命令：sort、wc、uniq</h3>
</div>
<div id="outline-container-orgac53fec" class="outline-3">
<h3 id="orgac53fec">双向重定向：tee</h3>
</div>
<div id="outline-container-org656194c" class="outline-3">
<h3 id="org656194c">字符转换命令：tr、col、join、paste、expand</h3>
</div>
<div id="outline-container-org3008d6e" class="outline-3">
<h3 id="org3008d6e">划分命令：split</h3>
</div>
<div id="outline-container-org8bb79c2" class="outline-3">
<h3 id="org8bb79c2">参数代换：xargs</h3>
</div>
<div id="outline-container-org63e0997" class="outline-3">
<h3 id="org63e0997">关于减号【-】的用途</h3>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-06-04 Sat 18:18</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
