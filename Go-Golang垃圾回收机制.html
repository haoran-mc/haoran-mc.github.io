<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-09-27 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Golang垃圾回收机制</title>
<meta name="author" content="L.M.haoran" />
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved." />
<meta name="generator" content="Org Mode" />
<link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
           <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
           <script type="module" src="static/js/main.js" defer></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Golang垃圾回收机制</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org1bd7085">垃圾回收概念</a>
<ul>
<li><a href="#org087dfdd">1. 垃圾回收过程</a></li>
<li><a href="#org2412ed3">2. 自动垃圾回收与手动垃圾回收</a></li>
<li><a href="#orgb083910">3. 垃圾回收目标</a></li>
</ul>
</li>
<li><a href="#org30ac152">常见的垃圾回收算法</a>
<ul>
<li><a href="#org8868957">1. 引用计数</a></li>
<li><a href="#org947363f">2. 追踪基础：可达性分析算法</a></li>
<li><a href="#org969b929">3. 标记-清除算法</a></li>
<li><a href="#org1d6014a">4. 标记-复制算法</a></li>
<li><a href="#orgc18070e">5. 标记-整理算法</a></li>
<li><a href="#org6dc9af3">6. 三色标记法</a></li>
<li><a href="#org8d2f62f">7. 分代收集算法</a>
<ul>
<li><a href="#orgad417e8">7.1 分代收集算法的三个假设</a></li>
<li><a href="#orgdc9a178">7.2 新生代分区和老年代分区</a></li>
<li><a href="#orga88dc28">7.3 对象的分配策略</a></li>
<li><a href="#org830a378">7.4 分代算法的大体流程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga0e5488">读写屏障技术</a>
<ul>
<li><a href="#org4542c75">1. 三色标记法的并发性问题</a></li>
<li><a href="#orgbfee836">2. 并发问题原因及解决思路</a></li>
<li><a href="#org6417d02">3. 读写屏障技术</a></li>
<li><a href="#org4aba49d">4. Dijkstra 插入写屏障 - 灰色赋值器</a></li>
<li><a href="#orgb390608">5. Yuasa 删除写屏障 - 黑色赋值器</a></li>
<li><a href="#orgfdc0c9c">6. 混合写屏障</a>
<ul>
<li><a href="#orgc1c60eb">6.1 引入混合写屏障的原因</a></li>
<li><a href="#org973cbeb">6.2 混合写屏障的实现</a></li>
<li><a href="#org5d9a6e4">6.3 具体场景的实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org609c7ed">增量和并发式垃圾回收</a>
<ul>
<li><a href="#orgec7cee2">1. 增量式垃圾回收</a></li>
<li><a href="#org9fa773b">2. 并发式垃圾回收</a></li>
</ul>
</li>
<li><a href="#org288a030">Golang GC 如何扫描对象</a>
<ul>
<li><a href="#orgfa78f01">1. 编译阶段</a>
<ul>
<li><a href="#orgee3e246">1.1 Golang 结构体对齐规则</a></li>
<li><a href="#org7c9bb87">1.2 长度对齐</a></li>
<li><a href="#org8032049">1.3 地址对齐</a></li>
<li><a href="#org4692919">1.4 指针位标记</a></li>
</ul>
</li>
<li><a href="#orga44d7fd">2. 运行期内存分配</a></li>
<li><a href="#org807cebc">3. 运行扫描阶段</a></li>
</ul>
</li>
<li><a href="#org639c780">Golang GC</a>
<ul>
<li><a href="#org2f5f6a2">1. Golang GC 发展历史</a></li>
<li><a href="#org30ed243">2. 回顾 Golang 内存管理内容</a></li>
<li><a href="#orgfa35762">3. Golang GC 实现</a>
<ul>
<li><a href="#org6e5722c">3.1 GC 过程（四个阶段）</a>
<ul>
<li><a href="#org26e7966">3.1.1 清除终止</a></li>
<li><a href="#org4f8e611">3.1.2 标记</a></li>
<li><a href="#org9bcb0ec">3.1.3 标记终止</a></li>
<li><a href="#orgfd237d2">3.1.4 清除</a></li>
</ul>
</li>
<li><a href="#orgf5507b0">3.2 辅助 GC</a></li>
<li><a href="#orge1cb668">3.3 GC 触发时机</a></li>
<li><a href="#orga0b7663">3.4 GC 百分比</a></li>
<li><a href="#org32af4c1">3.5 GC 过程演示</a></li>
</ul>
</li>
<li><a href="#orgd2ed4e4">6. GC 调优方法</a></li>
</ul>
</li>
<li><a href="#org49d78b4">Reference</a></li>
</ul>
</div>
</div>

<div id="outline-container-org1bd7085" class="outline-2">
<h2 id="org1bd7085">垃圾回收概念</h2>
<div class="outline-text-2" id="text-org1bd7085">
<p>
程序创建对象等引用类型实体时会在虚拟内存中分配给它们一块内存空间，如果该内存空间不再被任何引用变量引用时就成为需要被回收的垃圾。操作系统会记录一个进程运行时的所占用的内存、CPU和寄存器等资源，当进程结束后便由操作系统能够自动回收资源。但是对于一个运行较长时间的程序，如果使用完内存资源后没有及时释放就会造成内存泄漏甚至系统错误。<br>
</p>

<p>
以不支持自动垃圾回收的 <verbatim>C++</verbatim> 为例：<br>
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #ee7b29;">void</span> <span style="color: #fedd38;">foo</span>()
{
    <span style="color: #ee7b29;">char</span> *<span style="color: #cbccd1;">p</span> = <span style="color: #ea3d54;">new</span> <span style="color: #ee7b29;">char</span>[128];
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23545;&#25351;&#38024;&#30340;&#20351;&#29992;</span>
    <span style="color: #ea3d54;">delete</span>[] p; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">delete&#35821;&#21477;&#37322;&#25918;&#23545;&#35937;&#25968;&#32452;</span>
}
</pre>
</div>

<p>
如果由于异常或者其他原因导致 <code>delete</code> 语句没有正常执行，且该函数被频繁调用，那么很容易占用所有系统内存从而导致程序崩溃，如果泄漏的是系统资源的话甚至还会导致系统崩溃。另一方面如果我们在不该释放内存的时候释放内存，那么仍然在使用这块内存的指针就会变成野指针 <verbatim>wild pointer</verbatim> ，使用该指针对内存进行读写是未定义的行为。<br>
</p>

<p>
由于 <verbatim>C++</verbatim> 支持比较强大的指针计算功能，因此在 <verbatim>C++</verbatim> 中引入自动垃圾回收是一件比较困难的事情：<br>
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #ee7b29;">int</span> *<span style="color: #cbccd1;">p</span> = <span style="color: #ea3d54;">new</span> <span style="color: #ee7b29;">int</span>;
p += 10; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25351;&#38024;&#20559;&#31227;, &#21407;&#26469;p&#25351;&#21521;&#30340;&#20869;&#23384;&#19981;&#20877;&#34987;&#24341;&#29992;</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21407;&#26469;p&#25351;&#21521;&#30340;&#20869;&#23384;&#21487;&#33021;&#34987;&#22238;&#25910;</span>
p -= 10; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20559;&#31227;&#20026;&#25351;&#38024;p&#21021;&#22987;&#25351;&#21521;&#30340;&#20301;&#32622;</span>
*p = 10; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#22914;&#26524;p&#25351;&#21521;&#30340;&#20869;&#23384;&#34987;&#22238;&#25910;&#30340;&#35805;, &#37027;&#20040;&#36825;&#37324;&#23601;&#20250;&#20986;&#29616;&#37326;&#25351;&#38024;&#30340;&#38382;&#39064;</span>
</pre>
</div>

<p>
由于 <verbatim>Golang</verbatim> 没有 <verbatim>C++</verbatim> 这种对指针偏移的操作，因此可以在语言层面包含自动的垃圾回收功能，系统可以在 <verbatim>CPU</verbatim> 相对空闲的时候进行垃圾回收。<br>
</p>
</div>
<div id="outline-container-org087dfdd" class="outline-3">
<h3 id="org087dfdd">1. 垃圾回收过程</h3>
<div class="outline-text-3" id="text-org087dfdd">
<p>
用户程序 <verbatim>Mutator</verbatim> 通过内存分配器 <verbatim>Allocator</verbatim> 在堆 <verbatim>Heap</verbatim> 上申请内存，垃圾回收器Collector会定时清理堆上的内存。<br>
</p>

<img src="./images/Go-GC-申请、释放内存.png" />
</div>
</div>
<div id="outline-container-org2412ed3" class="outline-3">
<h3 id="org2412ed3">2. 自动垃圾回收与手动垃圾回收</h3>
<div class="outline-text-3" id="text-org2412ed3">
<p>
<verbatim>C</verbatim> 语言这种较为传统的语言通过 <code>malloc</code> 和 <code>free</code> 手动向操作系统申请和释放内存，这种自由管理内存的方式给予程序员极大的自由度，但是也相应地提高了对程序员的要求。 <verbatim>C</verbatim> 语言的内存分配和回收方式主要包括三种：<br>
</p>

<ul class="org-ul">
<li>函数体内的局部变量：在栈上创建，函数作用域结束后自动释放内存<br></li>
<li>静态变量：在静态存储区域上分配内存，整个程序运行结束后释放（全局生命周期）<br></li>
<li>动态分配内存的变量：在堆上分配，通过 <code>malloc</code> 申请， <code>free</code> 释放<br></li>
</ul>

<p>
<verbatim>C</verbatim> 、 <verbatim>C++</verbatim> 和 <verbatim>Rust</verbatim> 等较早的语言采用的是手动垃圾回收，需要程序员通过向操作系统申请和释放内存来手动管理内存，程序员极容易忘记释放自己申请的内存，对于一个长期运行的程序往往是一个致命的缺点。 <verbatim>Python</verbatim> 、 <verbatim>Java</verbatim> 和 <verbatim>Golang</verbatim> 等较新的语言采取的都是自动垃圾回收方式，程序员只需要负责申请内存，垃圾回收器会周期性释放结束生命周期的变量所占用的内存空间。<br>
</p>
</div>
</div>
<div id="outline-container-orgb083910" class="outline-3">
<h3 id="orgb083910">3. 垃圾回收目标</h3>
<div class="outline-text-3" id="text-orgb083910">
<p>
垃圾回收器主要包括三个目标：<br>
</p>

<ul class="org-ul">
<li>无内存泄漏：垃圾回收器最基本的目标就是减少防止程序员未及时释放导致的内存泄漏，垃圾回收器会识别并清理内存中的垃圾<br></li>
<li>自动回收无用内存：垃圾回收器作为独立的子任务，不需要程序员显式调用即可自动清理内存垃圾<br></li>
<li>内存整理：如果只是简单回收无用内存，那么堆上的内存空间会存在较多碎片而无法满足分配较大对象的需求，因此垃圾回收器需要重整内存空间，提高内存利用率<br></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org30ac152" class="outline-2">
<h2 id="org30ac152">常见的垃圾回收算法</h2>
<div class="outline-text-2" id="text-org30ac152">
<blockquote>
<p>
根据判断对象是否存活的方法，可以简单将 <verbatim>GC</verbatim> 算法分为“引用计数式”垃圾回收和“追踪回收式”垃圾回收。前者根据每个对象的引用计数器是否为0来判断该对象是否为未引用的垃圾对象，后者先判断哪些对象存活，然后将其余的所有对象作为垃圾进行回收。追踪回收本身包括标记-清除 <verbatim>Mark-Sweep</verbatim> 、标记-复制 <verbatim>Mark-Copy</verbatim> 和标记-整理 <verbatim>Mark-Compact</verbatim> 三种回收算法。<br>
</p>
</blockquote>
</div>
<div id="outline-container-org8868957" class="outline-3">
<h3 id="org8868957">1. 引用计数</h3>
<div class="outline-text-3" id="text-org8868957">
<p>
引用计数 <verbatim>Reference counting</verbatim> 会为每个对象维护一个计数器，当该对象被其他对象引用时加一，引用失效时减一，当引用次数归零后即可回收对象。使用这类 <verbatim>GC</verbatim> 方法的语言包括 <verbatim>python</verbatim> 、 <verbatim>php</verbatim> 、 <verbatim>objective-C</verbatim> 、 <verbatim>Swift</verbatim> 和 <verbatim>C++</verbatim> 标准库中的 <code>std::shared_ptr</code> 等。<br>
</p>

<p>
以 <verbatim>python</verbatim> 为例， <verbatim>python</verbatim> 中的每个对象都包含如下结构：<br>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ea3d54;">typedef</span> <span style="color: #ee7b29;">struct_object</span> {
    <span style="color: #ee7b29;">int</span> <span style="color: #cbccd1;">ob_refcnt</span>;
    <span style="color: #ee7b29;">struct_typeobject</span> *<span style="color: #cbccd1;">ob_type</span>;
} PyObject;
</pre>
</div>

<p>
其中 <code>ob_refcnt</code> 为引用计数器，当一个对象有新的引用时计数器增一，当引用它的对象被删除时计数器减一。<br>
</p>

<p>
引用计数法优点包括：<br>
</p>

<ul class="org-ul">
<li>原理和实现都比较简单<br></li>
<li>回收的即时性：当对象的引用计数为0时立即回收，不像其他 <verbatim>GC</verbatim> 机制需要等待特定时机再回收，提高了内存的利用率<br></li>
<li>不需要暂停应用即可完成回收<br></li>
</ul>

<p>
缺点包括：<br>
</p>

<ul class="org-ul">
<li>无法解决循环引用的回收问题：当 <verbatim>ObjA</verbatim> 引用了 <verbatim>ObjB</verbatim> ， <verbatim>ObjB</verbatim> 也引用 <verbatim>ObjA</verbatim> 时，这两个对象的引用次数使用大于 <verbatim>0</verbatim> ，从而占用的内存无法被回收<br></li>
<li>时间和空间成本较高：一方面是因为每个对象需要额外的空间存储引用计数器变量，另一方面是在栈上的赋值时修改引用次数时间成本较高（原本只需要修改寄存器中的值，现在计数器需要不断更新因此不是只读的，需要额外的原子操作来保证线程安全）<br></li>
<li>引用计数是一种摊销算法，会将内存的回收分摊到整个程序的运行过程，但是当销毁一个很大的树形结构时无法保证响应时间<br></li>
</ul>
</div>
</div>
<div id="outline-container-org947363f" class="outline-3">
<h3 id="org947363f">2. 追踪基础：可达性分析算法</h3>
<div class="outline-text-3" id="text-org947363f">
<p>
尽管前面提到的三种追踪式垃圾回收算法实现起来各不相同，但是第一步都是通过可达性分析算法标记 <code>Mark</code> 对象是否“可达”。一般可到达的对象主要包括两类：<br>
</p>

<ul class="org-ul">
<li><verbatim>GC Root</verbatim> 对象：包括全局对象、栈上的对象（函数参数与内部变量）<br></li>
<li>与 <verbatim>GC Root</verbatim> 对象通过引用链 <verbatim>Reference Chain</verbatim> 相连的对象<br></li>
</ul>

<p>
对于“不可达”的对象，我们可以认为该对象为垃圾对象并回收对应的内存空间。<br>
</p>

<img src="./images/Go-GC-可达与不可达.png" />

<p>
可达性算法中判断对象是否“可达”依赖于“引用”的定义， <verbatim>java</verbatim> 中的引用从强到弱可分为四类，不同的引用类型可以满足多样化的场景：<br>
</p>

<ul class="org-ul">
<li>强引用 <verbatim>Strong Reference</verbatim> ：使用 <code>Object obj = new Object()</code> 定义的引用，这类对象无论在什么情况下都不会被垃圾回收机制清理掉<br></li>
<li>软引用 <verbatim>Soft Reference</verbatim> ：用于描述有用但非必需的对象，只有在内存不足的时候才会回收该对象，适合实现内存敏感的高速缓存（网页缓存和图片缓存等）；软引用可以和引用队列 <verbatim>ReferenceQueue</verbatim> 一起使用，当软引用所引用的对象被回收时 <verbatim>JVM</verbatim> 会把这个软引用加入到与之关联的引用队列， <verbatim>GC</verbatim> 线程会在抛出 <verbatim>OOM</verbatim> 错误前根据引用队列来回收长时间闲置不用的软引用对象<br></li>
<li>弱引用 <verbatim>Weak Reference</verbatim> ：用于描述非必需对象，在 <verbatim>JVM</verbatim> 进行垃圾回收时会直接回收被弱引用关联的对象，同软引用相比有更短的生命周期<br></li>
<li>虚引用 <verbatim>Phantom Reference</verbatim> ：一个对象与虚引用关联时在任何时候都可以被垃圾回收器回收，因此并不会影响该对象的生命周期，主要用于跟踪对象被 <verbatim>GC</verbatim> 回收的活动；虚引用必须和引用队列联合使用，当回收一个对象时如果发现它还有虚引用，就会在回收对象的内存之前将这个虚引用加入到与之关联的引用队列中，这样程序可以通过判断引用队列是否加入虚引用来判断被引用的对象是否将进行垃圾回收<br></li>
</ul>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">引用类型</th>
<th scope="col" class="org-left">回收时机</th>
<th scope="col" class="org-left">用途</th>
<th scope="col" class="org-left">生存周期</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">强引用</td>
<td class="org-left">从不回收</td>
<td class="org-left">对象的一般状态</td>
<td class="org-left"><verbatim>JVM</verbatim> 停止运行时</td>
</tr>

<tr>
<td class="org-left">软引用</td>
<td class="org-left">内存不足时</td>
<td class="org-left">对象缓存</td>
<td class="org-left">内存不足时终止</td>
</tr>

<tr>
<td class="org-left">弱引用</td>
<td class="org-left">正常垃圾回收时</td>
<td class="org-left">对象缓存</td>
<td class="org-left">垃圾回收后终止</td>
</tr>

<tr>
<td class="org-left">虚引用</td>
<td class="org-left">正常垃圾回收时</td>
<td class="org-left">跟踪对象的垃圾回收</td>
<td class="org-left">垃圾回收后终止</td>
</tr>
</tbody>
</table>

<p>
同引用计数法相比，追踪式算法具有如下优点：<br>
</p>

<ul class="org-ul">
<li>解决了循环引用对象的回收问题<br></li>
<li>占用空间更少<br></li>
</ul>

<p>
缺点包括：<br>
</p>

<ul class="org-ul">
<li>同引用计数相比无法立刻识别出垃圾对象，需要依赖 <verbatim>GC</verbatim> 线程<br></li>
<li>算法在标记时必须暂停整个程序，即 <verbatim>Stop The World, STW</verbatim> ，否则其他线程的代码会修改对象状态从而回收不该回收的对象<br></li>
</ul>
</div>
</div>
<div id="outline-container-org969b929" class="outline-3">
<h3 id="org969b929">3. 标记-清除算法</h3>
<div class="outline-text-3" id="text-org969b929">
<p>
标记-清除 <verbatim>Mark-Sweep</verbatim> 算法是最基础的追踪式算法，分为“标记”和“清除”两个步骤：<br>
</p>

<ul class="org-ul">
<li>标记：记录需要回收的垃圾对象<br></li>
<li>清除：在标记完成后回收垃圾对象的内存空间<br></li>
</ul>

<img src="./images/Go-GC-标记_清除算法.png" />

<p>
优点包括：<br>
</p>

<ul class="org-ul">
<li>算法吞吐量较高，即运行用户代码时间 / （运行用户代码时间 + 运行垃圾收集时间）较高<br></li>
<li>空间利用率高：同标记-复制相比不需要额外空间复制对象，也不需要像引用计数算法为每个对象设置引用计数器<br></li>
</ul>

<p>
缺点包括：<br>
</p>

<ul class="org-ul">
<li>清除后会产生大量的内存碎片空间，导致程序在运行时可能没法为较大的对象分配内存空间，导致提前进行下一次垃圾回收<br></li>
</ul>
</div>
</div>
<div id="outline-container-org1d6014a" class="outline-3">
<h3 id="org1d6014a">4. 标记-复制算法</h3>
<div class="outline-text-3" id="text-org1d6014a">
<p>
标记-复制 <verbatim>Mark-Copy</verbatim> 算法将内存分成大小相同的两块，当某一块的内存使用完了之后就将使用中的对象挨个复制到另一块内存中，最后将当前内存恢复未使用的状态。<br>
</p>

<img src="./images/Go-GC-标记_复制算法.png" />

<p>
优点包括：<br>
</p>

<ul class="org-ul">
<li>标记-清除法需要在清除阶段对大量垃圾对象进行扫描，标记-复制则只需要从 <verbatim>GC Root</verbatim> 对象出发，将“可到达”的对象复制到另一块内存后直接清理当前这块的内存，因此提升了垃圾回收的效率<br></li>
<li>解决了内存碎片化的问题，防止分配较大连续空间时的提前 <verbatim>GC</verbatim> 问题<br></li>
</ul>

<p>
缺点包括：<br>
</p>

<ul class="org-ul">
<li>同标记-清除法相比，在“可达”对象占比较高的情况下有复制对象的开销<br></li>
<li>内存利用率较低，相当于可利用的内存仅有一半<br></li>
</ul>
</div>
</div>
<div id="outline-container-orgc18070e" class="outline-3">
<h3 id="orgc18070e">5. 标记-整理算法</h3>
<div class="outline-text-3" id="text-orgc18070e">
<p>
标记-整理 <verbatim>Mark-Compact</verbatim> 算法综合了标记-清除法和标记-复制法的优势，既不会产生内存碎片化的问题，也不会有一半内存空间浪费的问题。该方法首先标记出所有“可达”的对象，然后将存活的对象移动到内存空间的一端，最后清理掉端边界以外的内存。<br>
</p>

<img src="./images/Go-GC-标记_整理算法.png" />

<p>
优点包括：<br>
</p>

<ul class="org-ul">
<li>避免了内存碎片化的问题<br></li>
<li>在对象存活率较高的情况下，标记-整理算法由于不需要复制对象效率更高，因此更加适合老年代算法<br></li>
</ul>

<p>
缺点包括：<br>
</p>

<ul class="org-ul">
<li>整理过程较为复杂，需要多次遍历内存导致 <verbatim>STW</verbatim> 时间比标记-清除算法更长<br></li>
</ul>
</div>
</div>
<div id="outline-container-org6dc9af3" class="outline-3">
<h3 id="org6dc9af3">6. 三色标记法</h3>
<div class="outline-text-3" id="text-org6dc9af3">
<p>
前面提到的“标记”类算法都有一个共同的瑕疵，即在进行垃圾回收的时候会暂停整个程序（ <verbatim>STW</verbatim> 问题）。三色标记法是对“标记”阶段的改进，在不暂停程序的情况下即可完成对象的可达性分析。 <verbatim>GC</verbatim> 线程将所有对象分为三类：<br>
</p>

<ul class="org-ul">
<li>白色：未搜索的对象， <verbatim>gcmarkBits</verbatim> 对应位为 <verbatim>0</verbatim> ，在回收周期开始时所有对象都是白色，在回收周期结束时所有的白色都是垃圾对象<br></li>
<li>灰色：正在搜索的对象，还在标记队列中等待，且对象身上还有零个或多个引用没有扫描<br></li>
<li>黑色：已搜索完的对象， <verbatim>gcmarkBits</verbatim> 对应位为 <verbatim>1</verbatim> ，该对象不会在本次 <verbatim>GC</verbatim> 中被回收<br></li>
</ul>

<p>
三色标记法属于 <b>增量式 <verbatim>GC</verbatim> 算法</b> ，回收器首先将所有的对象着色成白色，然后从 <verbatim>GC Root</verbatim> 出发，逐步把所有“可达”的对象变成灰色再到黑色，最终所有的白色对象即是“不可达”对象。<br>
</p>

<p>
具体的实现如下：<br>
</p>

<ul class="org-ul">
<li>初始时所有对象都是白色对象<br></li>
<li>从 <verbatim>GC Root</verbatim> 对象出发，扫描所有可达对象并标记为灰色，放入待处理队列<br></li>
<li>从队列取出一个灰色对象并标记为黑色，将其引用对象标记为灰色放入队列<br></li>
<li>重复上一步骤，直到灰色对象队列为空<br></li>
<li>此时所有剩下的白色对象就是垃圾对象<br></li>
</ul>

<p>
<verbatim>GC Root</verbatim> （根对象）在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：<br>
</p>

<ul class="org-ul">
<li>全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。<br></li>
<li>执行栈：每个 <verbatim>goroutine</verbatim> 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。<br></li>
<li>寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。<br></li>
</ul>

<p>
优点：<br>
</p>

<ul class="org-ul">
<li>不需要暂停整个程序进行垃圾回收<br></li>
</ul>

<p>
缺点：<br>
</p>

<ul class="org-ul">
<li>如果程序垃圾对象的产生速度大于垃圾对象的回收速度时，可能导致程序中的垃圾对象越来越多而无法及时收集<br></li>
<li>线程切换和上下文转换的消耗会使得垃圾回收的总体成本上升，从而降低系统吞吐量<br></li>
</ul>
</div>
</div>
<div id="outline-container-org8d2f62f" class="outline-3">
<h3 id="org8d2f62f">7. 分代收集算法</h3>
<div class="outline-text-3" id="text-org8d2f62f">
<p>
前面提到追踪式垃圾回收算法一个显著的问题是会频繁扫描生命周期较长的对象，而内存分配存在一个 <verbatim>most object die young</verbatim> （绝大部分对象的生命周期都很短）的事实，因此有必要将对象按照生命周期的长度划分到堆 <verbatim>heap</verbatim> 上的两个甚至多个区域。对于新生代区域的扫描频率应该高于老年代区域。<br>
</p>

<ul class="org-ul">
<li>使用分代收集算法的代表语言：Java。<br></li>
<li>优点：回收性能好<br></li>
<li>缺点：算法复杂<br></li>
</ul>
</div>
<div id="outline-container-orgad417e8" class="outline-4">
<h4 id="orgad417e8">7.1 分代收集算法的三个假设</h4>
<div class="outline-text-4" id="text-orgad417e8">
<ul class="org-ul">
<li>弱分代假说：大多数对象的生命周期都很短<br></li>
<li>强分代假说：多轮垃圾回收都没清理掉的对象往往不容易死亡<br></li>
<li>跨代引用假说：跨代引用和同代引用相比仅占一小部分<br></li>
</ul>
</div>
</div>
<div id="outline-container-orgdc9a178" class="outline-4">
<h4 id="orgdc9a178">7.2 新生代分区和老年代分区</h4>
<div class="outline-text-4" id="text-orgdc9a178">
<p>
分代收集算法会将对象按照生命周期的长短划分到不同的分区。对于生命周期短的新生代区域，每次回收仅需要考虑如何保留少量的存活对象，因此可以采用标记-复制算法完成 <verbatim>GC</verbatim> ；对于生命周期长的老年代区域，可以通过减少垃圾回收的频率来提升效率，同时由于对象存活率高没有额外的空间用于复制，因此一般使用标记-清除算法或者标记-整理算法。<br>
</p>

<blockquote>
<p>
分代收集算法首先会根据对象的生命周期将内存划分为 <verbatim>Young</verbatim> 和 <verbatim>Old</verbatim> 两块大区域。由于新生代中的对象生命周期较短（每次回收约 <verbatim>98%</verbatim> 的对象是垃圾对象），再加上新生代采用标记-复制法需要两块内存交替使用， <verbatim>Young</verbatim> 区为了节省复制算法的内存代价又划分成 <verbatim>Eden</verbatim> 、 <verbatim>Survivor0</verbatim> 和 <verbatim>Survivor1</verbatim> 三个分区（内存分配比例为 <verbatim>8:1:1</verbatim> ）。另外，我们没法保证 <verbatim>Young</verbatim> 区每次回收都仅有 <verbatim>10%</verbatim> 不到的对象存活，因此当 <verbatim>Survivor</verbatim> 区空间不够时需要放到 <verbatim>Old</verbatim> 区，而且大对象需要直接进 <verbatim>Old</verbatim> 区。<br>
</p>
</blockquote>

<img src="./images/Go-GC-新生代分区和老年代分区.png" width="600px" />

<p>
由于堆分为 <verbatim>Young</verbatim> 和 <verbatim>Old</verbatim> 两个分区，因此垃圾回收也根据回收的分区不同划分为新生代回收 <verbatim>Minor GC</verbatim> 和老年代回收 <verbatim>Major GC</verbatim> 。<br>
</p>
</div>
</div>
<div id="outline-container-orga88dc28" class="outline-4">
<h4 id="orga88dc28">7.3 对象的分配策略</h4>
<div class="outline-text-4" id="text-orga88dc28">
<ul class="org-ul">
<li>对象优先在 <verbatim>Yonug</verbatim> 上的 <verbatim>Eden</verbatim> 区域分配<br></li>
<li>大对象直接进入 <verbatim>Old</verbatim> 区：主要是因为我们没法保证 <verbatim>Young</verbatim> 区每次回收都仅有 <verbatim>10%</verbatim> 不到的对象存活，因此标记-复制法下 <verbatim>Survivor</verbatim> 难以回收较大的对象<br></li>
<li>新生代中生命周期较长的对象在 <verbatim>Survivor</verbatim> 区每熬过因此 <verbatim>Minor GC</verbatim> 就会增加一岁，年龄增加到一定阈值时就进入老年代<br></li>
</ul>
</div>
</div>
<div id="outline-container-org830a378" class="outline-4">
<h4 id="org830a378">7.4 分代算法的大体流程</h4>
<div class="outline-text-4" id="text-org830a378">
<p>
假设一开始 <verbatim>Young</verbatim> 和 <verbatim>Old</verbatim> 区都是空的，流程如下：<br>
</p>

<ol class="org-ol">
<li>新分配的对象优先存放在 <verbatim>Eden</verbatim> 区（大对象直接进入 <verbatim>Old</verbatim> 区）<br></li>
<li><verbatim>Eden</verbatim> 区满了之后开始进行 <verbatim>Minor GC</verbatim> ，将 <verbatim>Eden</verbatim> 中存活的对象移动到 <verbatim>Survivor0</verbatim> 区，直接清空 <verbatim>Eden</verbatim> 区<br></li>
<li><verbatim>Eden</verbatim> 区第二次满了之后进行 <verbatim>Minor GC</verbatim> ，将 <verbatim>Eden</verbatim> 和 <verbatim>Survivor0</verbatim> 中存活的对象复制到 <verbatim>Survivor1</verbatim> 区，清空 <verbatim>Eden</verbatim> 和 <verbatim>Survivor0</verbatim> 区<br></li>
<li>若干轮 <verbatim>Minor GC</verbatim> 过后，此时新生代中生命周期较长的对象熬过了一定次数的 <verbatim>Minor GC</verbatim> 晋升成老年代移动到 <verbatim>Old</verbatim> 区，某轮 <verbatim>Minor GC</verbatim> 存活率较高 <verbatim>Survivor</verbatim> 区空间不足时也会将存活对象放到 <verbatim>Old</verbatim> 区<br></li>
<li>当 <verbatim>Old</verbatim> 区满了之后进行 <verbatim>Major GC</verbatim><br></li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-orga0e5488" class="outline-2">
<h2 id="orga0e5488">读写屏障技术</h2>
<div class="outline-text-2" id="text-orga0e5488">
</div>
<div id="outline-container-org4542c75" class="outline-3">
<h3 id="org4542c75">1. 三色标记法的并发性问题</h3>
<div class="outline-text-3" id="text-org4542c75">
<p>
假设三色标记法执行前，包含如下对象：<br>
</p>

<img src="./images/Go-GC-三色标记法-读写屏障01.png" />

<p>
则三色标记法的具体执行过程如下：<br>
</p>

<img src="./images/Go-GC-三色标记法-读写屏障02.png" />

<p>
上述三色标记执行过后堆内存中白色对象（只有 <verbatim>D</verbatim> ）会被当做垃圾对象清理掉，如果用户在标记执行过程中建立了从 <verbatim>A</verbatim> 对象到 <verbatim>D</verbatim> 对象的引用，那么会导致后续对 <verbatim>D</verbatim> 的访问出错。这种没有指向合法地址的指针一般被称为“野指针”，会造成严重的程序错误。<br>
</p>

<img src="./images/Go-GC-三色标记法-读写屏障03.png" />
</div>
</div>
<div id="outline-container-orgbfee836" class="outline-3">
<h3 id="orgbfee836">2. 并发问题原因及解决思路</h3>
<div class="outline-text-3" id="text-orgbfee836">
<p>
假设三色标记法和用户程序并发执行，那么下列两个条件 <b>同时满足</b> 就可能出现错误回收非垃圾对象的问题：<br>
</p>

<ul class="org-ul">
<li>条件1：某一黑色对象引用白色对象<br></li>
<li>条件2：对于某个白色对象，所有和它存在可达关系的灰色对象丢失了访问它的可达路径<br></li>
</ul>

<p>
简单证明一下：如果条件1不满足，那么任何不该被回收的白色对象都能和至少一个灰色对象存在“可达”路径，因此不会有白色对象被遗漏；如果条件2不满足，那么对于某一个白色对象，即使它被黑色对象引用，但至少存在一个和它存在可达关系的灰色对象，因此这个白色对象也不会被回收。<br>
</p>

<blockquote>
<p>
一句话总结即是：在三色标记法执行的某个特定时机，只要存在未经访问的能够到达白色对象的可达路径，就可以令黑色对象引用白色对象，反正该白色对象在后面标记中会被识别为“可达”对象从而不会被错误回收。<br>
</p>
</blockquote>

<p>
一种最简单解决三色标记并发问题的方法是停止所有的赋值器线程，保证标记过程不受干扰，即垃圾回收器中常提到的 <verbatim>STW, stop the world</verbatim> 方法。另外一种思路就是使用赋值器屏障技术使得赋值器在进行指针写操作时同步垃圾回收器，保证不破坏弱三色不变性（见下文）。<br>
</p>
</div>
</div>
<div id="outline-container-org6417d02" class="outline-3">
<h3 id="org6417d02">3. 读写屏障技术</h3>
<div class="outline-text-3" id="text-org6417d02">
<blockquote>
<p>
屏障技术：给代码操作内存的顺序添加一些限制，即在内存屏障前执行的动作必须先于在你内存屏障后执行的动作。<br>
</p>
</blockquote>

<p>
使用屏障技术可以使得用户程序和三色标记过程并发执行，我们只需要达成下列任意一种三色不变性：<br>
</p>

<ul class="org-ul">
<li>强三色不变性：黑色对象永远不会指向白色对象<br></li>
<li>弱三色不变性：黑色对象指向的白色对象至少包含一条由灰色对象经过白色对象的可达路径<br></li>
</ul>

<p>
<verbatim>GC</verbatim> 中使用的内存读写屏障技术指的是编译器会在编译期间生成一段代码，该代码在运行期间用户读取、创建或更新对象指针时会拦截内存读写操作，相当于一个 <verbatim>hook</verbatim> 调用，根据 <verbatim>hook</verbatim> 时机不同可分为不同的屏障技术。由于读屏障 <verbatim>Read barrier</verbatim> 技术需要在读操作中插入代码片段从而影响用户程序性能，所以一般使用写屏障技术来保证三色标记的稳健性。<br>
</p>

<blockquote>
<p>
我们讲内存屏障技术解决了三色标记法的STW缺点，并不是指消除了所有的赋值器挂起问题。需要分清楚STW方法是全局性的赋值器挂起而内存屏障技术是局部的赋值器挂起。<br>
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org4aba49d" class="outline-3">
<h3 id="org4aba49d">4. Dijkstra 插入写屏障 - 灰色赋值器</h3>
<div class="outline-text-3" id="text-org4aba49d">
<p>
<verbatim>Dijkstra</verbatim> 插入写屏障避免了前面提到的条件1，即防止黑色对象指向白色对象。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#28155;&#21152;&#19979;&#28216;&#23545;&#35937;&#30340;&#20989;&#25968;, &#24403;&#21069;&#19979;&#28216;&#23545;&#35937;slot, &#26032;&#19979;&#28216;&#23545;&#35937;ptr</span>
<span style="color: #ea3d54;">func</span> <span style="color: #fedd38;">DijkstraWritePointer</span>(<span style="color: #cbccd1;">slot</span> *<span style="color: #ee7b29;">unsafe.Pointer</span>, <span style="color: #cbccd1;">ptr</span> <span style="color: #ee7b29;">unsafe.Pointer</span>) {
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">1) &#23558;&#26032;&#19979;&#28216;&#23545;&#35937;&#26631;&#35760;&#20026;&#28784;&#33394;</span>
    <span style="color: #fedd38;">shade</span>(ptr)
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">2) &#24403;&#21069;&#19979;&#28216;&#23545;&#35937;slot = &#26032;&#19979;&#28216;&#23545;&#35937;ptr</span>
    *slot = ptr
}

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#22330;&#26223;&#19968;&#65306;A&#20043;&#21069;&#27809;&#26377;&#19979;&#28216;, &#26032;&#28155;&#21152;&#19968;&#20010;&#19979;&#28216;&#23545;&#35937;B, B&#34987;&#26631;&#35760;&#20026;&#28784;&#33394;</span>
A.<span style="color: #fedd38;">DijkstraWritePointer</span>(<span style="color: #ee7b29;">nil</span>, B)
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#22330;&#26223;&#20108;&#65306;A&#23558;&#19979;&#28216;&#23545;&#35937;C&#26356;&#25442;&#20026;B, B&#34987;&#26631;&#35760;&#20026;&#28784;&#33394;</span>
A.<span style="color: #fedd38;">DijkstraWritePointer</span>(C, B)
</pre>
</div>

<p>
一个对象可以存储在内存中的“栈”或者“堆”，由于“栈”空间容量小且要求相应速度较高，因此“插入写屏障”不适合用于“栈”空间。在“插入写屏障”保护下的三色标记法执行例子如下：<br>
</p>

<img src="./images/Go-GC-Dijkstra插入写屏障01.png" />

<img src="./images/Go-GC-Dijkstra插入写屏障02.png" />

<img src="./images/Go-GC-Dijkstra插入写屏障03.png" />

<ul class="org-ul">
<li>第一步：垃圾回收之前将所有的对象标记为白色<br></li>
<li>第二步：遍历 <verbatim>GC Root Set</verbatim> ，将可达对象标记为灰色<br></li>
<li>第三步：遍历灰色对象列表，将可达的对象从白色标记为灰色；将遍历完的灰色对象标记为黑色<br></li>
<li>第四步：在三色标记过程中用户程序令栈区对象A指向对象H，令堆区对象E指向对象I，由于对象E在堆区从而触发插入写屏障并将黑色对象E指向的白色对象I标记为灰色，栈区对象A不触发<br></li>
<li>第五步：继续三色标记直至灰色对象队列为空<br></li>
<li>第六步：由于栈区对象没有启动插入写屏障，因此栈上可能存在白色对象被引用的情况（上图中对应对象H），因此在回收白色对象前在 <verbatim>STW</verbatim> 保护下重新扫描一次栈空间<br></li>
<li>第七步：在 <verbatim>STW</verbatim> 保护下对栈空间一次性进行三色标记，直到灰色对象队列为空<br></li>
<li>第八步：结束 <verbatim>STW</verbatim><br></li>
<li>第九步：最后将栈空间和堆空间的白色垃圾对象进行回收<br></li>
</ul>

<p>
尽管 <verbatim>Dijkstra</verbatim> 插入写屏障可以实现垃圾回收和用户程序的并发执行，但是它存在两个缺点。一方面它是一种比较保守的垃圾回收方法，把有可能存活的对象都标记成灰色了以满足“强三色不变性”。以下图为例，用户程序 <verbatim>Mutator</verbatim> 将对象A原本指向B对象的指针改成指向C对象，尽管在修改后B对象已经是一个垃圾对象，但是它在本轮垃圾回收过程中不会被回收。<br>
</p>

<img src="./images/Go-GC-Dijkstra插入写屏障04.png" />

<p>
另外一个缺点在于栈上的对象也是根对象， <verbatim>Dijkstra</verbatim> 插入写屏障要么在用户程序执行内存写操作时为栈上对象插入写屏障，要么在一轮三色标记完成后使用 <verbatim>STW</verbatim> 重新对栈上的对象进行三色标记。前者会降低栈空间的响应速度，后者会暂停用户程序。<br>
</p>
</div>
</div>
<div id="outline-container-orgb390608" class="outline-3">
<h3 id="orgb390608">5. Yuasa 删除写屏障 - 黑色赋值器</h3>
<div class="outline-text-3" id="text-orgb390608">
<p>
<verbatim>Yuasa</verbatim> 删除写屏障避免了前面提到的条件2，防止丢失灰色对象到白色对象的可达路径。当用户程序执行 <code>*slot = ptr</code> 时（即令 <code>slot</code> 指向了 <code>ptr</code> ），我们会将当前下游对象 <code>*slot</code> 标记为灰色。一句话解释就是当删除对象A指向对象B的指针时，那么将被删除的对象标记为灰色。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#28155;&#21152;&#19979;&#28216;&#23545;&#35937;&#30340;&#20989;&#25968;, &#24403;&#21069;&#19979;&#28216;&#23545;&#35937;slot, &#26032;&#19979;&#28216;&#23545;&#35937;ptr</span>
<span style="color: #ea3d54;">func</span> <span style="color: #fedd38;">YuasaWritePointer</span>(<span style="color: #cbccd1;">slot</span> *<span style="color: #ee7b29;">unsafe.Pointer</span>, <span style="color: #cbccd1;">ptr</span> <span style="color: #ee7b29;">unsafe.Pointer</span>) {
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">1) &#23558;&#24403;&#21069;&#19979;&#28216;&#23545;&#35937;&#26631;&#35760;&#20026;&#28784;&#33394;</span>
    <span style="color: #fedd38;">shade</span>(*slot)
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">2) &#24403;&#21069;&#19979;&#28216;&#23545;&#35937;slot = &#26032;&#19979;&#28216;&#23545;&#35937;ptr</span>
    *slot = ptr
}

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#22330;&#26223;&#19968;&#65306;B&#34987;A&#21024;&#38500;, &#23558;B&#26631;&#35760;&#20026;&#28784;&#33394;</span>
A.<span style="color: #fedd38;">&#28155;&#21152;&#19979;&#28216;&#23545;&#35937;</span>(B, <span style="color: #ee7b29;">nil</span>)
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#22330;&#26223;&#20108;&#65306;B&#34987;A&#21024;&#38500;, &#23558;B&#26631;&#35760;&#20026;&#28784;&#33394;</span>
A.<span style="color: #fedd38;">&#28155;&#21152;&#19979;&#28216;&#23545;&#35937;</span>(B, C)
</pre>
</div>

<img src="./images/Go-GC-Yuasa删除写屏障01.png" />

<img src="./images/Go-GC-Yuasa删除写屏障02.png" />

<ul class="org-ul">
<li>第一步：将所有对象标记为白色<br></li>
<li>第二步：遍历 <verbatim>GC Root Set</verbatim> 将可达对象设为灰色<br></li>
<li>第三步：如果用户程序令灰色对象A删除了对白色对象D的引用，如果这时候不触发删除写屏障，那么对象D、B和C直到本轮垃圾回收结束都会是白色对象。因此需要触发删除写屏障，将对象D标记为灰色。<br></li>
<li>第四步：遍历灰色对象队列，将可达的白色对象标记为灰色，遍历完的灰色对象标记为黑色<br></li>
<li>第五步：继续进行三色标记，直到灰色对象队列为空<br></li>
<li>第六步：清除所有的白色对象<br></li>
</ul>

<p>
下图简单绘制了 <verbatim>Yuasa</verbatim> 删除写屏障是如何保证用户程序 <verbatim>Mutator</verbatim> 和垃圾回收器 <verbatim>Collector</verbatim> 的并发执行的：<br>
</p>

<ul class="org-ul">
<li>第二步中 <verbatim>Mutator</verbatim> 将对象A原本指向对象B的指针指向C，由于对象B本身就是灰色的，因此不需要对它重新着色<br></li>
<li>第三步中 <verbatim>Mutator</verbatim> 删除了对象B指向对象C的指针，删除写屏障将下游对象C标记为灰色<br></li>
</ul>

<img src="./images/Go-GC-Yuasa删除写屏障03.png" />

<p>
<verbatim>Yuasa</verbatim> 删除写屏障和 <verbatim>Dijkstra</verbatim> 插入写屏障相比优点在于不需要在一轮三色标记后对栈空间上的对象进行重新扫描，缺点在于 <verbatim>Collector</verbatim> 会悲观地认为所有被删除的对象都可能被黑色对象引用，比如上图中第三步 <verbatim>Mutator</verbatim> 删除了对象B指向对象C的指针，如果此时还有一个单独的对象E指向C，那么本该被删除的对象E却可以在本轮垃圾回收中存活。<br>
</p>
</div>
</div>
<div id="outline-container-orgfdc0c9c" class="outline-3">
<h3 id="orgfdc0c9c">6. 混合写屏障</h3>
<div class="outline-text-3" id="text-orgfdc0c9c">
</div>
<div id="outline-container-orgc1c60eb" class="outline-4">
<h4 id="orgc1c60eb">6.1 引入混合写屏障的原因</h4>
<div class="outline-text-4" id="text-orgc1c60eb">
<p>
在 <verbatim>go v1.8</verbatim> 引入混合写屏障 <verbatim>hybrid write barrier</verbatim> 之前，由于 <verbatim>GC Root</verbatim> 对象包括了栈对象，如果运行时在所有 <verbatim>GC Root</verbatim> 对象上开启插入写屏障意味着需要在数量庞大的 <verbatim>Goroutine</verbatim> 的栈上都开启 <verbatim>Dijkstra</verbatim> 写屏障从而严重影响用户程序的性能。之前的做法是 <verbatim>Mark</verbatim> 阶段（ <verbatim>golang</verbatim> 垃圾回收使用的是标记-清除法）结束后暂停整个程序，对栈上对象重新进行三色标记法。<br>
</p>

<blockquote>
<p>
如果 <verbatim>Goroutine</verbatim> 较多的话，对栈对象 <verbatim>re-scan</verbatim> 这一步需要耗费 <verbatim>10~100 ms</verbatim> 。<br>
</p>
</blockquote>

<p>
回顾一下之前提到的两种写屏障的劣势：<br>
</p>

<ul class="org-ul">
<li><verbatim>Dijkstra</verbatim> 插入写屏障：一轮标记结束后需要 <verbatim>STW</verbatim> 重新扫描栈上对象<br></li>
<li><verbatim>Yuasa</verbatim> 删除写屏障：回收精度低，在垃圾回收开始前使用 <verbatim>STW</verbatim> 扫描所有 <verbatim>GC Root</verbatim> 对象形成初始快照，用户程序 <verbatim>Mutator</verbatim> 从灰色/白色对象中删除白色指针时会将下游对象标记为灰色，相当于保护了所有初始快照中的白色对象不被删除<br></li>
</ul>
</div>
</div>
<div id="outline-container-org973cbeb" class="outline-4">
<h4 id="org973cbeb">6.2 混合写屏障的实现</h4>
<div class="outline-text-4" id="text-org973cbeb">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#28155;&#21152;&#19979;&#28216;&#23545;&#35937;&#30340;&#20989;&#25968;, &#24403;&#21069;&#19979;&#28216;&#23545;&#35937;slot, &#26032;&#19979;&#28216;&#23545;&#35937;ptr</span>
<span style="color: #ea3d54;">func</span> <span style="color: #fedd38;">HybridWritePointerSimple</span>(<span style="color: #cbccd1;">slot</span> *<span style="color: #ee7b29;">unsafe.Pointer</span>, <span style="color: #cbccd1;">ptr</span> <span style="color: #ee7b29;">unsafe.Pointer</span>) {
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">1) &#23558;&#34987;&#21024;&#38500;&#30340;&#19979;&#28216;&#23545;&#35937;&#26631;&#35760;&#20026;&#28784;&#33394;</span>
    <span style="color: #fedd38;">shade</span>(*slot)
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">2) &#23558;&#26032;&#19979;&#28216;&#23545;&#35937;&#26631;&#35760;&#20026;&#28784;&#33394;</span>
    <span style="color: #fedd38;">shade</span>(ptr)
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">3) &#24403;&#21069;&#19979;&#28216;&#23545;&#35937;slot = &#26032;&#19979;&#28216;&#23545;&#35937;ptr</span>
    *slot = ptr
}
</pre>
</div>

<blockquote>
<p>
注意：混合写屏障也是仅在堆空间启动的，防止降低栈空间的运行效率<br>
</p>
</blockquote>

<p>
混合写屏障逻辑如下：<br>
</p>

<ul class="org-ul">
<li><verbatim>GC</verbatim> 开始时将栈上所有对象标记为黑色，无须 <verbatim>STW</verbatim><br></li>
<li><verbatim>GC</verbatim> 期间在栈上创建的新对象均标记为黑色<br></li>
<li>将被删除的下游对象标记为灰色<br></li>
<li>将被添加的下游对象标记为灰色<br></li>
</ul>
</div>
</div>
<div id="outline-container-org5d9a6e4" class="outline-4">
<h4 id="org5d9a6e4">6.3 具体场景的实现</h4>
<div class="outline-text-4" id="text-org5d9a6e4">
<p>
<verbatim>GC</verbatim> 开始阶段会将所有栈空间可达对象都标记为黑色：<br>
</p>

<img src="./images/Go-GC-混合写屏障-开始阶段.png" />

<p>
场景一：某个对象从堆对象的下游变成栈对象的下游，这种情况下标记该对象为灰色，该对象就不会被错误地回收<br>
</p>

<img src="./images/Go-GC-混合写屏障-场景一.png" />

<p>
场景二：某个对象从一个栈对象的下游变成另一个对象的下游，由于对象全都在栈空间对象的可达对象中，因此混合写屏障不会对这些对象着色。<br>
</p>

<img src="./images/Go-GC-混合写屏障-场景二.png" />

<p>
场景三：某个对象从一个堆对象的下游变成另一个堆对象的下游，比如下图中对象 G 从 F 的下游移动到Y的下游，为了避免对象 G 被错误回收，我们需要将其标记为灰色<br>
</p>

<img src="./images/Go-GC-混合写屏障-场景三.png" />

<p>
场景四：某个对象从栈对象的下游变成堆对象的下游，对于栈空间对象不触发写屏障，但是对于被删除的堆空间对象 G 需要标记成灰色以保护它和它的下游对象不被错误删除<br>
</p>

<img src="./images/Go-GC-混合写屏障-场景四.png" />
</div>
</div>
</div>
</div>
<div id="outline-container-org609c7ed" class="outline-2">
<h2 id="org609c7ed">增量和并发式垃圾回收</h2>
<div class="outline-text-2" id="text-org609c7ed">
<img src="./images/Go-GC-STW垃圾回收过程.png" width="600px" />

<p>
前面提到传统的垃圾回收算法都有 <verbatim>STW</verbatim> 的弊端，即需要在执行垃圾回收过程中需要抢占 <verbatim>CPU</verbatim> ，这会暂停所有的用户程序。这有两个弊端：<br>
</p>

<ul class="org-ul">
<li>通常 <verbatim>GC</verbatim> 任务都比较繁重，长时间暂停用户程序会影响程序的响应速度，这对于实时性要求较高的程序是致命的缺点<br></li>
<li><p>
对于多核计算机而言，抢占 <verbatim>CPU</verbatim> 进行垃圾回收会造成计算资源浪费<br>
</p>

<blockquote>
<p>
三色标记法结合读写屏障技术使得垃圾回收器 <verbatim>Collector</verbatim> 避免了 <verbatim>STW</verbatim> ，因此后续提到的增量式垃圾回收和并发式垃圾回收都是基于三色标记法和读写屏障技术的。为了保证三色不变性，我们需要在垃圾回收前打开写屏障，在本轮垃圾回收过程中用户所有对内存的写操作都需要被写屏障拦截。<br>
</p>
</blockquote></li>
</ul>
</div>
<div id="outline-container-orgec7cee2" class="outline-3">
<h3 id="orgec7cee2">1. 增量式垃圾回收</h3>
<div class="outline-text-3" id="text-orgec7cee2">
<img src="./images/Go-GC-增量式垃圾回收过程.png" width="600px" />

<p>
增量式垃圾回收过程图如上所示，同 <verbatim>STW</verbatim> 垃圾回收过程相比：<br>
</p>

<ul class="org-ul">
<li>优势：将垃圾回收时间分摊开，避免了程序的长时间暂停，防止影响程序的实时性<br></li>
<li>劣势：一方面引入了内存写屏障技术，需要额外的计算开销；另一方面由于写屏障技术的保守性导致有一些垃圾对象没有被回收，会增加一轮垃圾回收的总时长<br></li>
</ul>
</div>
</div>
<div id="outline-container-org9fa773b" class="outline-3">
<h3 id="org9fa773b">2. 并发式垃圾回收</h3>
<div class="outline-text-3" id="text-org9fa773b">
<img src="./images/Go-GC-并发式垃圾回收过程.png" width="600px" />

<p>
并发式垃圾回收允许垃圾回收器 <verbatim>collector</verbatim> 和用户程序 <verbatim>mutator</verbatim> 同时执行，但仍然有一些阶段需要暂停用户程序。并发式的垃圾回收机制在一定程序上利用了多核计算机的优势并减少了对用户程序的干扰，不过依然无法摆脱读写屏障的额外计算开销和增加一轮垃圾回收总时长的问题。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org288a030" class="outline-2">
<h2 id="org288a030">Golang GC 如何扫描对象</h2>
<div class="outline-text-2" id="text-org288a030">
<p>
<verbatim>Golang</verbatim> 扫描对象可以分为三部分：<br>
</p>

<ul class="org-ul">
<li>编译阶段：对静态类型做好标记准备<br></li>
<li>运行阶段：赋值器分配内存时，根据编译阶段的 <verbatim>type</verbatim> 为对象内存对应的指针设置 <verbatim>bitmap</verbatim><br></li>
<li>扫描阶段：根据指针的 <verbatim>bitmap</verbatim> 进行扫描<br></li>
</ul>
</div>
<div id="outline-container-orgfa78f01" class="outline-3">
<h3 id="orgfa78f01">1. 编译阶段</h3>
<div class="outline-text-3" id="text-orgfa78f01">
</div>
<div id="outline-container-orgee3e246" class="outline-4">
<h4 id="orgee3e246">1.1 Golang 结构体对齐规则</h4>
<div class="outline-text-4" id="text-orgee3e246">
<p>
<verbatim>Golang</verbatim> 结构体对齐规则包括两部分：<br>
</p>

<ul class="org-ul">
<li>长度对齐<br></li>
<li>地址对齐<br></li>
</ul>
</div>
</div>
<div id="outline-container-org7c9bb87" class="outline-4">
<h4 id="org7c9bb87">1.2 长度对齐</h4>
<div class="outline-text-4" id="text-org7c9bb87">
<p>
长度对齐指的是结构体的长度至少是内部最长的基础字段的整数倍。比如下面这个结构体内存占用为16个字节，因为 <verbatim>TestStruct</verbatim> 整体要和内部最长的基础字段 <verbatim>ptr</verbatim> （8字节的 <verbatim>uintptr</verbatim> 类型）对齐。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #ea3d54;">type</span> <span style="color: #ee7b29;">TestStruct</span> <span style="color: #ea3d54;">struct</span> {
    ptr   <span style="color: #ee7b29;">uintptr</span>  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">8&#23383;&#33410;</span>
    int1  <span style="color: #ee7b29;">uint32</span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">4&#23383;&#33410;</span>
    int2  <span style="color: #ee7b29;">uint8</span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">1&#23383;&#33410;</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org8032049" class="outline-4">
<h4 id="org8032049">1.3 地址对齐</h4>
<div class="outline-text-4" id="text-org8032049">
<p>
字段的地址偏移是自身长度的整数倍，仍然以 <verbatim>TestStruct</verbatim> 为例，令第二个元素为1个字节大小：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20551;&#35774;new&#19968;&#20010;TestStruct&#32467;&#26500;&#20307;&#30340;&#22320;&#22336;&#26159;x, &#21017;&#21508;&#23383;&#27573;&#30340;&#22320;&#22336;&#22914;&#19979;</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">ptr: a + 0</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">int1: a + 8</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">int2: a + 8 + 4</span>
<span style="color: #ea3d54;">type</span> <span style="color: #ee7b29;">TestStruct</span> <span style="color: #ea3d54;">struct</span> {
    ptr   <span style="color: #ee7b29;">uintptr</span>  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">8&#23383;&#33410;</span>
    int1  <span style="color: #ee7b29;">uint8</span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">1&#23383;&#33410;</span>
    int2  <span style="color: #ee7b29;">uint32</span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">4&#23383;&#33410;</span>
}
</pre>
</div>

<p>
<verbatim>int1</verbatim> 和 <verbatim>int2</verbatim> 之间填充了一些没使用到的内存空间，进而实现了地址对齐。<br>
</p>
</div>
</div>
<div id="outline-container-org4692919" class="outline-4">
<h4 id="org4692919">1.4 指针位标记</h4>
<div class="outline-text-4" id="text-org4692919">
<p>
<verbatim>golang</verbatim> 的所有类型都对应一个 <verbatim>_type</verbatim> 结构：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">Needs to be in sync with ../cmd/link/internal/ld/decodesym.go:/^func.commonsize,</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">../cmd/compile/internal/gc/reflect.go:/^func.dcommontype and</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">../reflect/type.go:/^type.rtype.</span>
<span style="color: #ea3d54;">type</span> <span style="color: #ee7b29;">_type</span> <span style="color: #ea3d54;">struct</span> {
    size       <span style="color: #ee7b29;">uintptr</span>
    ptrdata    <span style="color: #ee7b29;">uintptr</span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">size of memory prefix holding all pointers</span>
    hash       <span style="color: #ee7b29;">uint32</span>
    tflag      <span style="color: #ee7b29;">tflag</span>
    align      <span style="color: #ee7b29;">uint8</span>
    fieldalign <span style="color: #ee7b29;">uint8</span>
    kind       <span style="color: #ee7b29;">uint8</span>
    alg        *<span style="color: #ee7b29;">typeAlg</span>
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">gcdata stores the GC type data for the garbage collector.</span>
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">If the KindGCProg bit is set in kind, gcdata is a GC program.</span>
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span>
    gcdata    *<span style="color: #ee7b29;">byte</span>
    str       <span style="color: #ee7b29;">nameOff</span>
    ptrToThis <span style="color: #ee7b29;">typeOff</span>
}
</pre>
</div>

<p>
比如说我们定义一个 <verbatim>struct</verbatim> 如下：<br>
</p>

<div class="org-src-container">
<pre class="src src-go">tStruct <span style="color: #ea3d54;">struct</span> {
    uintptr
    uint8
    *uint8
    uint32
    *uint64
    uint64

</pre>
</div>

<ul class="org-ul">
<li>size：类型长度，上面这个结构体的长度48个字节<br></li>
<li>ptrdata：指针截止的长度位置，由于最后一个指针是pint2，因此包含指针的字段截止到40字节的位置<br></li>
<li>kind：类型，自定义struct类型的kind为25<br></li>
<li>gcdata：byte数组（*byte类型），表示指针的bitmap。比如当gcdata等于20（二进制00010100，从低位到高位就是00101000，其中每个bit表示一个指针大小（8字节）的内存，第3个bit和第5个bit为1表示第三个和第五个字段是指针类型）。<br></li>
</ul>

<p>
第一个类型 <verbatim>uintptr</verbatim> 在指针的 <verbatim>bitmap</verbatim> 是不会标记成指针类型的，用这个存储指针是无法保护对象的（扫描的时候 <verbatim>uintptr</verbatim> 指向的对象不会被扫描）。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-orga44d7fd" class="outline-3">
<h3 id="orga44d7fd">2. 运行期内存分配</h3>
<div class="outline-text-3" id="text-orga44d7fd">
<p>
<verbatim>golang</verbatim> 在运行分配完内存后会调用函数 <verbatim>heapBitsSetType</verbatim> ，这个函数及其复杂，但是主要逻辑是根据编译期间对每个 <verbatim>struct</verbatim> 生成的 <verbatim>type</verbatim> 结构，用一个 <verbatim>bitmap</verbatim> 记录下来分配的内存块中哪些位置是指针。<br>
</p>
</div>
</div>
<div id="outline-container-org807cebc" class="outline-3">
<h3 id="org807cebc">3. 运行扫描阶段</h3>
<div class="outline-text-3" id="text-org807cebc">
<ul class="org-ul">
<li>扫描阶段从 <verbatim>markroot</verbatim> 开始，以栈对象、全局变量和寄存器对象作为 <verbatim>gc root</verbatim> ，创建一个有向引用图并将根对象添加到队列中<br></li>
<li>新起一个异步 <verbatim>goroutine</verbatim> 执行 <verbatim>gcDrain</verbatim> 函数，从队列里消费并扫描对象<br></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org639c780" class="outline-2">
<h2 id="org639c780">Golang GC</h2>
<div class="outline-text-2" id="text-org639c780">
</div>
<div id="outline-container-org2f5f6a2" class="outline-3">
<h3 id="org2f5f6a2">1. Golang GC 发展历史</h3>
<div class="outline-text-3" id="text-org2f5f6a2">
<p>
<verbatim>Golang</verbatim> 每次改版几乎都伴随着垃圾回收机制的改进，其中里程碑式的改动主要包括：<br>
</p>

<blockquote>
<p>
注意： <verbatim>gc pause</verbatim> 时间的缩短也就意味着程序的响应速度更快<br>
</p>
</blockquote>

<ul class="org-ul">
<li>go v1.1：标记-清除法，整个过程都需要 <verbatim>STW</verbatim><br></li>
<li>go v1.3：标记-清除法，标记过程仍然需要 <verbatim>STW</verbatim> 但清除过程并行化， <verbatim>gc pause</verbatim> 约几百ms<br></li>
<li>go v1.5：引入插入写屏障技术的三色标记法，仅在堆空间启动插入写屏障，全部扫描后需要 <verbatim>STW</verbatim> 重新扫描栈空间， <verbatim>gc pause</verbatim> 耗时降到 <verbatim>10ms</verbatim> 以下<br></li>
<li>go v1.8：引入混合写屏障技术的三色标记法，仅在堆空间启动混合写屏障，不需要在 <verbatim>GC</verbatim> 结束后对栈空间重新扫描， <verbatim>gc pause</verbatim> 时间降低至 <verbatim>0.5ms</verbatim> 以下<br></li>
<li>go v1.14：引入新的页分配器用于优化内存分配的速度<br></li>
</ul>
</div>
</div>
<div id="outline-container-org30ed243" class="outline-3">
<h3 id="org30ed243">2. 回顾 Golang 内存管理内容</h3>
<div class="outline-text-3" id="text-org30ed243">
<p>
每一个 <verbatim>Go</verbatim> 程序在启动时都会向操作系统申请一块内存（仅仅是虚拟的地址空间，并不会真正分配内存），在 <verbatim>x64</verbatim> 上申请的内存会被分成 512M、16G 和 512G 的三块空间，分别对应 <verbatim>spans</verbatim> 、 <verbatim>bitmap</verbatim> 和 <verbatim>arena</verbatim> 。<br>
</p>

<img src="./images/Go-GC-内存管理01.png" />

<ul class="org-ul">
<li>arena：堆区，运行时该区域每 <verbatim>8KB</verbatim> 会被划分成一个页，存储了所有在堆上初始化的对象<br></li>
<li><p>
bitmap：标识 <verbatim>arena</verbatim> 中哪些地址保存了对象， <verbatim>bitmap</verbatim> 中一个字节的内存对应 <verbatim>arena</verbatim> 区域中4个指针大小的内存，并标记了是否包含指针和是否扫描的信息（一个指针大小为 <verbatim>8B</verbatim> ，因此 <verbatim>bitmap</verbatim> 的大小为 512GB/(4*8)=16GB）<br>
</p>

<img src="./images/Go-GC-内存管理02.png" /></li>

<li><p>
spans：存放 <verbatim>mspan</verbatim> 的指针，其中每个 <verbatim>mspan</verbatim> 会包含多个页， <verbatim>spans</verbatim> 中一个指针（8B）表示 <verbatim>arena</verbatim> 中某一个 <verbatim>page</verbatim> （8KB），因此 <verbatim>spans</verbatim> 的大小为 512GB/(1024)=512MB<br>
</p>

<img src="./images/Go-GC-内存管理03.png" /></li>
</ul>
</div>
</div>
<div id="outline-container-orgfa35762" class="outline-3">
<h3 id="orgfa35762">3. Golang GC 实现</h3>
<div class="outline-text-3" id="text-orgfa35762">
<p>
<verbatim>go v1.5</verbatim> 至今使用的都是无无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的基于三色标记法实现的垃圾回收机制，原因在于：<br>
</p>

<ul class="org-ul">
<li>对象整理的优势是解决内存碎片问题以及“允许”使用顺序内存分配器。但 Go 运行时的分配算法基于 <verbatim>tcmalloc</verbatim> ，基本上没有碎片问题。 并且顺序内存分配器在多线程的场景下并不适用。Go 使用的是基于 <verbatim>tcmalloc</verbatim> 的现代内存分配算法，对对象进行整理不会带来实质性的性能提升。<br></li>
<li>分代 GC 依赖分代假设，即 GC 将主要的回收目标放在新创建的对象上（存活时间短，更倾向于被回收），而非频繁检查所有对象。<br></li>
<li>Go 的编译器会通过逃逸分析将大部分新生对象存储在栈上（栈直接被回收），只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。也就是说，分代 GC 回收的那些存活时间短的对象在 Go 中是直接被分配到栈上，当 <verbatim>goroutine</verbatim> 死亡后栈也会被直接回收，不需要 GC 的参与，进而分代假设并没有带来直接优势。<br></li>
<li>Go 的垃圾回收器与用户代码并发执行，使得 <verbatim>STW</verbatim> 的时间与对象的代际、对象的 size 没有关系。Go 团队更关注于如何更好地让 GC 与用户代码并发执行（使用适当的 CPU 来执行垃圾回收），而非减少停顿时间这一单一目标上。<br></li>
</ul>

<p>
<verbatim>Golang</verbatim> 将垃圾回收阶段分成三个状态：<br>
</p>

<ul class="org-ul">
<li><verbatim>GC</verbatim> 开始前将所有对象标记为白色<br></li>
<li>将 <verbatim>GC Root</verbatim> 对象（ <verbatim>golang</verbatim> 中是 <b>栈对象</b> 和 <b>全局变量</b> 的指针）加入灰色对象队列<br></li>
<li>使用并发的 <verbatim>goroutine</verbatim> 扫描队列中的指针，如果指针还引用了其他指针，那么将被引用的加入灰色对象队列，被扫描的对象标记为黑色<br></li>
</ul>

<p>
为了缩短 <verbatim>STW</verbatim> 时间，还添加了 <b>写屏障（Write Barrier）</b> 和 <b>辅助GC（Mutator Assist）</b> 两种优化垃圾回收的方法。<br>
</p>

<ul class="org-ul">
<li><b>写屏障（Write Barrier）</b> ：上面说到的 STW 的目的是防止 GC 扫描时内存变化引起的混乱，而写屏障就是让 goroutine 与 GC 同时运行的手段，虽然不能完全消除 STW，但是可以大大减少 STW 的时间。写屏障在 GC 的特定时间开启，开启后指针传递时会把指针标记，即本轮不回收，下次 GC 时再确定。<br></li>
<li><b>辅助 GC（Mutator Assist）</b> ：为了防止内存分配过快，在 GC 执行过程中，GC 过程中 mutator 线程会并发运行，而 mutator assist 机制会协助 GC 做一部分的工作。<br></li>
</ul>
</div>
<div id="outline-container-org6e5722c" class="outline-4">
<h4 id="org6e5722c">3.1 GC 过程（四个阶段）</h4>
<div class="outline-text-4" id="text-org6e5722c">
<p>
前面提到 <verbatim>Golang</verbatim> 的 <verbatim>GC</verbatim> 属于并发式垃圾回收（意味着不需要长时间的 <verbatim>STW</verbatim> ， <verbatim>GC</verbatim> 大部分执行过程是和用户代码并行的），它可以分为四个阶段：<br>
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">阶段</th>
<th scope="col" class="org-left">说明</th>
<th scope="col" class="org-left">赋值器状态</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">SweepTermination</td>
<td class="org-left">清扫终止阶段，为下一阶段的并发标记做准备工作，启动写屏障</td>
<td class="org-left">STW</td>
</tr>

<tr>
<td class="org-left">Mark</td>
<td class="org-left">扫描标记阶段，与赋值器并发执行，写屏障开启</td>
<td class="org-left">并发</td>
</tr>

<tr>
<td class="org-left">MarkTermination</td>
<td class="org-left">标记终止阶段，保证一个周期内标记任务完成，停止写屏障</td>
<td class="org-left">STW</td>
</tr>

<tr>
<td class="org-left">GCoff</td>
<td class="org-left">内存清扫阶段，将需要回收的内存归还到堆中，写屏障关闭</td>
<td class="org-left">并发</td>
</tr>

<tr>
<td class="org-left">GCoff</td>
<td class="org-left">内存归还阶段，将需要回收的内存归还给操作系统，写屏障关闭</td>
<td class="org-left">并发</td>
</tr>
</tbody>
</table>
</div>
<div id="outline-container-org26e7966" class="outline-5">
<h5 id="org26e7966">3.1.1 清除终止</h5>
<div class="outline-text-5" id="text-org26e7966">
<p>
<verbatim>Sweep Termination</verbatim><br>
</p>

<ul class="org-ul">
<li><p>
暂停程序，停止每个 <verbatim>goroutine</verbatim> ，让垃圾收集器观察并等待每个 <verbatim>goroutine</verbatim> 进行函数调用，等待函数调用是为了保证 <verbatim>goroutine</verbatim> 停止时处于安全点<br>
</p>

<p>
下面的代码中，由于 <code>for{}</code> 循环所在的 <verbatim>goroutine</verbatim> 永远不会中断，导致始终无法进入 <verbatim>STW</verbatim> 阶段，资源浪费；Go 1.14 之后，此类 <verbatim>goroutine</verbatim> 能被异步抢占，使得进入 <verbatim>STW</verbatim> 的时间不会超过抢占信号触发的周期，程序也不会因为仅仅等待一个 <verbatim>goroutine</verbatim> 的停止而停顿在进入 <verbatim>STW</verbatim> 之前的操作上。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #ea3d54;">func</span> <span style="color: #fedd38;">main</span>() {
    <span style="color: #ea3d54;">go</span> <span style="color: #ea3d54;">func</span>() {
        <span style="color: #ea3d54;">for</span> {
        }
    }()
    time.<span style="color: #fedd38;">Sleep</span>(time.Milliecond)
    runtime.<span style="color: #fedd38;">GC</span>()
    <span style="color: #fedd38;">println</span>(<span style="color: #4fb3d8;">"done"</span>)
}
</pre>
</div></li>

<li>清扫未被回收的内存管理单元 <verbatim>span</verbatim> ，当上一轮 <verbatim>GC</verbatim> 的清扫工作完成后才可以开始新一轮的 <verbatim>GC</verbatim><br></li>
</ul>
</div>
</div>
<div id="outline-container-org4f8e611" class="outline-5">
<h5 id="org4f8e611">3.1.2 标记</h5>
<div class="outline-text-5" id="text-org4f8e611">
<p>
<verbatim>Mark</verbatim><br>
</p>

<ul class="org-ul">
<li>切换至 <verbatim>_GCmark</verbatim> ，开启写屏障和用户程序协助 <verbatim>Mutator Assiste</verbatim> ，并将根对象添加到三色标记法队列<br>
<ul class="org-ul">
<li>一旦写屏障打开，垃圾收集器就开始标记阶段，垃圾收集器所做的第一件事是占用 <verbatim>25%CPU</verbatim><br></li>
</ul></li>
<li>恢复程序，标记进程和 <verbatim>Mutator Assiste</verbatim> 进程会开始并发标记内存中的对象，混合写屏障将被删除的指针和新加入的指针都标记成灰色，新创建的对象标记成黑色<br>
<ul class="org-ul">
<li>当存在新的内存分配时，会暂停分配内存过快的那些 <verbatim>goroutine</verbatim> ，并将其转去执行一些辅助标记（Mark Assist）的工作，从而达到放缓继续分配、辅助 GC 的标记工作的目的<br></li>
</ul></li>
<li>扫描根对象（包括所有 <verbatim>goroutine</verbatim> 的栈、全局对象以及不在堆中的运行时数据结构），扫描 <verbatim>goroutine</verbatim> 栈期间会暂停当前处理器<br></li>
<li>依次处理三色标记法队列，将扫描过的对象标记为黑色并将它们指向的对象标记成灰色<br></li>
<li>使用分布式终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段<br></li>
</ul>
</div>
</div>
<div id="outline-container-org9bcb0ec" class="outline-5">
<h5 id="org9bcb0ec">3.1.3 标记终止</h5>
<div class="outline-text-5" id="text-org9bcb0ec">
<p>
<verbatim>Mark Termination</verbatim><br>
</p>

<ul class="org-ul">
<li>暂停程序，切换至 <verbatim>_GCmarktermination</verbatim> 并关闭辅助标记的用户程序<br></li>
<li>清理处理器上的线程缓存<br></li>
</ul>
</div>
</div>
<div id="outline-container-orgfd237d2" class="outline-5">
<h5 id="orgfd237d2">3.1.4 清除</h5>
<div class="outline-text-5" id="text-orgfd237d2">
<p>
<verbatim>Sweep</verbatim><br>
</p>

<ul class="org-ul">
<li>将状态切换至 <verbatim>_GCoff</verbatim> ，关闭混合写屏障<br></li>
<li>恢复用户程序，所有新创建的对象标记为白色<br></li>
<li>后台并发清理所有的内存管理单元 <verbatim>span</verbatim> ，当 <verbatim>goroutine</verbatim> 申请新的内存管理单元时就会触发清理，清理导致的延迟和吞吐量降低被分散到每次内存分配时<br></li>
</ul>

<p>
清除阶段出现新对象：清除阶段是扫描整个堆内存，可以知道当前清除到什么位置，创建的新对象判定下，如果新对象的指针位置已经被扫描过了，那么就不用作任何操作，不会被误清除，如果在当前扫描的位置的后面，把该对象的颜色标记为黑色，这样就不会被误清除了<br>
</p>

<blockquote>
<p>
在 GC 过程中会有两种后台任务（G），包括标记任务和清扫任务。可以同时执行的标记任务约是 P 数量的四分之一，即 go 所说的 25%CPU 用于 GC 的依据。清扫任务会在程序启动后运行，进入清扫阶段时唤醒。<br>
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-orgf5507b0" class="outline-4">
<h4 id="orgf5507b0">3.2 辅助 GC</h4>
<div class="outline-text-4" id="text-orgf5507b0">
<p>
由于 Golang 使用了并发式的垃圾回收，将原本需要 <verbatim>STW</verbatim> 较长时间的 GC 过程分散到多次小规模的 GC。当用户分配内存的速度超过 GC 回收速度时，Golang 会通过辅助 GC 暂停用户程序进行垃圾回收，防止内存因分配对象速度过快消耗殆尽的问题。<br>
</p>
</div>
</div>
<div id="outline-container-orge1cb668" class="outline-4">
<h4 id="orge1cb668">3.3 GC 触发时机</h4>
<div class="outline-text-4" id="text-orge1cb668">
<p>
触发垃圾回收首先要满足三个前提条件：<br>
</p>

<ul class="org-ul">
<li>memstats.enablegc：允许垃圾回收<br></li>
<li>panicking == 0：程序没有 panic<br></li>
<li>gcphase == _GCoff：处于 _Gcoff 阶段<br></li>
</ul>

<p>
对应的触发时机包括：<br>
</p>

<ul class="org-ul">
<li>gcTriggerHeap：*内存分配量达到阙值* ，每次内存分配都会检查当前内存分配量是否达到阈值，如果达到阈值则触发 GC。 <verbatim>阈值 = 上次 GC 内存分配量 * 内存增长率</verbatim> ，内存增长率由环境变量 <verbatim>GOGC</verbatim> 控制，默认为 100，即每当内存扩大一倍时启动 GC。<br></li>
<li>gcTriggerTime：*定时触发GC* ，默认情况下，2分钟触发一次 GC，该间隔由 <verbatim>src/runtime/proc.go</verbatim> 中的 <code>forcegcperiod</code> 声明。<br></li>
<li>gcTriggerCycle：如果当前没有启动 GC 则开始新一轮的 GC<br></li>
<li><b>手动触发GC</b> ：在代码中，可通过使用 <code>runtime.GC()</code> 手动触发 GC<br></li>
</ul>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">test reports whether the trigger condition is satisfied, meaning</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">that the exit condition for the _GCoff phase has been met. The exit</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">condition should be tested when allocating.</span>
<span style="color: #ea3d54;">func</span> (<span style="color: #cbccd1;">t</span> <span style="color: #ee7b29;">gcTrigger</span>) <span style="color: #fedd38;">test</span>() <span style="color: #ee7b29;">bool</span> {
    <span style="color: #ea3d54;">if</span> <span style="color: #78bd65; font-weight: bold;">!</span>memstats.enablegc || panicking != 0 || gcphase != _GCoff {
        <span style="color: #ea3d54;">return</span> <span style="color: #ee7b29;">false</span>
    }
    <span style="color: #ea3d54;">switch</span> t.kind {
    <span style="color: #ea3d54;">case</span> gcTriggerHeap:
        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Non-atomic access to heap_live for performance. If</span>
        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">we are going to trigger on this, this thread just</span>
        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">atomically wrote heap_live anyway and we'll see our</span>
        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">own write.</span>
        <span style="color: #ea3d54;">return</span> memstats.heap_live &gt;= memstats.gc_trigger
    <span style="color: #ea3d54;">case</span> gcTriggerTime:
        <span style="color: #ea3d54;">if</span> gcpercent &lt; 0 {
            <span style="color: #ea3d54;">return</span> <span style="color: #ee7b29;">false</span>
        }
        <span style="color: #cbccd1;">lastgc</span> := <span style="color: #fedd38;">int64</span>(atomic.<span style="color: #fedd38;">Load64</span>(&amp;memstats.last_gc_nanotime))
        <span style="color: #ea3d54;">return</span> lastgc != 0 &amp;&amp; t.now-lastgc &gt; forcegcperiod
    <span style="color: #ea3d54;">case</span> gcTriggerCycle:
        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">t.n &gt; work.cycles, but accounting for wraparound.</span>
        <span style="color: #ea3d54;">return</span> <span style="color: #fedd38;">int32</span>(t.n-work.cycles) &gt; 0
    }
    <span style="color: #ea3d54;">return</span> <span style="color: #ee7b29;">true</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orga0b7663" class="outline-4">
<h4 id="orga0b7663">3.4 GC 百分比</h4>
<div class="outline-text-4" id="text-orga0b7663">
<p>
运行时中有GC 百分比的配置选项，默认情况下为100。此值表示在下一次垃圾收集必须启动之前可以分配多少新内存的比率。将GC百分比设置为100意味着：基于在垃圾收集完成后标记为活动的堆内存量，下次垃圾收集前，堆内存使用可以增加100%。<br>
</p>
</div>
</div>
<div id="outline-container-org32af4c1" class="outline-4">
<h4 id="org32af4c1">3.5 GC 过程演示</h4>
<div class="outline-text-4" id="text-org32af4c1">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #ea3d54;">package</span> main

<span style="color: #ea3d54;">import</span> (
    <span style="color: #4fb3d8;">"os"</span>
    <span style="color: #4fb3d8;">"runtime"</span>
    <span style="color: #4fb3d8;">"runtime/trace"</span>
)

<span style="color: #ea3d54;">func</span> <span style="color: #fedd38;">gcfinished</span>() *<span style="color: #ee7b29;">int</span> {
    <span style="color: #cbccd1;">p</span> := 1
    runtime.<span style="color: #fedd38;">SetFinalizer</span>(&amp;p, <span style="color: #ea3d54;">func</span>(<span style="color: #cbccd1;">_</span> *<span style="color: #ee7b29;">int</span>) {
        <span style="color: #fedd38;">println</span>(<span style="color: #4fb3d8;">"gc finished"</span>)
    })
    <span style="color: #ea3d54;">return</span> &amp;p
}
<span style="color: #ea3d54;">func</span> <span style="color: #fedd38;">allocate</span>() {
    _ = <span style="color: #fedd38;">make</span>([]<span style="color: #ee7b29;">byte</span>, <span style="color: #fedd38;">int</span>((1&lt;&lt;20)*0.25))
}
<span style="color: #ea3d54;">func</span> <span style="color: #fedd38;">main</span>() {
    <span style="color: #cbccd1;">f</span>, <span style="color: #cbccd1;">_</span> := os.<span style="color: #fedd38;">Create</span>(<span style="color: #4fb3d8;">"trace.out"</span>)
    <span style="color: #ea3d54;">defer</span> f.<span style="color: #fedd38;">Close</span>()
    trace.<span style="color: #fedd38;">Start</span>(f)
    <span style="color: #ea3d54;">defer</span> trace.<span style="color: #fedd38;">Stop</span>()
    <span style="color: #fedd38;">gcfinished</span>()
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#24403;&#23436;&#25104; GC &#26102;&#20572;&#27490;&#20998;&#37197;</span>
    <span style="color: #ea3d54;">for</span> <span style="color: #cbccd1;">n</span> := 1; n &lt; 50; n++ {
        <span style="color: #fedd38;">println</span>(<span style="color: #4fb3d8;">"#allocate: "</span>, n)
        <span style="color: #fedd38;">allocate</span>()
    }
    <span style="color: #fedd38;">println</span>(<span style="color: #4fb3d8;">"terminate"</span>)
}
</pre>
</div>

<p>
运行程序：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">&gt; $ <span style="color: #cbccd1;">GODEBUG</span>=<span style="color: #cbccd1;">gctrace</span>=1 go run main.go
gc 1 @0.005s 3%: 0.023+0.87+0.059 ms clock, 0.19+0.80/0.42/0+0.47 ms cpu, 4-&gt;4-&gt;0 MB, 5 MB goal, 8 P
</pre>
</div>

<p>
栈分析：<br>
</p>

<pre class="example" id="org4634878">
gc 1      : 第一个GC周期
@0.005s   : 从程序开始运行到第一次GC时间为0.001 秒
5%        : 此次GC过程中CPU 占用率

wall clock
0.023+0.87+0.059 ms clock
0.023 ms  : STW，Marking Start, 开启写屏障
0.87 ms   : Marking阶段
0.059 ms  : STW，Marking终止，关闭写屏障

CPU time
0.19+0.80/0.42/0+0.47 ms cpu
0.19 ms   : STW，Marking Start
0.80 ms  : 辅助标记时间
0.42 ms  : 并发标记时间
0 ms   : GC 空闲时间
0.47 ms   : Mark 终止时间

4-&gt;4-&gt;0 MB， 5 MB goal
4 MB      ：标记开始时，堆大小实际值
4 MB      ：标记结束时，堆大小实际值
0 MB      ：标记结束时，标记为存活对象大小
5 MB      ：标记结束时，堆大小预测值

8 P
8P       ：本次GC过程中使用的goroutine 数量
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd2ed4e4" class="outline-3">
<h3 id="orgd2ed4e4">6. GC 调优方法</h3>
<div class="outline-text-3" id="text-orgd2ed4e4">
<ul class="org-ul">
<li>GC 性能是与对象数量有关的，对象越多 GC 性能越差，对程序的影响也越大，所以在开发中尽量减少对对象分配个数，采用对象复用、将小对象组合成大对象等<br></li>
<li>尽量使用小数据类型，比如使用 <code>int8</code> 代替 <code>int</code> 。<br></li>
<li>避免 <code>string</code> 与 <code>[]byte</code> 转化，两者发生转化的时候，底层数据结构会进行复制，因此导致 GC 效率变低<br></li>
<li>少使用 <code>+</code> 连接 <code>string</code> ：go 语言中 <code>string</code> 是一个只读类型，针对 <code>string</code> 的每一个操作都会创建一个新的 <code>string</code> 。大量小文本拼接时优先使用 <code>strings.Join</code> ，大量大文本拼接时使用 <code>bytes.Buffer</code> 。<br></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org49d78b4" class="outline-2">
<h2 id="org49d78b4">Reference</h2>
<div class="outline-text-2" id="text-org49d78b4">
<p>
[1] <a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/hezhixiong/p/9577199.html">cnblogs.com/hezhixiong/&#x2026;</a><br>
[2] <a href="https://juejin.im/post/5e157b73e51d4541111e9d58">juejin.im/post/5e157b73&#x2026;</a><br>
[3] <a href="https://www.jianshu.com/p/fce70c407dce">jianshu.com/p/fce70c407&#x2026;</a><br>
[4] <a href="https://www.cnblogs.com/aademeng/articles/11028623.html">cnblogs.com/aademeng/ar&#x2026;</a><br>
[5] <a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/v">draveness.me/golang/doc&#x2026;</a><br>
[6] <a href="https://blog.csdn.net/qq_40585834/article/details/81583246">blog.csdn.net/qq_405858&#x2026;</a><br>
[7] <a href="https://www.bookstack.cn/read/qcrao-Go-Questions/spilt.9.GC-GC.md">bookstack.cn/read/qcrao&#x2026;</a><br>
[8] <a href="https://www.jianshu.com/p/776f4910a0c0">jianshu.com/p/776f4910a&#x2026;</a><br>
[9] <a href="https://www.jianshu.com/p/4c5a303af470">jianshu.com/p/4c5a303af&#x2026;</a><br>
[10] <a href="https://www.cnblogs.com/sqmax/p/9045394.html">cnblogs.com/sqmax/p/904&#x2026;</a><br>
[11] <a href="http://legendtkl.com/2017/04/28/golang-gc/">legendtkl.com/2017/04/2&#x2026;</a><br>
[12] <a href="https://zhuanlan.zhihu.com/p/92210761">zhuanlan.zhihu.com/p/92&#x2026;</a><br>
[13] <a href="https://www.cnblogs.com/xumaojun/p/8547439.html">cnblogs.com/xumaojun/p/&#x2026;</a><br>
[14] <a href="https://liqingqiya.github.io/golang/gc/%E6%89%AB%E6%8F%8F%E5%AF%B9%E8%B1%A1/2020/07/30/gc-scan-object.html">liqingqiya.github.io/go&#x2026;</a><br>
[15] <a href="https://www.oschina.net/translate/d">oschina.net/translate/d&#x2026;</a><br>
</p>

<div class="reference">
    <ul style="list-style: none;">
        <li><a href="https://zhuanlan.zhihu.com/p/297177002" target="_blank">图示 Golang 垃圾回收机制</a></li>
        <li><a href="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/" target="_blank">Golang 垃圾回收（GC）介绍</a></li>
    </ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-05-04 14:05 Wed</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-09-27</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
