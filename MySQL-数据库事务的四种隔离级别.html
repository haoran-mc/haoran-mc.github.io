<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-05-07 Sat 22:12 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>MySQL 数据库事务的四种隔离级别</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">MySQL 数据库事务的四种隔离级别</h1>
<p>
数据库定义了四种隔离级别：<br>
</p>

<ul class="org-ul">
<li>Read Uncommitted（未提交读）<br></li>
<li>Read Committed（提交读）<br></li>
<li>Repeatable Read（重复读）<br></li>
<li>Serializable（串行化）<br></li>
</ul>

<p>
这四种隔离依次升高，隔离级别越低，系统开销越小，并发支持性更高。<br>
</p>

<p>
使用命令 <code>show variables like '%isolation%';</code> 可以查看当前数据库使用的隔离级别<br>
</p>

<p>
在介绍四种隔离级别前先说明三种在使用事务时会出现的特殊(大部分情况会导致错误)读类型。<br>
</p>

<ul class="org-ul">
<li>脏读<br>
脏读是指一个事务a修改或添加了一条数据，在a事务提交之前，另一个事务b读到了这条数据，并进行了操作。a如果回滚的话，脏读可能会导致b操作不存在的数据。<br></li>
<li>不可重复读<br>
在一次事务中的两次相同条件的查询不一致，比如a事务执行select count(*) from user where name='alex' 这时事务b插入了一条数据name=alex并提交这就会导致事务a第二次查询的时候多了一个计数<br></li>
<li>幻读<br>
幻读与不可重复读相反，事务a与事务b是完全隔离的，事务a执行'select id from user得到的id为1和2.这个时候b事务在user表中添加了一条数据id=3并提交,然后事务a想添加一条id为3的数据，如果id是唯一的，那a就会发现插不进去并提示dumplicate entry 3 for key id，原因是事务a阻止事务b的插入行为。<br></li>
</ul>

<p>
注意不要混淆不可重复读和幻读<br>
</p>

<ul class="org-ul">
<li>Read Uncommited<br>
<ul class="org-ul">
<li>在RU模式下，即使事务没有commit,在其他事务中仍可以读到未提交的数据。<br></li>
<li>RU是所有隔离级别中最低的一种。RU模式会导致脏读<br></li>
</ul></li>
<li>Read Commited<br>
<ul class="org-ul">
<li>RC模式下，事务只能读取到已经commit的数据。<br></li>
<li>比如事务a在执行时，如果事务b没有提交,a是读不到b的数据的。如果b提交a便能读到b修改的数据。<br></li>
<li>RC可以避免脏读，但是会导致不可重复读。<br></li>
<li>大部分系统使用的是RC模式<br></li>
</ul></li>
<li>Repeatable<br>
<ul class="org-ul">
<li>RR模式下，事务的多次Read不会受其他事务的影响（无论提交与否）<br></li>
<li>可以理解为RR模式下事务a在创建的时候获取了一次当前时刻数据的快照，快照不受其余事务的影响。<br></li>
<li>RR模式可能会导致幻读，因为无法感知其余事务，可能导致重复的插入。<br></li>
<li>mysql innoDB的RR模式可以一定程度避免幻读，该特性是通过间隙锁（gap lock)来实现的,间隙锁的原理可以参照这篇文章<a href="http://www.jianshu.com/p/bf86">http://www.jianshu.com/p/bf86</a>&#x2026;<br></li>
</ul></li>
<li>Serializable<br>
<ul class="org-ul">
<li>串行化，顾名思义，是将所有读写操作完全串行。<br></li>
<li>串行化是所有隔离级别中最高的<br></li>
<li>每次读都需要获得表级共享锁，读写相互都会阻塞<br></li>
<li>串行化对资源的开销大，对并发支持不好，只在，某些场景下使用。<br></li>
</ul></li>
</ul>

<p>
最后给出四个隔离级别对三种读类型的对照表：<br>
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">隔离级别</th>
<th scope="col" class="org-left">脏读</th>
<th scope="col" class="org-left">不可重复读</th>
<th scope="col" class="org-left">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Read Uncommited</td>
<td class="org-left">可能</td>
<td class="org-left">可能</td>
<td class="org-left">可能</td>
</tr>

<tr>
<td class="org-left">Read Commited</td>
<td class="org-left">不可能</td>
<td class="org-left">可能</td>
<td class="org-left">可能</td>
</tr>

<tr>
<td class="org-left">Repeatable Read</td>
<td class="org-left">不可能</td>
<td class="org-left">不可能</td>
<td class="org-left">可能</td>
</tr>

<tr>
<td class="org-left">Serializable</td>
<td class="org-left">不可能</td>
<td class="org-left">不可能</td>
<td class="org-left">不可能</td>
</tr>
</tbody>
</table>

<div class="reference">
	<ul style="list-style: none;">
		<li><a href="https://segmentfault.com/a/1190000012529474" target="_blank">数据库事务的四种隔离级别</a></li>
	</ul>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-05-07 22:05 Sat</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-05-07 Sat 22:12</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
