<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-12-25 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>HTML模板</title>
<meta name="author" content="L.M.haoran" />
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved." />
<meta name="generator" content="Org Mode" />
<link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
           <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
           <script type="module" src="static/js/main.js" defer></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">HTML模板</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org8437286">服务端渲染</a></li>
<li><a href="#orgd06bd84">静态文件（Serve Static Files）</a></li>
<li><a href="#orgc858cff">HTML 模版渲染</a></li>
<li><a href="#orgf2e8ee5">使用 Demo</a></li>
</ul>
</div>
</div>

<div id="outline-container-org8437286" class="outline-2">
<h2 id="org8437286">服务端渲染</h2>
<div class="outline-text-2" id="text-org8437286">
<p>
现在越来越流行前后端分离的开发模式，即 Web 后端提供 RESTful 接口，返回结构化的数据(通常为 JSON 或者 XML)。前端使用 AJAX 技术请求到所需的数据，利用 JavaScript 进行渲染。Vue/React 等前端框架持续火热，这种开发模式前后端解耦，优势非常突出。后端童鞋专心解决资源利用，并发，数据库等问题，只需要考虑数据如何生成；前端童鞋专注于界面设计实现，只需要考虑拿到数据后如何渲染即可。使用 JSP 写过网站的童鞋，应该能感受到前后端耦合的痛苦。JSP 的表现力肯定是远不如 Vue/React 等专业做前端渲染的框架的。而且前后端分离在当前还有另外一个不可忽视的优势。因为后端只关注于数据，接口返回值是结构化的，与前端解耦。同一套后端服务能够同时支撑小程序、移动APP、PC端 Web 页面，以及对外提供的接口。随着前端工程化的不断地发展，Webpack，gulp 等工具层出不穷，前端技术越来越自成体系了。<br>
</p>

<p>
但前后分离的一大问题在于，页面是在客户端渲染的，比如浏览器，这对于爬虫并不友好。Google 爬虫已经能够爬取渲染后的网页，但是短期内爬取服务端直接渲染的 HTML 页面仍是主流。<br>
</p>

<p>
今天的内容便是介绍 Web 框架如何支持服务端渲染的场景。<br>
</p>
</div>
</div>
<div id="outline-container-orgd06bd84" class="outline-2">
<h2 id="orgd06bd84">静态文件（Serve Static Files）</h2>
<div class="outline-text-2" id="text-orgd06bd84">
<p>
网页的三剑客，JavaScript、CSS 和 HTML。要做到服务端渲染，第一步便是要支持 JS、CSS 等静态文件。还记得我们之前设计动态路由的时候，支持通配符*匹配多级子路径。比如路由规则 <code>/assets/*filepath</code> ，可以匹配 <code>/assets/</code> 开头的所有的地址。例如 <code>/assets/js/geektutu.js</code> ，匹配后，参数 <code>filepath</code> 就赋值为 <code>js/geektutu.js</code> 。<br>
</p>

<p>
那如果我么将所有的静态文件放在 <code>/usr/web</code> 目录下，那么 <code>filepath</code> 的值即是该目录下文件的相对地址。映射到真实的文件后，将文件返回，静态服务器就实现了。<br>
</p>

<p>
找到文件后，如何返回这一步， <code>net/http</code> 库已经实现了。因此，gee 框架要做的，仅仅是解析请求的地址，映射到服务器上文件的真实地址，交给 <code>http.FileServer</code> 处理就好了。<br>
</p>

<blockquote>
<p>
gee/gee.go<br>
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">create static handler</span>
<span style="color: #e45649;">func</span> (<span style="color: #6a1868;">group</span> *<span style="color: #986801;">RouterGroup</span>) <span style="color: #a626a4;">createStaticHandler</span>(<span style="color: #6a1868;">relativePath</span> <span style="color: #986801;">string</span>, <span style="color: #6a1868;">fs</span> <span style="color: #986801;">http.FileSystem</span>) <span style="color: #986801;">HandlerFunc</span> {
    <span style="color: #6a1868;">absolutePath</span> := path.<span style="color: #a626a4;">Join</span>(group.prefix, relativePath)
    <span style="color: #6a1868;">fileServer</span> := http.<span style="color: #a626a4;">StripPrefix</span>(absolutePath, http.<span style="color: #a626a4;">FileServer</span>(fs))
    <span style="color: #e45649;">return</span> <span style="color: #e45649;">func</span>(<span style="color: #6a1868;">c</span> *<span style="color: #986801;">Context</span>) {
        <span style="color: #6a1868;">file</span> := c.<span style="color: #a626a4;">Param</span>(<span style="color: #50a14f;">"filepath"</span>)
        <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">Check if file exists and/or if we have permission to access it</span>
        <span style="color: #e45649;">if</span> <span style="color: #6a1868;">_</span>, <span style="color: #6a1868;">err</span> := fs.<span style="color: #a626a4;">Open</span>(file); err != <span style="color: #b751b6;">nil</span> {
            c.<span style="color: #a626a4;">Status</span>(http.StatusNotFound)
            <span style="color: #e45649;">return</span>
        }

        fileServer.<span style="color: #a626a4;">ServeHTTP</span>(c.Writer, c.Req)
    }
}

<span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">serve static files</span>
<span style="color: #e45649;">func</span> (<span style="color: #6a1868;">group</span> *<span style="color: #986801;">RouterGroup</span>) <span style="color: #a626a4;">Static</span>(<span style="color: #6a1868;">relativePath</span> <span style="color: #986801;">string</span>, <span style="color: #6a1868;">root</span> <span style="color: #986801;">string</span>) {
    <span style="color: #6a1868;">handler</span> := group.<span style="color: #a626a4;">createStaticHandler</span>(relativePath, http.<span style="color: #a626a4;">Dir</span>(root))
    <span style="color: #6a1868;">urlPattern</span> := path.<span style="color: #a626a4;">Join</span>(relativePath, <span style="color: #50a14f;">"/*filepath"</span>)
    <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">Register GET handlers</span>
    group.<span style="color: #a626a4;">GET</span>(urlPattern, handler)
}
</pre>
</div>

<p>
我们给 <code>RouterGroup</code> 添加了2个方法， <code>Static</code> 这个方法是暴露给用户的。用户可以将磁盘上的某个文件夹 <code>root</code> 映射到路由 <code>relativePath</code> 。例如：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #6a1868;">r</span> := gee.<span style="color: #a626a4;">New</span>()
r.<span style="color: #a626a4;">Static</span>(<span style="color: #50a14f;">"/assets"</span>, <span style="color: #50a14f;">"/usr/geektutu/blog/static"</span>)
<span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">&#25110;&#30456;&#23545;&#36335;&#24452; r.Static("/assets", "./static")</span>
r.<span style="color: #a626a4;">Run</span>(<span style="color: #50a14f;">":9999"</span>)
</pre>
</div>

<p>
用户访问 <code>localhost:9999/assets/js/geektutu.js</code> ，最终返回 <code>/usr/geektutu/blog/static/js/geektutu.js</code> 。<br>
</p>
</div>
</div>
<div id="outline-container-orgc858cff" class="outline-2">
<h2 id="orgc858cff">HTML 模版渲染</h2>
<div class="outline-text-2" id="text-orgc858cff">
<p>
Go语言内置了 <code>text/template</code> 和 <code>html/template</code> 2个模板标准库，其中 <code>html/template</code> 为 HTML 提供了较为完整的支持。包括普通变量渲染、列表渲染、对象渲染等。gee 框架的模板渲染直接使用了 <code>html/template</code> 提供的能力。<br>
</p>

<blockquote>
<p>
gee/gee.go<br>
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-go">Engine <span style="color: #e45649;">struct</span> {
    *RouterGroup
    router        *<span style="color: #986801;">router</span>
    groups        []*<span style="color: #986801;">RouterGroup</span>     <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">store all groups</span>
    htmlTemplates *<span style="color: #986801;">template.Template</span> <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">for html render</span>
    funcMap       <span style="color: #986801;">template.FuncMap</span>   <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">for html render</span>
}

<span style="color: #e45649;">func</span> (<span style="color: #6a1868;">engine</span> *<span style="color: #986801;">Engine</span>) <span style="color: #a626a4;">SetFuncMap</span>(<span style="color: #6a1868;">funcMap</span> <span style="color: #986801;">template.FuncMap</span>) {
    engine.funcMap = funcMap
}

<span style="color: #e45649;">func</span> (<span style="color: #6a1868;">engine</span> *<span style="color: #986801;">Engine</span>) <span style="color: #a626a4;">LoadHTMLGlob</span>(<span style="color: #6a1868;">pattern</span> <span style="color: #986801;">string</span>) {
    engine.htmlTemplates = template.<span style="color: #a626a4;">Must</span>(template.<span style="color: #a626a4;">New</span>(<span style="color: #50a14f;">""</span>).<span style="color: #a626a4;">Funcs</span>(engine.funcMap).<span style="color: #a626a4;">ParseGlob</span>(pattern))
}
</pre>
</div>

<p>
首先为 <code>Engine</code> 示例添加了 <code>*template.Template</code> 和 <code>template.FuncMap</code> 对象，前者将所有的模板加载进内存，后者是所有的自定义模板渲染函数。<br>
</p>

<p>
另外，给用户分别提供了设置自定义渲染函数 <code>funcMap</code> 和加载模板的方法。<br>
</p>

<p>
接下来，对原来的 <code>(*Context).HTML()</code> 方法做了些小修改，使之支持根据模板文件名选择模板进行渲染。<br>
</p>

<blockquote>
<p>
gee/context.go<br>
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #e45649;">type</span> <span style="color: #986801;">Context</span> <span style="color: #e45649;">struct</span> {
    <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">...</span>
    <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">engine pointer</span>
    engine *<span style="color: #986801;">Engine</span>
}

<span style="color: #e45649;">func</span> (<span style="color: #6a1868;">c</span> *<span style="color: #986801;">Context</span>) <span style="color: #a626a4;">HTML</span>(<span style="color: #6a1868;">code</span> <span style="color: #986801;">int</span>, <span style="color: #6a1868;">name</span> <span style="color: #986801;">string</span>, <span style="color: #6a1868;">data</span> <span style="color: #e45649;">interface</span>{}) {
    c.<span style="color: #a626a4;">SetHeader</span>(<span style="color: #50a14f;">"Content-Type"</span>, <span style="color: #50a14f;">"text/html"</span>)
    c.<span style="color: #a626a4;">Status</span>(code)
    <span style="color: #e45649;">if</span> <span style="color: #6a1868;">err</span> := c.engine.htmlTemplates.<span style="color: #a626a4;">ExecuteTemplate</span>(c.Writer, name, data); err != <span style="color: #b751b6;">nil</span> {
        c.<span style="color: #a626a4;">Fail</span>(500, err.<span style="color: #a626a4;">Error</span>())
    }
}
</pre>
</div>

<p>
我们在 <code>Context</code> 中添加了成员变量 <code>engine *Engine</code> ，这样就能够通过 Context 访问 Engine 中的 HTML 模板。实例化 Context 时，还需要给 <code>c.engine</code> 赋值。<br>
</p>

<blockquote>
<p>
gee/gee.go<br>
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #e45649;">func</span> (<span style="color: #6a1868;">engine</span> *<span style="color: #986801;">Engine</span>) <span style="color: #a626a4;">ServeHTTP</span>(<span style="color: #6a1868;">w</span> <span style="color: #986801;">http.ResponseWriter</span>, <span style="color: #6a1868;">req</span> *<span style="color: #986801;">http.Request</span>) {
    <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">...</span>
    <span style="color: #6a1868;">c</span> := <span style="color: #a626a4;">newContext</span>(w, req)
    c.handlers = middlewares
    c.engine = engine
    engine.router.<span style="color: #a626a4;">handle</span>(c)
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf2e8ee5" class="outline-2">
<h2 id="orgf2e8ee5">使用 Demo</h2>
<div class="outline-text-2" id="text-orgf2e8ee5">
<p>
最终的目录结构<br>
</p>

<pre class="example" id="org094992a">
---gee/
---static/
   |---css/
        |---geektutu.css
   |---file1.txt
---templates/
   |---arr.tmpl
   |---css.tmpl
   |---custom_func.tmpl
---main.go
</pre>

<div class="org-src-container">
<pre class="src src-html"><span style="color: #9ca0a4;">&lt;!-- </span><span style="color: #9ca0a4;">day6-template/templates/css.tmpl</span><span style="color: #9ca0a4;"> --&gt;</span>
&lt;<span style="color: #a626a4;">html</span>&gt;
  &lt;<span style="color: #a626a4;">link</span> <span style="color: #6a1868;">rel</span>=<span style="color: #50a14f;">"stylesheet"</span> <span style="color: #6a1868;">href</span>=<span style="color: #50a14f;">"/assets/css/haoran.css"</span>&gt;
  &lt;<span style="color: #a626a4;">p</span>&gt;geektutu.css is loaded&lt;/<span style="color: #a626a4;">p</span>&gt;
&lt;/<span style="color: #a626a4;">html</span>&gt;
</pre>
</div>

<blockquote>
<p>
main.go<br>
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #e45649;">type</span> <span style="color: #986801;">student</span> <span style="color: #e45649;">struct</span> {
    Name <span style="color: #986801;">string</span>
    Age  <span style="color: #986801;">int8</span>
}

<span style="color: #e45649;">func</span> <span style="color: #a626a4;">FormatAsDate</span>(<span style="color: #6a1868;">t</span> <span style="color: #986801;">time.Time</span>) <span style="color: #986801;">string</span> {
    <span style="color: #6a1868;">year</span>, <span style="color: #6a1868;">month</span>, <span style="color: #6a1868;">day</span> := t.<span style="color: #a626a4;">Date</span>()
    <span style="color: #e45649;">return</span> fmt.<span style="color: #a626a4;">Sprintf</span>(<span style="color: #50a14f;">"%d-%02d-%02d"</span>, year, month, day)
}

<span style="color: #e45649;">func</span> <span style="color: #a626a4;">main</span>() {
    <span style="color: #6a1868;">r</span> := gee.<span style="color: #a626a4;">New</span>()
    r.<span style="color: #a626a4;">Use</span>(gee.<span style="color: #a626a4;">Logger</span>())
    r.<span style="color: #a626a4;">SetFuncMap</span>(<span style="color: #986801;">template.FuncMap</span>{
        <span style="color: #50a14f;">"FormatAsDate"</span>: FormatAsDate,
    })
    r.<span style="color: #a626a4;">LoadHTMLGlob</span>(<span style="color: #50a14f;">"templates/*"</span>)
    r.<span style="color: #a626a4;">Static</span>(<span style="color: #50a14f;">"/assets"</span>, <span style="color: #50a14f;">"./static"</span>)

    <span style="color: #6a1868;">stu1</span> := &amp;<span style="color: #986801;">student</span>{<span style="color: #b751b6;">Name</span>: <span style="color: #50a14f;">"Geektutu"</span>, <span style="color: #b751b6;">Age</span>: 20}
    <span style="color: #6a1868;">stu2</span> := &amp;<span style="color: #986801;">student</span>{<span style="color: #b751b6;">Name</span>: <span style="color: #50a14f;">"Jack"</span>, <span style="color: #b751b6;">Age</span>: 22}
    r.<span style="color: #a626a4;">GET</span>(<span style="color: #50a14f;">"/"</span>, <span style="color: #e45649;">func</span>(<span style="color: #6a1868;">c</span> *<span style="color: #986801;">gee.Context</span>) {
        c.<span style="color: #a626a4;">HTML</span>(http.StatusOK, <span style="color: #50a14f;">"css.tmpl"</span>, <span style="color: #b751b6;">nil</span>)
    })
    r.<span style="color: #a626a4;">GET</span>(<span style="color: #50a14f;">"/students"</span>, <span style="color: #e45649;">func</span>(<span style="color: #6a1868;">c</span> *<span style="color: #986801;">gee.Context</span>) {
        c.<span style="color: #a626a4;">HTML</span>(http.StatusOK, <span style="color: #50a14f;">"arr.tmpl"</span>, <span style="color: #986801;">gee.H</span>{
            <span style="color: #50a14f;">"title"</span>:  <span style="color: #50a14f;">"gee"</span>,
            <span style="color: #50a14f;">"stuArr"</span>: [2]*<span style="color: #986801;">student</span>{stu1, stu2},
        })
    })

    r.<span style="color: #a626a4;">GET</span>(<span style="color: #50a14f;">"/date"</span>, <span style="color: #e45649;">func</span>(<span style="color: #6a1868;">c</span> *<span style="color: #986801;">gee.Context</span>) {
        c.<span style="color: #a626a4;">HTML</span>(http.StatusOK, <span style="color: #50a14f;">"custom_func.tmpl"</span>, <span style="color: #986801;">gee.H</span>{
            <span style="color: #50a14f;">"title"</span>: <span style="color: #50a14f;">"gee"</span>,
            <span style="color: #50a14f;">"now"</span>:   time.<span style="color: #a626a4;">Date</span>(2019, 8, 17, 0, 0, 0, 0, time.UTC),
        })
    })

    r.<span style="color: #a626a4;">Run</span>(<span style="color: #50a14f;">":9999"</span>)
}
</pre>
</div>

<p>
访问 localhost:9999，模版正常渲染，CSS 静态文件加载成功。<br>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-12-25</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
