<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-10-07 Thu 09:09 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>排序</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran &lt;haoran.mc@outlook.com&gt;">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">排序</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgfb7cdf2">选择排序</a></li>
<li><a href="#org4447699">冒泡排序</a></li>
<li><a href="#org7eb0b5b">插入排序</a></li>
<li><a href="#org1424a55">计数排序</a></li>
<li><a href="#orgc0acda9">基数排序</a></li>
<li><a href="#org26c8fb1">快速排序</a></li>
<li><a href="#org92fb5ed">归并排序</a></li>
<li><a href="#org6ea5029">堆排序</a>
<ul>
<li><a href="#orgaf19529">小根堆性质</a></li>
<li><a href="#orgca096d8">堆的存储</a></li>
<li><a href="#org2416f48">堆的两个操作</a>
<ul>
<li><a href="#org3be53b3">down</a></li>
<li><a href="#orga6cc6a5">up</a></li>
</ul>
</li>
<li><a href="#org498df5e">对于堆这个数据结构，它能实现的操作</a></li>
</ul>
</li>
<li><a href="#orgefd2d9e">桶排序</a></li>
<li><a href="#orgb8bc576">希尔排序</a></li>
<li><a href="#orgee7582d">锦标赛排序</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgfb7cdf2" class="outline-2">
<h2 id="orgfb7cdf2">选择排序</h2>
<div class="outline-text-2" id="text-orgfb7cdf2">
<p>
选择排序（英语：Selection Sort）是一种简单直观的排序算法。它的工作原理是每次找出第 \(i\) 小的元素（也就是 \(A_{i \dots n}\) 中最小的元素），然后将这个元素与数组第 \(i\) 个位置上的元素交换。<br>
</p>

<img src="./images/SelectSort.svg" />

<dl class="org-dl">
<dt>稳定性</dt><dd>由于 swap（交换两个元素）操作的存在，选择排序是一种不稳定的排序算法。<br></dd>
<dt>时间复杂度</dt><dd>选择排序的最优时间复杂度、平均时间复杂度和最坏时间复杂度均为 \(O(n^2)\) 。<br></dd>
</dl>
</div>
</div>
<div id="outline-container-org4447699" class="outline-2">
<h2 id="org4447699">冒泡排序</h2>
<div class="outline-text-2" id="text-org4447699">
<p>
冒泡排序（英语：Bubble Sort）是一种简单的排序算法。由于在算法的执行过程中，较小的元素像是气泡般慢慢「浮」到数列的顶端，故叫做冒泡排序。<br>
</p>

<p>
它的工作原理是每次检查相邻两个元素，如果前面的元素与后面的元素满足给定的排序条件，就将相邻两个元素交换。当没有相邻的元素需要交换时，排序就完成了。<br>
</p>

<p>
经过 \(i\) 次扫描后，数列的末尾 \(i\) 项必然是最大的 \(i\) 项，因此冒泡排序最多需要扫描 \(n - 1\) 遍数组就能完成排序。<br>
</p>

<dl class="org-dl">
<dt>稳定性</dt><dd>冒泡排序是一种稳定的排序算法。<br></dd>
<dt>时间复杂度</dt><dd>冒泡排序的平均时间复杂度为 \(O(n^2)\) 。<br></dd>
</dl>
</div>
</div>
<div id="outline-container-org7eb0b5b" class="outline-2">
<h2 id="org7eb0b5b">插入排序</h2>
<div class="outline-text-2" id="text-org7eb0b5b">
<p>
插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理为将待排列元素划分为“已排序”和“未排序”两部分，每次从“未排序的”元素中选择一个插入到“已排序的”元素中的正确位置。<br>
</p>

<img src="./images/InsertSort.svg" />
<dl class="org-dl">
<dt>稳定性</dt><dd>插入排序是一种稳定的排序算法。<br></dd>
<dt>时间复杂度</dt><dd>插入排序的最坏时间复杂度和平均时间复杂度都为 \(O(n^2)\) 。<br></dd>
</dl>
</div>
</div>
<div id="outline-container-org1424a55" class="outline-2">
<h2 id="org1424a55">计数排序</h2>
</div>
<div id="outline-container-orgc0acda9" class="outline-2">
<h2 id="orgc0acda9">基数排序</h2>
</div>
<div id="outline-container-org26c8fb1" class="outline-2">
<h2 id="org26c8fb1">快速排序</h2>
<div class="outline-text-2" id="text-org26c8fb1">
<p>
快速排序（英语：Quicksort），又称分区交换排序（英语：partition-exchange sort），简称快排，是一种被广泛运用的排序算法。<br>
</p>

<p>
快速排序的工作原理是通过 分治 的方式来将一个数组排序。<br>
</p>

<p>
快速排序分为三个过程：<br>
</p>
<ul class="org-ul">
<li>将数列划分为两部分（要求保证相对大小关系）；<br></li>
<li>递归到两个子序列中分别进行快速排序；<br></li>
<li>不用合并，因为此时数列已经完全有序。<br></li>
</ul>

<p>
和归并排序不同，第一步并不是直接分成前后两个序列，而是在分的过程中要保证相对大小关系。具体来说，第一步要是要把数列分成两个部分，然后保证前一个子数列中的数都小于后一个子数列中的数。为了保证平均时间复杂度，一般是随机选择一个数 \(m\)  来当做两个子数列的分界。<br>
</p>

<p>
之后，维护一前一后两个指针 \(p\)  和 \(q\) ，依次考虑当前的数是否放在了应该放的位置（前还是后）。如果当前的数没放对，比如说如果后面的指针 \(q\) 遇到了一个比 \(m\) 小的数，那么可以交换 \(p\) 和 \(q\) 位置上的数，再把 \(p\) 向后移一位。当前的数的位置全放对后，再移动指针继续处理，直到两个指针相遇。<br>
</p>

<dl class="org-dl">
<dt>稳定性</dt><dd>快速排序是一种不稳定的排序算法。<br></dd>
<dt>时间复杂度</dt><dd>快速排序的最优时间复杂度和平均时间复杂度为 \(O(nlogn)\) ，最坏时间复杂度为 \(O(n^2)\) 。<br></dd>
</dl>
</div>
</div>
<div id="outline-container-org92fb5ed" class="outline-2">
<h2 id="org92fb5ed">归并排序</h2>
<div class="outline-text-2" id="text-org92fb5ed">
<p>
归并排序（英语：merge sort）是一种采用了 分治 思想的排序算法。<br>
</p>

<p>
归并排序分为三个步骤：<br>
</p>

<ul class="org-ul">
<li>将数列划分为两部分；<br></li>
<li>递归地分别对两个子序列进行归并排序；<br></li>
<li>合并两个子序列。<br></li>
</ul>

<p>
不难发现，归并排序的前两步都很好实现，关键是如何合并两个子序列。注意到两个子序列在第二步中已经保证了都是有序的了，第三步中实际上是想要把两个 有序 的序列合并起来。<br>
</p>

<dl class="org-dl">
<dt>稳定性</dt><dd>归并排序是一种稳定的排序算法。<br></dd>
<dt>时间复杂度</dt><dd>归并排序的最优时间复杂度、平均时间复杂度和最坏时间复杂度均为 \(O(nlogn)\) 。<br></dd>
<dt>空间复杂度</dt><dd>归并排序的空间复杂度为 \(O(n)\) 。<br></dd>
</dl>
</div>
</div>

<div id="outline-container-org6ea5029" class="outline-2">
<h2 id="org6ea5029">堆排序</h2>
<div class="outline-text-2" id="text-org6ea5029">
<p>
堆排序（英语：Heapsort）是指利用 二叉堆 这种数据结构所设计的一种排序算法。堆排序的适用数据结构为数组。<br>
</p>

<p>
本质是建立在堆上的选择排序。<br>
</p>

<p>
只介绍小根堆(堆顶是最小元素)，大根堆的算法思想与小根堆一样，对于输入的数全为正数的题目，可以通过存入相反数来用小根堆的代码实现大根堆的操作。<br>
</p>
</div>
<div id="outline-container-orgaf19529" class="outline-3">
<h3 id="orgaf19529">小根堆性质</h3>
<div class="outline-text-3" id="text-orgaf19529">
<ol class="org-ol">
<li>堆是一棵完全二叉树<br></li>
<li>且满足每个节点小于等于左右儿子节点。<br></li>
</ol>
</div>
</div>
<div id="outline-container-orgca096d8" class="outline-3">
<h3 id="orgca096d8">堆的存储</h3>
<div class="outline-text-3" id="text-orgca096d8">
<p>
堆的存储：由于堆是完全二叉树，所以满足left_node = 2 * node, right_node = 2 * node + 1，所以我们使用一维数组存储。<br>
</p>

<p>
上述描述的是下标从1开始，如果下标从0开始，那么左右节点与根节点的关系为left_node = 2 * node + 1, right_node = 2 * node + 2.<br>
</p>
</div>
</div>
<div id="outline-container-org2416f48" class="outline-3">
<h3 id="org2416f48">堆的两个操作</h3>
<div class="outline-text-3" id="text-org2416f48">
<p>
下面提到的堆的五个操作都可以通过down, up这两个操作实现。<br>
</p>
</div>
<div id="outline-container-org3be53b3" class="outline-4">
<h4 id="org3be53b3">down</h4>
<div class="outline-text-4" id="text-org3be53b3">
<p>
对于一个小根堆，如果一个位置上的数变大了，就要把这个节点向下移。<br>
</p>
<pre class="example" id="orge7d8aad">
      3                                  8                                  3                                 3
     / \                                / \                                / \                               / \
    /   \        堆顶元素变大          /   \             down             /   \             down            /   \
   3     4         -------&gt;           3     4          -------&gt;          8     4         -------&gt;          4     4
  /|    / \                          /|    / \                          /|    / \                         /|    / \
 / |   /   \                        / |   /   \                        / |   /   \                       / |   /   \
5  4  7     6                      5  4  7     6                      5  4  7     6                     5  8  7     6
</pre>
</div>
</div>
<div id="outline-container-orga6cc6a5" class="outline-4">
<h4 id="orga6cc6a5">up</h4>
<div class="outline-text-4" id="text-orga6cc6a5">
<p>
如果一个位置上的数变小了，就要把这个节点向上移。<br>
</p>
<pre class="example" id="org91736ed">
         3                               3                               3                                 3
        / \                             / \                             / \                               / \
       /   \         插入新元素        /   \           up              /   \             up              /   \
      3     4         -------&gt;        3     4       -------&gt;          3     4         -------&gt;          2     4
     /|    / \                       /|    / \                       /|    / \                         /|    / \
    / |   /   \                     / |   /   \                     / |   /   \                       / |   /   \
   5  4  7     6                   5  4  7     6                   2  4  7     6                     3  4  7     6
  /                               / \                             / \                               / \
 /                               /   \                           /   \                             /   \
6                               6     2                         6     5                           6     5

                     2
                    / \
   up              /   \
-------&gt;          3     4
                 /|    / \
                / |   /   \
               3  4  7     6
              / \
             /   \
            6     5
</pre>
</div>
</div>
</div>
<div id="outline-container-org498df5e" class="outline-3">
<h3 id="org498df5e">对于堆这个数据结构，它能实现的操作</h3>
<div class="outline-text-3" id="text-org498df5e">
<ol class="org-ol">
<li><p>
插入一个数<br>
</p>
<div class="org-src-container">
<pre class="src src-cpp">heap[++size] = x; <span style="color: #7c7c7c; font-style: italic;">// </span><span style="color: #7c7c7c; font-style: italic;">&#22312;&#22534;&#30340;&#26368;&#21518;&#38754;&#25554;&#20837;&#19968;&#20010;&#25968;</span>
up(size);  <span style="color: #7c7c7c; font-style: italic;">// </span><span style="color: #7c7c7c; font-style: italic;">&#26681;&#25454;&#25554;&#20837;&#30340;&#25968;&#30340;&#22823;&#23567;&#36827;&#34892;up&#25805;&#20316;</span>
</pre>
</div></li>

<li>求集合中的最小值: heap[1]<br></li>

<li><p>
删除最小值<br>
</p>
<pre class="example" id="org693a5cf">
         2                                 +                                       8
        / \                               / \                                     / \
       /   \                             /   \                                   /   \
      3     3       删除堆顶元素        3     3       最后一个元素放到堆顶      3     3        down
     /|    / \         -----&gt;          /|    / \           -------&gt;            /|    / \     -------&gt;
    / |   /   \                       / |   /   \                             / |   /   \                 ...
   6  5  4     4                     6  5  4      4                          6  5  4     4
  /                                 /            
 /                                 /             
8                                 8              

heap[1] = heap[size];  size --;  down(1);
</pre></li>

<li><p>
删除任意一个元素<br>
同删除最小值<br>
</p>
<div class="org-src-container">
<pre class="src src-cpp">heap[k] = heap[size];
size--; 
up(k), down(k);   <span style="color: #7c7c7c; font-style: italic;">// </span><span style="color: #7c7c7c; font-style: italic;">&#34429;&#28982;&#20004;&#20010;&#25805;&#20316;&#37117;&#20351;&#29992;&#65292;&#20294;&#23427;&#21482;&#20250;&#36816;&#34892;&#27491;&#30830;&#30340;&#37027;&#20010;</span>

<span style="color: #009F9F; font-style: italic;">/**</span>
<span style="color: #009F9F; font-style: italic;"> * if (&#21407;&#20808;&#30340;&#20540;&#21464;&#22823;&#20102;)</span>
<span style="color: #009F9F; font-style: italic;"> *     down(k);</span>
<span style="color: #009F9F; font-style: italic;"> * else</span>
<span style="color: #009F9F; font-style: italic;"> *     up(k);</span>
<span style="color: #009F9F; font-style: italic;"> */</span>
</pre>
</div></li>

<li>修改任意一个元素<br>
同上 <code>heap[k] = x; down(k), up(k);</code><br></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgefd2d9e" class="outline-2">
<h2 id="orgefd2d9e">桶排序</h2>
</div>
<div id="outline-container-orgb8bc576" class="outline-2">
<h2 id="orgb8bc576">希尔排序</h2>
</div>
<div id="outline-container-orgee7582d" class="outline-2">
<h2 id="orgee7582d">锦标赛排序</h2>
</div>
</div>
</body>
</html>
