<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2023-01-03 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>GIT-分支管理</title>
<meta name="author" content="L.M.haoran" />
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved." />
<meta name="generator" content="Org Mode" />
<link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
           <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
           <script type="module" src="static/js/main.js" defer></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">GIT-分支管理</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgef38997">创建与合并分支</a>
<ul>
<li><a href="#orgcaeedc2">创建、切换分支</a></li>
<li><a href="#org616fb74">删除分支</a></li>
<li><a href="#orgcf2b165">修改分支名称</a></li>
</ul>
</li>
<li><a href="#org6c2a247">合并代码、解决冲突</a>
<ul>
<li><a href="#org8116d03">git merge 和 git rebase 的区别</a>
<ul>
<li><a href="#org453997f">merge</a></li>
<li><a href="#orgf186033">Rebase</a>
<ul>
<li><a href="#orgffd1ad3">应用实例描述</a></li>
<li><a href="#org4c52acf">引入问题</a></li>
<li><a href="#orged3dedd">知识点引入</a>
<ul>
<li><a href="#orgeea764f">git pull &#x2013;rebase</a></li>
<li><a href="#orgffd5227">git fetch</a></li>
<li><a href="#orge2cccbf">git rebase</a></li>
<li><a href="#org6dbdd02">git pull &#x2013;rebase</a></li>
</ul>
</li>
<li><a href="#org3d843dc">解决冲突的三种方式</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org865561c">分支管理策略</a>
<ul>
<li><a href="#org1f4b6c9">Bug分支</a></li>
<li><a href="#org1a83e8e">Feature分支</a></li>
<li><a href="#orgf9cad09">多人协作</a></li>
<li><a href="#org13f9098">推送分支</a></li>
<li><a href="#org5a69c61">抓取分支</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgef38997" class="outline-2">
<h2 id="orgef38997">创建与合并分支</h2>
<div class="outline-text-2" id="text-orgef38997">
</div>
<div id="outline-container-orgcaeedc2" class="outline-3">
<h3 id="orgcaeedc2">创建、切换分支</h3>
<div class="outline-text-3" id="text-orgcaeedc2">
<dl class="org-dl">
<dt>git checkout -b dev</dt><dd>创建 dev 分支，然后切换到 dev 分支，等价与下面两条命令；<br>
<dl class="org-dl">
<dt>git branch dev</dt><dd>创建 dev 分支；<br></dd>
<dt>git checkout dev</dt><dd>切换到 dev 分支；<br></dd>
</dl></dd>
<dt>git branch</dt><dd>查看当前分支；<br></dd>
<dt>git merge dev</dt><dd>将 dev 分支的工作成果合并到 master 分支上；<br></dd>
<dt>git branch -d dev</dt><dd>删除 dev 分支；<br></dd>
<dt>git push origin &#x2013;delete &lt;branch-name&gt;</dt><dd>删除远程分支；<br></dd>
</dl>

<p>
使用 switch 切换分支更科学<br>
</p>

<dl class="org-dl">
<dt>git switch -c dev</dt><dd>创建并切换到新的 dev 分支；<br></dd>
<dt>git switch master</dt><dd>切换到已有的 master 分支；<br></dd>
</dl>
</div>
</div>
<div id="outline-container-org616fb74" class="outline-3">
<h3 id="org616fb74">删除分支</h3>
<div class="outline-text-3" id="text-org616fb74">
<dl class="org-dl">
<dt>git branch -d &lt;branch-name&gt;</dt><dd>删除本地分支<br></dd>
<dt>git push origin &#x2013;delete &lt;branch-name&gt;</dt><dd>删除远程分支<br></dd>
</dl>
</div>
</div>
<div id="outline-container-orgcf2b165" class="outline-3">
<h3 id="orgcf2b165">修改分支名称</h3>
<div class="outline-text-3" id="text-orgcf2b165">
<dl class="org-dl">
<dt>git branch -m &lt;oldBranchName&gt; &lt;newBranchName&gt;</dt><dd>重命名本地分支<br></dd>
<dt>git push &#x2013;delete origin &lt;oldBranchName&gt;</dt><dd>删除远程分支<br></dd>
<dt>git push origin &lt;newBranchName&gt;</dt><dd>上传新的分支名<br></dd>
<dt>git branch &#x2013;set-upstream-to origin/&lt;newBranchName&gt;</dt><dd>关联<br></dd>
</dl>
</div>
</div>
</div>
<div id="outline-container-org6c2a247" class="outline-2">
<h2 id="org6c2a247">合并代码、解决冲突</h2>
<div class="outline-text-2" id="text-org6c2a247">
<ul class="org-ul">
<li><code>git merge fature1</code> ：如果两个分支都修改了同一个文件的同一部分，就会冲突，git会标记冲突的地方，手动合并<br>
<ul class="org-ul">
<li>然后 <code>git add .</code><br></li>
<li><code>git commit -m ""</code><br></li>
</ul></li>
<li><code>git log --graph</code> ：分支合并图<br></li>
</ul>
</div>
<div id="outline-container-org8116d03" class="outline-3">
<h3 id="org8116d03">git merge 和 git rebase 的区别</h3>
<div class="outline-text-3" id="text-org8116d03">
<p>
目的都是将一个分支的 commit 合并道另外一个分支中去。<br>
</p>
</div>
<div id="outline-container-org453997f" class="outline-4">
<h4 id="org453997f">merge</h4>
</div>
<div id="outline-container-orgf186033" class="outline-4">
<h4 id="orgf186033">Rebase</h4>
<div class="outline-text-4" id="text-orgf186033">
</div>
<div id="outline-container-orgffd1ad3" class="outline-5">
<h5 id="orgffd1ad3">应用实例描述</h5>
<div class="outline-text-5" id="text-orgffd1ad3">
<p>
假设在 github 上建立了一个项目，默认分支为 master 分支，远程 master 分支上 c.sh 文件的内容：<br>
</p>

<pre class="example" id="org22deb42">
this is a new content!
hello world
</pre>

<p>
开发者 A、B 分别将项目拷贝到自己本地进行开发。某一天，开发者 B 提交 c.sh 并提交成功。<br>
</p>

<pre class="example" id="orgcf81f05">
this is developer B
this is a new content!
hello dev B
</pre>

<p>
之后，开发者 A 在本地代码并没有和远程 master 分支的代码同步的情况下，对本地 c.sh 进行了修改，修改后的 c.sh 内容如下：<br>
</p>

<pre class="example" id="org179167d">
this is a new content!
hello world
this is developer A
</pre>

<p>
修改后，开发者 A 准备将代码提交到远程 master 分支上。<br>
</p>
</div>
</div>
<div id="outline-container-org4c52acf" class="outline-5">
<h5 id="org4c52acf">引入问题</h5>
<div class="outline-text-5" id="text-org4c52acf">
<p>
假设开发者 A 提交过程如下：<br>
</p>

<div class="org-src-container">
<pre class="src src-sh">$ git add c.sh
$ git commit -m <span style="color: #c3e88d;">"xxx"</span>
</pre>
</div>

<p>
如果此时直接使用 <code>git push</code> ，则会报错，上述过程的节点走向如下：<br>
</p>

<img src="./images/git-rebase-节点走向01.png" width="650px" />

<p>
实际开发过程中考虑其他开发者可能会对 c.sh 进行修改，因此一般在开发过程中建议使用：<br>
</p>

<div class="org-src-container">
<pre class="src src-sh">git pull --rebase
</pre>
</div>

<p>
与远程代码同步，同步过程会检查冲突，<br>
</p>

<pre class="example" id="org8418221">
this is developer B
this is a new content!
&lt;&lt;&lt;&lt;&lt;&lt;&lt; xxx
hello dev B
=======
hello world
this is developer A
&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev A modified c.sh
</pre>

<p>
开发者根据 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD, <verbatim>=====</verbatim>, &gt;&gt;&gt;&gt;&gt;&gt;&gt; 可以知道冲突的位置。<br>
</p>

<blockquote>
<p>
注意：不是出现冲突才使用 git pull &#x2013;rebase，它是一种解决冲突的手段，另外还有 merge 的方式。<br>
</p>
</blockquote>
</div>
</div>
<div id="outline-container-orged3dedd" class="outline-5">
<h5 id="orged3dedd">知识点引入</h5>
<div class="outline-text-5" id="text-orged3dedd">
</div>
<div id="outline-container-orgeea764f" class="outline-6">
<h6 id="orgeea764f">git pull &#x2013;rebase</h6>
<div class="outline-text-6" id="text-orgeea764f">
<p>
<code>git pull</code> 的默认行为是 git fetch + git merge<br>
<code>git pull --rebase</code> 则是 git fetch + git rebase<br>
</p>
</div>
</div>
<div id="outline-container-orgffd5227" class="outline-6">
<h6 id="orgffd5227">git fetch</h6>
<div class="outline-text-6" id="text-orgffd5227">
<p>
从远程获取最新版本到本地，不会自动合并分支。<br>
</p>
</div>
</div>
<div id="outline-container-orge2cccbf" class="outline-6">
<h6 id="orge2cccbf">git rebase</h6>
<div class="outline-text-6" id="text-orge2cccbf">
<p>
git rebase，顾名思义，就是重新定义（re）起点（base）的作用，即重新定义分支的版本库状态。本地更新分支节点过程如下图：<br>
</p>

<img src="./images/git-rebase-节点走向02.png" width="650px" />
</div>
</div>
<div id="outline-container-org6dbdd02" class="outline-6">
<h6 id="org6dbdd02">git pull &#x2013;rebase</h6>
<div class="outline-text-6" id="text-org6dbdd02">
<p>
<code>git pull --rebase</code> 执行过程中会将本地当前分支里的每个提交（commit）取消掉，然后将本地分支更新为最新的 origin 分支，该过程本地分支节点更新图如下所示：<br>
</p>

<img src="./images/git-rebase-节点走向03.png" width="650px" />
</div>
</div>
</div>
<div id="outline-container-org3d843dc" class="outline-5">
<h5 id="org3d843dc">解决冲突的三种方式</h5>
<div class="outline-text-5" id="text-org3d843dc">
<ol class="org-ol">
<li>git rebase &#x2013;abort 放弃合并，回到 rebase 操作之前的状态，之前的提交不会丢弃；<br></li>
<li>git rebase &#x2013;skip 则会将引起冲突的 commits 丢弃掉（慎用）；<br></li>
<li>git rebase &#x2013;continue 合并冲突，结合 git add 命令一起用于修复冲突，提示开发者，一步一步地解决冲突；<br></li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org865561c" class="outline-2">
<h2 id="org865561c">分支管理策略</h2>
<div class="outline-text-2" id="text-org865561c">
<p>
通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。<br>
如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。<br>
</p>

<dl class="org-dl">
<dt>git switch -c dev</dt><dd>创建一个 dev 分支<br>
<dl class="org-dl">
<dt>git add .</dt><dd>修改 dev 分支的文件之后提交<br></dd>
<dt>git commit -m "dev commit"</dt><dd>这里的 commit 信息之后会保留<br></dd>
</dl></dd>
<dt>git switch master</dt><dd>回到 master 分支<br></dd>
<dt>git merge &#x2013;no-ff -m "这里需要commit 信息，因为使用参数后 merge 就相当于一次 commit" dev</dt><dd>使用 &#x2013;no-ff 参数合并分支<br></dd>
</dl>
</div>
<div id="outline-container-org1f4b6c9" class="outline-3">
<h3 id="org1f4b6c9">Bug分支</h3>
<div class="outline-text-3" id="text-org1f4b6c9">
<dl class="org-dl">
<dt>git stash</dt><dd>储存工作现场，因为当前工作未完成，但现在需要修复 bug，所以把现场存储起来。不是很理解，新建一个分支修改不就行了，这个分支不动它不就行了？<br></dd>
<dt>git stash list</dt><dd>查看存储的工作现场<br></dd>
<dt>git stash apply</dt><dd>恢复现场<br></dd>
<dt>git stash drop</dt><dd>删除存储的工作现场<br></dd>
<dt>git stash pop</dt><dd>恢复的同时删除 stash 内容<br></dd>
<dt>git cherry-pick 4c805e2</dt><dd>只复制 4c805e2 这个提交所做的修改，并不是把整个 master merge 过来<br></dd>
</dl>
</div>
</div>
<div id="outline-container-org1a83e8e" class="outline-3">
<h3 id="org1a83e8e">Feature分支</h3>
<div class="outline-text-3" id="text-org1a83e8e">
<p>
开发一个新的 feature，最好新建一个分支<br>
</p>
<dl class="org-dl">
<dt>git branch -D &lt;branchname&gt;</dt><dd>强行丢弃一个没有被合并过的分支，上级宣布这个功能丢弃<br></dd>
</dl>
</div>
</div>
<div id="outline-container-orgf9cad09" class="outline-3">
<h3 id="orgf9cad09">多人协作</h3>
<div class="outline-text-3" id="text-orgf9cad09">
<p>
当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。<br>
</p>
<dl class="org-dl">
<dt>git remote</dt><dd>查看远程库的信息<br></dd>
<dt>git remote -v</dt><dd>显示更详细的信息<br></dd>
</dl>
</div>
</div>
<div id="outline-container-org13f9098" class="outline-3">
<h3 id="org13f9098">推送分支</h3>
<div class="outline-text-3" id="text-org13f9098">
<p>
推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：<br>
</p>
<dl class="org-dl">
<dt>git push origin &lt;branch-name&gt;</dt><dd>推送自己的修改<br></dd>
<dt>git push &#x2013;set-upstream origin &lt;branch-name&gt;</dt><dd><p>
第一次推送需要建立与远程仓库的联系<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">git push origin master
git push origin dev
</pre>
</div></dd>
</dl>

<p>
但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？<br>
</p>

<ul class="org-ul">
<li><verbatim>master</verbatim> 分支是主分支，因此要时刻与远程同步；<br></li>
<li><verbatim>dev</verbatim> 分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；<br></li>
<li><verbatim>bug</verbatim> 分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；<br></li>
<li><verbatim>feature</verbatim> 分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。<br></li>
</ul>

<p>
总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！<br>
</p>
</div>
</div>
<div id="outline-container-org5a69c61" class="outline-3">
<h3 id="org5a69c61">抓取分支</h3>
<div class="outline-text-3" id="text-org5a69c61">
<p>
从远程库 clone 时，默认情况下是能看到 master 分支，如果要在 dev 分支上开发，就必须创建远程 origin 的 dev 分支到本地<br>
</p>

<dl class="org-dl">
<dt>git checkout -b dev origin/dev</dt><dd>clone 远程库的 dev 分支到本地<br></dd>
</dl>

<p>
遇到推送的提交有冲突，就需要先把最新的提交从远程库中抓下来，然后在本地合并，解决冲突后再推送<br>
</p>

<p>
git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：<br>
</p>

<dl class="org-dl">
<dt>git branch &#x2013;set-upstream-to=origin/dev dev</dt><dd>建立本地分支与远程分支的关联<br></dd>
<dt>git pull</dt><dd>推送失败是因为没有从远程分支更新，使用 git pull 然后手动合并<br></dd>
</dl>
</div>
</div>
</div>
</div>
</body>
</html>
