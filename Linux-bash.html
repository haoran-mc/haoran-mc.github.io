<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-06-19 Sun 13:33 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>LINUX-认识与学习BASH</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="static/MathJax/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div id="content">
<h1 class="title">LINUX-认识与学习BASH</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgf46ba3f">什么是 shell</a></li>
<li><a href="#org7bbc9e1">常用的 shell</a></li>
<li><a href="#org8e4bda8">Bash shell 的功能</a></li>
<li><a href="#org9101d4f">查询命令是否为 Bash 的内置命令：type</a></li>
<li><a href="#orgef339cf">shell 的变量功能</a>
<ul>
<li><a href="#orgb58bca4">变量的使用与设置</a></li>
<li><a href="#org5311303">环境变量的功能</a>
<ul>
<li><a href="#orga9b4c7f">查看环境变量</a></li>
<li><a href="#org552ce82">重要的环境变量</a>
<ul>
<li><a href="#org51fcf18">RANDOM</a></li>
<li><a href="#orgd65f31b">PS1</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9af63c1">变量键盘读取、数组与声明</a>
<ul>
<li><a href="#org55cd3ca">变量键盘读取：read</a></li>
<li><a href="#orge55cd27">声明：declare</a></li>
</ul>
</li>
<li><a href="#orgd464d16">与文件系统及程序的限制关系（ulimit）</a></li>
</ul>
</li>
<li><a href="#org0bb53a2">命令别名与历史命令</a>
<ul>
<li><a href="#org1875b3a">命令别名设置：alias、unalias</a></li>
<li><a href="#orgb6ca417">历史命令：history</a></li>
</ul>
</li>
<li><a href="#org1adb71c">Bash shell 的操作环境</a>
<ul>
<li><a href="#org883522d">路径与命令查找顺序</a></li>
<li><a href="#org8dbe1e1">bash 的登录与欢迎信息</a></li>
<li><a href="#orgef1b5aa">bash 的环境配置文件</a>
<ul>
<li><a href="#orgd21c6d7">login 与 non-login shell</a></li>
<li><a href="#org43dd516">/etc/profile</a>
<ul>
<li><a href="#org01daeea">/etc/profile.d/*sh</a></li>
<li><a href="#org28dddb5">/etc/locale.conf</a></li>
<li><a href="#org5d89748">/usr/share/bash-completion/completions/*</a></li>
</ul>
</li>
<li><a href="#org1deb25b">~/.bash_profile</a>
<ul>
<li><a href="#orgde05856">source</a></li>
<li><a href="#org153fb23">~/.bashrc</a></li>
</ul>
</li>
<li><a href="#org9799988">其他相关配置文件</a>
<ul>
<li><a href="#orgd53e5f4">/etc/man_db.conf</a></li>
<li><a href="#orgc958737">~/.bash_history</a></li>
<li><a href="#org3f36e93">~/.bash_logout</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org12e35c6">终端的环境设置：stty、set</a></li>
<li><a href="#orgfb543df">通配符与特殊符号</a></li>
</ul>
</li>
<li><a href="#orgaba247c">数据流重定向</a>
<ul>
<li><a href="#org1ad5dc0">什么是数据流重定向</a>
<ul>
<li><a href="#org70d97d2">standard output 与 standard error output</a></li>
<li><a href="#org8a46c2b">/dev/null 垃圾桶黑洞</a></li>
<li><a href="#orgd962618">正确与错误数据同时写入一个文件</a></li>
<li><a href="#orgd452483">standard input</a></li>
</ul>
</li>
<li><a href="#org55c9959">命令执行的判断依据：;、&amp;&amp;、||</a>
<ul>
<li><a href="#org0373790">cmd; cmd（不考虑命令相关性的连续命令执行）</a></li>
<li><a href="#org36db345">$?（命令返回值）与 &amp;&amp; 与 ||</a></li>
<li><a href="#org72920cf">判断式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgcfd7815">管道命令（pipe）</a>
<ul>
<li><a href="#org6e0c1d9">选取命令：cut、grep</a>
<ul>
<li><a href="#org22769ad">cut 选取命令</a></li>
<li><a href="#org6358ce3">grep 查找命令</a></li>
</ul>
</li>
<li><a href="#org8a1be41">排序命令：sort、wc、uniq</a>
<ul>
<li><a href="#orgcd762eb">sort 排序命令</a></li>
<li><a href="#orgc68b3de">uniq 去重命令</a></li>
<li><a href="#org585eb1a">wc 统计字数</a></li>
</ul>
</li>
<li><a href="#orga9effe5">双向重定向：tee</a></li>
<li><a href="#orge0735d5">字符转换命令：tr、col、join、paste、expand</a>
<ul>
<li><a href="#org9131c6c">tr 转换或删除文件中的字符</a></li>
<li><a href="#orga8f730d">col 过滤控制字符</a></li>
<li><a href="#org7a93117">join 将文件中指定栏位内容相同的行连接起来</a></li>
<li><a href="#orgb59ff38">paste 合并文件的列</a></li>
<li><a href="#orgce81452">expand 制表符转换为空白字符</a></li>
</ul>
</li>
<li><a href="#org0ba6916">划分命令：split</a></li>
<li><a href="#org5d23894">参数代换：xargs</a></li>
<li><a href="#orgcdaa971">关于减号【-】的用途</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgf46ba3f" class="outline-2">
<h2 id="orgf46ba3f">什么是 shell</h2>
<div class="outline-text-2" id="text-orgf46ba3f">
<p>
shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。<br>
</p>
</div>
</div>
<div id="outline-container-org7bbc9e1" class="outline-2">
<h2 id="org7bbc9e1">常用的 shell</h2>
<div class="outline-text-2" id="text-org7bbc9e1">
<p>
/etc/shells 文件中列出了可以使用的 shell。<br>
</p>

<dl class="org-dl">
<dt>/bin/sh</dt><dd>已经被 /bin/bash 所替换<br></dd>
<dt>/bin/bash</dt><dd>Linux 默认的 shell<br></dd>
<dt>/bin/tcsh</dt><dd>整合 C Shell，提供更多的功能<br></dd>
<dt>/bin/csh</dt><dd>已经被 /bin/tcsh 所替换<br></dd>
</dl>
</div>
</div>
<div id="outline-container-org8e4bda8" class="outline-2">
<h2 id="org8e4bda8">Bash shell 的功能</h2>
<div class="outline-text-2" id="text-org8e4bda8">
<ul class="org-ul">
<li><p>
历史命令（history）<br>
在命令行按【上下键】就可以找到前后一个输入的命令，在很多 Linux 发行版里，默认的命令条目可以到达 1000 个。<br>
</p>

<p>
这些命令记录在哪里？在家目录下的 .bash_history，不过 ~/.bash_history 记录的是前一次登录以前所执行过的命令，这一次登录执行的命令都被缓存在内存中，当你成功的注销系统后，该命令才会记录到 .bash_history 当中。<br>
</p></li>
<li>命令与文件补全功能<br>
<ul class="org-ul">
<li>[Tab] 接在一串命令的第一个字的后面，则为命令补全；<br></li>
<li>[Tab] 接在一串命令的第二个字的后面，则为文件补齐；<br></li>
<li>若安装 bash-completion 软件，则在某些命令后面使用 [Tab] 按键时，可以进行【选项/参数的补齐】功能；<br></li>
</ul></li>
<li>命令别名设置（alias）<br></li>
<li>任务管理、前台、后台控制（job control、foreground、background）<br>
使用前、后台的控制可以让工作进行的更为顺利！至于任务管理（jobs）的用途则更广， 可以让我们随时将工作丢到后台中执行！而不怕不小心使用了 [Ctrl] + c 来停掉该程序！此外，也可以在单一登陆的环境中，达到多任务的目的呢！<br></li>
<li>程序化脚本<br></li>
<li>通配符<br></li>
</ul>
</div>
</div>
<div id="outline-container-org9101d4f" class="outline-2">
<h2 id="org9101d4f">查询命令是否为 Bash 的内置命令：type<a id="org625be94"></a></h2>
<div class="outline-text-2" id="text-org9101d4f">
<p>
查询命令是来自于外部（非 bash 所提供的命令）或是内置在 bash 中的。<br>
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #268bd2;">type</span> [-tpa] name
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#19981;&#21152;&#20219;&#20309;&#36873;&#39033;&#21644;&#21442;&#25968;&#26102;&#65292;type &#20250;&#26174;&#31034;&#20986; name &#26159;&#22806;&#37096;&#21629;&#20196;&#36824;&#26159; bash &#20869;&#32622;&#21629;&#20196;</span>
</pre>
</div>

<ul class="org-ul">
<li>t：当加入 -t 参数时，type 将 name 以下面这些字眼显示出它的意义：<br>
<ul class="org-ul">
<li>file：表示为外部命令<br></li>
<li>alias：表示该命令为命令别名所设置的名称<br></li>
<li>builtin：表示该命令为 bash 内置的命令功能<br></li>
</ul></li>
<li>p：如果后面接的 name 为外部命令时，才会显示完整的文件名；<br></li>
<li>a：会由 PATH 变量定义的路径中，将所有含 name 的命令都列出来，包含 alias；<br></li>
</ul>
</div>
</div>

<div id="outline-container-orgef339cf" class="outline-2">
<h2 id="orgef339cf">shell 的变量功能</h2>
<div class="outline-text-2" id="text-orgef339cf">
</div>
<div id="outline-container-orgb58bca4" class="outline-3">
<h3 id="orgb58bca4">变量的使用与设置</h3>
<div class="outline-text-3" id="text-orgb58bca4">
<p>
<a href="Shell.html#orgfd33b9c">Shell::变量（variable）</a><br>
</p>
</div>
</div>
<div id="outline-container-org5311303" class="outline-3">
<h3 id="org5311303">环境变量的功能</h3>
<div class="outline-text-3" id="text-org5311303">
<p>
环境变量可以帮我们达到很多功能，包括主文件夹的变换、提示字符的显示、可执行文件搜寻的路径等等， 那么，既然环境变量有那么多的功能，问一下，目前我的 shell 环境中， 有多少默认的环境变量？我们可以利用两个指令来查阅，分别是 <code>env</code> 与 <code>export</code> 呢！<br>
</p>
</div>
<div id="outline-container-orga9b4c7f" class="outline-4">
<h4 id="orga9b4c7f">查看环境变量</h4>
<div class="outline-text-4" id="text-orga9b4c7f">
<div class="org-src-container">
<pre class="src src-bash">$ env         <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#26597;&#30475;&#29615;&#22659;&#21464;&#37327;</span>
$ set         <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#35266;&#23519;&#25152;&#26377;&#21464;&#37327;&#65306;&#29615;&#22659;&#21464;&#37327;&#19982;&#33258;&#23450;&#20041;&#21464;&#37327;</span>
$ export &#21464;&#37327;&#21517;&#31216;      <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33258;&#23450;&#20041;&#21464;&#37327;&#36716;&#25104;&#29615;&#22659;&#21464;&#37327;</span>
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#21487;&#20197;&#20351;&#29992; declare &#23558;&#29615;&#22659;&#21464;&#37327;&#36716;&#25104;&#33258;&#23450;&#20041;&#21464;&#37327;</span>
$ export      <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#26597;&#30475;&#29615;&#22659;&#21464;&#37327;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org552ce82" class="outline-4">
<h4 id="org552ce82">重要的环境变量</h4>
<div class="outline-text-4" id="text-org552ce82">
<dl class="org-dl">
<dt>HOME</dt><dd>用户的根目录；<br></dd>
<dt>SHELL</dt><dd>目前这个环境使用的 shell 是哪个程序；<br></dd>
<dt>MAIL</dt><dd>使用 mail 这个命令在收信时，系统会读取邮箱文件；<br></dd>
<dt>HISTSIZE</dt><dd>历史记录条数；<br></dd>
<dt>PATH</dt><dd>执行文件查找的路径，目录与目录中间以冒号分隔，由于文件的查找是依序由 PATH 的变量内的目录来查询的，所以目录的顺序也很重要；<br></dd>
<dt>LANG</dt><dd>语系数据；<br></dd>
<dt>OSTYPE、HOSTTYPE、MACHTYPE</dt><dd>主机硬件与核心的等级；<br></dd>
<dt>$</dt><dd>目前 shell 的进程号，即 PID（Process ID）；<br></dd>
<dt>?</dt><dd>上一个执行的命令的返回值，如果上一个执行的命令被成功执行了， <code>?</code> 这个特殊的变量就会赋值 0，否则返回错误代码，一般以非 0 的数值替换；<br></dd>
</dl>
</div>
<div id="outline-container-org51fcf18" class="outline-5">
<h5 id="org51fcf18">RANDOM</h5>
<div class="outline-text-5" id="text-org51fcf18">
<p>
随机数的变量，目前大多数的 Linux 发行版都会有随机数生成器，那就是 /dev/random 这个文件。 我们可以通过这个随机数文件相关的变量（$RANDOM）来随机取得随机数。在 BASH 的环境下，这个 RANDOM 变量的内容，介于 0~32767 之间，所以，你只要 echo $RANDOM 时，系统就会主动的随机取出一个介于 0~32767 的数值。万一我想要使用 0~9 之间的数值呢？利用 declare 宣告数值类型， 然后这样做就可以了：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">$ declare -i <span style="color: #8787d7;">number</span>=$<span style="color: #8787d7;">RANDOM</span>*10/32768; <span style="color: #268bd2;">echo</span> $<span style="color: #8787d7;">number</span>
8                     <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&lt;== &#27492;&#26102;&#20250;&#38543;&#26426;&#21462;&#20986; 0~9 &#20043;&#38388;&#30340;&#25968;&#20540;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd65f31b" class="outline-5">
<h5 id="orgd65f31b">PS1</h5>
<div class="outline-text-5" id="text-orgd65f31b">
<p>
命令提示字符：<br>
</p>

<ul class="org-ul">
<li>\d ：可显示出“星期 月 日”的日期格式，如："Mon Feb 2"；<br></li>
<li>\H ：完整的主机名称；<br></li>
<li>\h ：仅取主机名称在第一个小数点之前的名字；<br></li>
<li>\t ：显示时间，为 24 小时格式的“HH:MM:SS”；<br></li>
<li>\T ：显示时间，为 12 小时格式的“HH:MM:SS”；<br></li>
<li>\A ：显示时间，为 24 小时格式的“HH:MM”；<br></li>
<li>\@ ：显示时间，为 12 小时格式的“am/pm”样式；<br></li>
<li>\u ：目前使用者的帐号名称；<br></li>
<li>\v ：BASH 的版本信息，如鸟哥的测试主机版本为 4.2.46（1）-release，仅取“4.2”显示；<br></li>
<li>\w ：完整的工作目录名称，由根目录写起的目录名称，但主文件夹会以 ~ 取代；<br></li>
<li>\W ：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名；<br></li>
<li># ：下达的第几个指令；<br></li>
<li>$ ：提示字符，如果是 root 时，提示字符为 # ，否则就是 $；<br></li>
</ul>

<pre class="example">
CentOS 默认的 PS1 内容：
[\u@\h \W]$ 
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org9af63c1" class="outline-3">
<h3 id="org9af63c1">变量键盘读取、数组与声明</h3>
<div class="outline-text-3" id="text-org9af63c1">
</div>
<div id="outline-container-org55cd3ca" class="outline-4">
<h4 id="org55cd3ca">变量键盘读取：read<a id="orgba454ff"></a></h4>
<div class="outline-text-4" id="text-org55cd3ca">
<pre class="example">
read - read from a file descriptor

- -p :: 提示信息；
- -a :: 将输入的数据进行空格分隔成数组；
- -d :: 设置结束符；
- -t :: 时间限制，规定时间内没有输入变量就会结束该命令；
- -n :: 设置输入的长度；
</pre>
</div>
</div>
<div id="outline-container-orge55cd27" class="outline-4">
<h4 id="orge55cd27">声明：declare<a id="orgd6f4d49"></a></h4>
<div class="outline-text-4" id="text-orge55cd27">
<pre class="example">
declare [-aixr] variable

-a: 将后面名为 variable 的变量定义成为数组（array）类型；
-i: 将后面名为 variable 的变量定义成为整数（integer）类型；
-x: 用法与 export 一样，就是将后面的 variable 变成环境变量；
-r: 将变量设置成为 readonly 类型，该变量不可被更改内容，也不能 unset；
</pre>

<div class="org-src-container">
<pre class="src src-bash">$ declare -i <span style="color: #8787d7;">sum</span>=100+300+50
$ echo ${<span style="color: #8787d7;">sum</span>}
450
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd464d16" class="outline-3">
<h3 id="orgd464d16">与文件系统及程序的限制关系（ulimit）<a id="org668bd12"></a></h3>
<div class="outline-text-3" id="text-orgd464d16">
<p>
<a id="orgac1ba76"></a>想象一个状况：我的 Linux 主机里面同时登陆了十个人，这十个人同时开启了 100 个文件，每个文件的大小约为 10MB。<br>
</p>

<p>
10*100*10 = 10000MB = 10GB，想要满足上面的情况，我的 Linux 主机的内存需要有 10GB&#x2026;&#x2026;，显然我的主机没有那么多的内存，操作系统会挂掉的。<br>
</p>

<p>
为了预防这种情况的发生，我们的 bash 可以限制用户的某些系统资源，包括可以开启的文件数量，可以使用的 CPU 时间，可以使用的内存总量等，该如何设置呢？使用 ulimit：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">$ ulimit [-SHacdfltu] [&#37197;&#39069;]
</pre>
</div>

<ul class="org-ul">
<li>-H：hard limit ，严格的设置，必定不能超过这个设置的数值；<br></li>
<li>-S：soft limit ，警告的设置，可以超过这个设置值，但是若超过则有警告讯息。<br>
<ul class="org-ul">
<li>在设置上，通常 soft 会比 hard 小，举例来说，soft 可设置为 80 而 hard 设置为 100，那么你可以使用到 90 （因为没有超过 100），但介于 80~100 之间时，系统会有警告讯息通知你！<br></li>
</ul></li>
<li>-a：后面不接任何选项与参数，可列出所有的限制额度；<br></li>
<li>-c：当某些程序发生错误时，系统可能会将该程序在内存中的信息写成文件（除错用），<br>
<ul class="org-ul">
<li>这种文件就被称为核心文件（core file）。此为限制每个核心文件的最大容量。<br></li>
</ul></li>
<li>-f：此 shell 可以创建的最大文件大小（一般可能设置为 2GB）单位为 KBytes<br></li>
<li>-d：程序可使用的最大断裂内存（segment）容量；<br></li>
<li>-l：可用于锁定 （lock） 的内存量<br></li>
<li>-t：可使用的最大 CPU 时间 （单位为秒）<br></li>
<li>-u：单一使用者可以使用的最大程序（process）数量。<br></li>
</ul>

<p>
想要复原 ulimit 的设置最简单的方法就是登出再登陆，否则就是得要重新以 ulimit 设置才行！ 不过，要注意的是，一般身份使用者如果以 ulimit 设置了 -f 的文件大小， 那么他“只能继续减小文件大小，不能增加文件大小！”<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org0bb53a2" class="outline-2">
<h2 id="org0bb53a2">命令别名与历史命令</h2>
<div class="outline-text-2" id="text-org0bb53a2">
</div>
<div id="outline-container-org1875b3a" class="outline-3">
<h3 id="org1875b3a">命令别名设置：alias、unalias<a id="org4958f36"></a></h3>
<div class="outline-text-3" id="text-org1875b3a">
<p>
使用 alias 命令，不加任何参数可以查看目前有哪些命名。<br>
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #268bd2;">alias</span> <span style="color: #8787d7;">lm</span>=<span style="color: #2aa198;">'ls -al | more'</span>    <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#26597;&#35810;&#38544;&#34255;&#25991;&#20214;&#65292;&#19988;&#19981;&#24819;&#29992;&#40736;&#26631;&#19968;&#39029;&#19968;&#39029;&#30340;&#32763;&#30475;</span>
<span style="color: #268bd2;">alias</span> <span style="color: #8787d7;">rm</span>=<span style="color: #2aa198;">'rm -i'</span>            <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#27599;&#27425;&#21024;&#38500;&#21069;&#35810;&#38382;&#26159;&#21542;&#21024;&#38500;</span>
</pre>
</div>

<p>
使用 unalias 将别名删除。<br>
</p>
</div>
</div>
<div id="outline-container-orgb6ca417" class="outline-3">
<h3 id="orgb6ca417">历史命令：history<a id="org9c62486"></a></h3>
<div class="outline-text-3" id="text-orgb6ca417">
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #268bd2;">history</span> [n]
<span style="color: #268bd2;">history</span> [-c]
<span style="color: #268bd2;">history</span> [-raw] histfiles
</pre>
</div>

<p>
选项与参数：<br>
</p>

<pre class="example">
n : 列出最近执行的 n 条命令
-c : 将新增的历史命令写入 histfiles 中，若没有加 histfiles，则默认写入 ~/.bash_history
-r : 将 history 的内容读到目前这个 shell 的 history 记录中
-w : 将目前的 history 记录内容写入 histfiles 中
</pre>

<p>
利用历史记录的功能来执行命令：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">$ !number      <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#25191;&#34892;&#31532;&#20960;&#26465;&#21629;&#20196;&#30340;&#24847;&#24605;</span>
$ !command     <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#30001;&#26368;&#36817;&#30340;&#21629;&#20196;&#21521;&#21069;&#26597;&#25214;&#12304;&#21629;&#20196;&#20018;&#24320;&#22836;&#20026; command&#12305;&#30340;&#37027;&#20010;&#21629;&#20196;&#65292;&#24182;&#25191;&#34892;</span>
$ !!           <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#25191;&#34892;&#19978;&#19968;&#20010;&#21629;&#20196;</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org1adb71c" class="outline-2">
<h2 id="org1adb71c">Bash shell 的操作环境</h2>
<div class="outline-text-2" id="text-org1adb71c">
</div>
<div id="outline-container-org883522d" class="outline-3">
<h3 id="org883522d">路径与命令查找顺序</h3>
<div class="outline-text-3" id="text-org883522d">
<p>
命令的运行顺序：<br>
</p>

<ol class="org-ol">
<li>以相对/绝对路径执行指令，例如 "/bin/ls" 或 "./ls"；<br></li>
<li>由 alias 找到该指令来执行；<br></li>
<li>由 bash 内置的（builtin）指令来执行；<br></li>
<li>通过 $PATH 这个变量的顺序搜寻到的第一个指令来执行；<br></li>
</ol>
</div>
</div>
<div id="outline-container-org8dbe1e1" class="outline-3">
<h3 id="org8dbe1e1">bash 的登录与欢迎信息</h3>
<div class="outline-text-3" id="text-org8dbe1e1">
<dl class="org-dl">
<dt>/etc/issue</dt><dd>本机的登录画面<br></dd>
<dt>/etc/issue.net</dt><dd>远程登录的登录画面<br></dd>
<dt>/etc/motd</dt><dd>欢迎信息<br></dd>
</dl>

<p>
issue 内的各代码意义：<br>
</p>

<ul class="org-ul">
<li>\d 本地端时间的日期；<br></li>
<li>\l 显示第几个终端机接口；<br></li>
<li>\m 显示硬件的等级（i386/i486/i586/i686&#x2026;）；<br></li>
<li>\n 显示主机的网络名称；<br></li>
<li>\O 显示 domain name；<br></li>
<li>\r 操作系统的版本（相当于 uname -r）<br></li>
<li>\t 显示本地端时间的时间；<br></li>
<li>&sect; 操作系统的名称；<br></li>
<li>\v 操作系统的版本；<br></li>
</ul>
</div>
</div>
<div id="outline-container-orgef1b5aa" class="outline-3">
<h3 id="orgef1b5aa">bash 的环境配置文件</h3>
<div class="outline-text-3" id="text-orgef1b5aa">
</div>
<div id="outline-container-orgd21c6d7" class="outline-4">
<h4 id="orgd21c6d7">login 与 non-login shell</h4>
<div class="outline-text-4" id="text-orgd21c6d7">
<ul class="org-ul">
<li>login shell：取得 bash 时需要完整的登录流程，就称为 login shell。举例来说，你要由 tty1 ~ tty6 登录，需要输入用户的账号与密码，此时取得的 bash 就称为【login shell】；<br></li>
<li>non-login shell：取得 bash 的方法不需要重复登录的操作<br>
<ul class="org-ul">
<li>以 X Window 登录 Linux 后，该 bash 的环境就称为 non-login shell；<br></li>
<li>再原本的 bash 环境下再次执行 bash 这个命令，同样的没有输入账号密码，那第二个 bash（子进程）也是 non-login shell；<br></li>
</ul></li>
</ul>

<p>
在这两个取得 bash 的情况中，读取的配置文件并不一样，一般来说，login shell 只会读取两个配置文件：<br>
</p>

<ol class="org-ol">
<li>/etc/profile：这是系统整体的设置，最好不要修改这个文件；<br></li>
<li>~/.bash_profile 或 ~/.bash_login 或 ~/.profile：属于用户个人设置，你要添加自己的数据，就写入这里；<br></li>
</ol>
</div>
</div>
<div id="outline-container-org43dd516" class="outline-4">
<h4 id="org43dd516">/etc/profile</h4>
<div class="outline-text-4" id="text-org43dd516">
<p>
该文件设置的变量主要有：<br>
</p>

<dl class="org-dl">
<dt>PATH</dt><dd>根据 UID 决定 PATH 变量要不要含有 sbin 的系统命令目录；<br></dd>
<dt>MAIL</dt><dd>根据账号设置用户的 mailbox 到 /var/spool/mail/账号名；<br></dd>
<dt>USER</dt><dd>根据用户的账号设置此变量内容；<br></dd>
<dt>HOSTNAME</dt><dd>根据主机的 hostname 命令决定；<br></dd>
<dt>HISTSIZE</dt><dd>历史命令记录条数；<br></dd>
<dt>umask</dt><dd>包括 root 默认为 022，而一般用户为 002 等；<br></dd>
</dl>

<p>
/etc/profile 不止会做这些事而已，他还会去调用外部文件：<br>
</p>
</div>
<div id="outline-container-org01daeea" class="outline-5">
<h5 id="org01daeea">/etc/profile.d/*sh</h5>
<div class="outline-text-5" id="text-org01daeea">
<p>
/etc/profile.d/这个目录内且扩展名为 .sh 的文件都会被调用，这个目录下的文件规范了 bash 操作界面的颜色、语系、ll 与 ls 命令的别名、vi 的命令别名、which 的命令别名等。<br>
</p>

<p>
如果你需要帮所有用户设置一些共享的命令别名，可以在这个目录下自行建立扩展名为 .sh 的文件，并将数写入就好。<br>
</p>
</div>
</div>
<div id="outline-container-org28dddb5" class="outline-5">
<h5 id="org28dddb5">/etc/locale.conf</h5>
<div class="outline-text-5" id="text-org28dddb5">
<p>
这个文件是由 /etc/profile.d/lang.sh 调用的，决定 bash 默认使用何种语系，文件中最重要的就是 Lang/LC_ALL 这个变量的设置。<br>
</p>
</div>
</div>
<div id="outline-container-org5d89748" class="outline-5">
<h5 id="org5d89748">/usr/share/bash-completion/completions/*</h5>
<div class="outline-text-5" id="text-org5d89748">
<p>
命令补齐、文件名补齐、参数补全等，这个目录下的内容是由 /etc/profile.d/bash_completion.sh 文件加载的。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org1deb25b" class="outline-4">
<h4 id="org1deb25b">~/.bash_profile</h4>
<div class="outline-text-4" id="text-org1deb25b">
<p>
bash 在读完了整体环境设置的 /etc/profile 并借此调用其他配置文件后，接下来则是会读取使用者的个人配置文件。 在 login shell 的 bash 环境中，所读取的个人偏好配置文件其实主要有三个，依序分别是：<br>
</p>

<ol class="org-ol">
<li>~/.bash_profile<br></li>
<li>~/.bash_login<br></li>
<li>~/.profile<br></li>
</ol>

<p>
其实 bash 的 login shell 设置只会读取上面三个文件的其中一个， 而读取的顺序则是依照上面的顺序。<br>
</p>
</div>
<div id="outline-container-orgde05856" class="outline-5">
<h5 id="orgde05856">source</h5>
<div class="outline-text-5" id="text-orgde05856">
<p>
由于/etc/profile与~/.bash_profile 都是在取得 login shell 的时候才会读取的配置文件，所以， 如果你将自己的偏好设置写入上述的文件后，通常都是得登出再登陆后，该设置才会生效。那么，能不能直接读取配置文件而不登出登陆呢？ 可以的！那就得要利用 source 这个指令了！<br>
</p>

<p>
利用 source 或小数点 （.） 都可以将配置文件的内容读进来目前的 shell 环境中！<br>
</p>
</div>
</div>
<div id="outline-container-org153fb23" class="outline-5">
<h5 id="org153fb23">~/.bashrc</h5>
<div class="outline-text-5" id="text-org153fb23">
<p>
谈完了 login shell 后，那么 non-login shell 这种非登陆情况取得 bash 操作接口的环境配置文件又是什么？ 当你取得 non-login shell 时，该 bash 配置文件仅会读取 ~/.bashrc ！<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org9799988" class="outline-4">
<h4 id="org9799988">其他相关配置文件</h4>
<div class="outline-text-4" id="text-org9799988">
</div>
<div id="outline-container-orgd53e5f4" class="outline-5">
<h5 id="orgd53e5f4">/etc/man_db.conf</h5>
<div class="outline-text-5" id="text-orgd53e5f4">
<p>
规范了使用 man 的时候，man page 的路径到哪里去寻找。<br>
</p>

<p>
那么什么时候要来修改这个文件呢？如果你是以 tarball 的方式来安装你的数据，那么你的 man page 可能会放置在 /usr/local/softpackage/man 里头，那个 softpackage 是你的套件名称， 这个时候你就得以手动的方式将该路径加到 /etc/man_db.conf 里头，否则使用 man 的时候就会找不到相关的说明文档。<br>
</p>
</div>
</div>
<div id="outline-container-orgc958737" class="outline-5">
<h5 id="orgc958737">~/.bash_history</h5>
<div class="outline-text-5" id="text-orgc958737">
<p>
我们执行的命令历史记录就在里面。<br>
</p>
</div>
</div>
<div id="outline-container-org3f36e93" class="outline-5">
<h5 id="org3f36e93">~/.bash_logout</h5>
<div class="outline-text-5" id="text-org3f36e93">
<p>
这个文件则记录了“当我登出 bash 后，系统再帮我做完什么动作后才离开”的意思。 你可以去读取一下这个文件的内容，默认的情况下，登出时， bash 只是帮我们清掉屏幕的讯息而已。不过，你也可以将一些备份或者是其他你认为重要的工作写在这个文件中 （例如清空暂存盘）， 那么当你离开 Linux 的时候，就可以解决一些烦人的事情！<br>
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org12e35c6" class="outline-3">
<h3 id="org12e35c6">终端的环境设置：stty<a id="orgbf513e5"></a>、set<a id="org4a187bd"></a></h3>
<div class="outline-text-3" id="text-org12e35c6">
<p>
使用 stty 可以查看目前的一些按键内容，也可以帮助设置终端的输入按键代表的意义。<br>
</p>

<pre class="example">
stty [-a]

-a: 将目前所有的 stty 参数列出来；
</pre>

<p>
除了 stty 之外，其实我们的 bash 还有自己的一些中断设置值，那就是利用 set 来设置。<br>
</p>

<pre class="example">
set [-uvCHhmBx]

-u: 默认不启用，若启用后，当使用未设置变量时，会显示错误信息；
-v: 默认不启用，若启用后，当信息被输出前，会先显示信息的原始内容；
-x: 默认不启用，若启用后，在命令被执行前，会显示命令内容（前面有 ++ 符号）；
-h: 默认启用，与历史命令有关；
-H: 默认启用，与历史命令有关；
-m: 默认启用，与任务管理有关；
-B: 默认启用，与中括号 [] 的作用有关；
-C: 默认不启用，若使用 &gt; 等，则若文件存在时，该文件不会被覆盖；
</pre>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#19968;&#65306;&#26174;&#31034;&#30446;&#21069;&#25152;&#26377;&#30340; set &#35774;&#32622;&#20540;</span>
$ echo $<span style="color: #8787d7;">-</span>
himBH
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#37027;&#20010; $- &#21464;&#37327;&#20869;&#23481;&#23601;&#26159; set &#30340;&#25152;&#26377;&#35774;&#32622;&#65292;bash &#40664;&#35748;&#26159; himBH</span>
</pre>
</div>

<p>
另外，我们还有其他的按键设置功能，就在 /etc/inputrc 这个文件里设置。还有例如 /etc/DIR_COLORS* 与 /usr/share/terminfo/* 等，也都是与终端有关的环境配置文件。<br>
</p>

<p>
最后，将 bash 默认的组合键汇整如下：<br>
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">组合按键</th>
<th scope="col" class="org-left">执行结果</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Ctrl + C</td>
<td class="org-left">终止目前的命令</td>
</tr>

<tr>
<td class="org-left">Ctrl + D</td>
<td class="org-left">输入结束 （EOF），例如邮件结束的时候；</td>
</tr>

<tr>
<td class="org-left">Ctrl + M</td>
<td class="org-left">就是 Enter 啦！</td>
</tr>

<tr>
<td class="org-left">Ctrl + S</td>
<td class="org-left">暂停屏幕的输出</td>
</tr>

<tr>
<td class="org-left">Ctrl + Q</td>
<td class="org-left">恢复屏幕的输出</td>
</tr>

<tr>
<td class="org-left">Ctrl + U</td>
<td class="org-left">在提示字符下，将整列命令删除</td>
</tr>

<tr>
<td class="org-left">Ctrl + Z</td>
<td class="org-left">“暂停”目前的命令</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgfb543df" class="outline-3">
<h3 id="orgfb543df">通配符与特殊符号</h3>
<div class="outline-text-3" id="text-orgfb543df">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">符号</td>
<td class="org-left">意义</td>
</tr>

<tr>
<td class="org-left">*</td>
<td class="org-left">代表“ 0 个到无穷多个”任意字符</td>
</tr>

<tr>
<td class="org-left">?</td>
<td class="org-left">代表“一定有一个”任意字符</td>
</tr>

<tr>
<td class="org-left">[ ]</td>
<td class="org-left">同样代表“一定有一个在括号内”的字符（非任意字符）。例如 [abcd] 代表“一定有一个字符， 可能是 a, b, c, d 这四个任何一个”</td>
</tr>

<tr>
<td class="org-left">[ - ]</td>
<td class="org-left">若有减号在中括号内时，代表“在编码顺序内的所有字符”。例如 [0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的！</td>
</tr>

<tr>
<td class="org-left">[^]</td>
<td class="org-left">若中括号内的第一个字符为指数符号 （^） ，那表示“反向选择”，例如 [^abc] 代表一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思。</td>
</tr>
</tbody>
</table>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">符号</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">#</td>
<td class="org-left">注解符号：这个最常被使用在 script 当中，视为说明！在后的数据均不执行</td>
</tr>

<tr>
<td class="org-left">\</td>
<td class="org-left">跳脱符号：将“特殊字符或万用字符”还原成一般字符</td>
</tr>

<tr>
<td class="org-left">pipe</td>
<td class="org-left">管线 （pipe）：分隔两个管线命令的界定（后两节介绍）；</td>
</tr>

<tr>
<td class="org-left">;</td>
<td class="org-left">连续指令下达分隔符号：连续性命令的界定 （注意！与管线命令并不相同）</td>
</tr>

<tr>
<td class="org-left">~</td>
<td class="org-left">使用者的主文件夹</td>
</tr>

<tr>
<td class="org-left">$</td>
<td class="org-left">取用变量前置字符：亦即是变量之前需要加的变量取代值</td>
</tr>

<tr>
<td class="org-left">&amp;</td>
<td class="org-left">工作控制 （job control）：将指令变成背景下工作</td>
</tr>

<tr>
<td class="org-left">!</td>
<td class="org-left">逻辑运算意义上的“非” not 的意思！</td>
</tr>

<tr>
<td class="org-left">&gt;, &gt;&gt;</td>
<td class="org-left">数据流重导向：输出导向，分别是“取代”与“累加”</td>
</tr>

<tr>
<td class="org-left">&lt;, &lt;&lt;</td>
<td class="org-left">数据流重导向：输入导向 （这两个留待下节介绍）</td>
</tr>

<tr>
<td class="org-left">' '</td>
<td class="org-left">单引号，不具有变量置换的功能 （$ 变为纯文本）</td>
</tr>

<tr>
<td class="org-left">" "</td>
<td class="org-left">具有变量置换的功能！ （$ 可保留相关功能）</td>
</tr>

<tr>
<td class="org-left">``</td>
<td class="org-left">两个“ ` ”中间为可以先执行的指令，亦可使用 $（ ）</td>
</tr>

<tr>
<td class="org-left">（ ）</td>
<td class="org-left">在中间为子 shell 的起始与结束</td>
</tr>

<tr>
<td class="org-left">{ }</td>
<td class="org-left">在中间为命令区块的组合！</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-orgaba247c" class="outline-2">
<h2 id="orgaba247c">数据流重定向</h2>
<div class="outline-text-2" id="text-orgaba247c">
</div>
<div id="outline-container-org1ad5dc0" class="outline-3">
<h3 id="org1ad5dc0">什么是数据流重定向</h3>
<div class="outline-text-3" id="text-org1ad5dc0">
</div>
<div id="outline-container-org70d97d2" class="outline-4">
<h4 id="org70d97d2">standard output 与 standard error output</h4>
<div class="outline-text-4" id="text-org70d97d2">
<p>
标准输出指的是“指令执行所回传的正确的讯息”，而标准错误输出可理解为“ 指令执行失败后，所回传的错误讯息”。<br>
</p>

<p>
数据流重导向可以将 standard output （简称 stdout） 与 standard error output （简称 stderr） 分别传送到其他的文件或设备去，而分别传送所用的特殊字符则如下所示：<br>
</p>

<ul class="org-ul">
<li>标准输入（stdin）：代码为 0，使用 &lt; 或 &lt;&lt; ；<br></li>
<li>标准输出（stdout）：代码为 1，使用 &gt; 或 &gt;&gt; ；<br></li>
<li>标准错误输出（stderr）：代码为 2，使用 2&gt; 或 2&gt;&gt;<br></li>

<li>1&gt; ：以覆盖的方法将【正确的数据】输出到指定的文件或设备上；<br></li>
<li>1&gt;&gt;：以累加的方法将【正确的数据】输出到指定的文件或设备上；<br></li>
<li>2&gt; ：以覆盖的方法将【错误的数据】输出到指定的文件或设备上；<br></li>
<li>2&gt;&gt;：以累加的方法将【错误的数据】输出到指定的文件或设备上；<br></li>
</ul>
</div>
</div>
<div id="outline-container-org8a46c2b" class="outline-4">
<h4 id="org8a46c2b">/dev/null 垃圾桶黑洞</h4>
<div class="outline-text-4" id="text-org8a46c2b">
<div class="org-src-container">
<pre class="src src-bash">$ find /home -name .bashrc 2&gt; /dev/null
</pre>
</div>

<p>
这个 /dev/null 可以吃掉任何导向这个设备的信息，这里 stderr 就被丢弃了。<br>
</p>
</div>
</div>
<div id="outline-container-orgd962618" class="outline-4">
<h4 id="orgd962618">正确与错误数据同时写入一个文件</h4>
<div class="outline-text-4" id="text-orgd962618">
<div class="org-src-container">
<pre class="src src-bash">$ find /home -name .bashrc &gt; list 2&gt; list      <span style="color: #008787; background-color: #262626;">#  </span><span style="color: #008787; background-color: #262626;">&lt;== &#38169;&#35823;</span>
$ find /home -name .bashrc &gt; list 2&gt;&amp;1         <span style="color: #008787; background-color: #262626;">#  </span><span style="color: #008787; background-color: #262626;">&lt;== &#27491;&#30830;</span>
$ find /home -name .bashrc &amp;&gt; list             <span style="color: #008787; background-color: #262626;">#  </span><span style="color: #008787; background-color: #262626;">&lt;== &#27491;&#30830;</span>

$ echo <span style="color: #2aa198;">"error message"</span> 1&gt;&amp;2
$ echo <span style="color: #2aa198;">"error message"</span> 2&gt; /dev/null 1&gt;&amp;2
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd452483" class="outline-4">
<h4 id="orgd452483">standard input</h4>
<div class="outline-text-4" id="text-orgd452483">
<p>
利用 cat 命令来建立一个文件的简单流程：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">$ cat &gt; catfile
testing
cat file test
&lt;== &#36825;&#37324;&#25353;&#19979; [ctrl]+d &#26469;&#36864;&#20986;

$ cat catfile
testing
cat file test
</pre>
</div>

<p>
由于加入 <code>&gt;</code> 在 cat 之后，所以这个 catfile 文件会被建立，而内容就是刚刚键盘上输入的那两行数据。<br>
</p>

<p>
那我能不能用纯文本文件替换键盘的输入？用 stdin 替换键盘的输入以建立新文件的简单流程：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">$ cat &gt; catfile &lt; ~/.bashrc
</pre>
</div>

<p>
其次是这个 <code>&lt;&lt;</code> 这个符号了，它代表的是【结束的输入字符】的意思：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">$ cat &gt; catfile &lt;&lt; <span style="color: #2aa198;">"eof"</span>
<span style="color: #2aa198;">&gt; This is a test</span>
<span style="color: #2aa198;">&gt; OK now stop</span>
<span style="color: #2aa198;">&gt; eof   &lt;== &#36755;&#20837;&#36825;&#20010;&#20851;&#38190;&#35789;&#65292;&#31435;&#21051;&#32467;&#26463;&#32780;&#19981;&#38656;&#35201;&#36755;&#20837; [ctrl]+d</span>

<span style="color: #2aa198;">$ cat catfile</span>
<span style="color: #2aa198;">This is a test</span>
<span style="color: #2aa198;">OK now stop</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org55c9959" class="outline-3">
<h3 id="org55c9959">命令执行的判断依据：;、&amp;&amp;、||</h3>
<div class="outline-text-3" id="text-org55c9959">
</div>
<div id="outline-container-org0373790" class="outline-4">
<h4 id="org0373790">cmd; cmd（不考虑命令相关性的连续命令执行）</h4>
<div class="outline-text-4" id="text-org0373790">
<p>
关机的时候我希望可以先执行两次 sync 同步写入磁盘后才 shutdown 计算机：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">$ sync; sync; shutdown -h now
</pre>
</div>
</div>
</div>
<div id="outline-container-org36db345" class="outline-4">
<h4 id="org36db345">$?（命令返回值）与 &amp;&amp; 与 ||</h4>
<div class="outline-text-4" id="text-org36db345">
<ul class="org-ul">
<li>cmd1 &amp;&amp; cmd2<br>
<ol class="org-ol">
<li>若 cmd1 执行完毕且正确执行（$?=0），则开始执行 cmd2；<br></li>
<li>若 cmd1 执行完毕且为错误（$?≠0），则 cmd2 不执行；<br></li>
</ol></li>
<li>cmd1 || cmd2<br>
<ol class="org-ol">
<li>若 cmd1 执行完毕且正确执行（$?=0），则 cmd2 不执行；<br></li>
<li>若 cmd1 执行完毕且为错误（$?≠0），则开始执行 cmd2；<br></li>
</ol></li>
</ul>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#20351;&#29992; ls &#26597;&#30475;&#30446;&#24405; /tmp/abc &#26159;&#21542;&#23384;&#22312;&#65292;&#33509;&#23384;&#22312;&#21017;&#29992; touch &#24314;&#31435; /tmp/abc/hehe</span>
$ ls /tmp/abc &amp;&amp; touch /tmp/abc/hehe
ls: cannot access /tmp/abc: No such file or directory
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">ls &#25214;&#19981;&#21040;&#35813;&#30446;&#24405;&#65292;&#20294;&#27809;&#26377; touch &#30340;&#38169;&#35823;&#65292;&#35828;&#26126; touch &#24182;&#27809;&#26377;&#25191;&#34892;</span>

$ mkdir /tmp/abc
$ ls /tmp/abc &amp;&amp; touch /tmp/abc/hehe
</pre>
</div>

<p>
如果 /tmp/abc 不存在时，touch 就不会被执行，若 /tmp/abc 存在的话，那么 touch 就会开始执行。不过我们还是要手动建立目录，那能不能自动判断，如果没有该目录就创建这个目录？<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">$ ls /tmp/abc || mkdir /tmp/abc &amp;&amp; touch /tmp/abc/hehe
</pre>
</div>
</div>
</div>
<div id="outline-container-org72920cf" class="outline-4">
<h4 id="org72920cf">判断式</h4>
<div class="outline-text-4" id="text-org72920cf">
<div class="org-src-container">
<pre class="src src-bash">command1 &amp;&amp; command2 || command3
</pre>
</div>

<p>
以 ls 测试 /tmp/abc 是否存在，若存在则显示 "exist"；若不存在，则显示 "not exist"<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">ls /tmp/abc &amp;&amp; <span style="color: #268bd2;">echo</span> <span style="color: #2aa198;">"exist"</span> || <span style="color: #268bd2;">echo</span> <span style="color: #2aa198;">"not exist"</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgcfd7815" class="outline-2">
<h2 id="orgcfd7815">管道命令（pipe）</h2>
<div class="outline-text-2" id="text-orgcfd7815">
</div>
<div id="outline-container-org6e0c1d9" class="outline-3">
<h3 id="org6e0c1d9">选取命令：cut、grep</h3>
<div class="outline-text-3" id="text-org6e0c1d9">
</div>
<div id="outline-container-org22769ad" class="outline-4">
<h4 id="org22769ad">cut 选取命令<a id="org9d07411"></a></h4>
<div class="outline-text-4" id="text-org22769ad">
<p>
Linux cut 命令用于显示每行从开头算起 num1 到 num2 的文字。<br>
</p>

<pre class="example">
-f: 根据 -d 的分隔字符将一段信息划分成为数段，用 -f 取出第几段的意思；
-d: 后面接分隔字符，与 -f 一起使用；
-c: 以字符（character）的单位取出固定字符区间；
</pre>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#19968;&#65306;&#21462;&#20986; PATH &#30340;&#31532;&#20116;&#20010;&#36335;&#24452;</span>
$ echo ${<span style="color: #8787d7;">PATH</span>}
/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin

<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#20197; ':' &#20998;&#38548;&#21462;&#31532;&#20116;&#20010;</span>
$ echo ${<span style="color: #8787d7;">PATH</span>} | cut -d <span style="color: #2aa198;">':'</span> -f 5

<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#21462;&#20986; PATH &#30340;&#31532;&#19977;&#19982;&#31532;&#20116;&#20010;</span>
$ echo ${<span style="color: #8787d7;">PATH</span>} | cut -d <span style="color: #2aa198;">':'</span> -f 3,5

<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#21462;&#20986; PATH &#30340;&#31532;&#19977;&#12289;&#31532;&#22235;&#19982;&#31532;&#20116;&#20010;</span>
$ echo ${<span style="color: #8787d7;">PATH</span>} | cut -d <span style="color: #2aa198;">':'</span> -f 3,4,5
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#20108;&#65306;&#21462;&#24471;&#23558; export &#36755;&#20986;&#30340;&#20449;&#24687;&#31532; 12 &#23383;&#31526;&#20197;&#21518;&#30340;&#25152;&#26377;&#23383;&#31526;</span>
<span style="color: #268bd2;">export</span> | cut -c 12-

<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">12-20 &#26159;&#25351;&#23450;&#33539;&#22260;&#30340;&#20540;</span>
<span style="color: #268bd2;">export</span> | cut -c 12-20
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#19977;&#65306;&#29992; last &#23558;&#26174;&#31034;&#30340;&#30331;&#24405;&#32773;&#30340;&#20449;&#24687;&#65292;&#20351;&#29992; cut &#20999;&#20986;&#20351;&#29992;&#32773;&#21517;&#23383;&#37096;&#20998;</span>
last | cut -d <span style="color: #2aa198;">' '</span> -f 1
</pre>
</div>
</div>
</div>
<div id="outline-container-org6358ce3" class="outline-4">
<h4 id="org6358ce3">grep 查找命令<a id="org4b66a3b"></a></h4>
<div class="outline-text-4" id="text-org6358ce3">
<p>
用于查找文件里符合条件的字符串。<br>
</p>

<pre class="example">
grep [-acinv] [--color=auto] '查找字符' filename

-a: 将二进制文件以文本文件的方式查找数据；
-c: 计算找到 '查找字符' 的次数；
-i: 忽略大小写的不同，所以大小写视为相同；
-n: 顺便输出行号；
-v: 反向选择，即显示出没有 '查找字符' 内容的那一行；
--color=auto: 可以将找到的关键字部分加上颜色的显示；
</pre>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#19968;&#65306;&#23558; last &#20013;&#65292;&#20986;&#29616; root &#30340;&#37027;&#19968;&#34892;&#26174;&#31034;&#20986;&#26469;</span>
last | grep <span style="color: #2aa198;">'root'</span>

<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#20108;&#65306;&#19982;&#33539;&#20363;&#19968;&#30456;&#21453;&#65292;&#21462;&#20986;&#27809;&#26377; root &#30340;&#37027;&#19968;&#34892;</span>
last | grep -v <span style="color: #2aa198;">'root'</span>

<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#19977;&#65306;&#22312; last &#30340;&#36755;&#20986;&#20449;&#24687;&#20013;&#65292;&#21482;&#35201;&#26377; root &#23601;&#21462;&#20986;&#65292;&#24182;&#19988;&#20165;&#21462;&#31532;&#19968;&#26639;</span>
last | grep <span style="color: #2aa198;">'root'</span> | cut -d <span style="color: #2aa198;">' '</span> -f 1

<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#22235;&#65306;&#21462;&#20986; /etc/man_db.conf &#20869;&#21547; MANPATH &#30340;&#37027;&#20960;&#34892;</span>
grep --color=auto <span style="color: #2aa198;">'MANPATH'</span> /etc/man_db.conf
</pre>
</div>

<p>
<a href="Linux-正则表达式与文件格式化处理.html">grep的高级用法</a><br>
</p>
</div>
</div>
</div>
<div id="outline-container-org8a1be41" class="outline-3">
<h3 id="org8a1be41">排序命令：sort、wc、uniq</h3>
<div class="outline-text-3" id="text-org8a1be41">
</div>
<div id="outline-container-orgcd762eb" class="outline-4">
<h4 id="orgcd762eb">sort 排序命令<a id="org256bdee"></a></h4>
<div class="outline-text-4" id="text-orgcd762eb">
<p>
sort 可以根据不同的数据形态来排序，例如数字与文字的排序就不同。此外，排序的字符与语系的编码有关，因此，如果需要排序时，建议使用 LANG=C 来让语系统一。<br>
</p>

<pre class="example">
sort [-fbMnrtuk] [file or stdin]

-f: 忽略大小写的差异；
-b: 忽略最前面的空格字符部分；
-M: 以月份的名字来排序，例如 JAN、DEC 等的排序方法；
-n: 使用【纯数字】进行排序（默认是以文字形式来排序的）；
-r: 反向排序；
-u: 就是 uniq，相同的数据中，仅出现一行代表；
-t: 分隔符号，默认是用 [Tab] 键来分隔；
-k: 以哪个区间（field）来进行排序的；
</pre>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#19968;&#65306;&#20010;&#20154;&#36134;&#21495;&#37117;&#35760;&#24405;&#22312; /etc/passwd &#19979;&#65292;&#35831;&#23558;&#36134;&#21495;&#36827;&#34892;&#25490;&#24207;</span>
cat /etc/passwd | sort

<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#20108;&#65306;/etc/passwd &#26159;&#20197; ':' &#26469;&#20998;&#38548;&#30340;&#65292;&#22914;&#20309;&#20197;&#31532;&#19977;&#26639;&#36827;&#34892;&#25490;&#24207;</span>
cat /etc/passwd | sort -t <span style="color: #2aa198;">':'</span> -k 3
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#31532;&#19977;&#26639;&#26159;&#25968;&#23383;&#65292;&#25152;&#20197; 1000 &#20250;&#22312; 2 &#21069;&#38754;&#65292;&#25152;&#20197;&#25105;&#20204;&#38656;&#35201;&#20351;&#29992; -n &#21442;&#25968;</span>
cat /etc/passwd | sort -t <span style="color: #2aa198;">':'</span> -k 3 -n

<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#19977;&#65306;&#21033;&#29992; last&#65292;&#20165;&#26174;&#31034;&#36755;&#20986;&#25968;&#25454;&#30340;&#36134;&#21495;&#65292;&#24182;&#21152;&#20197;&#25490;&#24207;</span>
last | cut -d <span style="color: #2aa198;">' '</span> -f1 | sort
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc68b3de" class="outline-4">
<h4 id="orgc68b3de">uniq 去重命令<a id="org279467d"></a></h4>
<div class="outline-text-4" id="text-orgc68b3de">
<p>
用于检查及删除文本中重复出现的行列，一般与 sort 命令结合使用。<br>
</p>

<pre class="example">
uniq [-ic]

-i: 忽略大小写字符的不同；
-c: 进行计数；
</pre>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#19968;&#65306;&#20351;&#29992; last &#23558;&#36134;&#21495;&#21015;&#20986;&#65292;&#20165;&#21462;&#20986;&#36134;&#21495;&#26639;&#65292;&#36827;&#34892;&#25490;&#24207;&#21518;&#20165;&#21462;&#20986;&#19968;&#20301;</span>
last | cut -d <span style="color: #2aa198;">' '</span> -f 1 | sort | uniq

<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#20108;&#65306;&#25215;&#19978;&#39064;&#65292;&#22914;&#26524;&#25105;&#36824;&#24819;&#30693;&#36947;&#27599;&#20010;&#20154;&#30340;&#30331;&#24405;&#24635;&#27425;&#25968;&#65311;</span>
last | cut -d <span style="color: #2aa198;">' '</span> -f 1 | sort | uniq -c
</pre>
</div>
</div>
</div>
<div id="outline-container-org585eb1a" class="outline-4">
<h4 id="org585eb1a">wc 统计字数<a id="org38b1b24"></a></h4>
<div class="outline-text-4" id="text-org585eb1a">
<p>
用于计算字数。<br>
</p>

<pre class="example">
wc [-lwm]

-l: 仅列出行；
-w: 仅列出多少字；
-m: 多少字符；
</pre>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#19968;&#65306;/etc/man db.conf &#37324;&#38754;&#26377;&#22810;&#23569;&#23383;&#12289;&#34892;&#12289;&#23383;&#31526;&#25968;&#65311;</span>
cat /etc/man_db.conf | wc

<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#20108;&#65306;&#20351;&#29992; last &#21487;&#20197;&#36755;&#20986;&#30331;&#38470;&#32773;&#65292;&#20294;&#26159; last &#26368;&#21518;&#20004;&#34892;&#24182;&#38750;&#24080;&#21495;&#20869;&#23481;&#65292;&#37027;&#20040;&#35831;&#38382;&#65292;&#35813;&#22914;&#20309;&#20197;&#19968;&#34892;&#25351;&#20196;&#20018;&#21462;&#24471;&#30331;&#38470;&#31995;&#32479;&#30340;&#24635;&#20154;&#27425;&#65311;</span>
last | grep [a-zA-Z] | grep -v <span style="color: #2aa198;">'wtmp'</span> | grep -v <span style="color: #2aa198;">'reboot'</span> | <span style="color: #2aa198;">\</span>
&gt; grep -v <span style="color: #2aa198;">'unknown'</span> | wc -l

<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#30001;&#20110; last &#20250;&#36755;&#20986;&#31354;&#30333;&#34892;, wtmp, unknown, reboot &#31561;&#26080;&#20851;&#24080;&#21495;&#30331;&#38470;&#30340;&#20449;&#24687;&#65292;&#22240;&#27492;&#65292;&#21033;&#29992;</span>
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">grep &#21462;&#20986;&#38750;&#31354;&#30333;&#34892;&#65292;&#20197;&#21450;&#21435;&#38500;&#19978;&#36848;&#20851;&#38190;&#23383;&#37027;&#20960;&#34892;&#65292;&#20877;&#35745;&#31639;&#34892;&#25968;&#65292;&#23601;&#33021;&#22815;&#24471;&#21040;&#32467;&#26524;</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orga9effe5" class="outline-3">
<h3 id="orga9effe5">双向重定向：tee<a id="org94ff101"></a></h3>
<div class="outline-text-3" id="text-orga9effe5">
<p>
想个简单的东西，我们由前一节知道 <code>&gt;</code> 会将数据流整个传送给文件或设备，因此我们除非去读取该文件或设备， 否则就无法继续利用这个数据流。万一我想要将这个数据流的处理过程中将某段讯息存下来，应该怎么做？利用 tee 就可以。<br>
</p>

<p>
tee 会同时将数据流分送到文件去与屏幕 （screen）；而输出到屏幕的，其实就是 stdout ，那就可以让下个指令继续处理！<br>
</p>

<pre class="example">
tee [-a] file

-a ：以累加 （append） 的方式，将数据加入 file 当中！
</pre>

<div class="org-src-container">
<pre class="src src-bash">$ last | tee last.list | cut -d <span style="color: #2aa198;">" "</span> -f1
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#36825;&#20010;&#33539;&#20363;&#21487;&#20197;&#35753;&#25105;&#20204;&#23558; last &#30340;&#36755;&#20986;&#23384;&#19968;&#20221;&#21040; last.list &#25991;&#20214;&#20013;&#65307;</span>

ls -l /home | tee ~/homefile | more
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#36825;&#20010;&#33539;&#20363;&#21017;&#26159;&#23558; ls &#30340;&#25968;&#25454;&#23384;&#19968;&#20221;&#21040; ~/homefile &#65292;&#21516;&#26102;&#23631;&#24149;&#20063;&#26377;&#36755;&#20986;&#35759;&#24687;&#65281;</span>

ls -l / | tee -a ~/homefile | more
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#35201;&#27880;&#24847;&#65281; tee &#21518;&#25509;&#30340;&#25991;&#20214;&#20250;&#34987;&#35206;&#30422;&#65292;&#33509;&#21152;&#19978; -a &#36825;&#20010;&#36873;&#39033;&#21017;&#33021;&#23558;&#35759;&#24687;&#32047;&#21152;&#12290;</span>
</pre>
</div>

<p>
tee 可以让 standard output 转存一份到文件内并将同样的数据继续送到屏幕去处理！这样除了可以让我们同时分析一份数据并记录下来之外，还可以作为处理一份数据的中间暂存盘记录之用！<br>
</p>
</div>
</div>
<div id="outline-container-orge0735d5" class="outline-3">
<h3 id="orge0735d5">字符转换命令：tr、col、join、paste、expand</h3>
<div class="outline-text-3" id="text-orge0735d5">
</div>
<div id="outline-container-org9131c6c" class="outline-4">
<h4 id="org9131c6c">tr 转换或删除文件中的字符<a id="org39fd114"></a></h4>
<div class="outline-text-4" id="text-org9131c6c">
<pre class="example">
tr [-ds] SET1 ...

-d: 删除信息当中的 SET1 这个字符；
-s: 替换掉重复的字符；
</pre>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#19968;&#65306;&#23558; last &#36755;&#20986;&#30340;&#20449;&#24687;&#20013;&#65292;&#25152;&#26377;&#23567;&#20889;&#21464;&#25104;&#22823;&#20889;&#23383;&#31526;</span>
$ last | tr <span style="color: #2aa198;">'[a-z]'</span> <span style="color: #2aa198;">'[A-Z]'</span>

<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#20108;&#65306;&#23558; /etc/passwd &#36755;&#20986;&#30340;&#20449;&#24687;&#20013;&#65292;&#23558;&#20882;&#21495; ':' &#21024;&#38500;</span>
$ cat /etc/passwd | tr -d <span style="color: #2aa198;">':'</span>

<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#19977;&#65306;&#23558; /etc/passwd &#36716;&#25442;&#25104; dos &#25442;&#34892;&#21040; /root/passwd &#20013;&#65292;&#20877;&#23558; ^M &#31526;&#21495;&#21024;&#38500;</span>
$ cp /etc/passwd ~/passwd &amp;&amp; unix2dos ~/passwd
$ file /etc/passwd ~/passwd
/etc/passwd: ASCII text
/home/haoran/passwd: ASCII text, with CRLF line terminators   &lt;== &#23601;&#26159; DOS &#25442;&#34892;

$ cat ~/passwd | tr -d <span style="color: #2aa198;">'\r'</span> &gt; ~/passwd.Linux
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">\r &#25351;&#30340;&#23601;&#26159; DES &#30340;&#25442;&#34892;&#31526;&#65292;&#20851;&#20110;&#26356;&#22810;&#30340;&#23383;&#31526;&#65292;&#35831;&#21442;&#32771; man tr</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orga8f730d" class="outline-4">
<h4 id="orga8f730d">col 过滤控制字符<a id="org4b08f8b"></a></h4>
<div class="outline-text-4" id="text-orga8f730d">
<pre class="example">
col [-xb]

-x:  将 tab 键转换成对等的空格键
</pre>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#19968;&#65306;&#21033;&#29992; cat -A &#26174;&#31034;&#20986;&#25152;&#26377;&#29305;&#27530;&#25353;&#38190;&#65292;&#26368;&#21518;&#20197; col &#23558; [tab] &#36716;&#25104;&#31354;&#30333;</span>
cat -A /etc/man_db.conf   &lt;== &#27492;&#26102;&#20250;&#30475;&#21040;&#24456;&#22810; ^I &#30340;&#31526;&#21495;&#65292;&#36825;&#23601;&#26159; [tab]
cat /etc/man_db.conf | col -x | cat -A | mort
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#22914;&#27492;&#19968;&#26469;&#65292;[tab] &#25353;&#38190;&#23601;&#20250;&#34987;&#26367;&#20195;&#20026;&#31354;&#26684;&#38190;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org7a93117" class="outline-4">
<h4 id="org7a93117">join 将文件中指定栏位内容相同的行连接起来<a id="orgede80b5"></a></h4>
<div class="outline-text-4" id="text-org7a93117">
<p>
将两个文件有相同数据的那一行加在一起。<br>
</p>

<pre class="example">
join [-ti12] file1 file2

-t: join 默认以空格字符分隔数据，并且比对【第一个栏位】的数据，如果两个文件相同，则将两条数据连成一行，且第一个栏位放在第一个；
-i: 忽略大小写差异；
-1: 第一个文件要用哪个栏位进行分析；
-2: 第二个文件要用哪个栏位进行分析；
</pre>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#19968;&#65306;&#29992; root &#30340;&#36523;&#20221;&#65292;&#23558; /etc/passwd &#19982; /etc/shadow &#30456;&#20851;&#25968;&#25454;&#25972;&#21512;&#25104;&#19968;&#26639;</span>
$ head -n 3 /etc/passwd /etc/shadow
==&gt; /etc/passwd &lt;==
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin

==&gt; /etc/shadow &lt;==
root:$<span style="color: #8787d7;">6</span>$<span style="color: #8787d7;">wtbCCce</span>/PxMeE5wm$<span style="color: #8787d7;">KE2IfSJr</span>...:16559:0:99999:7:::
bin:*:16372:0:99999:7:::
daemon:*:16372:0:99999:7:::
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#30001;&#36755;&#20986;&#30340;&#25968;&#25454;&#21487;&#20197;&#21457;&#29616;&#36825;&#20004;&#20010;&#25991;&#20214;&#30340;&#26368;&#24038;&#36793;&#23383;&#27573;&#37117;&#26159;&#30456;&#21516;&#24080;&#21495;&#65281;&#19988;&#20197; : &#20998;&#38548;</span>

$ join -t <span style="color: #2aa198;">':'</span> /etc/passwd /etc/shadow | head -n 3
root:x:0:0:root:/root:/bin/bash:$<span style="color: #8787d7;">6</span>$<span style="color: #8787d7;">wtbCCce</span>/PxMeE5wm$<span style="color: #8787d7;">KE2IfSJr</span>...:16559:0:99999:7:::
bin:x:1:1:bin:/bin:/sbin/nologin:*:16372:0:99999:7:::
daemon:x:2:2:daemon:/sbin:/sbin/nologin:*:16372:0:99999:7:::

<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#36890;&#36807;&#19978;&#38754;&#36825;&#20010;&#21160;&#20316;&#65292;&#25105;&#20204;&#21487;&#20197;&#23558;&#20004;&#20010;&#25991;&#20214;&#31532;&#19968;&#23383;&#27573;&#30456;&#21516;&#32773;&#25972;&#21512;&#25104;&#19968;&#21015;&#65281;</span>
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#31532;&#20108;&#20010;&#25991;&#20214;&#30340;&#30456;&#21516;&#23383;&#27573;&#24182;&#19981;&#20250;&#26174;&#31034;&#65288;&#22240;&#20026;&#24050;&#32463;&#22312;&#26368;&#24038;&#36793;&#30340;&#23383;&#27573;&#20986;&#29616;&#20102;&#21834;&#65281;&#65289;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#20108;&#65306;&#25105;&#20204;&#30693;&#36947; /etc/passwd &#31532;&#22235;&#20010;&#23383;&#27573;&#26159; GID &#65292;&#37027;&#20010; GID &#35760;&#24405;&#22312; /etc/group &#24403;&#20013;&#30340;&#31532;&#19977;&#20010;&#23383;&#27573;&#65292;&#35831;&#38382;&#22914;&#20309;&#23558;&#20004;&#20010;&#25991;&#20214;&#25972;&#21512;&#65311;</span>
$ head -n 3 /etc/passwd /etc/group
==&gt; /etc/passwd &lt;==
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
==&gt; /etc/group &lt;==
root:x:0:
bin:x:1:
daemon:x:2:
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#20174;&#19978;&#38754;&#21487;&#20197;&#30475;&#21040;&#65292;&#30830;&#23454;&#26377;&#30456;&#21516;&#30340;&#37096;&#20998;&#21908;&#65281;&#36214;&#32039;&#26469;&#25972;&#21512;&#19968;&#19979;&#65281;</span>

$ join -t <span style="color: #2aa198;">':'</span> -1 4 /etc/passwd -2 3 /etc/group | head -n 3
0:root:x:0:root:/root:/bin/bash:root:x:
1:bin:x:1:bin:/bin:/sbin/nologin:bin:x:
2:daemon:x:2:daemon:/sbin:/sbin/nologin:daemon:x:
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#21516;&#26679;&#30340;&#65292;&#30456;&#21516;&#30340;&#23383;&#27573;&#37096;&#20998;&#34987;&#31227;&#21160;&#21040;&#26368;&#21069;&#38754;&#20102;&#65281;&#25152;&#20197;&#31532;&#20108;&#20010;&#25991;&#20214;&#30340;&#20869;&#23481;&#23601;&#27809;&#20877;&#26174;&#31034;&#12290;</span>
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#35831;&#35835;&#32773;&#20204;&#37197;&#21512;&#19978;&#36848;&#26174;&#31034;&#20004;&#20010;&#25991;&#20214;&#30340;&#23454;&#38469;&#20869;&#23481;&#26469;&#27604;&#23545;&#65281;</span>
</pre>
</div>

<p>
此外，需要特别注意的是，在使用 join 之前，你所需要处理的文件应该要事先经过排序（sort） 处理！ 否则有些比对的项目会被略过！<br>
</p>
</div>
</div>
<div id="outline-container-orgb59ff38" class="outline-4">
<h4 id="orgb59ff38">paste 合并文件的列<a id="orgefffa3d"></a></h4>
<div class="outline-text-4" id="text-orgb59ff38">
<p>
paste 命令要比 join 简单，相对于 join 必须要比对两个文件的数据相关性，paste 就直接将两行贴在一起，且中间以 [Tab] 键隔开。<br>
</p>

<pre class="example">
paste [-d] file1 file2

-d: 后面可以接分隔字符，默认是以 [Tab] 来分割；
-: 如果 file 部分写成 -，表示来自标准输入的数据的意思；
</pre>

<div class="org-src-container">
<pre class="src src-bash">&#33539;&#20363;&#19968;&#65306;&#29992; root &#36523;&#20221;&#65292;&#23558; /etc/passwd &#19982; /etc/shadow &#21516;&#19968;&#34892;&#36148;&#22312;&#19968;&#36215;
paste /etc/passwd /etc/shadow
root:x:0:0:root:/root:/bin/bash root:$<span style="color: #8787d7;">6</span>$<span style="color: #8787d7;">wtbCCce</span>/PxMeE5wm$<span style="color: #8787d7;">KE2IfSJr</span>...:16559:0:99999:7:::
bin:x:1:1:bin:/bin:/sbin/nologin bin:*:16372:0:99999:7:::
daemon:x:2:2:daemon:/sbin:/sbin/nologin daemon:*:16372:0:99999:7:::
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#27880;&#24847;&#21908;&#65281;&#21516;&#19968;&#34892;&#20013;&#38388;&#26159;&#20197; [tab] &#25353;&#38190;&#38548;&#24320;&#30340;&#65281;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash">&#33539;&#20363;&#20108;&#65306;&#20808;&#23558; /etc/group &#35835;&#20986;&#65292;&#28982;&#21518;&#19982;&#33539;&#20363;&#19968;&#36148;&#19978;&#19968;&#36215;&#65292;&#19988;&#20165;&#21462;&#20986;&#21069;&#19977;&#34892;
cat /etc/group | paste /etc/passwd /etc/shadow - | head -n 3
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#36825;&#20010;&#20363;&#23376;&#30340;&#37325;&#28857;&#22312;&#36825;&#20010; - &#30340;&#20351;&#29992;&#65292;&#37027;&#29609;&#24847;&#24120;&#24120;&#20195;&#34920; stdin</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgce81452" class="outline-4">
<h4 id="orgce81452">expand 制表符转换为空白字符<a id="org7e5875d"></a></h4>
<div class="outline-text-4" id="text-orgce81452">
<pre class="example">
expand [-t] file

-t: 后面可接数字，一般来说一个 Tab 按键可以用 8 个空格键替换，我们也可以自行定义一个 [Tab] 按键代表多少个字符
</pre>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#19968;&#65306;&#23558; /etc/man_db.conf &#20869;&#34892;&#39318;&#20026; MANPATH &#30340;&#34892;&#21462;&#20986;&#65292;&#19988;&#20165;&#21462;&#21069;&#19977;&#34892;</span>
$ grep <span style="color: #2aa198;">'^MANPATH'</span> /etc/man_db.conf | head -n 3
MANPATH_MAP /bin /usr/share/man
MANPATH_MAP /usr/bin /usr/share/man
MANPATH_MAP /sbin /usr/share/man
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash">&#33539;&#20363;&#20108;&#65306;&#25215;&#19978;&#65292;&#23558;&#25152;&#26377;&#30340;&#31526;&#21495;&#37117;&#21015;&#20986;&#26469;
$ grep <span style="color: #2aa198;">'^MANPATH'</span> /etc/man_db.conf | head -n 3 | cat -A
MANPATH_MAP^I/bin^I^I^I/usr/share/man$
MANPATH_MAP^I/usr/bin^I^I/usr/share/man$
MANPATH_MAP^I/sbin^I^I^I/usr/share/man$
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#21457;&#29616;&#24046;&#21035;&#20102;&#21527;&#65311;&#27809;&#38169;&#65374; [tab] &#25353;&#38190;&#21487;&#20197;&#34987; cat -A &#26174;&#31034;&#25104;&#20026; ^I</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash">&#33539;&#20363;&#19977;&#65306;&#25215;&#19978;&#65292;&#23558; [tab] &#25353;&#38190;&#35774;&#32622;&#25104; 6 &#20010;&#23383;&#31526;
$ grep <span style="color: #2aa198;">'^MANPATH'</span> /etc/man_db.conf | head -n 3 | expand -t 6 - | cat -A
MANPATH_MAP /bin /usr/share/man$
MANPATH_MAP /usr/bin /usr/share/man$
MANPATH_MAP /sbin /usr/share/man$
123456123456123456123456123456123456123456123456...
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org0ba6916" class="outline-3">
<h3 id="org0ba6916">划分命令：split<a id="org1dedc67"></a></h3>
<div class="outline-text-3" id="text-org0ba6916">
<pre class="example">
split [-bl] file PREFIX

-b: 后面可接欲分区成的文件大小，可加单位，例如 b, k, m 等；
-l: 以行数来进行分区。
PREFIX: 代表前置字符的意思，可作为分区文件的前导文字。
</pre>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#19968;&#65306;/etc/services &#26377;&#20845;&#30334;&#22810;K&#65292;&#23558;&#23427;&#20998;&#25104; 300K &#19968;&#20010;&#25991;&#20214;&#26102;</span>
$ cd /tmp; split -b 300k /etc/services services
$ ll -k services*
-rw-rw-r--. 1 haoran haoran 307200 Jul 9 22:52 servicesaa
-rw-rw-r--. 1 haoran haoran 307200 Jul 9 22:52 servicesab
-rw-rw-r--. 1 haoran haoran 55893 Jul 9 22:52 servicesac
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#37027;&#20010;&#25991;&#20214;&#21517;&#21487;&#20197;&#38543;&#24847;&#21462;&#65281;&#21482;&#35201;&#20889;&#19978;&#21069;&#23548;&#25991;&#23383;&#65292;&#23567;&#25991;&#20214;&#23601;&#20250;&#20197;</span>
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">xxxaa, xxxab, xxxac &#31561;&#26041;&#24335;&#26469;&#21019;&#24314;&#23567;&#25991;&#20214;&#30340;&#65281;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#20108;&#65306;&#22914;&#20309;&#23558;&#19978;&#38754;&#30340;&#19977;&#20010;&#23567;&#25991;&#20214;&#21512;&#25104;&#19968;&#20010;&#25991;&#20214;&#65292;&#25991;&#20214;&#21517;&#20026; servicesback</span>
$ cat services* &gt;&gt; servicesback
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#24456;&#31616;&#21333;&#21543;&#65311;&#23601;&#29992;&#25968;&#25454;&#27969;&#37325;&#23548;&#21521;&#23601;&#22909;&#21862;&#65281;&#31616;&#21333;&#65281;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#19977;&#65306;&#20351;&#29992; ls -al / &#36755;&#20986;&#30340;&#20449;&#24687;&#20013;&#65292;&#27599;&#21313;&#34892;&#35760;&#24405;&#25104;&#19968;&#20010;&#25991;&#20214;</span>
$ ls -al / | split -l 10 - lsroot
$ wc -l lsroot*
10 lsrootaa
10 lsrootab
4 lsrootac
24 total
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#37325;&#28857;&#22312;&#37027;&#20010; - &#65281;&#19968;&#33324;&#26469;&#35828;&#65292;&#22914;&#26524;&#38656;&#35201; stdout/stdin &#26102;&#65292;&#20294;&#20559;&#20559;&#21448;&#27809;&#26377;&#25991;&#20214;&#65292;</span>
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#26377;&#30340;&#21482;&#26159; - &#26102;&#65292;&#37027;&#20040;&#37027;&#20010; - &#23601;&#20250;&#34987;&#24403;&#25104; stdin &#25110; stdout</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org5d23894" class="outline-3">
<h3 id="org5d23894">参数代换：xargs<a id="orgeaf01a3"></a></h3>
<div class="outline-text-3" id="text-org5d23894">
<p>
xargs 是在做什么的呢？就以字面上的意义来看， x 是加减乘除的乘号，args 则是 arguments（参数）的意思，所以说，这个玩意儿就是在产生某个指令的参数的意思！xargs 可以读入 stdin 的数据，并且以空白字符或断行字符作为分辨，将 stdin 的数据分隔成为 arguments 。 因为是以空白字符作为分隔，所以，如果有一些文件名或者是其他意义的名词内含有空白字符的时候， xargs 可能就会误判了。<br>
</p>

<pre class="example">
xargs [-0epn] command

-0: 如果输入的 stdin 含有特殊字符，例如 `, \, 空白键等等字符时，这个 -0 参数可以将他还原成一般字符。这个参数可以用于特殊状态喔！
-e: 这个是 EOF （end of file） 的意思。后面可以接一个字串，当 xargs 分析到这个字串时，就会停止继续工作！
-p: 在执行每个指令的 argument 时，都会询问使用者的意思；
-n: 后面接次数，每次 command 指令执行时，要使用几个参数的意思。

当 xargs 后面没有接任何的指令时，默认是以 echo 来进行输出！
</pre>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#19968;&#65306;&#23558; /etc/passwd &#20869;&#30340;&#31532;&#19968;&#26639;&#21462;&#20986;&#65292;&#20165;&#21462;&#19977;&#34892;&#65292;&#20351;&#29992; id &#36825;&#20010;&#25351;&#20196;&#23558;&#27599;&#20010;&#24080;&#21495;&#20869;&#23481;&#31168;&#20986;&#26469;</span>
$ id root
<span style="color: #8787d7;">uid</span>=0(root) <span style="color: #8787d7;">gid</span>=0(root) <span style="color: #8787d7;">groups</span>=0(root) <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#36825;&#20010; id &#25351;&#20196;&#21487;&#20197;&#26597;&#35810;&#20351;&#29992;&#32773;&#30340; UID/GID &#31561;&#20449;&#24687;</span>

$ id $(cut -d <span style="color: #2aa198;">':'</span> -f 1 /etc/passwd | head -n 3)
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#34429;&#28982;&#20351;&#29992; $(cmd) &#21487;&#20197;&#39044;&#20808;&#21462;&#24471;&#21442;&#25968;&#65292;&#20294;&#21487;&#24796;&#30340;&#26159;&#65292;id &#36825;&#20010;&#25351;&#20196;&#8220;&#20165;&#8221;&#33021;&#25509;&#21463;&#19968;&#20010;&#21442;&#25968;&#32780;&#24050;&#65281;</span>
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#25152;&#20197;&#19978;&#36848;&#30340;&#36825;&#20010;&#25351;&#20196;&#25191;&#34892;&#20250;&#20986;&#29616;&#38169;&#35823;&#65281;&#26681;&#26412;&#19981;&#20250;&#26174;&#31034;&#29992;&#25143;&#30340; ID &#21834;&#65281;</span>

$ cut -d <span style="color: #2aa198;">':'</span> -f 1 /etc/passwd | head -n 3 | id
<span style="color: #8787d7;">uid</span>=1000(dmtsai) <span style="color: #8787d7;">gid</span>=1000(dmtsai) <span style="color: #8787d7;">groups</span>=1000(dmtsai),10(wheel) <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#25105;&#19981;&#26159;&#35201;&#26597;&#33258;&#24049;&#21834;&#65281;</span>
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#22240;&#20026; id &#24182;&#19981;&#26159;&#31649;&#32447;&#21629;&#20196;&#65292;&#22240;&#27492;&#22312;&#19978;&#38754;&#36825;&#20010;&#25351;&#20196;&#25191;&#34892;&#21518;&#65292;&#21069;&#38754;&#30340;&#19996;&#35199;&#36890;&#36890;&#19981;&#35265;&#65281;&#21482;&#20250;&#25191;&#34892; id&#65281;</span>

$ cut -d <span style="color: #2aa198;">':'</span> -f 1 /etc/passwd | head -n 3 | xargs id
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#20381;&#26087;&#20250;&#20986;&#29616;&#38169;&#35823;&#65281;&#36825;&#26159;&#22240;&#20026; xargs &#19968;&#21475;&#27668;&#23558;&#20840;&#37096;&#30340;&#25968;&#25454;&#36890;&#36890;&#20002;&#32473; id &#22788;&#29702;&#65374;&#20294; id &#23601;&#25509;&#21463; 1 &#20010;&#21834;&#26368;&#22810;&#65281;</span>

$ cut -d <span style="color: #2aa198;">':'</span> -f 1 /etc/passwd | head -n 3 | xargs -n 1 id
<span style="color: #8787d7;">uid</span>=0(root) <span style="color: #8787d7;">gid</span>=0(root) <span style="color: #8787d7;">groups</span>=0(root)
<span style="color: #8787d7;">uid</span>=1(bin) <span style="color: #8787d7;">gid</span>=1(bin) <span style="color: #8787d7;">groups</span>=1(bin)
<span style="color: #8787d7;">uid</span>=2(daemon) <span style="color: #8787d7;">gid</span>=2(daemon) <span style="color: #8787d7;">groups</span>=2(daemon)
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#36890;&#36807; -n &#26469;&#22788;&#29702;&#65292;&#19968;&#27425;&#32473;&#20104;&#19968;&#20010;&#21442;&#25968;&#65292;&#22240;&#27492;&#19978;&#36848;&#30340;&#32467;&#26524;&#23601; OK &#27491;&#24120;&#30340;&#26174;&#31034;&#65281;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#20108;&#65306;&#21516;&#19978;&#65292;&#20294;&#26159;&#27599;&#27425;&#25191;&#34892; id &#26102;&#65292;&#37117;&#35201;&#35810;&#38382;&#20351;&#29992;&#32773;&#26159;&#21542;&#21160;&#20316;&#65311;</span>
$ cut -d <span style="color: #2aa198;">':'</span> -f 1 /etc/passwd | head -n 3 | xargs -p -n 1 id
id root ?...y
<span style="color: #8787d7;">uid</span>=0(root) <span style="color: #8787d7;">gid</span>=0(root) <span style="color: #8787d7;">groups</span>=0(root)
id bin ?...y
<span style="color: #d75fd7; font-weight: bold;">.....</span>(&#19979;&#38754;&#30465;&#30053;).....
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#36825;&#20010; -p &#30340;&#36873;&#39033;&#21487;&#20197;&#35753;&#20351;&#29992;&#32773;&#30340;&#20351;&#29992;&#36807;&#31243;&#20013;&#65292;&#34987;&#35810;&#38382;&#21040;&#27599;&#20010;&#25351;&#20196;&#26159;&#21542;&#25191;&#34892;&#65281;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#19977;&#65306;&#23558;&#25152;&#26377;&#30340; /etc/passwd &#20869;&#30340;&#24080;&#21495;&#37117;&#20197; id &#26597;&#38405;&#65292;&#20294;&#26597;&#21040; sync &#23601;&#32467;&#26463;&#25351;&#20196;&#20018;</span>
$ cut -d <span style="color: #2aa198;">':'</span> -f 1 /etc/passwd | xargs -e<span style="color: #2aa198;">'sync'</span> -n 1 id
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#20180;&#32454;&#19982;&#19978;&#38754;&#30340;&#26696;&#20363;&#20570;&#27604;&#36739;&#12290;&#20063;&#21516;&#26102;&#27880;&#24847;&#65292;&#37027;&#20010; -e'sync' &#26159;&#36830;&#22312;&#19968;&#36215;&#30340;&#65292;&#20013;&#38388;&#27809;&#26377;&#31354;&#30333;&#38190;&#12290;</span>
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#19978;&#20010;&#20363;&#23376;&#24403;&#20013;&#65292;&#31532;&#20845;&#20010;&#21442;&#25968;&#26159; sync &#21834;&#65292;&#37027;&#20040;&#25105;&#20204;&#19979;&#36798; -e'sync' &#21518;&#65292;&#21017;&#20998;&#26512;&#21040; sync &#36825;&#20010;&#23383;&#20018;&#26102;&#65292;</span>
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#21518;&#38754;&#30340;&#20854;&#20182; stdin &#30340;&#20869;&#23481;&#23601;&#20250;&#34987; xargs &#33293;&#24323;&#25481;&#20102;&#65281;</span>
</pre>
</div>

<p>
其实，在 man xargs 里面就有三四个小范例，您可以自行参考一下内容。 此外， xargs 真的是很好用的一个玩意儿！您真的需要好好的参详参详！会使用 xargs 的原因是， 很多指令其实并不支持管线命令，因此我们可以通过 xargs 来提供该指令引用 standard input 之用！举例来说，我们使用如下的范例来说明：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#33539;&#20363;&#22235;&#65306;&#25214;&#20986; /usr/sbin &#19979;&#38754;&#20855;&#26377;&#29305;&#27530;&#26435;&#38480;&#30340;&#25991;&#20214;&#21517;&#65292;&#24182;&#20351;&#29992; ls -l &#21015;&#20986;&#35814;&#32454;&#23646;&#24615;</span>
$ find /usr/sbin -perm /7000 | xargs ls -l
-rwx--s--x. 1 root lock 11208 Jun 10 2014 /usr/sbin/lockdev
-rwsr-xr-x. 1 root root 113400 Mar 6 12:17 /usr/sbin/mount.nfs
-rwxr-sr-x. 1 root root 11208 Mar 6 11:05 /usr/sbin/netreport
.....&#65288;&#19979;&#38754;&#30465;&#30053;&#65289;.....
<span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#25110;&#32773; ls -l $(find /usr/sbin -perm /7000)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcdaa971" class="outline-3">
<h3 id="orgcdaa971">关于减号【-】的用途</h3>
<div class="outline-text-3" id="text-orgcdaa971">
<p>
管道命令在 bash 的连续的处理程序中是相当重要的！另外，在日志的分析当中也是相当重要的一环， 所以请特别留意！另外，在管道命令当中，常常会使用到前一个指令的 stdout 作为这次的 stdin ， 某些指令需要用到文件名称 （例如 tar） 来进行处理时，该 stdin 与 stdout 可以利用减号 "-" 来替代， 举例来说：<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">$ mkdir /tmp/homeback
$ tar -cvf - /home &amp;<span style="color: #008787; background-color: #262626;">#</span><span style="color: #008787; background-color: #262626;">124; tar -xvf - -C /tmp/homeback</span>
</pre>
</div>

<p>
上面这个例子是说：将 /home 里面的文件给他打包，但打包的数据不是纪录到文件，而是传送到 stdout； 经过管线后，将 tar -cvf - /home 传送给后面的 tar -xvf - 。后面的这个 - 则是取用前一个指令的 stdout， 因此，我们就不需要使用 filename 了！这是很常见的例子！注意注意！<br>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-06-19 Sun 13:33</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
