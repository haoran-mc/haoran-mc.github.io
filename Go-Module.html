<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-12-12 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>GO MODULE</title>
<meta name="author" content="L.M.haoran" />
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved." />
<meta name="generator" content="Org Mode" />
<link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
           <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
           <script type="module" src="static/js/main.js" defer></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">GO MODULE</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org5ec0e81">什么是go.mod？</a></li>
<li><a href="#org18f3acd">Modules 与传统 GOPATH 的区别</a></li>
<li><a href="#orgea4225b">GO111MODULE</a></li>
<li><a href="#org963b641">go.mod 如何在项目中使用？</a>
<ul>
<li><a href="#org99d802d">1. 使用 go.mod</a></li>
<li><a href="#orga024524">2. 写一个 hello.go 文件</a></li>
<li><a href="#org05afc64">3. 在当前目录下运行命令行 go mod init + 模块名称 初始化模板</a></li>
<li><a href="#org8abf809">4. go.mod 命令</a></li>
</ul>
</li>
<li><a href="#org9d2bd69">go.sum</a></li>
<li><a href="#org5a76045">依赖包</a>
<ul>
<li><a href="#orgfcaf7ae">自动下载依赖包</a></li>
<li><a href="#org40aa9df">依赖的包下载到哪里了？</a></li>
<li><a href="#orgadb1b89">如何控制依赖包的版本？</a></li>
</ul>
</li>
<li><a href="#org936a295">包缓存</a></li>
</ul>
</div>
</div>

<div id="outline-container-org5ec0e81" class="outline-2">
<h2 id="org5ec0e81">什么是go.mod？</h2>
<div class="outline-text-2" id="text-org5ec0e81">
<p>
go.mod 是 Golang1.11 版本新引入的官方包管理工具用于解决之前没有地方记录依赖包具体版本的问题，方便依赖包的管理。<br>
</p>

<p>
就是一个 Modules，关于 Modules 的 <a href="https://pkg.go.dev/cmd/go#hdr-Modules__module_versions__and_more">官方定义</a> 为：<br>
</p>

<blockquote>
<p>
A module is a collection of packages that are released, versioned, and distributed together. Modules may be downloaded directly from version control repositories or from module proxy servers.<br>
</p>

<p>
Modules 是相关 Go 包的集合，是源代码发行，版本控制，分布式的单元。Modules 可以直接从版本控制库或代理服务器直接下载。<br>
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org18f3acd" class="outline-2">
<h2 id="org18f3acd">Modules 与传统 GOPATH 的区别</h2>
<div class="outline-text-2" id="text-org18f3acd">
<p>
若是想要在其他位置新建 go 项目，就不得不更改系统变量 GOPATH，将其设为新项目的位置，可能还要改 goland 中的 GOPATH 设置。<br>
</p>

<p>
go mod 是 golang1.11 后引入的 package 依赖管理工具，用于解决之前没有地方记录依赖包具体版本的问题，方便依赖包管理。之前主要是用 GOPATH 和 Vendor，vendor 相对主流，但现在官方更提倡 go mod。<br>
</p>

<p>
在 GOPATH 的目录下，新建项目文件夹，进入新建路径执行 go mod init，在文件夹下生成 go.mod 文件，然后将需要引入外部包的 go 文件置于项目目录下，编译文件，就会把外部包下载到本地的 GOPATH/pkg/mod 目录下。<br>
</p>

<p>
set GO111MODULE=off，GOPATH mode，查找 vendor 和 GOPATH 目录。<br>
set GO111MODULE=auto，如果当前目录不在 $GOPATH 并且 当前目录（或者父目录）下有 go.mod 文件，则使用 GO111MODULE，否则仍旧使用 GOPATH mode。<br>
</p>

<p>
注意：在使用 goLand 工具时，不要配置 Project GOPATH 为当前工程目录，最好不要配置 Project GOPATH，而是配置 Module GOPATH。<br>
</p>

<p>
在使用模块的时候，GOPATH 是无意义的，不过它还是会把下载的依赖储存在 GOPATH/src/mod 中，也会把 go install 的结果放在 GOPATH/bin（如果 GOBIN 不存在的话）。<br>
</p>
</div>
</div>
<div id="outline-container-orgea4225b" class="outline-2">
<h2 id="orgea4225b">GO111MODULE</h2>
<div class="outline-text-2" id="text-orgea4225b">
<p>
GO111MODULE有三个值：off, on和auto。<br>
</p>

<ul class="org-ul">
<li>GO111MODULE=off，go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找。<br></li>
<li>GO111MODULE=on，go命令行会使用modules，而一点也不会去GOPATH目录下查找。<br></li>
<li>GO111MODULE=auto，默认值，go命令行将会根据当前目录来决定是否启用module功能。<br>
<ul class="org-ul">
<li>当前目录在GOPATH/src之外且该目录包含go.mod文件，启用module功能。<br></li>
<li>当前文件在包含go.mod文件的目录下面，启用module功能。<br></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org963b641" class="outline-2">
<h2 id="org963b641">go.mod 如何在项目中使用？</h2>
<div class="outline-text-2" id="text-org963b641">
</div>
<div id="outline-container-org99d802d" class="outline-3">
<h3 id="org99d802d">1. 使用 go.mod</h3>
<div class="outline-text-3" id="text-org99d802d">
<ol class="org-ol">
<li>首先将 go 的版本升级到 1.11 以上；<br></li>
<li>设置 GO111MODULE；<br></li>
</ol>
</div>
</div>
<div id="outline-container-orga024524" class="outline-3">
<h3 id="orga024524">2. 写一个 hello.go 文件</h3>
<div class="outline-text-3" id="text-orga024524">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #9d0006;">package</span> main

<span style="color: #9d0006;">import</span> <span style="color: #79740e;">"fmt"</span>

<span style="color: #9d0006;">func</span> <span style="color: #b57614;">main</span>() {
    fmt.<span style="color: #b57614;">Println</span>(<span style="color: #79740e;">"Hello World!"</span>)
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org05afc64" class="outline-3">
<h3 id="org05afc64">3. 在当前目录下运行命令行 go mod init + 模块名称 初始化模板</h3>
<div class="outline-text-3" id="text-org05afc64">
<div class="org-src-container">
<pre class="src src-sh">go mod init hello
</pre>
</div>

<p>
运行完后，会在当前目录下生成一个 go.mod 文件，这是一个关键文件，之后的包管理都是通过这个文件管理。<br>
</p>
</div>
</div>
<div id="outline-container-org8abf809" class="outline-3">
<h3 id="org8abf809">4. go.mod 命令</h3>
<div class="outline-text-3" id="text-org8abf809">
<p>
在使用模块的时候， GOPATH 是无意义的，不过它还是会把下载的依赖储存在 GOPATH/src/mod 中，也会把 go install 的结果放在 GOPATH/bin（如果 GOBIN 不存在的话）。<br>
</p>

<dl class="org-dl">
<dt>go mod download</dt><dd>下载模块到本地缓存，缓存路径是 $GOPATH/pkg/mod/cache<br></dd>
<dt>go mod edit</dt><dd>是提供了命令版编辑 go.mod 的功能，例如 go mod edit -fmt go.mod 会格式化 go.mod<br></dd>
<dt>go mod graph</dt><dd>把模块之间的依赖图显示出来<br></dd>
<dt>go mod init</dt><dd>初始化模块（例如把原本dep管理的依赖关系转换过来）<br></dd>
<dt>go mod tidy</dt><dd>增加缺失的包，移除没用的包<br></dd>
<dt>go mod vendor</dt><dd>把依赖拷贝到 vendor/ 目录下<br></dd>
<dt>go mod verify</dt><dd>校验依赖并查看是否有修改<br></dd>
<dt>go mod why</dt><dd>解释为什么需要包和模块<br></dd>
<dt>go mod init example.com/hello</dt><dd>指定module的根目录并生成go.mod文件<br></dd>
<dt>go build, go test</dt><dd>下载并添加依赖到go.mod文件中<br></dd>
<dt>go list -m all</dt><dd>查看module下的所有依赖<br></dd>
<dt>go get rec.io/sampler</dt><dd>更新稳定版依赖<br></dd>
<dt>go build -mod=vendor</dt><dd>忽略cache里的包，只使用vendor目录里的依赖进行编译<br></dd>
</dl>

<hr>

<ul class="org-ul">
<li>更新为指定版本依赖<br></li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">go list -m -versions rsc.io/sampler

rsc.io/sampler v1.0.0 v1.2.0 v1.2.1 v1.3.0 v1.3.1 v1.99.99

go get rsc.io/sampler@v1.3.1
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org9d2bd69" class="outline-2">
<h2 id="org9d2bd69">go.sum</h2>
<div class="outline-text-2" id="text-org9d2bd69">
<p>
除了 go.mod 之外，go 命令还维护了一个名为 go.sum 的文件，其中包含特定模块版本内容的预期加密哈系。<br>
</p>

<p>
go 命令使用 go.sum 文件确保这些模块的未来下载检索与第一次下载相同的位，以确保项目所依赖的模块不会出现意外更改，无论是出于恶意、意外还是其他原因。go.mod 和 go.sum 都应检入版本控制。<br>
</p>

<p>
go.sum 不需要手工维护，所以可以不用太关注。<br>
</p>
</div>
</div>
<div id="outline-container-org5a76045" class="outline-2">
<h2 id="org5a76045">依赖包</h2>
<div class="outline-text-2" id="text-org5a76045">
</div>
<div id="outline-container-orgfcaf7ae" class="outline-3">
<h3 id="orgfcaf7ae">自动下载依赖包</h3>
<div class="outline-text-3" id="text-orgfcaf7ae">
<p>
注意：子目录里是不需要 init 的，所有的子目录里的依赖都会组织在根目录的 go.mod 文件里。<br>
</p>

<p>
现在比如修改了 hello.go 文件，按照过去的做法，要运行 hello.go 需要执行go get 命令下载 gorose 包到 $GOPATH/src。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #9d0006;">package</span> main

<span style="color: #9d0006;">import</span> (
    <span style="color: #79740e;">"fmt"</span>
    <span style="color: #79740e;">"gohouse/gorose"</span>
)

<span style="color: #9d0006;">func</span> <span style="color: #b57614;">main</span>() {
    fmt.<span style="color: #b57614;">Println</span>(<span style="color: #79740e;">"Hello, world!"</span>)
}
</pre>
</div>

<p>
但是使用了新的包管理就不再需要这样做了，只需要 go run hello.go，稍等片刻&#x2026; go 会自动查找代码中的包，下载未下载的依赖包，并把具体的依赖关系和版本写入到 go.mod 和 go.sum 文件中去。<br>
</p>

<p>
查看 go.mod：<br>
</p>

<div class="org-src-container">
<pre class="src src-go">module <span style="color: #8f3f71;">hello</span>

<span style="color: #b57614;">require</span> (
    gohouse/gorose <span style="color: #8f3f71;">v1.0</span>.5
)
</pre>
</div>

<p>
require 关键字是引用，后面是包，最后 v1.0.5 是引用的版本号。<br>
</p>

<p>
这样，一个使用 go 包管理方式创建项目的小例子就完成了。<br>
</p>
</div>
</div>
<div id="outline-container-org40aa9df" class="outline-3">
<h3 id="org40aa9df">依赖的包下载到哪里了？</h3>
<div class="outline-text-3" id="text-org40aa9df">
<p>
不是下载到 GOPATH 里，依赖的第三方包被下载到了 $GOPATH/pkg/mod 路径下。<br>
</p>
</div>
</div>
<div id="outline-container-orgadb1b89" class="outline-3">
<h3 id="orgadb1b89">如何控制依赖包的版本？</h3>
<div class="outline-text-3" id="text-orgadb1b89">
<p>
在上一个问题里，可以看到最终下载在 $GOPATH/pkg/mod 下的包中最后会有一个版本号 v1.0.5，也就是说，$GOPATH/pkg/mod 里可以保存相同包的不同版本。<br>
</p>

<p>
版本是在 go.mod 中指定的。如果，在 go.mod 中没有指定，go 命令会自动下载代码中的依赖的最新版本，本例就是自动下载最新的版本。如果，在 go.mod 用 require 语句指定包和版本，go 命令会根据指定的路径和版本下载包。<br>
</p>

<p>
指定版本时可以用 latest，这样它会自动下载指定包的最新版本；<br>
</p>
</div>
</div>
</div>

<div id="outline-container-org936a295" class="outline-2">
<h2 id="org936a295">包缓存</h2>
<div class="outline-text-2" id="text-org936a295">
<p>
最后简单谈一下当我们使用 go mod 后包缓存存储问题，依赖包存储在 $GOPATH/pkg/mod，该目录中可以存储特定依赖包的多个版本。需要注意的是 $GOPATH/pkg/mod 目录下有个 cache 目录，它用来存储依赖包的缓存，简单说，go 命令每次下载新的依赖包都会在该 cache 目录中保存一份，每个版本都会有一份缓存。<br>
</p>

<p>
值得注意的是包名大小写问题，有时我们使用的包名中会包含大写字母，GOMODULE 模式下，在存储时会将包名做大小写编码处理，即每个大写字母将变 !+ 相应的小写字母，比如 github.com/pibigstar/GO-demo 包在存储时将会被放置在 $GOPATH/pkg/mod/github.com/pibigstar/!g!o-demo 目录中。所以这里我不推荐你用大写字母定义包名。<br>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2021-10-28 19:10 Thu</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-12-12</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
