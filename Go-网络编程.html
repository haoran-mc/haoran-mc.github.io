<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-07-24 Sun 04:03 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Go 网络编程</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">Go 网络编程</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org862a83f">什么是 Socket 编程</a></li>
<li><a href="#org49d31c8">网络应用程序设计模式</a></li>
<li><a href="#orgae838b5">Socket 编程</a>
<ul>
<li><a href="#org8b21d52">TCP</a>
<ul>
<li><a href="#org911e1c1">服务端</a>
<ul>
<li><a href="#org706df9a">1. 解析地址</a></li>
<li><a href="#org9d2933c">2. 监听请求</a></li>
<li><a href="#orgfd59870">3. 接收请求</a></li>
<li><a href="#orgb84d1ae">4. 连接配置</a></li>
</ul>
</li>
<li><a href="#orga86844f">客户端</a>
<ul>
<li><a href="#org87289dd">1. 解析 TCP 地址</a></li>
<li><a href="#org4710f04">2. 发送连接请求</a></li>
</ul>
</li>
<li><a href="#org8b9069b">一个回声服务器端/客户端实例</a>
<ul>
<li><a href="#orgaf01703">server.go</a></li>
<li><a href="#org527ad24">client.go</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4475ac9">UDP</a>
<ul>
<li><a href="#orgc9ceaa6">UDP 服务端</a></li>
<li><a href="#org7b961cb">UDP 客户端</a></li>
</ul>
</li>
<li><a href="#orgb278932">总结</a></li>
</ul>
</li>
<li><a href="#orgd9824ea">HTTP 编程</a>
<ul>
<li><a href="#org058a248">HTTP 服务端</a>
<ul>
<li><a href="#orga8058d7">处理 HTTP 请求</a></li>
</ul>
</li>
<li><a href="#org790b97c">HTTP 客户端</a>
<ul>
<li><a href="#orga0c7caa">基本方法</a></li>
<li><a href="#org34c40d3">http.Get()</a></li>
<li><a href="#org0435ad0">http.Post()</a></li>
<li><a href="#orgbeddf5b">http.PostForm()</a></li>
<li><a href="#orgc4e335f">http.Head()</a></li>
<li><a href="#org380ce00">(*http.Client).Do()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org0b07415">RPC 编程</a></li>
</ul>
</div>
</div>

<div id="outline-container-org862a83f" class="outline-2">
<h2 id="org862a83f">什么是 Socket 编程</h2>
</div>
<div id="outline-container-org49d31c8" class="outline-2">
<h2 id="org49d31c8">网络应用程序设计模式</h2>
<div class="outline-text-2" id="text-org49d31c8">
<blockquote>
<p>
C/S模式<br>
传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。<br>
</p>
</blockquote>

<blockquote>
<p>
B/S模式<br>
浏览器(Browser)/服务器(Server)模式。只需在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输。<br>
</p>
</blockquote>

<p>
优缺点：<br>
</p>

<ul class="org-ul">
<li>对于C/S模式来说，其优点明显。客户端位于目标主机上可以保证性能，将数据缓存至客户端本地，从而提高数据传输效率。且，一般来说客户端和服务器程序由一个开发团队创作，所以他们之间所采用的协议相对灵活。可以在标准协议的基础上根据需求裁剪及定制。例如，腾讯所采用的通信协议，即为ftp协议的修改剪裁版。因此，传统的网络应用程序及较大型的网络应用程序都首选C/S模式进行开发。如，知名的网络游戏魔兽世界。3D画面，数据量庞大，使用C/S模式可以提前在本地进行大量数据的缓存处理，从而提高观感。<br></li>
<li>C/S模式的缺点也较突出。由于客户端和服务器都需要有一个开发团队来完成开发。工作量将成倍提升，开发周期较长。另外，从用户角度出发，需要将客户端安插至用户主机上，对用户主机的安全性构成威胁。这也是很多用户不愿使用C/S模式应用程序的重要原因。<br></li>
<li>B/S模式相比C/S模式而言，由于它没有独立的客户端，使用标准浏览器作为客户端，其工作开发量较小。只需开发服务器端即可。另外由于其采用浏览器显示数据，因此移植性非常好，不受平台限制。如早期的偷菜游戏，在各个平台上都可以完美运行。<br></li>
<li>B/S模式的缺点也较明显。由于使用第三方浏览器，因此网络应用支持受限。另外，没有客户端放到对方主机上，缓存数据不尽如人意，从而传输数据量受到限制。应用的观感大打折扣。第三，必须与浏览器一样，采用标准http协议进行通信，协议选择不灵活。<br></li>
</ul>
<p>
因此在开发过程中，模式的选择由上述各自的特点决定。根据实际需求选择应用程序设计模式。<br>
</p>
</div>
</div>
<div id="outline-container-orgae838b5" class="outline-2">
<h2 id="orgae838b5">Socket 编程</h2>
<div class="outline-text-2" id="text-orgae838b5">
</div>
<div id="outline-container-org8b21d52" class="outline-3">
<h3 id="org8b21d52">TCP</h3>
<div class="outline-text-3" id="text-org8b21d52">
</div>
<div id="outline-container-org911e1c1" class="outline-4">
<h4 id="org911e1c1">服务端</h4>
<div class="outline-text-4" id="text-org911e1c1">
</div>
<div id="outline-container-org706df9a" class="outline-5">
<h5 id="org706df9a">1. 解析地址</h5>
<div class="outline-text-5" id="text-org706df9a">
<p>
在服务端我们需要监听一个地址，因此建立服务端前我们需要生成一个正确的地址，这就需要用到下面的函数了。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">ResolveTCPAddr &#20989;&#25968;&#20250;&#36755;&#20986;&#19968;&#20010; TCP &#36830;&#25509;&#22320;&#22336;&#21644;&#19968;&#20010;&#38169;&#35823;&#20449;&#24687;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">ResolveTCPAddr</span>(<span style="color: #8787d7;">network</span>, <span style="color: #8787d7;">address</span> <span style="color: #df005f; font-weight: bold;">string</span>) (*<span style="color: #df005f; font-weight: bold;">TCPAddr</span>, <span style="color: #df005f; font-weight: bold;">error</span>)
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35299;&#26512;IP&#22320;&#22336;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">ResolveIPAddr</span>(<span style="color: #8787d7;">net</span>, <span style="color: #8787d7;">addr</span> <span style="color: #df005f; font-weight: bold;">string</span>) (*<span style="color: #df005f; font-weight: bold;">IPAddr</span>, <span style="color: #df005f; font-weight: bold;">error</span>)
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35299;&#26512;UDP&#22320;&#22336;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">ResolveUDPAddr</span>(<span style="color: #8787d7;">net</span>, <span style="color: #8787d7;">addr</span> <span style="color: #df005f; font-weight: bold;">string</span>) (*<span style="color: #df005f; font-weight: bold;">UDPAddr</span>, <span style="color: #df005f; font-weight: bold;">error</span>)
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35299;&#26512;Unix&#22320;&#22336;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">ResolveUnixAddr</span>(<span style="color: #8787d7;">net</span>, <span style="color: #8787d7;">addr</span> <span style="color: #df005f; font-weight: bold;">string</span>) (*<span style="color: #df005f; font-weight: bold;">UnixAddr</span>, <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-org9d2933c" class="outline-5">
<h5 id="org9d2933c">2. 监听请求</h5>
<div class="outline-text-5" id="text-org9d2933c">
<p>
通过 ListenTCP 方法监听我们解析后的网络地址。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#30417;&#21548; TCP &#22320;&#22336;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">ListenTCP</span>(<span style="color: #8787d7;">network</span> <span style="color: #df005f; font-weight: bold;">string</span>, <span style="color: #8787d7;">laddr</span> *<span style="color: #df005f; font-weight: bold;">TCPAddr</span>) (*<span style="color: #df005f; font-weight: bold;">TCPListener</span>, <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>

<p>
除此之外还有监听其他类型的方法：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#30417;&#21548; net &#31867;&#22411;&#65292;&#22320;&#22336;&#20026; laddr &#30340;&#22320;&#22336;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">Listen</span>(<span style="color: #8787d7;">net</span>, <span style="color: #8787d7;">laddr</span> <span style="color: #df005f; font-weight: bold;">string</span>) (<span style="color: #df005f; font-weight: bold;">Listener</span>, <span style="color: #df005f; font-weight: bold;">error</span>)
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#30417;&#21548; IP &#22320;&#22336;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">ListenIP</span>(<span style="color: #8787d7;">netProto</span> <span style="color: #df005f; font-weight: bold;">string</span>, <span style="color: #8787d7;">laddr</span> *<span style="color: #df005f; font-weight: bold;">IPAddr</span>) (*<span style="color: #df005f; font-weight: bold;">IPConn</span>, <span style="color: #df005f; font-weight: bold;">error</span>)
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#30417;&#21548; UDP &#22320;&#22336;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">ListenMulticastUDP</span>(<span style="color: #8787d7;">net</span> <span style="color: #df005f; font-weight: bold;">string</span>, <span style="color: #8787d7;">ifi</span> *<span style="color: #df005f; font-weight: bold;">Interface</span>, <span style="color: #8787d7;">gaddr</span> *<span style="color: #df005f; font-weight: bold;">UDPAddr</span>) (*<span style="color: #df005f; font-weight: bold;">UDPConn</span>, <span style="color: #df005f; font-weight: bold;">error</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">ListenUDP</span>(<span style="color: #8787d7;">net</span> <span style="color: #df005f; font-weight: bold;">string</span>, <span style="color: #8787d7;">laddr</span> *<span style="color: #df005f; font-weight: bold;">UDPAddr</span>) (*<span style="color: #df005f; font-weight: bold;">UDPConn</span>, <span style="color: #df005f; font-weight: bold;">error</span>)
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#30417;&#21548; Unix &#22320;&#22336;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">ListenUnixgram</span>(<span style="color: #8787d7;">net</span> <span style="color: #df005f; font-weight: bold;">string</span>, <span style="color: #8787d7;">laddr</span> *<span style="color: #df005f; font-weight: bold;">UnixAddr</span>) (*<span style="color: #df005f; font-weight: bold;">UnixConn</span>, <span style="color: #df005f; font-weight: bold;">error</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">ListenUnix</span>(<span style="color: #8787d7;">net</span> <span style="color: #df005f; font-weight: bold;">string</span>, <span style="color: #8787d7;">laddr</span> *<span style="color: #df005f; font-weight: bold;">UnixAddr</span>) (*<span style="color: #df005f; font-weight: bold;">UnixListener</span>, <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>

<p>
其中的 Listen 方法也可用来监听 TCP，那么什么时候该使用 Listen，什么时候该使用 ListenTCP 呢？<br>
</p>

<p>
Listen 函数是 ListenTCP 和 ListenUnix 的通用抽象。Listen 函数返回一个特定于协议的监听器类型作为监听器接口。Listen 还提供了额外的便利，可以将字符串地址转换为 ListenTCP 和 ListenUnix 所需的特定地址类型。如果您有 TCPAddr，或者需要使用 Listener接口上不可用的 TCPListener 方法，则使用 ListenTCP。<br>
</p>
</div>
</div>
<div id="outline-container-orgfd59870" class="outline-5">
<h5 id="orgfd59870">3. 接收请求</h5>
<div class="outline-text-5" id="text-orgfd59870">
<p>
TCPAddr 实现了两个接受请求的方法，两者代码实现其实是一样的，唯一的区别是第一种返回了一个对象，第二种返回了一个接口。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">l</span> *<span style="color: #df005f; font-weight: bold;">TCPListener</span>) <span style="color: #d75fd7; font-weight: bold;">AcceptTCP</span>() (*<span style="color: #df005f; font-weight: bold;">TCPConn</span>, <span style="color: #df005f; font-weight: bold;">error</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">l</span> *<span style="color: #df005f; font-weight: bold;">TCPListener</span>) <span style="color: #d75fd7; font-weight: bold;">Accept</span>() (<span style="color: #df005f; font-weight: bold;">Conn</span>, <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>

<p>
其他类型也有类似的方法，具体请参考go语言标准库文档。<br>
</p>
</div>
</div>
<div id="outline-container-orgb84d1ae" class="outline-5">
<h5 id="orgb84d1ae">4. 连接配置</h5>
<div class="outline-text-5" id="text-orgb84d1ae">
<ul class="org-ul">
<li><p>
配置监听器超时时间<br>
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36229;&#36807;t&#20043;&#21518;&#30417;&#21548;&#22120;&#33258;&#21160;&#20851;&#38381;&#65292;0&#34920;&#31034;&#19981;&#35774;&#32622;&#36229;&#26102;&#26102;&#38388;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">l</span> *<span style="color: #df005f; font-weight: bold;">TCPListener</span>) <span style="color: #d75fd7; font-weight: bold;">SetDeadline</span>(<span style="color: #8787d7;">t</span> <span style="color: #df005f; font-weight: bold;">time.Time</span>) <span style="color: #df005f; font-weight: bold;">error</span>
</pre>
</div></li>
<li><p>
关闭监听器<br>
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20851;&#38381;&#30417;&#21548;&#22120;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">l</span> *<span style="color: #df005f; font-weight: bold;">TCPListener</span>) <span style="color: #d75fd7; font-weight: bold;">Close</span>() <span style="color: #df005f; font-weight: bold;">error</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga86844f" class="outline-4">
<h4 id="orga86844f">客户端</h4>
<div class="outline-text-4" id="text-orga86844f">
</div>
<div id="outline-container-org87289dd" class="outline-5">
<h5 id="org87289dd">1. 解析 TCP 地址</h5>
<div class="outline-text-5" id="text-org87289dd">
<p>
在 TCP 服务端我们需要监听一个 TCP 地址，因此建立服务端前我们需要生成一个正确的 TCP 地址，这就需要用到下面的函数了。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">ResolveTCPAddr&#20989;&#25968;&#20250;&#36755;&#20986;&#19968;&#20010;TCP&#36830;&#25509;&#22320;&#22336;&#21644;&#19968;&#20010;&#38169;&#35823;&#20449;&#24687;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">ResolveTCPAddr</span>(<span style="color: #8787d7;">network</span>, <span style="color: #8787d7;">address</span> <span style="color: #df005f; font-weight: bold;">string</span>) (*<span style="color: #df005f; font-weight: bold;">TCPAddr</span>, <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-org4710f04" class="outline-5">
<h5 id="org4710f04">2. 发送连接请求</h5>
<div class="outline-text-5" id="text-org4710f04">
<p>
使用 DialTCP 方法进行连接：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">DialTCP &#19987;&#38376;&#29992;&#26469;&#36827;&#34892;TCP&#36890;&#20449;&#30340;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">DialTCP</span>(<span style="color: #8787d7;">network</span> <span style="color: #df005f; font-weight: bold;">string</span>, <span style="color: #8787d7;">laddr</span>, <span style="color: #8787d7;">raddr</span> *<span style="color: #df005f; font-weight: bold;">TCPAddr</span>) (*<span style="color: #df005f; font-weight: bold;">TCPConn</span>, <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>

<p>
net 包还对 DialTCP()、DialUDP()、DialIP() 和 DialUnix() 进行封装得到 Dial()，它们的功能是一致的。<br>
</p>

<p>
Go 语言标准库对此过程进行了抽象和封装。无论我们期望使用什么协议建立什么形式的连接，都只需要调用 net.Dial() 即可。<br>
</p>

<p>
Dial() 函数的原型如下：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">Dial</span>(<span style="color: #8787d7;">net</span>, <span style="color: #8787d7;">addr</span> <span style="color: #df005f; font-weight: bold;">string</span>) (<span style="color: #df005f; font-weight: bold;">Conn</span>, <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>

<p>
其中 net 参数是网络协议的名字，addr 参数是IP 地址或域名，而端口号以:的形式跟随在地址或域名的后面，端口号可选。如果连接成功，返回连接对象，否则返回 error。<br>
我们来看一下几种常见协议的调用方式。<br>
</p>

<ul class="org-ul">
<li><p>
TCP 链接：<br>
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">conn</span>, <span style="color: #8787d7;">err</span> := net.<span style="color: #d75fd7; font-weight: bold;">Dial</span>(<span style="color: #2aa198;">"tcp"</span>, <span style="color: #2aa198;">"192.168.1.8:3000"</span>)
</pre>
</div></li>
<li><p>
UDP 链接：<br>
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">conn</span>, <span style="color: #8787d7;">err</span> := net.<span style="color: #d75fd7; font-weight: bold;">Dial</span>(<span style="color: #2aa198;">"udp"</span>, <span style="color: #2aa198;">"192.168.1.12:975"</span>)
</pre>
</div></li>
<li><p>
ICMP 链接（使用协议名称）：<br>
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">conn</span>, <span style="color: #8787d7;">err</span> := net.<span style="color: #d75fd7; font-weight: bold;">Dial</span>(<span style="color: #2aa198;">"ip4:icmp"</span>, <span style="color: #2aa198;">"www.baidu.com"</span>)
</pre>
</div></li>
<li><p>
ICMP 链接（使用协议编号）：<br>
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">conn</span>, <span style="color: #8787d7;">err</span> := net.<span style="color: #d75fd7; font-weight: bold;">Dial</span>(<span style="color: #2aa198;">"ip4:1"</span>, <span style="color: #2aa198;">"10.0.0.3"</span>)
</pre>
</div></li>
</ul>

<p>
在成功建立连接后，我们就可以进行数据的发送和接收。发送数据时，使用 conn 的 Write() 成员方法，接收数据时使用 Read() 方法。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org8b9069b" class="outline-4">
<h4 id="org8b9069b">一个回声服务器端/客户端实例</h4>
<div class="outline-text-4" id="text-org8b9069b">
<p>
这里使用 net.Listen() 方法，代码更简洁。<br>
</p>
</div>
<div id="outline-container-orgaf01703" class="outline-5">
<h5 id="orgaf01703">server.go</h5>
<div class="outline-text-5" id="text-orgaf01703">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">1. &#30417;&#21548;&#30446;&#26631;&#31471;&#21475;</span>
    <span style="color: #8787d7;">listener</span>, <span style="color: #8787d7;">_</span> := net.<span style="color: #d75fd7; font-weight: bold;">Listen</span>(<span style="color: #2aa198;">"tcp4"</span>, <span style="color: #2aa198;">":8081"</span>)

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">2.</span>
    <span style="color: #8787d7;">conn</span>, <span style="color: #8787d7;">_</span> := listener.<span style="color: #d75fd7; font-weight: bold;">Accept</span>()
    <span style="color: #268bd2; font-weight: bold;">defer</span> conn.<span style="color: #d75fd7; font-weight: bold;">Close</span>()

    <span style="color: #8787d7;">buf</span> := <span style="color: #268bd2;">make</span>([]<span style="color: #df005f; font-weight: bold;">byte</span>, <span style="color: #d75fd7;">1024</span>) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#32531;&#20914;&#21306;</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20174;&#22871;&#25509;&#23383;&#25509;&#25910;&#23458;&#25143;&#31471;&#20256;&#26469;&#30340;&#28040;&#24687;</span>
    <span style="color: #8787d7;">n</span>, <span style="color: #8787d7;">_</span> := conn.<span style="color: #d75fd7; font-weight: bold;">Read</span>(buf)

    _, _ = conn.<span style="color: #d75fd7; font-weight: bold;">Write</span>(buf)
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #d75fd7; font-weight: bold;">string</span>(buf[:n]))
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org527ad24" class="outline-5">
<h5 id="org527ad24">client.go</h5>
<div class="outline-text-5" id="text-org527ad24">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">1. &#25320;&#36890; 127.0.0.1:8081</span>
    <span style="color: #8787d7;">conn</span>, <span style="color: #8787d7;">_</span> := net.<span style="color: #d75fd7; font-weight: bold;">Dial</span>(<span style="color: #2aa198;">"tcp4"</span>, <span style="color: #2aa198;">":8081"</span>)
    <span style="color: #268bd2; font-weight: bold;">defer</span> conn.<span style="color: #d75fd7; font-weight: bold;">Close</span>()

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21521;&#22871;&#25509;&#23383;&#20889;&#20837;&#28040;&#24687;</span>
    _, _ = conn.<span style="color: #d75fd7; font-weight: bold;">Write</span>([]<span style="color: #d75fd7; font-weight: bold;">byte</span>(<span style="color: #2aa198;">"hello world"</span>))

    <span style="color: #8787d7;">buf</span> := <span style="color: #268bd2;">make</span>([]<span style="color: #df005f; font-weight: bold;">byte</span>, <span style="color: #d75fd7;">1024</span>)
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20174;&#22871;&#25509;&#23383;&#35835;&#21462;&#28040;&#24687;&#65292;&#36820;&#22238;&#35835;&#21462;&#28040;&#24687;&#30340;&#38271;&#24230;</span>
    <span style="color: #8787d7;">n</span>, <span style="color: #8787d7;">_</span> := conn.<span style="color: #d75fd7; font-weight: bold;">Read</span>(buf)
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #d75fd7; font-weight: bold;">string</span>(buf[:n]))
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org4475ac9" class="outline-3">
<h3 id="org4475ac9">UDP</h3>
<div class="outline-text-3" id="text-org4475ac9">
</div>
<div id="outline-container-orgc9ceaa6" class="outline-4">
<h4 id="orgc9ceaa6">UDP 服务端</h4>
</div>
<div id="outline-container-org7b961cb" class="outline-4">
<h4 id="org7b961cb">UDP 客户端</h4>
</div>
</div>
<div id="outline-container-orgb278932" class="outline-3">
<h3 id="orgb278932">总结</h3>
<div class="outline-text-3" id="text-orgb278932">
<p>
在 Go 语言中编写网络程序时，我们将看不到传统的编码形式。以前我们使用 Socket 编程时，会按照如下步骤展开。<br>
</p>

<ol class="org-ol">
<li>建立 Socket：使用 socket() 函数；<br></li>
<li>绑定 Socket：使用 bind() 函数；<br></li>
<li>服务端监听：使用 listen() 函数；客户端连接：使用 connect() 函数；<br></li>
<li>接受连接：使用 accept() 函数；<br></li>
<li>接收：使用 receive() 函数；或者发送：使用 send() 函数；<br></li>
</ol>

<p>
Go 语言标准库对此过程进行了抽象和封装。<br>
</p>

<p>
服务端只需要 net.Listen() 月 listener.Accept()，而服务端只需要调用 net.Dial() 就可。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-orgd9824ea" class="outline-2">
<h2 id="orgd9824ea">HTTP 编程</h2>
<div class="outline-text-2" id="text-orgd9824ea">
</div>
<div id="outline-container-org058a248" class="outline-3">
<h3 id="org058a248">HTTP 服务端</h3>
<div class="outline-text-3" id="text-org058a248">
</div>
<div id="outline-container-orga8058d7" class="outline-4">
<h4 id="orga8058d7">处理 HTTP 请求</h4>
<div class="outline-text-4" id="text-orga8058d7">
<p>
使用 net/http 包提供的 http.ListenAndServe() 方法，可以在指定的地址进行监听，开启一个 HTTP，服务端该方法的原型如下：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">ListenAndServe</span>(<span style="color: #8787d7;">addr</span> <span style="color: #df005f; font-weight: bold;">string</span>, <span style="color: #8787d7;">handler</span> <span style="color: #df005f; font-weight: bold;">Handler</span>) <span style="color: #df005f; font-weight: bold;">error</span>
</pre>
</div>

<p>
该方法用于在指定的 TCP 网络地址 addr 进行监听，然后调用服务端处理程序来处理传入的连接请求。该方法有两个参数：第一个参数 addr 即监听地址；第二个参数表示服务端处理程序，通常为空，这意味着服务端调用 http.DefaultServeMux 进行处理，而服务端编写的业务逻辑处理程序 http.Handle() 或 http.HandleFunc() 默认注入 http.DefaultServeMux 中，具体代码如下：<br>
</p>

<div class="org-src-container">
<pre class="src src-go">http.<span style="color: #d75fd7; font-weight: bold;">Handle</span>(<span style="color: #2aa198;">"/foo"</span>, fooHandler)
http.<span style="color: #d75fd7; font-weight: bold;">HandleFunc</span>(<span style="color: #2aa198;">"/bar"</span>, <span style="color: #268bd2; font-weight: bold;">func</span>(<span style="color: #8787d7;">w</span> <span style="color: #df005f; font-weight: bold;">http.ResponseWriter</span>, <span style="color: #8787d7;">r</span> *<span style="color: #df005f; font-weight: bold;">http.Request</span>) {
        fmt.<span style="color: #d75fd7; font-weight: bold;">Fprintf</span>(w, <span style="color: #2aa198;">"Hello, %q"</span>, html.<span style="color: #d75fd7; font-weight: bold;">EscapeString</span>(r.URL.Path))
})
log.<span style="color: #d75fd7; font-weight: bold;">Fatal</span>(http.<span style="color: #d75fd7; font-weight: bold;">ListenAndServe</span>(<span style="color: #2aa198;">":8080"</span>, <span style="color: #d75fd7;">nil</span>))
</pre>
</div>

<p>
net/http 包还提供 http.ListenAndServeTLS() 方法，用于处理 HTTPS 连接请求：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">ListenAndServeTLS</span>(<span style="color: #8787d7;">addr</span> <span style="color: #df005f; font-weight: bold;">string</span>, <span style="color: #8787d7;">certFile</span> <span style="color: #df005f; font-weight: bold;">string</span>, <span style="color: #8787d7;">keyFile</span> <span style="color: #df005f; font-weight: bold;">string</span>, <span style="color: #8787d7;">handler</span> <span style="color: #df005f; font-weight: bold;">Handler</span>) <span style="color: #df005f; font-weight: bold;">error</span>
</pre>
</div>

<p>
ListenAndServeTLS()和ListenAndServe() 的行为一致，区别在于只处理 HTTPS 请求。此外，服务器上必须存在包含证书和与之匹配的私钥的相关文件，比如 certFile 对应 SSL证书文件存放路径，keyFile 对应证书私钥文件路径。如果证书是由证书颁发机构签署的，certFile 参数指定的路径必须是存放在服务器上的经由 CA认证过的 SSL 证书。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org790b97c" class="outline-3">
<h3 id="org790b97c">HTTP 客户端</h3>
<div class="outline-text-3" id="text-org790b97c">
<p>
Go 内置的 net/http 包提供了最简洁的 HTTP 客户端实现，我们无需借助第三方网络通信库（比如 libcurl）就可以直接使用 HTTP 中用得最多的 GET 和 POST 方式请求数据。<br>
</p>
</div>
<div id="outline-container-orga0c7caa" class="outline-4">
<h4 id="orga0c7caa">基本方法</h4>
<div class="outline-text-4" id="text-orga0c7caa">
<p>
net/http 包的 Client 类型提供了如下几个方法，让我们可以用最简洁的方式实现HTTP 请求：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">Client</span>) <span style="color: #d75fd7; font-weight: bold;">Get</span>(<span style="color: #8787d7;">url</span> <span style="color: #df005f; font-weight: bold;">string</span>) (<span style="color: #8787d7;">r</span> *<span style="color: #df005f; font-weight: bold;">Response</span>, <span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">Client</span>) <span style="color: #d75fd7; font-weight: bold;">Post</span>(<span style="color: #8787d7;">url</span> <span style="color: #df005f; font-weight: bold;">string</span>, <span style="color: #8787d7;">bodyType</span> <span style="color: #df005f; font-weight: bold;">string</span>, <span style="color: #8787d7;">body</span> <span style="color: #df005f; font-weight: bold;">io.Reader</span>) (<span style="color: #8787d7;">r</span> *<span style="color: #df005f; font-weight: bold;">Response</span>, <span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">Client</span>) <span style="color: #d75fd7; font-weight: bold;">PostForm</span>(<span style="color: #8787d7;">url</span> <span style="color: #df005f; font-weight: bold;">string</span>, <span style="color: #8787d7;">data</span> <span style="color: #df005f; font-weight: bold;">url.Values</span>) (<span style="color: #8787d7;">r</span> *<span style="color: #df005f; font-weight: bold;">Response</span>, <span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">Client</span>) <span style="color: #d75fd7; font-weight: bold;">Head</span>(<span style="color: #8787d7;">url</span> <span style="color: #df005f; font-weight: bold;">string</span>) (<span style="color: #8787d7;">r</span> *<span style="color: #df005f; font-weight: bold;">Response</span>, <span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">Client</span>) <span style="color: #d75fd7; font-weight: bold;">Do</span>(<span style="color: #8787d7;">req</span> *<span style="color: #df005f; font-weight: bold;">Request</span>) (<span style="color: #8787d7;">resp</span> *<span style="color: #df005f; font-weight: bold;">Response</span>, <span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>)
</pre>
</div>

<p>
下面概要介绍这几个方法。<br>
</p>
</div>
</div>
<div id="outline-container-org34c40d3" class="outline-4">
<h4 id="org34c40d3">http.Get()</h4>
<div class="outline-text-4" id="text-org34c40d3">
<p>
要请求一个资源，只需调用 http.Get()方法（等价于 http.DefaultClient.Get()）即可，示例代码如下：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">resp</span>, <span style="color: #8787d7;">err</span> := http.<span style="color: #d75fd7; font-weight: bold;">Get</span>(<span style="color: #2aa198;">"http://example.com/"</span>)
<span style="color: #268bd2; font-weight: bold;">if</span> err != <span style="color: #d75fd7;">nil</span> { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22788;&#29702;&#38169;&#35823; ...</span>
        <span style="color: #268bd2; font-weight: bold;">return</span>
}
<span style="color: #268bd2; font-weight: bold;">defer</span> resp.Body.<span style="color: #268bd2;">close</span>()
io.<span style="color: #d75fd7; font-weight: bold;">Copy</span>(os.Stdout, resp.Body)
</pre>
</div>

<p>
上面这段代码请求一个网站首页，并将其网页内容打印到标准输出流中。<br>
</p>
</div>
</div>
<div id="outline-container-org0435ad0" class="outline-4">
<h4 id="org0435ad0">http.Post()</h4>
<div class="outline-text-4" id="text-org0435ad0">
<p>
要以POST 的方式发送数据，也很简单，只需调用 http.Post()方法并依次传递下面的 3 个参数即可：<br>
</p>

<p>
请求的目标 URL将要 POST 数据的资源类型（MIMEType）数据的比特流（[]byte 形式）<br>
</p>

<p>
下面的示例代码演示了如何上传一张图片：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">resp</span>, <span style="color: #8787d7;">err</span> := http.<span style="color: #d75fd7; font-weight: bold;">Post</span>(<span style="color: #2aa198;">"http://example.com/upload"</span>, <span style="color: #2aa198;">"image/jpeg"</span>, &amp;imageDataBuf)
<span style="color: #268bd2; font-weight: bold;">if</span> err != <span style="color: #d75fd7;">nil</span>{ <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22788;&#29702;&#38169;&#35823;</span>
        <span style="color: #268bd2; font-weight: bold;">return</span>
}
<span style="color: #268bd2; font-weight: bold;">if</span> resp.StatusCode != http.StatusOK {<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22788;&#29702;&#38169;&#35823;</span>
        <span style="color: #268bd2; font-weight: bold;">return</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbeddf5b" class="outline-4">
<h4 id="orgbeddf5b">http.PostForm()</h4>
<div class="outline-text-4" id="text-orgbeddf5b">
<p>
http.PostForm()方法实现了标准编码格式为 application/x-www-form-urlencoded的表单提交。下面的示例代码模拟 HTML 表单提交一篇新文章：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">resp</span>, <span style="color: #8787d7;">err</span> := http.<span style="color: #d75fd7; font-weight: bold;">PostForm</span>(<span style="color: #2aa198;">"http://example.com/posts"</span>, <span style="color: #df005f; font-weight: bold;">url.Values</span>{<span style="color: #2aa198;">"title"</span>: 
{<span style="color: #2aa198;">"article title"</span>}, <span style="color: #2aa198;">"content"</span>: {<span style="color: #2aa198;">"article body"</span>}})
<span style="color: #268bd2; font-weight: bold;">if</span> err != <span style="color: #d75fd7;">nil</span>{ <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22788;&#29702;&#38169;&#35823;</span>
        <span style="color: #268bd2; font-weight: bold;">return</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc4e335f" class="outline-4">
<h4 id="orgc4e335f">http.Head()</h4>
<div class="outline-text-4" id="text-orgc4e335f">
<p>
HTTP 中的 Head 请求方式表明只请求目标 URL 的头部信息，即 HTTP Header 而不返回 HTTP<br>
Body。Go 内置的 net/http 包同样也提供了 http.Head() 方法，该方法同 http.Get() 方法一样，<br>
只需传入目标 URL 一个参数即可。下面的示例代码请求一个网站首页的 HTTP Header 信息：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">resp</span>, <span style="color: #8787d7;">err</span> := http.<span style="color: #d75fd7; font-weight: bold;">Head</span>(<span style="color: #2aa198;">"http://baidu.com/"</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-org380ce00" class="outline-4">
<h4 id="org380ce00">(*http.Client).Do()</h4>
<div class="outline-text-4" id="text-org380ce00">
<p>
在多数情况下，http.Get()和 http.PostForm() 就可以满足需求，但是如果我们发起的<br>
HTTP 请求需要更多的定制信息，我们希望设定一些自定义的 Http Header 字段，比如：<br>
</p>

<p>
设定自定义的"User-Agent"<br>
传递 Cookie<br>
此时可以使用 net/http 包 http.Client对象的 Do()方法来实现<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">req</span>, <span style="color: #8787d7;">err</span> := http.<span style="color: #d75fd7; font-weight: bold;">NewRequest</span>(<span style="color: #2aa198;">"GET"</span>, <span style="color: #2aa198;">"http://baidu.com"</span>, <span style="color: #d75fd7;">nil</span>) 
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">...</span>
req.Header.<span style="color: #d75fd7; font-weight: bold;">Add</span>(<span style="color: #2aa198;">"User-Agent"</span>, <span style="color: #2aa198;">"Gobook Custom User-Agent"</span>) 
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">...</span>
<span style="color: #8787d7;">client</span> := &amp;<span style="color: #df005f; font-weight: bold;">http.Client</span>{ <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">... } </span>
<span style="color: #8787d7;">resp</span>, <span style="color: #8787d7;">err</span> := client.<span style="color: #d75fd7; font-weight: bold;">Do</span>(req)
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org0b07415" class="outline-2">
<h2 id="org0b07415">RPC 编程</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-07-24 Sun 04:03</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
