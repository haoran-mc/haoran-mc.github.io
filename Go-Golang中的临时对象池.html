<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-02-14 Mon 23:08 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>GOLANG 中的临时对象池</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">GOLANG 中的临时对象池</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org1eb8ea0">概要</a></li>
<li><a href="#org699b2bf">如何使用</a>
<ul>
<li><a href="#org5b4eff4">初始化 Pool 实例 New</a></li>
<li><a href="#orgca594f5">申请对象 Get</a></li>
<li><a href="#orgdea28d9">释放对象 Put</a></li>
</ul>
</li>
<li><a href="#orgc9249e4">为什么使用 Pool 而不是在运行时直接实例化对象</a>
<ul>
<li><a href="#org9329afe">类比现实的例子</a></li>
</ul>
</li>
<li><a href="#org383f58f">sync.Pool 是并发安全吗</a></li>
<li><a href="#orgadeb272">为什么 sync.Pool 不适合用于像 socket 长连接或数据库连接池</a></li>
<li><a href="#org38fb345">总结</a></li>
</ul>
</div>
</div>

<div id="outline-container-org1eb8ea0" class="outline-2">
<h2 id="org1eb8ea0">概要</h2>
<div class="outline-text-2" id="text-org1eb8ea0">
<p>
Go 并发相关库 <code>sync</code> 里面有一个 <code>sync.Pool</code> ，用很少的代码实现了很棒的功能。第一眼看到， <code>Pool</code> 这个名字，就让人想到池子， <b>元素池化是常用的性能手段</b> （性能优化的几把斧头：并发、预处理、缓存）。比如，创建一个 100 个元素的池，然后就可以在池子里面直接获取到元素，免去了申请和初始化的流程，大大提高了性能。释放元素也是直接丢回池子而免去了真正释放元素带来的开销。<br>
</p>

<p>
<code>sync.Pool</code> 除了最常见的池化提升性能之外，最重要的是减少 GC，常用于一些对象实例创建昂贵的场景，注意： <b>Pool 是 Goroutine 并发安全的</b> 。<br>
</p>
</div>
</div>
<div id="outline-container-org699b2bf" class="outline-2">
<h2 id="org699b2bf">如何使用</h2>
<div class="outline-text-2" id="text-org699b2bf">
<p>
<code>Pool</code> 的用户使用界面只有三个接口，非常简单，而且是通用型的 <code>Pool</code> 池模式，针对所有的对象类型都可以用。<br>
</p>
</div>
<div id="outline-container-org5b4eff4" class="outline-3">
<h3 id="org5b4eff4">初始化 Pool 实例 New</h3>
<div class="outline-text-3" id="text-org5b4eff4">
<p>
使用对象池的第一个步骤就是创建一个 <code>Pool</code> 实例，关键一点是配置 <code>New</code> 方法，声明 <code>Pool</code> 元素创建的方法。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"> <span style="color: #8787d7;">bufferPool</span> := &amp;sync.Pool {
     <span style="color: #d75fd7;">New</span>: <span style="color: #268bd2; font-weight: bold;">func</span>() <span style="color: #268bd2; font-weight: bold;">interface</span> {} {
         <span style="color: #268bd2;">println</span>(<span style="color: #2aa198;">"Create new instance"</span>)
         <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}{}
     },
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgca594f5" class="outline-3">
<h3 id="orgca594f5">申请对象 Get</h3>
<div class="outline-text-3" id="text-orgca594f5">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">buffer</span> := bufferPool.<span style="color: #d75fd7; font-weight: bold;">Get</span>()
</pre>
</div>

<p>
<code>Get</code> 方法会返回 <code>Pool</code> 已经存在的对象，如果没有，那么就走慢路径，也就是调用初始化的时候定义的 <code>New</code> 方法（也就是最开始定义的初始化行为）来初始化一个对象。<br>
</p>
</div>
</div>
<div id="outline-container-orgdea28d9" class="outline-3">
<h3 id="orgdea28d9">释放对象 Put</h3>
<div class="outline-text-3" id="text-orgdea28d9">
<div class="org-src-container">
<pre class="src src-go">bufferPool.<span style="color: #d75fd7; font-weight: bold;">Put</span>(buffer)
</pre>
</div>

<p>
使用对象之后，调用 <code>Put</code> 方法声明把对象放回池子，注意了：这个调用之后仅仅是把这个对象放回池子，池子里面的 <b>对象什么时候真正释放，外界是不清楚的，是不受外部控制的</b> 。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-orgc9249e4" class="outline-2">
<h2 id="orgc9249e4">为什么使用 Pool 而不是在运行时直接实例化对象</h2>
<div class="outline-text-2" id="text-orgc9249e4">
<p>
<b>本质原因</b> ：Go 的内存释放是由 <code>runtime</code> 来自动处理的，有 GC 过程。<br>
</p>

<p>
举个例子：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> main

<span style="color: #268bd2; font-weight: bold;">import</span> (
    <span style="color: #2aa198;">"fmt"</span>
    <span style="color: #2aa198;">"sync"</span>
    <span style="color: #2aa198;">"sync/atomic"</span>
)

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#29992;&#26469;&#32479;&#35745;&#23454;&#20363;&#30495;&#27491;&#21019;&#24314;&#30340;&#27425;&#25968;</span>
<span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">numCalcsCreated</span> <span style="color: #df005f; font-weight: bold;">int32</span>

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21019;&#24314;&#23454;&#20363;&#30340;&#20989;&#25968;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">createBuffer</span>() <span style="color: #268bd2; font-weight: bold;">interface</span>{} {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36825;&#37324;&#35201;&#27880;&#24847;&#19979;&#65292;&#38750;&#24120;&#37325;&#35201;&#30340;&#19968;&#28857;&#12290;&#36825;&#37324;&#24517;&#39035;&#20351;&#29992;&#21407;&#23376;&#21152;&#65292;&#19981;&#28982;&#26377;&#24182;&#21457;&#38382;&#39064;&#65307;</span>
    atomic.<span style="color: #d75fd7; font-weight: bold;">AddInt32</span>(&amp;numCalcsCreated, <span style="color: #d75fd7;">1</span>)
    <span style="color: #8787d7;">buffer</span> := <span style="color: #268bd2;">make</span>([]<span style="color: #df005f; font-weight: bold;">byte</span>, <span style="color: #d75fd7;">1024</span>)
    <span style="color: #268bd2; font-weight: bold;">return</span> &amp;buffer
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21019;&#24314;&#23454;&#20363;</span>
    <span style="color: #8787d7;">bufferPool</span> := &amp;<span style="color: #df005f; font-weight: bold;">sync.Pool</span>{
        <span style="color: #d75fd7;">New</span>: createBuffer,
    }

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22810; goroutine &#24182;&#21457;&#27979;&#35797;</span>
    <span style="color: #8787d7;">numWorkers</span> := <span style="color: #d75fd7;">1024</span> * <span style="color: #d75fd7;">1024</span>
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">wg</span> <span style="color: #df005f; font-weight: bold;">sync.WaitGroup</span>
    wg.<span style="color: #d75fd7; font-weight: bold;">Add</span>(numWorkers)

    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := <span style="color: #d75fd7;">0</span>; i &lt; numWorkers; i++ {
        <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
            <span style="color: #268bd2; font-weight: bold;">defer</span> wg.<span style="color: #d75fd7; font-weight: bold;">Done</span>()
            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#30003;&#35831;&#19968;&#20010; buffer &#23454;&#20363;</span>
            <span style="color: #8787d7;">buffer</span> := bufferPool.<span style="color: #d75fd7; font-weight: bold;">Get</span>()
            _ = buffer.(*[]<span style="color: #df005f; font-weight: bold;">byte</span>)
            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#37322;&#25918;&#19968;&#20010; buffer &#23454;&#20363;</span>
            <span style="color: #268bd2; font-weight: bold;">defer</span> bufferPool.<span style="color: #d75fd7; font-weight: bold;">Put</span>(buffer)
        }()
    }
    wg.<span style="color: #d75fd7; font-weight: bold;">Wait</span>()
    fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%d buffer objects were created.\n"</span>, numCalcsCreated)
}
</pre>
</div>

<p>
输出结果：<br>
</p>

<pre class="example" id="orge04246a">
8 buffer objects were created.
</pre>

<p>
本次运行的结果是有 8 个 <code>buffer</code> 被创建，但是这个数目是不确定的。在创建 <code>Pool</code> 实例时，只填充了 <code>New</code> 函数，没有声明或者限制这个 <code>Pool</code> 的大小。所以， <b>记住一点，程序员作为使用方不能对 <code>Pool</code> 里面的元素个数做假定</b> 。<br>
</p>

<p>
那么，如果不使用 <code>Pool</code> 来申请实例，而是直接申请，也就是上面的代码只改一行：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">buffer := bufferPol.Get()</span>
<span style="color: #8787d7;">buffer</span> := <span style="color: #d75fd7; font-weight: bold;">createBuffer</span>()
</pre>
</div>

<p>
这时候再执行程序：<br>
</p>

<pre class="example" id="org135cef7">
1048576 buffer objects were created.
</pre>

<p>
对象创建的数量和并发 <code>Worker</code> 数量相同，数量等于 1048576（也就是 1024 * 1024），而且这个数量不会变化，是确定的数量。<br>
</p>

<p>
原因很简单，因为每次都是直接调用 <code>createBuffer</code> 函数申请 buffer，有 1048576 个并发 Worker 调用，所以跑多少次结果都会是 1048576。<br>
</p>

<p>
实际上还有一个不同点，就是程序跑的过程中，该进程分配消耗的内存很大。因为 Go 申请内存是程序员触发的，回收却是 Go 内部 runtime GC 回收器来执行的，这是一个异步的操作。这种业务不负责任的内存使用会对 GC 带来非常大的负担，进而影响整体程序的性能。<br>
</p>
</div>

<div id="outline-container-org9329afe" class="outline-3">
<h3 id="org9329afe">类比现实的例子</h3>
<div class="outline-text-3" id="text-org9329afe">
<p>
一个程序猿喝奶茶，需要一个吸管（吸管类比就是我们代码里的 buffer 对象喽），奶茶喝完吸管就扔了，那就是塑料垃圾了（ Garbage ）。清洁工老李（ GC 回收器 ）需要紧跟在后面打扫卫生，现在 1048576 个程序猿同时喝奶茶，每个人都现场要一根新吸管，喝完就扔，马上地上有 1048576 个塑料吸管垃圾。清洁工老李估计要累个半死。<br>
</p>

<p>
那如果，现在在某个隐秘的角落放一个回收箱 （ 类比成 sync.Pool ） ，程序员喝完奶茶之后，吸管就丢到回收箱里，下一个程序员要用吸管的话，伸手进箱子摸一下，看下有管子吗？有的话，就拿来用了。没有的话，就再找人要一根新吸管。这样新吸管的使用数量就大大减少了呀，地上也没垃圾了，老李也轻松了，多好呀。<br>
</p>

<p>
并且，极限情况下，如果大家喝奶茶足够快，保证箱子里每时每刻都至少有一根用过的吸管，那 1048576 个程序员估计用一根吸管都够了。。。。（有点想吐。。。）<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org383f58f" class="outline-2">
<h2 id="org383f58f">sync.Pool 是并发安全吗</h2>
<div class="outline-text-2" id="text-org383f58f">
<p>
<code>sync.Pool</code> 是并发安全的，官方文档里明确说了：<br>
</p>

<blockquote>
<p>
A Pool is safe for use by multiple goroutines simultaneously.<br>
</p>
</blockquote>

<p>
但是 <code>sync.Pool</code> 只是本身的 <code>Pool</code> 数据结构是并发安全的，并不是说 <code>Pool.New</code> 函数一定是线程安全的。 <code>Pool.New</code> <b>函数可能会被并发调用</b> ，如果 <code>New</code> 函数里面的实现是非并发安全的，那就会有问题。<br>
</p>

<p>
细心的小伙伴会注意到我在上面的代码例子里，关于 createBuffer 函数的实现里，对于 numCalcsCreated 的计数加是用原子操作的：atomic.AddInt32(&amp;numCalcsCreated, 1) 。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">createBuffer</span>() <span style="color: #268bd2; font-weight: bold;">interface</span>{} {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36825;&#37324;&#35201;&#27880;&#24847;&#19979;&#65292;&#38750;&#24120;&#37325;&#35201;&#30340;&#19968;&#28857;&#12290;&#36825;&#37324;&#24517;&#39035;&#20351;&#29992;&#21407;&#23376;&#21152;&#65292;&#19981;&#28982;&#26377;&#24182;&#21457;&#38382;&#39064;&#65307;</span>
    atomic.<span style="color: #d75fd7; font-weight: bold;">AddInt32</span>(&amp;numCalcsCreated, <span style="color: #d75fd7;">1</span>)
    <span style="color: #8787d7;">buffer</span> := <span style="color: #268bd2;">make</span>([]<span style="color: #df005f; font-weight: bold;">byte</span>, <span style="color: #d75fd7;">1024</span>)
    <span style="color: #268bd2; font-weight: bold;">return</span> &amp;buffer
}
</pre>
</div>

<p>
因为 <code>numCalcsCreated</code> 是个全局变量， <code>Pool.New</code> （ 也就是 <code>createBuffer</code> ） 并发调用的时候，会导致 data race ，所以只有用原子操作才能保证数据的正确性。<br>
</p>

<p>
小伙伴们可以尝试下，把 <code>atomic.AddInt32(&amp;numCalcsCreated, 1)</code> 这样代码改成 <code>numCalcsCreated ++</code> ，然后用 <code>go run -race test_pool.go</code> 命令检查一下，肯定会报告告警的，类似如下：<br>
</p>

<pre class="example" id="org70b9e88">
WARNING: DATA RACE
Read at 0x000001287538 by goroutine 10:

Previous write at 0x000001287538 by goroutine 7:

==================
==================
WARNING: DATA RACE
Read at 0x000001287538 by goroutine 9:
	main.createBuffer()

</pre>

<p>
<b>本质原因</b> ： <code>Pool.New</code> 函数可能会被并发调用。<br>
</p>
</div>
</div>
<div id="outline-container-orgadeb272" class="outline-2">
<h2 id="orgadeb272">为什么 sync.Pool 不适合用于像 socket 长连接或数据库连接池</h2>
<div class="outline-text-2" id="text-orgadeb272">
<p>
因为，我们不能对 sync.Pool 中保存的元素做任何假设，以下事情是都可以发生的：<br>
</p>

<ol class="org-ol">
<li>Pool 池里的元素随时可能释放掉，释放策略完全由 runtime 内部管理；<br></li>
<li>Get 获取到的元素对象可能是刚创建的，也可能是之前创建好 cache 住的。使用者无法区分；<br></li>
<li>Pool 池里面的元素个数你无法知道；<br></li>
</ol>

<p>
所以，只有的你的场景满足以上的假定，才能正确的使用 Pool 。sync.Pool 本质用途是增加临时对象的重用率，减少 GC 负担。划重点：临时对象。所以说，像 socket 这种带状态的，长期有效的资源是不适合 Pool 的。<br>
</p>
</div>
</div>
<div id="outline-container-org38fb345" class="outline-2">
<h2 id="org38fb345">总结</h2>
<div class="outline-text-2" id="text-org38fb345">
<ol class="org-ol">
<li>sync.Pool 本质用途是增加临时对象的重用率，减少 GC 负担；<br></li>
<li>不能对 Pool.Get 出来的对象做预判，有可能是新的（新分配的），有可能是旧的（之前人用过，然后 Put 进去的）；<br></li>
<li>不能对 Pool 池里的元素个数做假定，你不能够；<br></li>
<li>sync.Pool 本身的 Get, Put 调用是并发安全的，sync.New 指向的初始化函数会并发调用，里面安不安全只有自己知道；<br></li>
<li>当用完一个从 Pool 取出的实例时候，一定要记得调用 Put，否则 Pool 无法复用这个实例，通常这个用 defer 完成；<br></li>
</ol>

<p style="font-size: smaller; text-align: right;">本文分享自微信公众号 - 网管叨bi叨（kevin_tech）</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-02-14 20:02 Mon</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-02-14 Mon 23:08</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
