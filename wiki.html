<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-06-30 Thu 16:09 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>WIKI</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">WIKI</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org6525efa"><i><span class="timestamp-wrapper"><span class="timestamp">[2022-06-30 Thu 16:09]</span></span></i> 冯·诺依曼体系结构</a></li>
<li><a href="#org6259003"><i><span class="timestamp-wrapper"><span class="timestamp">[2022-05-31 Tue 16:08]</span></span></i> shebang</a></li>
<li><a href="#orgaa232c9"><i><span class="timestamp-wrapper"><span class="timestamp">[2022-05-29 Sun 14:51]</span></span></i> 奶头乐理论</a></li>
<li><a href="#orgc4c1d22"><i><span class="timestamp-wrapper"><span class="timestamp">[2022-05-28 Sat 11:34]</span></span></i> 回调函数（callback）是什么？</a></li>
<li><a href="#org3a6b917"><i><span class="timestamp-wrapper"><span class="timestamp">[2022-05-28 Sat 03:54]</span></span></i> handle 与 handler 的区别</a></li>
<li><a href="#orgbc69921"><i><span class="timestamp-wrapper"><span class="timestamp">[2022-05-15 Sun 02:46]</span></span></i> 有300%利润资本敢冒杀头的危险</a></li>
<li><a href="#orga310d3a"><i><span class="timestamp-wrapper"><span class="timestamp">[2022-03-25 Fri 17:48]</span></span></i> 节点和结点有什么区别</a></li>
<li><a href="#orgef74666"><i><span class="timestamp-wrapper"><span class="timestamp">[2022-02-27 Sun 20:45]</span></span></i> TCP 标志字段的含义</a></li>
<li><a href="#org11d2605"><i><span class="timestamp-wrapper"><span class="timestamp">[2022-11-14 Mon 10:28]</span></span></i> 把 rm 命令更改为 mv 命令</a></li>
<li><a href="#org12de429"><i><span class="timestamp-wrapper"><span class="timestamp">[2021-11-24 Wed 14:27]</span></span></i> 命令行工具 curl</a></li>
<li><a href="#orgca7c7e3"><i><span class="timestamp-wrapper"><span class="timestamp">[2021-11-24 Wed 14:27]</span></span></i> 不同语言中的自增运算符</a></li>
<li><a href="#org819be70"><i><span class="timestamp-wrapper"><span class="timestamp">[2021-11-24 Wed 14:27]</span></span></i> 静态网页与动态网页</a></li>
<li><a href="#org2e65a21"><i><span class="timestamp-wrapper"><span class="timestamp">[2021-11-24 Wed 14:27]</span></span></i> 几个 C++ 在线编译器</a></li>
</ul>
</div>
</div>
<style>
#table-of-contents i {
    display: none;
}
</style>

<div id="outline-container-org6525efa" class="outline-2">
<h2 id="org6525efa"><i><span class="timestamp-wrapper"><span class="timestamp">[2022-06-30 Thu 16:09]</span></span></i> 冯·诺依曼体系结构</h2>
<div class="outline-text-2" id="text-org6525efa">
<p>
数学家冯·诺依曼提出了计算机制造的三个基本原则，即采用二进制逻辑、程序存储执行以及计算机由五个部分组成（运算器、控制器、存储器、输入设备、输出设备），这套理论被称为冯·诺依曼体系结构。<br>
</p>
</div>
</div>
<div id="outline-container-org6259003" class="outline-2">
<h2 id="org6259003"><i><span class="timestamp-wrapper"><span class="timestamp">[2022-05-31 Tue 16:08]</span></span></i> shebang</h2>
<div class="outline-text-2" id="text-org6259003">
<p>
在计算领域中， <b>Shebang</b> （也称为 <b>Hashbang</b> ）是一个由井号和叹号构成的字符序列 <code>#!</code> ，其出现在文本文件的第一行的前两个字符。 在文件中存在 Shebang 的情况下，类 Unix 操作系统的程序载入器会分析 Shebang 后的内容，将这些内容作为解释器指令，并调用该指令，并将载有 Shebang 的文件路径作为该解释器的参数。<br>
</p>

<p>
例如，以指令 <code>#!/bin/sh</code> 开头的文件在执行时会实际调用 <code>/bin/sh</code> 程序（通常是 Bourne shell 或兼容的 shell，例如 bash、dash 等）来执行。这行内容也是 shell 脚本的标准起始行。<br>
</p>

<p>
由于 <code>#</code> 符号在许多脚本语言中都是注释标识符，Shebang 的内容会被这些脚本解释器自动忽略。 在 <code>#</code> 字符不是注释标识符的语言中，例如 Scheme，解释器也可能忽略以 <code>#!</code> 开头的首行内容，以提供与 Shebang 的兼容性。<br>
</p>

<p>
"Shebang"或者说"Hashbang"的名字有时也被当做Ajax应用程序中的分段标识符，用于浏览器的状态保存；Google网站站长中心提到，以叹号开头的分段标识符（即&#x2026;url#!state&#x2026;）会为Google的网页爬虫所索引。<br>
</p>
</div>
</div>
<div id="outline-container-orgaa232c9" class="outline-2">
<h2 id="orgaa232c9"><i><span class="timestamp-wrapper"><span class="timestamp">[2022-05-29 Sun 14:51]</span></span></i> 奶头乐理论</h2>
<div class="outline-text-2" id="text-orgaa232c9">
<blockquote>
<p>
刺激他们的欲望，降低他们的工资，借钱给他们花，让他们忙的停不下来，同时开放大量的娱乐项目，使他们又不至于崩溃。<br>
</p>

<p>
当娱乐大量占用人们的时间，让人们丧失思考的能力，这一社会麻醉剂将会带来“马太效应”，沉迷的人继续沉迷，清醒的人保持清醒，人与人的差距，甚至阶层间的差距也就拉大了。<br>
</p>

<p>
从而消磨他们的斗志，抹平阶级跃迁的愿望。<br>
</p>
</blockquote>
</div>
</div>
<div id="outline-container-orgc4c1d22" class="outline-2">
<h2 id="orgc4c1d22"><i><span class="timestamp-wrapper"><span class="timestamp">[2022-05-28 Sat 11:34]</span></span></i> 回调函数（callback）是什么？</h2>
<div class="outline-text-2" id="text-orgc4c1d22">
<blockquote>
<p>
A "callback" is any function that is called by another function which takes the first function as a parameter. （在一个函数中调用另外一个函数就是callback）<br>
</p>
</blockquote>

<p>
回调函数就是一个函数，形式上和其他函数没有半点区别。只不过这个所谓的回调函数是将要被当作参数传递给另一个函数，并被其调用。<br>
</p>

<ul class="org-ul">
<li>一般函数： <code>function a(int a, String b)</code> 接收的参数是一般类型；<br></li>
<li>特殊函数： <code>function b(function c)</code> 接收的参数是一个函数，这个函数就叫回调函数；<br></li>
</ul>

<p>
本质区别是：一般一个函数调用另一个函数，被调用的函数是出现在方法体当中；而回调函数比较特殊，他是出现在参数列表中，当调用的时候，需要从其他地方拿到这个（回调）函数，以参数的形式传入。<br>
</p>

<p>
一般的函数调用被称作调用；然而另一种，执行时才将某个函数传入再调用的调用方式就叫 "回调"，当然，不用纠结于翻译的准不准，主要需要理解本质是什么。<br>
</p>

<p>
完全面向对象的语言（例如Java）中没有回调函数的概念，因为 "接口"（中的方法）充当了调用函数的作用，也就是说上面的函数 b 接受的对象是一个接口实现类对象。 <span class="underline">回调函数的概念一般出现在面向过程或者函数式编程中才出现。</span><br>
</p>

<p>
让我们看一些例子：<br>
</p>

<div class="org-src-container">
<pre class="src src-js"><span style="color: #268bd2; font-weight: bold;">function</span> <span style="color: #d75fd7; font-weight: bold;">callback</span>() {
    alert(<span style="color: #2aa198;">"I am in the callback!"</span>);
}

<span style="color: #268bd2; font-weight: bold;">function</span> <span style="color: #d75fd7; font-weight: bold;">work</span>(<span style="color: #8787d7;">func</span>) {
    alert(<span style="color: #2aa198;">"I am calling the callback!"</span>);
    func();
}

work(callback);
</pre>
</div>

<p>
这就是一个简单的 <i>callback</i> ， <i>callback</i> 作为一个变量传入函数 <i>work</i> 中，在 <i>work</i> 中被调用。<br>
</p>

<p>
再来看一看 <i>callback</i> 经常的使用场景：<br>
</p>

<blockquote>
<p>
A lot of the time, a "callback" is a function that is called when something happens. That something can be called an "event" in programmer-speak.（很多时候 callback 都是用来执行事件驱动的任务 比如有货了通知我 | 你到家了再叫我做饭 等等之类的 ）<br>
</p>
</blockquote>

<p>
举个简单的例子，对一个文件的读入：<br>
</p>

<p>
如果不用 <i>callback</i> ：<br>
</p>

<div class="org-src-container">
<pre class="src src-js">fileObject = open(file)
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#25105;&#20204;&#24517;&#39035;&#31561;&#21040;&#25991;&#20214;&#25171;&#24320;&#25165;&#33021;&#36827;&#34892;&#35835;&#20837; &#22312;&#36825;&#20043;&#21069;&#25105;&#20204;&#19981;&#33021;&#20570;&#20854;&#20182;&#20107;&#24773;</span>
fileObject.write(<span style="color: #2aa198;">"We are writing to the file."</span>)
</pre>
</div>

<p>
使用 <i>callback</i> ：<br>
</p>

<div class="org-src-container">
<pre class="src src-js"><span style="color: #268bd2; font-weight: bold;">function</span> <span style="color: #d75fd7; font-weight: bold;">openFile</span>(<span style="color: #8787d7;">filePath</span>, <span style="color: #8787d7;">callback</span>){
    alert(<span style="color: #2aa198;">"start opening file in"</span> + filePath);
    callback();   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">when finished, execute callback()</span>
}

<span style="color: #268bd2; font-weight: bold;">function</span> <span style="color: #d75fd7; font-weight: bold;">writeToFile</span>(){
    alert(<span style="color: #2aa198;">"i'm now writing file"</span>);
}

openFile(<span style="color: #2aa198;">"c://test.csv"</span>, writeToFile);
</pre>
</div>

<p>
如果我们在调用 <code>openFile</code> 这个例子 我们先会收到 start opening file in c://test.csv 然后会收到 i'm now writing file 这不需要你 <i>call</i> 它。。在你 open file 结束之后就会被自动执行了。<br>
</p>
</div>
</div>
<div id="outline-container-org3a6b917" class="outline-2">
<h2 id="org3a6b917"><i><span class="timestamp-wrapper"><span class="timestamp">[2022-05-28 Sat 03:54]</span></span></i> handle 与 handler 的区别</h2>
<div class="outline-text-2" id="text-org3a6b917">
<p>
<a id="org75bc823"></a> handle 既是名词也是动词，而 handler 只是个名词。在计算机编程术语里 handle 作为名词时是对可进行管理的资源对象的抽象，handle 指向某个类别的资源对象，如文件句柄，进程 ID 都可以用 handle 来表达，在当动词讲时含义是处理和操作。<br>
</p>

<p>
而 handler 表示的是过程（函数），理解为功能处理器的含义，如常用的回调函数可以用 handler 来表示。<br>
</p>
</div>
</div>
<div id="outline-container-orgbc69921" class="outline-2">
<h2 id="orgbc69921"><i><span class="timestamp-wrapper"><span class="timestamp">[2022-05-15 Sun 02:46]</span></span></i> 有300%利润资本敢冒杀头的危险</h2>
<div class="outline-text-2" id="text-orgbc69921">
<p>
评论家季刊说：“资本逃避动乱和纷争，它的本性是胆怯的。这是真的，但还不是全部真理。资本害怕没有利润或利润太少，就象自然界害怕真空一样。一旦有适当的利润，资本就胆大起来。如果有10%的利润，它就保证到处被使用；有20%的利润，它就活跃起来；有50%的利润，它就铤而走险；为了100%的利润，它就敢践踏一切人间法律；有300%的利润，它就敢犯任何罪行，甚至冒绞首的危险。如果动乱和纷争能带来利润，它就会鼓励动乱和纷争。走私和贩卖奴隶就是证明。”（托·约·登宁《工联和罢工》1860年伦敦版第35、36页）<br>
</p>
</div>
</div>
<div id="outline-container-orga310d3a" class="outline-2">
<h2 id="orga310d3a"><i><span class="timestamp-wrapper"><span class="timestamp">[2022-03-25 Fri 17:48]</span></span></i> 节点和结点有什么区别</h2>
<div class="outline-text-2" id="text-orga310d3a">
<p>
节点和结点的区别是：1、节点是一个实体，它具有处理的能力；2、结点是一个交叉点、一个标记，算法中的点一般都称为结点，数据集合中的每一个数据元素都用中间标有元素值的方框来表示，我们称它为结点。<br>
</p>

<p>
节点被认为是一个实体，有处理能力，比如网络上的一台计算机；而结点则只是一个交叉点，像"结绳记事"，打个结，做个标记，仅此而已，还有就是，要记住：一般算法中点的都是结点。<br>
</p>

<p>
我们在数据结构的图形表示中，对于数据集合中的每一个数据元素用中间标有元素值的方框表示，一般称它为数据结点，简称结点。在链表数据结构中，链表中每一个元素称为"结点"，每个结点都应包括两个部分：一个是需要用的实际数据 data；另一个就是存储下一个结点地址的指针，即数据域和指针域。数据结构中的每一个数据结点对应于一个存储单元，这种储存单元称为储存结点，也可简称结点。<br>
</p>
</div>
</div>
<div id="outline-container-orgef74666" class="outline-2">
<h2 id="orgef74666"><i><span class="timestamp-wrapper"><span class="timestamp">[2022-02-27 Sun 20:45]</span></span></i> TCP 标志字段的含义</h2>
<div class="outline-text-2" id="text-orgef74666">
<ul class="org-ul">
<li>FIN: "finished"简写。表示发送者以及发送完数据。通常用在发送者发送完数据的最后一个包中。<br></li>
<li>SYN: "Synchronisation"简写。表示三次握手建立连接的第一步，在建立连接时发送者发送的第一个包中设置flag值为SYN。<br></li>
<li>RST: "reset"简写。重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者发送包发送到一个不是期望的                  目的主机时，接收端发送reset 重置连接标志的包。<br></li>
<li>PSH: "push"简写。通知接收端处理接收的报文，而不是将报文缓存到buffer中。<br></li>
<li>ACK: "Acknowledgment"简写。表示包已经被成功接收。<br></li>
<li>URG: "urgent"简写。通知接收端处理在处理其他包前优先处理接收到的紧急报文（urgent packets）。详见RFC6093。<br></li>
<li>ECE: "ECN-Echo"简写。ECN表示Explicit Congestion Notification。表示TCP peer有ECN能力。详见RFC3168。<br></li>
<li>CWR: "Congestion Window Reduced"简写。发送者在接收到一个带有ECE flag包时，将会使用CWR flag。 详见RFC3168。<br></li>
<li>NS: "nonce sum"简写。该标签用来保护不受发送者发送的突发的恶意隐藏报文的侵害。详见 RFC 3540。<br></li>
</ul>
</div>
</div>

<div id="outline-container-org11d2605" class="outline-2">
<h2 id="org11d2605"><i><span class="timestamp-wrapper"><span class="timestamp">[2022-11-14 Mon 10:28]</span></span></i> 把 rm 命令更改为 mv 命令</h2>
<div class="outline-text-2" id="text-org11d2605">
<p>
前几天使用一个日志包，配置指定了日志的输出位置为 <code>~/logs</code> ，然后就项目里多了一个 <code>~/logs</code> 文件夹，看来这个日志包输出位置有默认的前缀就是当前项目，于是我就下意识的 <code>rm -rf ~</code> ，刚按下回车键就猛然想到 <code>~</code> 有家目录的特殊含义，于是我就强行停止了这个命令，后面我大致的看一看也没发现少什么东西，所以还庆幸自己反应快。<br>
</p>

<p>
然而今天打开我的 <code>Code</code> 文件夹时，我哇的一声就哭了出来，我的 <code>ACM</code> 模板没了。<br>
</p>

<p>
请大家吸取我的教训，把 rm 命令改为 mv 命令，把所有的删除命令改为把需要删除的文件、目录放在 ~/.trash，然后定期清理。<br>
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#23558;&#19979;&#38754;&#20960;&#34892;&#25918;&#22312; ~/.bashrc &#25991;&#20214;&#22841;&#30340;&#26368;&#21518;</span>

mkdir -p ~/.trash   <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#22312;&#23478;&#30446;&#24405;&#19979;&#21019;&#24314;&#19968;&#20010;.trash&#25991;&#20214;&#22841;(&#38544;&#34255;&#25991;&#20214;&#65292;ls -a &#26597;&#30475;)</span>
<span style="color: #268bd2;">alias</span> <span style="color: #8787d7;">rm</span>=del        <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#20351;&#29992;&#21035;&#21517;del&#20195;&#26367;rm   </span>
<span style="color: #d75fd7; font-weight: bold;">del</span>()               <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#20989;&#25968;del&#65292;&#20316;&#29992;&#65306;&#23558;rm&#21629;&#20196;&#20462;&#25913;&#20026;mv&#21629;&#20196;</span>
{  
    mv $<span style="color: #8787d7;">@</span> ~/.trash/  
}  
</pre>
</div>
</div>
</div>

<div id="outline-container-org12de429" class="outline-2">
<h2 id="org12de429"><i><span class="timestamp-wrapper"><span class="timestamp">[2021-11-24 Wed 14:27]</span></span></i> 命令行工具 curl</h2>
<div class="outline-text-2" id="text-org12de429">
<p>
cURL是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。cURL还包含了用于程序开发的libcurl。<br>
</p>

<p>
<a href="Linux-curl.html">详细介绍在这！</a> <br>
</p>
</div>
</div>
<div id="outline-container-orgca7c7e3" class="outline-2">
<h2 id="orgca7c7e3"><i><span class="timestamp-wrapper"><span class="timestamp">[2021-11-24 Wed 14:27]</span></span></i> 不同语言中的自增运算符</h2>
<div class="outline-text-2" id="text-orgca7c7e3">
<dl class="org-dl">
<dt>C</dt><dd>既有 <code>i ++</code> ，也有 <code>++ i</code><br></dd>
<dt>Python</dt><dd>没有自增运算符<br></dd>
<dt>Go</dt><dd>Golang 的设计者认为 C 语言中的两种自增自减会引起歧义，所以没有留下 <code>++ i</code> ，只有 <code>i ++</code><br></dd>
</dl>
</div>
</div>
<div id="outline-container-org819be70" class="outline-2">
<h2 id="org819be70"><i><span class="timestamp-wrapper"><span class="timestamp">[2021-11-24 Wed 14:27]</span></span></i> 静态网页与动态网页</h2>
<div class="outline-text-2" id="text-org819be70">
<p>
静态网页是网站建设的基础，静态网页和动态网页之间也并不矛盾，为了网站适应搜索引擎检索的需要，即使采用动态网站技术，也可以将网页内容转化为静态网页发布。<br>
</p>

<p>
一、静态页面<br>
</p>
<ol class="org-ol">
<li>在静态Web程序中，客户端使用Web浏览器（IE、FireFox等）经过网络（Network）连接到服务器上，使用HTTP协议发起一个请求（Request），告诉服务器我现在需要得到哪个页面，所有的请求交给Web服务器，之后WEB服务器根据用户的需要，从文件系统（存放了所有静态页面的磁盘）取出内容。之后通过Web服务器返回给客户端，客户端接收到内容之后经过浏览器渲染解析，得到显示的效果。<br></li>
<li>为了让静态web页面显示更加好看，使用javascript／VBScript／ajax（AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。）但是这些特效都是在客户端上借助于浏览器展现给用户的，所以在服务器上本身并没有任何的变化。<br></li>
</ol>

<p>
二、动态页面<br>
动态WEB中，程序依然使用客户端和服务端，客户端依然使用浏览器（IE、FireFox等），通过网络（Network）连接到服务器上，使用HTTP协议发起请求（Request），现在的所有请求都先经过一个WEB Server来处理。<br>
如果客户端请求的是静态资源（.htm或者是.htm），则将请求直接转交给WEB服务器，之后WEB服务器从文件系统中取出内容，发送回客户端浏览器进行解析执行。<br>
</p>

<ol class="org-ol">
<li>如果客户端请求的是动态资源（.jsp、.asp/.aspx、.php），则先将请求转交给WEB Container（WEB容器），在WEB Container中连接数据库，从数据库中取出数据等一系列操作后动态拼凑页面的展示内容，拼凑页面的展示内容后，把所有的展示内容交给WEB服务器，之后通过WEB服务器将内容发送回客户端浏览器进行解析执行。再进一步深入分析动态web的访问过程：浏览器访问web时，看似是直接访问的jsp页面，其实是，最先到达的地方是服务器，服务器创建好req和resp对象后再给jsp页面使用。在jsp中完成设置字符集和取得表单参数后再调用servlet，完成业务处理。然后返回到jsp，jsp就会生成相应的html页面。该页面会返回到服务器，再由服务器，通过response对象返回给客户端。<br></li>
<li>采用动态网页技术的网站可以实现更多的功能，如用户注册、用户登录、在线调查、用户管理、订单管理等等；<br></li>
<li>动态网页实际上并不是独立存在于服务器上的网页文件，只有当用户请求时服务器才返回一个完整的网页；<br></li>
</ol>
</div>
</div>
<div id="outline-container-org2e65a21" class="outline-2">
<h2 id="org2e65a21"><i><span class="timestamp-wrapper"><span class="timestamp">[2021-11-24 Wed 14:27]</span></span></i> 几个 C++ 在线编译器</h2>
<div class="outline-text-2" id="text-org2e65a21">
<ul class="org-ul">
<li><a href="http://ideone.com/">http://ideone.com/</a><br></li>
<li><a href="http://coliru.stacked-crooked.com/">http://coliru.stacked-crooked.com/</a><br></li>
<li><a href="http://gcc.godbolt.org/">http://gcc.godbolt.org/</a><br></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2021-10-13 22:10 Wed</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-06-30 Thu 16:09</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
