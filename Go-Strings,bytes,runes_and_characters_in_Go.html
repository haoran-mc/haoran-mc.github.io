<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-04-15 Fri 01:38 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Strings, bytes, runes and characters in Go</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="static/MathJax/cdn.bootcdn.net/ajax/libs/mathjax/3.1.2/es5/tex-mml-chtml.min.js"></script>
</head>
<body>
<div id="content">
<h1 class="title">Strings, bytes, runes and characters in Go</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org4bc53ec">为什么读取不到字符串下标n的值？</a></li>
<li><a href="#org5bcd976">介绍</a></li>
<li><a href="#org0d5cb5c">什么是string？</a></li>
<li><a href="#org5d59d59">看一个例子：打印 string</a></li>
<li><a href="#orgf27a138">UTF-8和字符串文字</a></li>
<li><a href="#org6bf27b0">code point、字符和runes之间的关系</a></li>
<li><a href="#orgc0372a0">再看一个例子：range 循环和下标循环的区别</a></li>
<li><a href="#orgfb1eccb">一些常用的字符串处理库</a></li>
<li><a href="#orgf191842">总结</a></li>
</ul>
</div>
</div>
<p>
Note. 本文主要参考 <a href="https://blog.golang.org/strings">官方介绍字符串的博客</a> ，希望能帮助读者在编码过程中能够正确处理字符串。<br>
</p>
<div id="outline-container-org4bc53ec" class="outline-2">
<h2 id="org4bc53ec">为什么读取不到字符串下标n的值？</h2>
<div class="outline-text-2" id="text-org4bc53ec">
<p>
我们先来看一个常见的读取字符串里面某个字符操作：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">testString</span>() {
        <span style="color: #8787d7;">s</span> := <span style="color: #2aa198;">"&#25105;&#26159;&#20013;&#22269;&#20154;"</span>
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#38169;&#35823;&#29992;&#27861;&#65306;&#35835;&#21462;&#8220;&#25105;&#8221;</span>
        fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"%c"</span>,s[0]) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36755;&#20986;&#65306;&#230;</span>
}
</pre>
</div>

<p>
这是一个很多从其他编程语言如 java、c++ 的开发者刚转到 golang 来可能都会犯的错误：本来是想读取 s 的第一个字符“我”，但是输出的是一个拉丁符号“æ”。下面开始介绍 golang 的 string 类型，最后再回答为什么会输出号“æ”，如果想输出“我”代码该怎么写。<br>
</p>
</div>
</div>
<div id="outline-container-org5bcd976" class="outline-2">
<h2 id="org5bcd976">介绍</h2>
<div class="outline-text-2" id="text-org5bcd976">
<p>
在介绍 string 类型前，希望能先阅读 <a href="http://blog.golang.org/slices">Arrays, slices (and strings): The mechanics of 'append'</a>  了解下 golang 的 slices。这篇 blog 用了大量示例来说明 slice 实现背后的机制。在此背景下，本文再来讨论 golang 的字符串。刚开始读者可能觉得字符串看起来太过简单，以至于不值得用一篇博客来介绍。但是要使用它们，不仅需要理解它们的原理，还需要理解字节，字符和 rune 之间的区别，Unicode 和 UTF-8，字符串和字符串文字的区别，以及其他更微妙的区别。<br>
</p>

<p>
<b>Note. UTF-8 是一种字符编码规范，一个字符的长度不固定，可以用 1-4 个字节来表示，更多详细请参考 <a href="https://zh.wikipedia.org/wiki/UTF-8">UTF-8</a> 介绍链接。而 Unicode 是另外一种字符编码规范，用“U+”随后紧接着 4 个数字来表示一个字符。</b><br>
</p>

<p>
正如上面那个问题，有很多细节需要掌握才能正确使用 golang 的 string 类型。<br>
</p>
</div>
</div>
<div id="outline-container-org0d5cb5c" class="outline-2">
<h2 id="org0d5cb5c">什么是string？</h2>
<div class="outline-text-2" id="text-org0d5cb5c">
<p>
我们先从一些基础开始。<br>
</p>

<p>
在 Go 中，一个字符串实际上是一个 <b>只读的字节 slice</b> 。如果你完全不确定字节 slice 是什么或者它的用法，请先阅读 <a href="https://go.dev/blog/slices">Arrays, slices (and strings): The mechanics of 'append'</a> ；下面假设你已经了解过 slice。<br>
</p>

<p>
值得重要声明的是： <b>一个字符串能够存储任意字节</b> 。它没有约定一定要存储 Unicode 文本、UTF-8文本或者任何其他预定义的格式。就字符串的内容而言，它完全等价于一个字节 slice。<br>
</p>

<p>
下面是一个字符串文字，它使用 \xNN 符号来定义一个包含一些特殊字节值的字符串常量。（当然，每个字节范围是从十六进制的 00 到 FF）<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">const</span> <span style="color: #d75fd7;">sample</span> = <span style="color: #2aa198;">"\xbd\xb2\x3d\xbc\x20\xe2\x8c\x98"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org5d59d59" class="outline-2">
<h2 id="org5d59d59">看一个例子：打印 string</h2>
<div class="outline-text-2" id="text-org5d59d59">
<p>
由于上面的示例字符串里面包含一些特殊的字节值，这些值既不是有效的 ASCII 码，也不是有效的 UTF-8 码，直接打印这个字符串会输出一些奇怪的符号。打印 string：<br>
</p>

<div class="org-src-container">
<pre class="src src-go">fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(sample)
</pre>
</div>

<p>
会输出一堆乱码（具体的输出跟运行环境有关）<br>
</p>

<pre class="example">
��=� ⌘
</pre>

<p>
为了弄清楚这个字符串究竟是什么，我们需要拆开这个字符串看看里面都是些什么。有好几种方式可以做到这点，但最明显的就是循环遍历这个字符串内容并单独分析每个里面每个字节，就像在 for 循环中一样：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := 0; i &lt; <span style="color: #268bd2;">len</span>(sample); i++ {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%x "</span>, sample[i])
}
</pre>
</div>

<p>
如前面的例子所暗示，索引字符串可以访问单个字节，而不是字符。我们将在下面回过头来详细讨论这个话题，以下是按字节循环输出的结果：<br>
</p>

<pre class="example">
bd b2 3d bc 20 e2 8c 98
</pre>

<p>
这个字符串使用了转移的十六进制符来表示每个字节。<br>
</p>

<p>
为杂乱的字符串生成美观的可呈现的输出的更简单的方法是使用 fmt.Printf 的 %x（十六进制）格式化输出字符串。它会把字符串的连续字节转换为十六进制数字，每个字节两个数字。<br>
</p>

<div class="org-src-container">
<pre class="src src-go">fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%x\n"</span>, sample)
</pre>
</div>

<p>
这种输出的结果如下：<br>
</p>

<pre class="example">
bdb23dbc20e28c98
</pre>

<p>
一个小窍门是使用该格式的“空格”标志，在 % 和 x 之间放置一个空格，这样能够使得输出看起来更美观。<br>
</p>

<div class="org-src-container">
<pre class="src src-go">fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"% x\n"</span>, sample)
</pre>
</div>

<p>
从下面的输出结果可以看出每个字节间有一个空格符，从而使得整个字符串看起来不那么费劲：<br>
</p>

<pre class="example">
bd b2 3d bc 20 e2 8c 98
</pre>

<p>
还有一种打印方式，使用 fmt.Printf 的 %q（引用）占位符，这个占位符对任何无法打印的字节序列转义，对可以打印的字节序列直接输出相应的字符，所以在不同环境下输出结果也不会是一些无棱两可的乱码。<br>
</p>

<div class="org-src-container">
<pre class="src src-go">fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%q\n"</span>, sample)
</pre>
</div>

<p>
输出结果如下：<br>
</p>

<pre class="example">
"\xbd\xb2=\xbc ⌘"
</pre>

<p>
如果我们仔细看输出，我们可以看到除了几个无法打印被转移的十六进制符号外，还有一个 ASCII 等号和一个空格符和一个瑞典符号”Place of Interest”。这个符号的 Unicode 值为 U+2318，在空格（十六进制 20）后面，它的 UTF-8 值为 <code>e2 8c 98</code> 。<br>
</p>

<p>
如果我们对字符串中的奇怪值不熟悉或感到困惑的时候，可以似乎用 %+q 占位符来查看这些奇怪值对应的 UTF-8 值是什么，然后通过 <a href="http://www.utf8-chartable.de/unicode-utf8-table.pl">UTF-8</a> 表查询就可以知道是哪个国家的什么符号。这种占位符不仅可以转义不可打印的序列，而且还可以转义任何非 ASCII 字节，同时能够解析 UTF-8 字节。结果是它会显示正确格式的 UTF-8 字节序列的 Unicode 值，它表示字符串中的非 ASCII 数据：<br>
</p>

<div class="org-src-container">
<pre class="src src-go">fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%+q\n"</span>, sample)
</pre>
</div>

<p>
用这种格式，瑞典符号”Place of Interest”将显示为转义的 Unicode 值 \uxxxx:<br>
</p>

<pre class="example">
"\xbd\xb2=\xbc \u2318"
</pre>

<p>
这些打印技术在调试字符串的内容时很有用，并且在下面的讨论中也很方便。值得指出的是，所有这些方法对字节 slices 和字符串的作用都是一样的。 <b>这也印证了 golang 的字符串本质上是字节 slices</b> 。<br>
</p>
</div>
</div>
<div id="outline-container-orgf27a138" class="outline-2">
<h2 id="orgf27a138">UTF-8和字符串文字</h2>
<div class="outline-text-2" id="text-orgf27a138">
<p>
正如我们所看到的，索引一个字符串会产生一个字节而不是一个字符：一个字符串只是一堆字节。这意味着当我们将一个字符存到一个字符串中时，我们只是把字符对应的字节存起来。我们通过下面的例子来说明这个结论。<br>
</p>

<p>
这是一个简单的程序，它用三种不同的方式打印一个字符串常量，一个是纯字符串，一个是 ASCII 引用字符串，一个是十六进制单个字节。为了避免混淆，我们通过后引号来声明一个“原始字符串”，因此它只包含文本。（用双引号括起来的一般字符串可以包含以上所示的转义序列）<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
        <span style="color: #268bd2; font-weight: bold;">const</span> <span style="color: #d75fd7;">placeOfInterest</span> = <span style="color: #2aa198;">`&#8984;`</span>

        fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"plain string: "</span>)
        fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%s"</span>, placeOfInterest)
        fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"\n"</span>)

        fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"quoted string: "</span>)
        fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%+q"</span>, placeOfInterest)
        fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"\n"</span>)

        fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"hex bytes: "</span>)
        <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := 0; i &lt; <span style="color: #268bd2;">len</span>(placeOfInterest); i++ {
                fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%x "</span>, placeOfInterest[i])
        }
        fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"\n"</span>)
}
</pre>
</div>

<p>
输出结果是：<br>
</p>

<pre class="example">
plain string: ⌘
quoted string: "\u2318"
hex bytes: e2 8c 98
</pre>

<p>
这也告诉我们 Unicode 字符值 U+2318 对应的是一个”Place of Interest”符号 ⌘，由字节序列 <code>e2 8c 98</code> 表示，并且这些字节是十六进制值 2318 的 UTF-8 编码。<br>
</p>

<p>
可能有些读者通过观察输出结果很快就得出这个结论，也有读者可能感到很困惑，这取决于你对 UTF-8 的熟悉程度，但值得花一点时间来解释如何创建字符串的 UTF-8 表示。简单的事实是：它是在编写源码时创建的。<br>
</p>

<p>
golang 的源代码被定义为 UTF-8 文本，并且不允许其他的表示形式。这意味着当我们在源代码编写文本 <code>⌘</code> 时，用于创建程序的文本编辑器将符号 ⌘ 的 UTF-8 编码放入源文本。当我们打印出十六进制字节时，我们只是将编辑器放置在文件中的数据转储出来。<br>
</p>

<p>
简而言之，go 的源代码使用 UTF-8 编码，所以字符串文字的源代码也是 UTF-8 文本。如果该字符串文本不包含转义序列，而原始字符串不能，则构造的字符串将精确地保存引号之间的源文本。因此，通过定义和构造，原始字符串将始终包含其内容的有效 UTF-8 表示。同样，除非它包含像前一节那样的 UTF-8-breaking 转义符，否则常规字符串文字将始终包含有效的 UTF-8。<br>
</p>

<p>
有些人认为 go 字符串总是 UTF-8 文本，但它们不是：只有字符串文字才是 UTF-8 文本。正如我们在前一节中所展示的，字符串值可以包含任意字节；正如我们在这里所展示的那样，只要字符串文字没有字节级转义，字符串文本总是包含 UTF-8 文本。<br>
</p>

<p>
总而言之，字符串可以包含任意字节，但是当从字符串文字构造时，这些字节（几乎总是）UTF-8 文本。<br>
</p>
</div>
</div>
<div id="outline-container-org6bf27b0" class="outline-2">
<h2 id="org6bf27b0">code point、字符和runes之间的关系</h2>
<div class="outline-text-2" id="text-org6bf27b0">
<p>
迄今为止，我们一直非常小心地使用“字节”和“字符”这两个字。其中一部分原因是字符串包含字节，另外一部分原因是“字符”的概念有点难以定义。Unicode 标准使用术语“code point”来表示某个字符。code point U+2318（十六进制值2318）表示符号⌘。（想查看更多关于 code point 的信息，请参阅其 <a href="http://unicode.org/cldr/utility/character.jsp?a=2318">Unicode页面</a> ）<br>
</p>

<p>
更一个更普通的例子，Unicode 代码点 U+0061 是小写拉丁字母’A’:a。<br>
</p>

<p>
但是小写字母重音字母’A’:à呢？这是一个字符，他也是一个 code point（U+00E0）,但它有其他表示。例如，我们可以使用“组合”重音 code point U+0300，并将其附加到小写字符 a，U+0061，以创建相同的字符 à。一般来说，一个字符可以用许多不同的 code point 序列表示美因茨可以用不同的 UTF-8 字节序列表示。<br>
</p>

<p>
因此，计算中的字符概念是模棱两可的，或者至少是令人困惑的，所以我们谨慎。为了使概念更可靠，有一些规范化技术可以保证给定的字符总是由相同的 code point 序列表示，但是这个主题现在离我们太远了。后面将解释 Go 库如何解决规范化问题。<br>
</p>

<p>
“code point”有点儿含糊不清，所以 GO 为这个概念引入了一个较短的术语：rune。该术语出现在 Go 库和源代码中，其含义与”code point”完全相同，只是一个有趣的增加。<br>
</p>

<p>
Go 语言将 rune 这个词定义为 int32 类型的别名。因此当整数值表示一个 code pint 时，程序看起来会清楚些。另外，你可以把 Go 里的一个字符串常量称作 rune 常量。符号’⌘’的类型和值分别为 rune 和 0x2318。<br>
</p>
</div>
</div>
<div id="outline-container-orgc0372a0" class="outline-2">
<h2 id="orgc0372a0">再看一个例子：range 循环和下标循环的区别</h2>
<div class="outline-text-2" id="text-orgc0372a0">
<p>
除了 Go 源代码是 UTF-8 这个事实外，Go 只有一种以 UTF-8 编码方式处理字符串，那就会在字符串上使用 for range 循环。<br>
</p>

<p>
我们已经看过很多一般的 for 循环是怎样的。相比之下，for range 循环，在每次迭代时解码一个 UTF-8 编码 rune。每次循环时，循环的索引都是当前 rune 的起始位置，以字节为单位，code point 是其值。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">s</span> := <span style="color: #2aa198;">"&#25105;&#26159;&#20013;&#22269;&#20154;"</span>
<span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">index</span>, <span style="color: #8787d7;">runeValue</span> := <span style="color: #268bd2; font-weight: bold;">range</span> s {
        fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%#U &#36215;&#22987;&#20110;&#23383;&#20301;&#32622;%d\n"</span>, runeValue, index)
}

</pre>
</div>

<pre class="example">
// 输出结果如下：
我 起始于字位置0
是 起始于字位置3
中 起始于字位置6
国 起始于字位置9
人 起始于字位置12
</pre>

<p>
作为对比，我们下标循环来遍历字符串，看看打印的又是什么。<br>
</p>

<div class="org-src-container">
<pre class="src src-go">fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"% x\n"</span>, s)
<span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := 0; i &lt; <span style="color: #268bd2;">len</span>(s); i++ {
        fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%c &#36215;&#22987;&#20110;&#23383;&#20301;&#32622;%d\n"</span>, s[i], i)
}
</pre>
</div>

<pre class="example">
// 输出结果如下：
e6 88 91 e6 98 af e4 b8 ad e5 9b bd e4 ba ba
æ 起始于字位置0
 起始于字位置1
 起始于字位置2
æ 起始于字位置3
 起始于字位置4
¯ 起始于字位置5
ä 起始于字位置6
¸ 起始于字位置7
­ 起始于字位置8
å 起始于字位置9
 起始于字位置10
½ 起始于字位置11
ä 起始于字位置12
º 起始于字位置13
º 起始于字位置14
</pre>

<p>
前面已经说过，使用下标方式索引字符串 s，得到的是 s[i] 的字节值。是字符串 s 对应的二进制序列为 <code>e6 88 91 e6 98 af e4 b8 ad e5 9b bd e4 ba ba</code> ，所以 s[0] 对应的字节为 e6，通过查 UTF-8 编码表发现，e6 对应的 UTF-8 字符就是拉丁字符æ。所以也就回答了一开始所遇到的问题。为什么 s[0] 输出的不是“我”而是”æ”。如果确实想读取第一个字符“我”的话，可以先把字符串转为 rune 数组（ <code>runeArray :=[]rune(s)</code> ），再通过索引 runeArray 来读取，runeArray[0]。<br>
</p>
</div>
</div>
<div id="outline-container-orgfb1eccb" class="outline-2">
<h2 id="orgfb1eccb">一些常用的字符串处理库</h2>
<div class="outline-text-2" id="text-orgfb1eccb">
<p>
Go 的标准库为解释 UTF-8 文本提供了强大支持。如果一个 range 循环不足以满足你的需求的话，那么可以考虑使用 Go 的标准库。<br>
</p>

<p>
最重要的包是 <a href="Go-unicode_utf8.html">unicode/utf8</a>  ，它包含了用于验证，反汇编和重组 UTF-8 字符串的编码模板。这里有一个等同于上述 range 循环的例子，但是这个例子中使用了该包重的 <code>DecodeRuneInString</code> 函数来完成相同的功能。函数的返回值是 UTF-8 编码字节中的 rune 以及宽度。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span>, <span style="color: #8787d7;">w</span> := 0, 0; i &lt; <span style="color: #268bd2;">len</span>(s); i += w {
        <span style="color: #8787d7;">runeValue</span>, <span style="color: #8787d7;">width</span> := utf8.<span style="color: #d75fd7; font-weight: bold;">DecodeRuneInString</span>(s[i:])
        fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%#U starts at byte position %d\n"</span>, runeValue, i)
        w = width
}
</pre>
</div>

<pre class="example">
// 输出结果如下
U+6211 '我' 起始于字位置 0
U+662F '是' 起始于字位置 3
U+4E2D '中' 起始于字位置 6
U+56FD '国' 起始于字位置 9
U+4EBA '人' 起始于字位置 12
</pre>
</div>
</div>
<div id="outline-container-orgf191842" class="outline-2">
<h2 id="orgf191842">总结</h2>
<div class="outline-text-2" id="text-orgf191842">
<p>
最后，对字符串类型做一个总结，希望能够帮助大家能够了解golang的字符串，并且能够在开发过程中正确处理它。<br>
</p>

<ul class="org-ul">
<li>golang 的 string 是以 UTF-8 编码的，而 UTF-8 是一种 1-4 字节的可变长字符集，每个字符可用 1-4 字节来表示<br></li>
<li>使用下标方式 s[i] 访问字符串 s，s[i] 是 UTF-8 编码后的一个字节（uint8），即按字节遍历<br></li>
<li>使用 <code>for i,v := range s</code> 方式访问 s，i 是字符串下标编号，v 是对应的字符值（int32=rune），即按字符遍历<br></li>
<li>使用 fmt.Printf 打印时，%c 占位符打印的是字符，%+v 占位符打印的是这个类型自身，如 <code>fmt.Printf(“%+v”, s[i])</code> 打印的就是字节一个十进制的无符号整数 s[i]<br></li>
<li>如果希望以随机方式访问字符串 s 的每个字符，可以先转为 []rune 数组，再以下标访问<br></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-04-14 23:04 Thu</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-04-15 Fri 01:38</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
