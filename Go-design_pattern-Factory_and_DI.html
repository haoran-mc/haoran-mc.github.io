<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-07-09 Sat 16:06 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>工厂模式</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">工厂模式</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org42464e6">需求样例</a></li>
<li><a href="#org7f5fdc4">简单工厂</a>
<ul>
<li><a href="#orgf5f6fd7">模式动机</a></li>
<li><a href="#org420e337">go 实现</a></li>
<li><a href="#org030b464">简单工厂模式的优缺点</a></li>
</ul>
</li>
<li><a href="#org35de328">工厂方法</a>
<ul>
<li><a href="#org8aff838">模式动机</a></li>
<li><a href="#org1c34ea4">go 实现</a></li>
<li><a href="#org211d346">模式分析</a></li>
<li><a href="#orgec0e847">工厂方法模式的优缺点</a></li>
<li><a href="#org06526bf">适用环境</a></li>
</ul>
</li>
<li><a href="#org843a9b9">抽象工厂</a>
<ul>
<li><a href="#org092454f">模式动机</a></li>
<li><a href="#org6d1660a">go 实现</a></li>
</ul>
</li>
<li><a href="#orgca81f47">DI 容器</a>
<ul>
<li><a href="#orgbca46f4">工厂模式和 DI 容器有何区别</a></li>
<li><a href="#org4b8a3dd">DI 容器的核心功能</a>
<ul>
<li><a href="#orgc43e39c">配置解析</a></li>
<li><a href="#org2f7a6c3">对象创建</a></li>
<li><a href="#org611f670">对象生命周期管理</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org42464e6" class="outline-2">
<h2 id="org42464e6">需求样例</h2>
<div class="outline-text-2" id="text-org42464e6">
<p>
先设计一个需求，然后使用不同的工厂模式重构。假设我们需要根据配置文件的文件名来解析这个配置文件，不同格式的文件使用不同的解析器解析，代码如下：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">ConfigParser &#37197;&#32622;&#25991;&#20214;&#35299;&#26512;&#22120;&#25509;&#21475;</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">ConfigParser</span> <span style="color: #268bd2; font-weight: bold;">interface</span> {
    <span style="color: #d75fd7; font-weight: bold;">Parse</span>(<span style="color: #8787d7;">data</span> []<span style="color: #df005f; font-weight: bold;">byte</span>)
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">jsonConfigParser json &#26684;&#24335;&#30340;&#37197;&#32622;&#25991;&#20214;&#35299;&#26512;&#22120;</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">jsonConfigParser</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">J</span> <span style="color: #df005f; font-weight: bold;">jsonConfigParser</span>) <span style="color: #d75fd7; font-weight: bold;">Parse</span>(<span style="color: #8787d7;">data</span> []<span style="color: #df005f; font-weight: bold;">byte</span>) {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"json parsing..."</span>, <span style="color: #d75fd7; font-weight: bold;">string</span>(data))
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">yamlConfigParser yaml &#26684;&#24335;&#30340;&#37197;&#32622;&#25991;&#20214;&#35299;&#26512;&#22120;</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">yamlConfigParser</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">Y</span> <span style="color: #df005f; font-weight: bold;">yamlConfigParser</span>) <span style="color: #d75fd7; font-weight: bold;">Parse</span>(<span style="color: #8787d7;">data</span> []<span style="color: #df005f; font-weight: bold;">byte</span>) {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"yaml parsing..."</span>, <span style="color: #d75fd7; font-weight: bold;">string</span>(data))
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Load &#21152;&#36733;&#37197;&#32622;&#25991;&#20214;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">Load</span>(<span style="color: #8787d7;">configFilePath</span> <span style="color: #df005f; font-weight: bold;">string</span>) {
    <span style="color: #8787d7;">ext</span>, <span style="color: #8787d7;">err</span> := <span style="color: #d75fd7; font-weight: bold;">GetFileExtension</span>(configFilePath) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#33719;&#21462;&#37197;&#32622;&#25991;&#20214;&#25193;&#23637;&#21517;</span>
    <span style="color: #268bd2; font-weight: bold;">if</span> err != <span style="color: #d75fd7;">nil</span> {
        <span style="color: #268bd2;">panic</span>(<span style="color: #2aa198;">"cannot get file extension"</span>)
    }

    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">parser</span> <span style="color: #df005f; font-weight: bold;">ConfigParser</span>
    <span style="color: #268bd2; font-weight: bold;">if</span> ext == <span style="color: #2aa198;">"json"</span> { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#26681;&#25454;&#19981;&#21516;&#26684;&#24335;&#65292;&#33719;&#21462;&#19981;&#21516;&#35299;&#26512;&#22120;</span>
        parser = <span style="color: #df005f; font-weight: bold;">jsonConfigParser</span>{}
    } <span style="color: #268bd2; font-weight: bold;">else</span> <span style="color: #268bd2; font-weight: bold;">if</span> ext == <span style="color: #2aa198;">"yaml"</span> {
        parser = <span style="color: #df005f; font-weight: bold;">yamlConfigParser</span>{}
    }

    <span style="color: #8787d7;">configText</span> := <span style="color: #2aa198;">"name: mc"</span> <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#37197;&#32622;&#25991;&#20214;&#20869;&#23481;</span>
    parser.<span style="color: #d75fd7; font-weight: bold;">Parse</span>([]<span style="color: #d75fd7; font-weight: bold;">byte</span>(configText))
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">GetFileExtension &#36890;&#36807;&#25991;&#20214;&#21517;&#33719;&#21462;&#25193;&#23637;&#21517;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">GetFileExtension</span>(<span style="color: #8787d7;">filePath</span> <span style="color: #df005f; font-weight: bold;">string</span>) (<span style="color: #df005f; font-weight: bold;">string</span>, <span style="color: #df005f; font-weight: bold;">error</span>) {
    <span style="color: #8787d7;">dotPos</span> := strings.<span style="color: #d75fd7; font-weight: bold;">LastIndexByte</span>(filePath, <span style="color: #2aa198;">'.'</span>)
    <span style="color: #8787d7;">fileSuffix</span> := filePath[dotPos+1:]
    <span style="color: #268bd2; font-weight: bold;">if</span> fileSuffix == <span style="color: #2aa198;">"json"</span> {
        <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #2aa198;">"json"</span>, <span style="color: #d75fd7;">nil</span>
    } <span style="color: #268bd2; font-weight: bold;">else</span> <span style="color: #268bd2; font-weight: bold;">if</span> fileSuffix == <span style="color: #2aa198;">"yaml"</span> {
        <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #2aa198;">"yaml"</span>, <span style="color: #d75fd7;">nil</span>
    }
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #2aa198;">""</span>, errors.<span style="color: #d75fd7; font-weight: bold;">New</span>(<span style="color: #2aa198;">"cannot get file extension"</span>)
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org7f5fdc4" class="outline-2">
<h2 id="org7f5fdc4">简单工厂</h2>
<div class="outline-text-2" id="text-org7f5fdc4">
</div>
<div id="outline-container-orgf5f6fd7" class="outline-3">
<h3 id="orgf5f6fd7">模式动机</h3>
<div class="outline-text-3" id="text-orgf5f6fd7">
<p>
考虑一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。<br>
</p>
</div>
</div>
<div id="outline-container-org420e337" class="outline-3">
<h3 id="org420e337">go 实现</h3>
<div class="outline-text-3" id="text-org420e337">
<p>
回看上面的解析器代码。<br>
</p>

<p>
为了让代码逻辑更加清晰，可读性更好，我们要善于将功能独立的代码块封装成函数。按照这个设计思路，我们可以将 <code>Load</code> 函数中涉及 <code>parser</code> 创建的部分逻辑剥离出来：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">NewConfigParser &#26159;&#29983;&#20135; IRuleConfigParser &#30340;&#24037;&#21378;</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21442;&#25968;&#26159;&#37197;&#32622;&#25991;&#20214;&#65292;&#22914;&#26524;&#25991;&#20214;&#21518;&#32512;&#26159; json&#65292;&#37027;&#20040;&#23601;&#20250;&#29983;&#20135;&#20986;&#19968;&#20010;&#35299;&#26512; json</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#30340;&#35299;&#37322;&#22120;&#65292;&#22914;&#26524;&#25991;&#20214;&#21518;&#32512;&#26159; yaml&#65292;&#37027;&#20040;&#23601;&#20250;&#29983;&#20135;&#19968;&#20010;&#35299;&#26512; yaml &#30340;&#35299;&#26512;&#22120;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">NewConfigParser</span>(<span style="color: #8787d7;">fileExt</span> <span style="color: #df005f; font-weight: bold;">string</span>) <span style="color: #df005f; font-weight: bold;">ConfigParser</span> {
    <span style="color: #268bd2; font-weight: bold;">switch</span> fileExt {
    <span style="color: #268bd2; font-weight: bold;">case</span> <span style="color: #2aa198;">"json"</span>:
        <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #df005f; font-weight: bold;">jsonConfigParser</span>{}
    <span style="color: #268bd2; font-weight: bold;">case</span> <span style="color: #2aa198;">"yaml"</span>:
        <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #df005f; font-weight: bold;">yamlConfigParser</span>{}
    }
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">nil</span>
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Load &#21152;&#36733;&#37197;&#32622;&#25991;&#20214;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">Load</span>(<span style="color: #8787d7;">configFilePath</span> <span style="color: #df005f; font-weight: bold;">string</span>) {
    <span style="color: #8787d7;">ext</span> := <span style="color: #d75fd7; font-weight: bold;">GetFileExtension</span>(configFilePath)
    <span style="color: #8787d7;">parser</span> := <span style="color: #d75fd7; font-weight: bold;">NewConfigParser</span>(ext) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#24037;&#21378;&#29983;&#20135;&#35299;&#26512;&#22120;</span>
    <span style="color: #8787d7;">configText</span> := []<span style="color: #d75fd7; font-weight: bold;">byte</span>(<span style="color: #2aa198;">""</span>)
    parser.<span style="color: #d75fd7; font-weight: bold;">Parse</span>(configText)
} 
</pre>
</div>
</div>
</div>
<div id="outline-container-org030b464" class="outline-3">
<h3 id="org030b464">简单工厂模式的优缺点</h3>
<div class="outline-text-3" id="text-org030b464">
<ul class="org-ul">
<li>将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。<br></li>
<li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。<br></li>
<li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。<br></li>
<li>由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。<br></li>
<li>简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。<br></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org35de328" class="outline-2">
<h2 id="org35de328">工厂方法</h2>
<div class="outline-text-2" id="text-org35de328">
</div>
<div id="outline-container-org8aff838" class="outline-3">
<h3 id="org8aff838">模式动机</h3>
<div class="outline-text-3" id="text-org8aff838">
<p>
现在对该系统进行修改，不再设计一个按钮工厂类来统一负责所有产品的创建，而是将具体按钮的创建过程交给专门的工厂子类去完成，我们先定义一个抽象的按钮工厂类，再定义具体的工厂类来生成圆形按钮、矩形按钮、菱形按钮等，它们实现在抽象按钮工厂类中定义的方法。这种抽象化的结果使这种结构可以在不修改具体工厂类的情况下引进新的产品，如果出现新的按钮类型，只需要为这种新类型的按钮创建一个具体的工厂类就可以获得该新按钮的实例，这一特点无疑使得工厂方法模式具有超越简单工厂模式的优越性，更加符合“开闭原则”。<br>
</p>
</div>
</div>
<div id="outline-container-org1c34ea4" class="outline-3">
<h3 id="org1c34ea4">go 实现</h3>
<div class="outline-text-3" id="text-org1c34ea4">
<p>
回看上面的解析器代码。<br>
</p>

<p>
对于简单工厂模式的实现方法，如果我们要添加新的 parser，那势必要改动到 <code>NewConfigParser</code> 的代码，那这是不是违反开闭原则呢？实际上，如果不是需要频繁地添加新地 parser，只是偶尔修改一下 <code>NewConfigParser</code> 代码，稍微不符合开闭原则，也是完全可以接受地。<br>
</p>

<p>
除此之外，我们是不是可以用多态或其他设计模式来代替 <code>if</code> 分支判断逻辑呢？其实，如果 <code>if</code> 分支并不是很多，代码中有 <code>if</code> 分支也是完全可以接受的。<br>
</p>

<p>
如果我们非要将 <code>if</code> 分支逻辑去掉，那该怎么办呢？ <span class="underline">我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。</span><br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">ConfigParserFactory &#24037;&#21378;&#26041;&#27861;&#25509;&#21475;</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">ConfigParserFactory</span> <span style="color: #268bd2; font-weight: bold;">interface</span> {
    <span style="color: #d75fd7; font-weight: bold;">CreateParser</span>() <span style="color: #df005f; font-weight: bold;">ConfigParser</span>
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">jsonConfigParserFactory jsonConfigParser &#30340;&#24037;&#21378;&#31867;</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">jsonConfigParserFactory</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">J</span> <span style="color: #df005f; font-weight: bold;">jsonConfigParserFactory</span>) <span style="color: #d75fd7; font-weight: bold;">CreateParser</span>() <span style="color: #df005f; font-weight: bold;">ConfigParser</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #df005f; font-weight: bold;">jsonConfigParser</span>{}
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">yamlConfigParserFactory yamlConfigParser &#30340;&#24037;&#21378;&#31867;</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">yamlConfigParserFactory</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">Y</span> <span style="color: #df005f; font-weight: bold;">yamlConfigParserFactory</span>) <span style="color: #d75fd7; font-weight: bold;">CreateParser</span>() <span style="color: #df005f; font-weight: bold;">ConfigParser</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #df005f; font-weight: bold;">yamlConfigParser</span>{}
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">NewConfigParserFactory &#29983;&#20135;&#35299;&#26512;&#22120;&#24037;&#21378;&#30340;&#24037;&#21378;&#65292;&#21442;&#25968;&#26159;&#37197;&#32622;&#25991;&#20214;</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22914;&#26524;&#25991;&#20214;&#21518;&#32512;&#26159; json&#65292;&#37027;&#20040;&#23601;&#20250;&#29983;&#20135;&#19968;&#20010; json &#35299;&#26512;&#22120;&#24037;&#21378;</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22914;&#26524;&#25991;&#20214;&#21518;&#32512;&#26159; yaml&#65292;&#37027;&#20040;&#23601;&#20250;&#29983;&#20135;&#19968;&#20010; yaml &#35299;&#26512;&#22120;&#24037;&#21378;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">NewConfigParserFactory</span>(<span style="color: #8787d7;">fileExt</span> <span style="color: #df005f; font-weight: bold;">string</span>) <span style="color: #df005f; font-weight: bold;">ConfigParserFactory</span> {
    <span style="color: #268bd2; font-weight: bold;">switch</span> fileExt {
    <span style="color: #268bd2; font-weight: bold;">case</span> <span style="color: #2aa198;">"json"</span>:
        <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #df005f; font-weight: bold;">jsonConfigParserFactory</span>{}
    <span style="color: #268bd2; font-weight: bold;">case</span> <span style="color: #2aa198;">"yaml"</span>:
        <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #df005f; font-weight: bold;">yamlConfigParserFactory</span>{}
    }
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">nil</span>
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Load &#21152;&#36733;&#37197;&#32622;&#25991;&#20214;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">Load</span>(<span style="color: #8787d7;">configFilePath</span> <span style="color: #df005f; font-weight: bold;">string</span>) {
    <span style="color: #8787d7;">ext</span> := <span style="color: #d75fd7; font-weight: bold;">GetFileExtension</span>(configFilePath)
    <span style="color: #8787d7;">parserFactory</span> := <span style="color: #d75fd7; font-weight: bold;">NewConfigParserFactory</span>(ext)
    <span style="color: #8787d7;">parser</span> := parserFactory.<span style="color: #d75fd7; font-weight: bold;">CreateParser</span>()
    <span style="color: #8787d7;">configText</span> := []<span style="color: #d75fd7; font-weight: bold;">byte</span>(<span style="color: #2aa198;">""</span>)
    parser.<span style="color: #d75fd7; font-weight: bold;">Parse</span>(configText)
} 
</pre>
</div>

<p>
这里由于我们的每个工厂类只是做简单的 <code>new</code> 操作，功能非常单薄（只有一行代码），也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式简单好用，比工厂方法模式更加适合。<br>
</p>
</div>
</div>
<div id="outline-container-org211d346" class="outline-3">
<h3 id="org211d346">模式分析</h3>
<div class="outline-text-3" id="text-org211d346">
<p>
工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。<br>
</p>
</div>
</div>
<div id="outline-container-orgec0e847" class="outline-3">
<h3 id="orgec0e847">工厂方法模式的优缺点</h3>
<div class="outline-text-3" id="text-orgec0e847">
<ul class="org-ul">
<li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。<br></li>
<li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。<br></li>
<li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。<br></li>
</ul>
</div>
</div>
<div id="outline-container-org06526bf" class="outline-3">
<h3 id="org06526bf">适用环境</h3>
<div class="outline-text-3" id="text-org06526bf">
<p>
<b>那什么时候该用工厂方法模式，而非简单工厂模式呢？</b><br>
</p>

<p>
我们前面提到，之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不复杂，就几行代码而已，我们完全没必要将它拆分成单独的函数或者类。<br>
</p>

<p>
基于这个设计思想，当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。<br>
</p>

<p>
除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org843a9b9" class="outline-2">
<h2 id="org843a9b9">抽象工厂</h2>
<div class="outline-text-2" id="text-org843a9b9">
</div>
<div id="outline-container-org092454f" class="outline-3">
<h3 id="org092454f">模式动机</h3>
<div class="outline-text-3" id="text-org092454f">
<p>
抽象工厂的应用场景比较特殊，没有前两种常用。<br>
</p>

<p>
在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应下面这 4 个 parser 类。<br>
</p>

<pre class="example">
针对规则配置的解析器：基于接口 IRuleConfigParser
JsonRuleConfigParser
YamlRuleConfigParser

针对系统配置的解析器：基于接口 ISystemConfigParser
JsonSystemConfigParser
YamlSystemConfigParser
</pre>

<p>
针对这种特殊的场景，如果还是继续用工厂方法来实现的话，我们要针对每个 parser 都编写一个工厂类，也就是要编写 4 个工厂类。如果我们未来还需要增加针对业务配置的解析器（比如 IBizConfigParser），那就要再对应地增加 2 个工厂类。而我们知道，过多的类也会让系统难维护。这个问题该怎么解决呢？<br>
</p>

<p>
抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：<br>
</p>
</div>
</div>
<div id="outline-container-org6d1660a" class="outline-3">
<h3 id="org6d1660a">go 实现</h3>
<div class="outline-text-3" id="text-org6d1660a">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">RuleConfigParser &#35268;&#21017;&#35299;&#26512;&#22120;&#25509;&#21475;</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">RuleConfigParser</span> <span style="color: #268bd2; font-weight: bold;">interface</span> {
    <span style="color: #d75fd7; font-weight: bold;">ParseRule</span>(<span style="color: #8787d7;">data</span> []<span style="color: #df005f; font-weight: bold;">byte</span>)
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">jsonRuleConfigParser</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">jsonRuleConfigParser</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">j</span> <span style="color: #df005f; font-weight: bold;">jsonRuleConfigParser</span>) <span style="color: #d75fd7; font-weight: bold;">ParseRule</span>(<span style="color: #8787d7;">data</span> []<span style="color: #df005f; font-weight: bold;">byte</span>) {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"json rule parsing..."</span>, <span style="color: #d75fd7; font-weight: bold;">string</span>(data))
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">--------------------------</span>

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">SystemConfigParser &#31995;&#32479;&#35299;&#26512;&#22120;&#25509;&#21475;</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">SystemConfigParser</span> <span style="color: #268bd2; font-weight: bold;">interface</span> {
    <span style="color: #d75fd7; font-weight: bold;">ParseSystem</span>(<span style="color: #8787d7;">data</span> []<span style="color: #df005f; font-weight: bold;">byte</span>)
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">jsonSystemConfigParser</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">jsonSystemConfigParser</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">j</span> <span style="color: #df005f; font-weight: bold;">jsonSystemConfigParser</span>) <span style="color: #d75fd7; font-weight: bold;">ParseSystem</span>(<span style="color: #8787d7;">data</span> []<span style="color: #df005f; font-weight: bold;">byte</span>) {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"json system parsing..."</span>, <span style="color: #d75fd7; font-weight: bold;">string</span>(data))
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">--------------------------</span>

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">ConfigParserFactory &#24037;&#21378;&#26041;&#27861;&#25509;&#21475;</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">ConfigParserFactory</span> <span style="color: #268bd2; font-weight: bold;">interface</span> {
    <span style="color: #d75fd7; font-weight: bold;">CreateRuleParser</span>() <span style="color: #df005f; font-weight: bold;">RuleConfigParser</span>
    <span style="color: #d75fd7; font-weight: bold;">CreateSystemParser</span>() <span style="color: #df005f; font-weight: bold;">SystemConfigParser</span>
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">--------------------------</span>

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">jsonConfigParserFactory</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">j</span> <span style="color: #df005f; font-weight: bold;">jsonConfigParserFactory</span>) <span style="color: #d75fd7; font-weight: bold;">CreateRuleParser</span>() <span style="color: #df005f; font-weight: bold;">RuleConfigParser</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #df005f; font-weight: bold;">jsonRuleConfigParser</span>{}
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">j</span> <span style="color: #df005f; font-weight: bold;">jsonConfigParserFactory</span>) <span style="color: #d75fd7; font-weight: bold;">CreateSystemParser</span>() <span style="color: #df005f; font-weight: bold;">SystemConfigParser</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #df005f; font-weight: bold;">jsonSystemConfigParser</span>{}
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">-----------------------------------------------------</span>

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">NewConfigParserFactory</span>(<span style="color: #8787d7;">fileExt</span> <span style="color: #df005f; font-weight: bold;">string</span>) <span style="color: #df005f; font-weight: bold;">ConfigParserFactory</span> {
    <span style="color: #268bd2; font-weight: bold;">switch</span> fileExt {
    <span style="color: #268bd2; font-weight: bold;">case</span> <span style="color: #2aa198;">"json"</span>:
        <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #df005f; font-weight: bold;">jsonConfigParserFactory</span>{}
    }
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">nil</span>
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Load &#21152;&#36733;&#37197;&#32622;&#25991;&#20214;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">Load</span>(<span style="color: #8787d7;">configFilePath</span> <span style="color: #df005f; font-weight: bold;">string</span>) {
    <span style="color: #8787d7;">ext</span> := <span style="color: #d75fd7; font-weight: bold;">GetFileExtension</span>(configFilePath)
    <span style="color: #8787d7;">parserFactory</span> := <span style="color: #d75fd7; font-weight: bold;">NewConfigParserFactory</span>(ext)
    <span style="color: #8787d7;">parser</span> := parserFactory.<span style="color: #d75fd7; font-weight: bold;">CreateRuleParser</span>()
    <span style="color: #8787d7;">configText</span> := []<span style="color: #d75fd7; font-weight: bold;">byte</span>(<span style="color: #2aa198;">""</span>)
    parser.<span style="color: #d75fd7; font-weight: bold;">ParseRule</span>(configText)
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">GetFileExtension &#36890;&#36807;&#25991;&#20214;&#21517;&#33719;&#21462;&#25193;&#23637;&#21517;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">GetFileExtension</span>(<span style="color: #8787d7;">filePath</span> <span style="color: #df005f; font-weight: bold;">string</span>) <span style="color: #df005f; font-weight: bold;">string</span> {
    <span style="color: #8787d7;">dotPos</span> := strings.<span style="color: #d75fd7; font-weight: bold;">LastIndexByte</span>(filePath, <span style="color: #2aa198;">'.'</span>)
    <span style="color: #8787d7;">fileSuffix</span> := filePath[dotPos+1:]
    <span style="color: #268bd2; font-weight: bold;">if</span> fileSuffix == <span style="color: #2aa198;">"json"</span> {
        <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #2aa198;">"json"</span>
    } <span style="color: #268bd2; font-weight: bold;">else</span> <span style="color: #268bd2; font-weight: bold;">if</span> fileSuffix == <span style="color: #2aa198;">"yml"</span> {
        <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #2aa198;">"yml"</span>
    }
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #2aa198;">""</span>
} 
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgca81f47" class="outline-2">
<h2 id="orgca81f47">DI 容器</h2>
<div class="outline-text-2" id="text-orgca81f47">
<p>
当创建对象是一个“大工程”的时候，我们一般会选择使用工厂模式，来封装对象复杂的创建过程，将对象的创建和使用分离，让代码更加清晰。那何为“大工程”呢？一种是创建过程涉及复杂的 if-else 分支判断，另一种是对象创建需要组装多个其他类对象或者需要复杂的初始化过程。<br>
</p>

<p>
创建对象的大工程还有依赖注入框架，或者叫依赖注入容器（Dependency Injection Container），简称 DI 容器。<br>
</p>
</div>
<div id="outline-container-orgbca46f4" class="outline-3">
<h3 id="orgbca46f4">工厂模式和 DI 容器有何区别</h3>
<div class="outline-text-3" id="text-orgbca46f4">
<p>
DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。<br>
</p>

<p>
DI 容器相对于工厂模式的例子来说，它处理的是更大的对象创建工程。工厂模式中，一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 DI 容器负责的是整个应用中所有类对象的创建。<br>
</p>

<p>
除此之外，DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。<br>
</p>
</div>
</div>
<div id="outline-container-org4b8a3dd" class="outline-3">
<h3 id="org4b8a3dd">DI 容器的核心功能</h3>
<div class="outline-text-3" id="text-org4b8a3dd">
<p>
一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。<br>
</p>
</div>
<div id="outline-container-orgc43e39c" class="outline-4">
<h4 id="orgc43e39c">配置解析</h4>
<div class="outline-text-4" id="text-orgc43e39c">
<p>
工厂模式中，工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI 容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。所以，我们需要通过一种形式，让应用告知 DI 容器要创建哪些对象。这种形式就是我们要讲的配置。<br>
</p>

<p>
我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象。<br>
</p>
</div>
</div>
<div id="outline-container-org2f7a6c3" class="outline-4">
<h4 id="org2f7a6c3">对象创建</h4>
<div class="outline-text-4" id="text-org2f7a6c3">
<p>
在 DI 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如 BeansFactory。<br>
</p>

<p>
你可能会说，如果要创建的类对象非常多，BeansFactory 中的代码会不会线性膨胀（代码量跟创建对象的个数成正比）呢？实际上并不会。待会讲到 DI 容器的具体实现的时候，我们会讲“反射”这种机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象，BeansFactory 工厂类代码都是一样的。<br>
</p>
</div>
</div>
<div id="outline-container-org611f670" class="outline-4">
<h4 id="org611f670">对象生命周期管理</h4>
<div class="outline-text-4" id="text-org611f670">
<p>
简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。在 Spring 框架中，我们可以通过配置 scope 属性，来区分这两种不同类型的对象。scope=prototype 表示返回新创建的对象，scope=singleton 表示返回单例对象。<br>
</p>

<p>
除此之外，我们还可以配置对象是否支持懒加载。如果 lazy-init=true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)）才被被创建；如果 lazy-init=false，对象在应用启动的时候就事先创建好。<br>
</p>

<p>
不仅如此，我们还可以配置对象的 init-method 和 destroy-method 方法，比如 init-method=loadProperties()，destroy-method=updateConfigFile()。DI 容器在创建好对象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件。<br>
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-07-09 Sat 16:06</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
