# 快速傅里叶变换

## 快速傅里叶变换是什么？
快速傅里叶变换是一种能够在 $O(nlogn)$ 的时间内计算离散福利也变换的算法，在算法竞赛中常用于快速计算多项式乘法。

## 多项式乘法
对于两个多项式 $A(x) = a_0 + a_1x + a_2x^2 + \cdots + a_nx^n, B(x) = b_0 + b_1x + b_2x^2 + \cdots + b_nx^n$ ，求出 $C(x) = A(x) \times B(x)$ ，使用朴素算法的时间复杂度为 $O(n^2)$

```cpp
for (int i = 0; i < n; ++i) 
    for (int j = 0; j < n; ++j)
        c[i + j] += a[i] * b[j];
```

如何加速多项式的乘法呢？

## 多项式的两种表示方法
多项式有两种表示方法：1. 系数表示法 2. 点值表示法

多项式由系数表示法转为点值表示法的过程，就称为DFT；把一个多项式的点值表示法转化为系数表示法的过程，称为IDFT，FFT就是通过取某些特殊的x的点值来加速DFT和IDFT的过程。

### 系数表示法
对于一个 ${n}$ 维的多项式A(x)，它的系数 $(a_0, a_1, a_2, \cdots a_n)$ 能够唯一的表示这个多项式。

### 点值表示法
对于一个 ${n}$ 维的多项式A(x)，带入 ${n+1}$ 个自变量 $(x_0, x_1, x_2, \cdots x_n) (\forall i,j \in [0, n], i \neq j, x_i \neq x_j)$ 的值，得到的这 ${n+1}$ 个点也能够唯一确定这个多项式。

> 证明：
假设：不能够唯一确定这个多项式，即，虽然有 $A(x_i) = B(x_i) (\forall i \in [0, n])$，但 $B(x) \neq A(x)$
则令 $C(x) = A(x) - B(x)$，有 $C(x_i) = 0 (\forall i \in [0, n])$，这与代数基本定理(一个 ${n}$ 次多项式有且仅有 ${n}$ 个根相矛盾，假设不成立，则这 ${n+1}$ 个点能够唯一的确定这个多项式。

容易知道我们能够在 $O(n)$ 的时间内计算出 $C(x)$ 在这 $n + 1$ 个位置的值

```cpp
// x[]中存放的是这n + 1个自变量的取值
for (int i = 0; i <= n; ++i) {
    c[i] = a[x[i]] * b[x[i]];
}
```

既然点值表达式能够较快的算出两个多项式的乘积，那么我们能否在点值表达式与系数表达式之间建立联系，这样我们就能够在得到两个多项式的系数表达式后，转化为点值表达式，然后求出两个多项式的乘积，最后转化回系数表达式。

*快速傅里叶变换！！！*

但在学习快速傅里叶变换之前，我们需要知道一些复数的知识。

## 复数中的单位根
就是一些特殊的复数

## 离散傅里叶变换
离散傅里叶变换使用分治求 $x = \omega_n^k$ 的时候， $A(x) \times B(x)$ 的值，它的分治思想体现在将多项式分为奇次项与偶次项处理。

对于多项式 $A(x)$ ，其系数向量为 $(a_0, a_1, a_2, ... a_{n-1})$ 。我们将n次单位根的0 ~ n-1次幂分别带入 $A(x)$ 得到其点值向量 $(A(\omega_{n}^{0}), A(\omega_{n}^{1}), A(\omega_{n}^{2}), ..., A(\omega_{n}^{n-1}))$ 的过程就是离散傅里叶变换。

如果朴素带入，时间复杂度是 $O(n^2)$ 的，所以我们必须要利用到单位根 $\omega$ 的特殊性质。

对于 $A(x) = a_0 + a_1 \cdots x + a_2 \cdots x^2 + ... + a_{n-1} \cdots x^{n-1}$

将其按照奇偶分组

$A(x) = (a_0 + a_2 \cdots x^2 + a_4 \cdots x^4 + ... + a_{n-2} \cdots x^{n-2}) + (a_1 \cdots x^1 + a_3 \cdots x^3 + a_5 \cdots x^5 + ... + a_{n-1} \cdots x^{n-1})$

$A(x) = (a_0 + a_2 \cdots x^2 + a_4 \cdots x^4 + ... + a_{n-2} \cdots x^{n-2}) + x \cdots (a_1 + a_3 \cdots x^2 + a_5 \cdots x^4 + ... + a_{n-1} \cdots x^{n-2})$

令

$A1(x) = a_0 + a_2 \cdots x + a_4 \cdots x^2 + ... + a_{n-2} \cdots x^{ \frac{n-2}{2}}$

$A2(x) = a_1 + a_3 \cdots x + a_5 \cdots x^2 + ... + a_{n-1} \cdots x^{ \frac{n-2}{2}}$

则可得到

$A(x) = A1(x) + x \cdots A2(x^2)$

$A1(x)$ 和 $A2(x)$ 都是 $A(x)$ 一半的规模，可以转化为子问题递归求解

## 离散傅里叶反变换
通过点值表达式求出系数表达式，这个过程称为离散傅里叶反变换

不证了，不证了，留着以后证明吧~

直接给出结论，离散傅里叶反变换所需要的操作和离散傅里叶变换一样，只是带入的值 $\omega_N^{-k}$ 是离散傅里叶变换带入值的共轭复数

## FFT代码
```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;
const int maxn = 1 << 10;
const double PI = acos(-1.0);
int a[maxn], b[maxn];

struct Complex {
    double r, i;
    Complex() {}
    Complex(double _r, double _i) : r (_r), i (_i) {}
    inline void real(const double& x) {r = x;}
    inline double real() {return r;}
    inline Complex operator + (const Complex& rhs) const {
        return Complex (r + rhs.r, i + rhs.i) ;
    }
    inline Complex operator - (const Complex& rhs) const {
        return Complex (r - rhs.r, i - rhs.i);
    }
    inline Complex operator * (const Complex& rhs) const {
        return Complex (r*rhs.r - i*rhs.i, r*rhs.i + i*rhs.r);
    }
    inline void operator /= (const double& x) {
        r /= x, i /= x ;
    }
    inline void operator *= (const Complex& rhs) {
        *this = Complex (r*rhs.r - i*rhs.i, r*rhs.i + i*rhs.r);
    }
    inline void operator += (const Complex& rhs) {
        r += rhs.r, i += rhs.i;
    }
    inline Complex conj() {
        return Complex (r, -i) ;
    }
};

struct FastFourierTransform {
    Complex omega[maxn], omegaInverse[maxn];

    void init(const int& n) {
        for (int i = 0; i < n; ++i) {
            omega[i] = Complex(cos(2*PI / n*i), sin(2*PI / n*i));
            omegaInverse[i] = omega[i].conj();
        }
    }

    void transform(Complex *a, const int& n, const Complex* omega) {
        for (int i = 0, j = 0; i < n; ++i) {
            if (i > j)
                swap(a[i], a[j]);
            for (int l = n >> 1; (j ^= l) < l; l >>= 1);
        }

        for (int l = 2; l <= n; l <<= 1) {
            int m = l / 2;
            for (Complex *p = a; p != a + n; p += l)
                for (int i = 0; i < m; ++i) {
                    Complex t = omega[n / l * i] * p [m + i];
                    p[m + i] = p[i] - t;
                    p[i] += t;
                }
        }
    }

    void dft(Complex *a, const int& n) {
        transform(a, n, omega);
    }

    void idft(Complex *a, const int& n) {
        transform(a, n, omegaInverse);
        for (int i = 0; i < n; ++i)
            a[i] /= n;
    }
} fft;

int main() {
    /*
     * 这是两个多项式的系数：
     * A(x) = 5 + 2x + 3x^2
     * B(x) = 2 + 6x + x^2   
     * 下面的len1，len2分别是两个多项式最大项的最高次幂+1
     * FFT中len一定要是2^k这种形式，否则在进行分治时会左右不均失败
     */
    a[0] = 5; a[1] = 2; a[2] = 3;
    b[0] = 2; b[1] = 6; b[2] = 1;
    int len1 = 3, len2 = 3;
    int len = 1;
    while (len < len1 * 2 || len < len2 * 2)
        len <<= 1;
    fft.init(len);   // 初始化\omega

    Complex x1[maxn], x2[maxn];   // 存储两个多项式的系数
    for (int i = 0; i < len; ++i) {
        x1[i].r = a[i]; x1[i].i = 0.0;
        x2[i].r = b[i]; x2[i].i = 0.0;
    }
    fft.dft(x1, len); fft.dft(x2, len);
    for (int i = 0; i < len; ++i)
        x1[i] = x1[i] * x2[i];
    fft.idft(x1, len);

    int res[maxn];
    for (int i = 0; i < len; ++i) 
        res[i] = (int)(x1[i].r + 0.5);
    while (len && res[len-1] == 0) 
        --len;
    for (int i = 0; i < len; ++i)
        printf("%d ", res[i]);
    puts("");
    return 0;
}
```


