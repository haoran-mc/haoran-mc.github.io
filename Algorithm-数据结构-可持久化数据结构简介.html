<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-10-01 五 13:24 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>可持久化数据结构简介</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">可持久化数据结构简介</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org1e097ff">简介</a></li>
<li><a href="#org9bf70fd">可持久化分类</a></li>
<li><a href="#org5a5c4b8">实际应用</a>
<ul>
<li><a href="#orgf66b4ed">几何计算</a></li>
<li><a href="#org651860e">字串处理</a></li>
<li><a href="#org3c5bf5a">版本回溯</a></li>
<li><a href="#org85a0397">函数式编程</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org1e097ff" class="outline-2">
<h2 id="org1e097ff">简介</h2>
<div class="outline-text-2" id="text-org1e097ff">
<p>
可持久化数据结构 (Persistent data structure) 总是可以保留每一个历史版本，并且支持操作的不可变特性 (immutable)。
</p>
</div>
</div>
<div id="outline-container-org9bf70fd" class="outline-2">
<h2 id="org9bf70fd">可持久化分类</h2>
<div class="outline-text-2" id="text-org9bf70fd">
<dl class="org-dl">
<dt>部分可持久化</dt><dd>所有版本都可以访问，但是只有最新版本可以修改。</dd>
<dt>完全可持久化</dt><dd>所有版本都既可以访问又可以修改。若支持将两个历史版本合并，则又称为 Confluently Persistent</dd>
</dl>
</div>
</div>
<div id="outline-container-org5a5c4b8" class="outline-2">
<h2 id="org5a5c4b8">实际应用</h2>
<div class="outline-text-2" id="text-org5a5c4b8">
</div>
<div id="outline-container-orgf66b4ed" class="outline-3">
<h3 id="orgf66b4ed">几何计算</h3>
<div class="outline-text-3" id="text-orgf66b4ed">
<p>
在几何计算中有许多离线算法，如扫描线算法一次扫过去回答所有询问，在时间复杂度分析上相当优异。但强迫在线的情况下，每一次都扫描一次，询问操作的时间复杂度就从对数时间降成线性。为了解决这一种情况，持久化技术给了另一种思维，我们将扫描线的时间轴作为一个变动依据，持久化相关的结构，只要我们能将询问在对数时间内穿梭于这个时间轴，必能动态解决先前的问题。
</p>
</div>
</div>
<div id="outline-container-org651860e" class="outline-3">
<h3 id="org651860e">字串处理</h3>
<div class="outline-text-3" id="text-org651860e">
<p>
为了达到非常高效率的合并操作，防止大量重复性字串的生成伴随的效能退化，使得各方面的操作都能远低于线性操作。如 C++ rope 就是一个持久化的数据结构。不只是字串操作，若处理类型有大量重复的情况，持久化的概念便能派上用场。
</p>
</div>
</div>
<div id="outline-container-org3c5bf5a" class="outline-3">
<h3 id="org3c5bf5a">版本回溯</h3>
<div class="outline-text-3" id="text-org3c5bf5a">
<p>
实际上就是对应大部分的应用软体中的 redo/undo。如果资料库/操作变动为了高效率操作而会配上复杂的结构（并不像 hash, set 反转操作只需要常数或对数时间），那么为了快速回推变动结果，持久化结构就是要减少 redo/undo 的花费。
</p>

<p>
资料库本身可以常数回推，纪录变动的部分情况即可。而应用层的计算，大部分实作都是砍掉快取，并且重新计算出一份新的结构，有时候回推的变动大小为 m，为了重新计算结构而消耗了 n+m，如果 n 和 m 的差距非常大，那连续回推的体感就很糟糕。
</p>
</div>
</div>
<div id="outline-container-org85a0397" class="outline-3">
<h3 id="org85a0397">函数式编程</h3>
<div class="outline-text-3" id="text-org85a0397">
<p>
函数式编程需要特别的数据结构以符合语言特性，其中不可变的性质更为重要，以利于并行环境与除错。如面向对象编程的 Java 8 后引入 stream 类，支援写出函数式的语法设计，可提供惰性求值、无限值域等的特殊功能。
</p>
</div>
</div>
</div>
</div>
</body>
</html>
