<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-02-14 Mon 04:31 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>SYNC包应用详解</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">SYNC包应用详解</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org571af1e">简介</a></li>
<li><a href="#orgb15e6dd">sync.Mutex</a>
<ul>
<li><a href="#orgf6ad9a3">方法</a>
<ul>
<li><a href="#orgb7f2374">func (*Mutex) Lock</a></li>
<li><a href="#org793a7b3">func (*Mutex) Unlock</a></li>
</ul>
</li>
<li><a href="#org530fcd3">注意</a></li>
<li><a href="#org84ba749">实例</a></li>
</ul>
</li>
<li><a href="#org453cb69">sync.RWMutex</a>
<ul>
<li><a href="#orgf926639">用例</a></li>
<li><a href="#orgd2341a2">禁止嵌套</a></li>
</ul>
</li>
<li><a href="#org8a76c3a">sync.WaitGroup</a></li>
<li><a href="#orgcecf5d8">sync.Map</a></li>
<li><a href="#org2139f82">sync.Poll</a></li>
<li><a href="#org6d1dd15">sync.Once</a></li>
<li><a href="#orgdf61913">sync.Cond</a></li>
</ul>
</div>
</div>

<div id="outline-container-org571af1e" class="outline-2">
<h2 id="org571af1e">简介</h2>
<div class="outline-text-2" id="text-org571af1e">
<p>
在并发编程中同步原语也就是我们通常说的锁的主要作用是保证多个线程或者 <code>goroutine</code> 在访问同一片内存时不会出现混乱的问题。Go 语言的 <code>sync</code> 包提供了常见的并发编程同步原语，<a href="https://link.segmentfault.com/?enc=64KVB0dVY%2B5H93bQIG79Ag%3D%3D.JDGOYzKbXUsZrxckZxgjNRSzxXk4fIitNGXe%2BXOXm3hQnxcaJ08%2FfkZudRO10Q34s6VET1gamJPctRGW%2F9Eygi68puz0EPoIQDT60dPMNhCwk%2FIDHfDHiqKK6FFYZqp5bbNqfnkhJmSUJ2j91tHXcxBrqOJjacRK%2BcyL%2FdQPbkYibY3jYDFVi%2B1qGYKFFvBWr4OD%2BqJo0uMGIYvo%2BvTkRkBU4uOsY4808wj8pIQTETS3kbYEW%2FSahUEfVPjhHmxfXddkLVvc7qxlyqmm3c8KJtWExl0OT1zoUwb1rwN%2FcDUUDBTFB9uB6BCFXdPL3639S0t1nMgul97tUqljYX6Pzg%3D%3D">《Golang 并发编程之同步原语》</a> 这篇文章中详述了 <code>Mutex</code> 、 <code>RWMutex</code> 、 <code>WaitGroup</code> 、 <code>Once</code> 和 <code>Cond</code> 这些同步原语的实现原理。今天的文章里我们回到应用层，聚焦 <code>sync</code> 包里这些同步原语的应用场景，同时也会介绍 <code>sync</code> 包中的 <code>Pool</code> 和 <code>Map</code> 的应用场景和使用方法。<br>
</p>
</div>
</div>
<div id="outline-container-orgb15e6dd" class="outline-2">
<h2 id="orgb15e6dd">sync.Mutex</h2>
<div class="outline-text-2" id="text-orgb15e6dd">
<p>
<code>sync.Mutex</code> 可能是是 <code>sync</code> 包中使用最广泛的原语，它允许在共享资源上互斥访问（不能同时访问）：<br>
</p>
</div>
<div id="outline-container-orgf6ad9a3" class="outline-3">
<h3 id="orgf6ad9a3">方法</h3>
<div class="outline-text-3" id="text-orgf6ad9a3">
</div>
<div id="outline-container-orgb7f2374" class="outline-4">
<h4 id="orgb7f2374">func (*Mutex) Lock</h4>
<div class="outline-text-4" id="text-orgb7f2374">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">m</span> *<span style="color: #df005f; font-weight: bold;">Mutex</span>) <span style="color: #d75fd7; font-weight: bold;">Lock</span>()
</pre>
</div>

<p>
Lock 方法锁住 m，如果 m 已经加锁，则阻塞直到 m 解锁。<br>
</p>
</div>
</div>
<div id="outline-container-org793a7b3" class="outline-4">
<h4 id="org793a7b3">func (*Mutex) Unlock</h4>
<div class="outline-text-4" id="text-org793a7b3">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">m</span> *<span style="color: #df005f; font-weight: bold;">Mutex</span>) <span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
</pre>
</div>

<p>
Unlock 方法解锁 m，如果 m 未加锁会导致运行时错误。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org530fcd3" class="outline-3">
<h3 id="org530fcd3">注意</h3>
<div class="outline-text-3" id="text-org530fcd3">
<ul class="org-ul">
<li>在一个 goroutine 获得 Mutex 后，其他 goroutine 只能等到这个 goroutine 释放该 Mutex<br></li>
<li>使用 Lock() 加锁后，不能再继续对其加锁，直到利用 Unlock() 解锁后才能再加锁<br></li>
<li>在 Lock() 之前使用 Unlock() 会导致 panic 异常<br></li>
<li>已经锁定的 Mutex 并不与特定的 goroutine 相关联，这样可以利用一个 goroutine 对其加锁，再利用其他 goroutine 对其解锁<br></li>
<li>在同一个 goroutine 中的 Mutex 解锁之前再次进行加锁，会导致死锁<br></li>
<li>适用于读写不确定，并且只有一个读或者写的场景<br></li>
</ul>
</div>
</div>
<div id="outline-container-org84ba749" class="outline-3">
<h3 id="org84ba749">实例</h3>
<div class="outline-text-3" id="text-org84ba749">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> main

<span style="color: #268bd2; font-weight: bold;">import</span> (
    <span style="color: #2aa198;">"fmt"</span>
    <span style="color: #2aa198;">"sync"</span>
    <span style="color: #2aa198;">"time"</span>
)

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {

    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">mutex</span> <span style="color: #df005f; font-weight: bold;">sync.Mutex</span>
    <span style="color: #8787d7;">wait</span> := <span style="color: #df005f; font-weight: bold;">sync.WaitGroup</span>{}

    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"Locked"</span>)
    mutex.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()

    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := <span style="color: #d75fd7;">1</span>; i &lt;= <span style="color: #d75fd7;">3</span>; i++ {
        wait.<span style="color: #d75fd7; font-weight: bold;">Add</span>(<span style="color: #d75fd7;">1</span>)

        <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>(<span style="color: #8787d7;">i</span> <span style="color: #df005f; font-weight: bold;">int</span>) {
            fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"Not lock:"</span>, i)

            mutex.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
            fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"Lock:"</span>, i)

            time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(time.Second)

            fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"Unlock:"</span>, i)
            mutex.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()

            <span style="color: #268bd2; font-weight: bold;">defer</span> wait.<span style="color: #d75fd7; font-weight: bold;">Done</span>()
        }(i)
    }

    time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(time.Second)
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"Unlocked"</span>)
    mutex.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()

    wait.<span style="color: #d75fd7; font-weight: bold;">Wait</span>()
}
</pre>
</div>

<p>
运行结果：<br>
</p>

<pre class="example" id="orga5baf5b">
Locked
Not lock: 1
Not lock: 2
Not lock: 3
Unlocked
Lock: 1
Unlock: 1
Lock: 2
Unlock: 2
Lock: 3
Unlock: 3
</pre>
</div>
</div>
</div>
<div id="outline-container-org453cb69" class="outline-2">
<h2 id="org453cb69">sync.RWMutex</h2>
<div class="outline-text-2" id="text-org453cb69">
<p>
<code>sync.RWMutex</code> 是一个读写互斥锁，它提供了我们上面的刚刚看到的 <code>sync.Mutex</code> 和 <code>Lock</code> 和 <code>Unlock</code> 方法（因为这两个结构都实现了 <code>sync.Locker</code> 接口）。但是，它还允许使用 <code>RLock</code> 和 <code>RUnlock</code> 方法进行并发读取：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">mutex</span> := &amp;<span style="color: #df005f; font-weight: bold;">sync.RWMutex</span>{}

mutex.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Update &#20849;&#20139;&#21464;&#37327;</span>
mutex.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()

mutex.<span style="color: #d75fd7; font-weight: bold;">RLock</span>()
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Read &#20849;&#20139;&#21464;&#37327;</span>
mutex.<span style="color: #d75fd7; font-weight: bold;">RUnlock</span>()
</pre>
</div>

<p>
<code>sync.Mutex</code> 允许一个读锁或一个写锁存在，而 <code>sync.RWMutex</code> 允许至少一个读锁或一个写锁存在。简单来说就是 <code>RWMutex</code> 可以由任意数量的读者同时使用，或者只由一个写者使用的锁。<br>
</p>

<p>
在并发编程的很多场景下，数据的读取可能比写入更加频繁，这时就要允许多个线程同时读取一块内容。<br>
</p>

<pre class="example" id="orge2911cd">
BenchmarkMutexLock-4       83497579         17.7 ns/op
BenchmarkRWMutexLock-4     35286374         44.3 ns/op
BenchmarkRWMutexRLock-4    89403342         15.3 ns/op
</pre>

<p>
可以看到 <code>sync.RWMutex</code> 读锁的速度比 <code>sync.Mutex</code> 更快，另一方面，在 <code>sync.RWMutex</code> 上调用 <code>Lock()</code> / <code>Unlock()</code> 是最慢的操作。<br>
</p>

<p>
因此，只有在频繁读取和不频繁写入的场景里，才应该使用 <code>sync.RWMutex</code> 。<br>
</p>
</div>
<div id="outline-container-orgf926639" class="outline-3">
<h3 id="orgf926639">用例</h3>
<div class="outline-text-3" id="text-orgf926639">
<p>
Go 中，RWMutex 的零值是一个未加锁的互斥量。<br>
</p>

<p>
RWMutex 使用起来相对比较简单，这里举一个简单的例子：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> main
<span style="color: #268bd2; font-weight: bold;">import</span> (
    <span style="color: #2aa198;">"fmt"</span>
    <span style="color: #2aa198;">"sync"</span>
    <span style="color: #2aa198;">"time"</span>
)
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">rw</span> := <span style="color: #268bd2;">new</span>(<span style="color: #df005f; font-weight: bold;">sync.RWMutex</span>)
    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := <span style="color: #d75fd7;">0</span>; i &lt; <span style="color: #d75fd7;">2</span>; i++ {   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#24314;&#31435;&#20004;&#20010;&#20889;&#32773;</span>
        <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
            <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">j</span> := <span style="color: #d75fd7;">0</span>; j &lt; <span style="color: #d75fd7;">3</span>; j++ {
                rw.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
                <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20889;</span>
                rw.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
            }
        }()
    }
    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := <span style="color: #d75fd7;">0</span>; i &lt; <span style="color: #d75fd7;">5</span>; i++ {    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#24314;&#31435;&#20004;&#20010;&#35835;&#32773;</span>
        <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
            <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">j</span> := <span style="color: #d75fd7;">0</span>; j &lt; <span style="color: #d75fd7;">3</span>; j++ {
                rw.<span style="color: #d75fd7; font-weight: bold;">RLock</span>()
                <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#35835;</span>
                rw.<span style="color: #d75fd7; font-weight: bold;">RUnlock</span>()
            }
        }()
    }
    time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(time.Second)
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"Done"</span>)
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd2341a2" class="outline-3">
<h3 id="orgd2341a2">禁止嵌套</h3>
<div class="outline-text-3" id="text-orgd2341a2">
<blockquote>
<p>
读者在读的时候，不能够假定别的读者也能够获得锁。因此，禁止读锁嵌套。<br>
</p>
</blockquote>

<p>
是不是有点儿绕？下面举个“七秒例”<br>
</p>

<ul class="org-ul">
<li>第一秒：读者1在第1秒成功申请了读锁<br></li>
<li>第二秒：写者1在第2秒申请写锁，申请失败，阻塞，但它会防止新的读者获锁<br></li>
<li>第三秒：读者2在第3秒申请读锁，申请失败<br></li>
<li>第四秒：读者1释放读锁，写者1获得写锁<br></li>
<li>第五秒：写者1释放写锁，读者2获得读锁<br></li>
<li>第六秒：读者1再次申请读锁，申请成功，与读者2共享<br></li>
<li>第七秒：读者1、读者2释放读锁，结束<br></li>
</ul>

<p>
当写锁阻塞时，新的读锁是无法申请的，这可以有效防止写者饥饿。如果一个线程因为某种原因，导致得不到CPU运行时间，这种状态被称之为 <b>饥饿</b> 。<br>
</p>

<p>
然而，这种机制也禁止了读锁嵌套。读锁嵌套可能造成死锁：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> main
<span style="color: #268bd2; font-weight: bold;">import</span> (
    <span style="color: #2aa198;">"fmt"</span>
    <span style="color: #2aa198;">"sync"</span>
    <span style="color: #2aa198;">"time"</span>
)
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">rw</span> := <span style="color: #268bd2;">new</span>(<span style="color: #df005f; font-weight: bold;">sync.RWMutex</span>)
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">deadLockCase</span> <span style="color: #df005f; font-weight: bold;">time.Duration</span> = <span style="color: #d75fd7;">1</span>
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
        time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(time.Second * deadLockCase)
        fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"Writer Try"</span>)
        rw.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
        fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"Writer Fetch"</span>)
        time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(time.Second * <span style="color: #d75fd7;">1</span>)
        fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"Writer Release"</span>)
        rw.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
    }()
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"Reader 1 Try"</span>)
    rw.<span style="color: #d75fd7; font-weight: bold;">RLock</span>()
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"Reader 1 Fetch"</span>)
    time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(time.Second * <span style="color: #d75fd7;">2</span>)
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"Reader 2 Try"</span>)
    rw.<span style="color: #d75fd7; font-weight: bold;">RLock</span>()
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"Reader 2 Fetch"</span>)
    time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(time.Second * <span style="color: #d75fd7;">2</span>)
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"Reader 1 Release"</span>)
    rw.<span style="color: #d75fd7; font-weight: bold;">RUnlock</span>()
    time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(time.Second * <span style="color: #d75fd7;">1</span>)
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"Reader 2 Release"</span>)
    rw.<span style="color: #d75fd7; font-weight: bold;">RUnlock</span>()
    time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(time.Second * <span style="color: #d75fd7;">2</span>)
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"Done"</span>)
}
</pre>
</div>

<p>
读者1和读者2是嵌套关系，按照这种时间安排，上述程序会导致死锁。<br>
</p>

<p>
而有些死锁的可怕之处就在于，它不一定会发生。假设上面程序中的time.Sleep都是随机的时间，那么这一段代码每次的结果有可能不一致，这会给Debug带来极大的困难。<br>
</p>

<p>
读锁嵌套了还有概率成功，写锁嵌套了就一定会死锁！<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org8a76c3a" class="outline-2">
<h2 id="org8a76c3a">sync.WaitGroup</h2>
<div class="outline-text-2" id="text-org8a76c3a">
<p>
<code>sync.WaitGroup</code> 也是一个经常会用到的同步原语，它的使用场景是在一个 <code>goroutine</code> 等待一组 <code>goroutine</code> 执行完成。<br>
</p>

<p>
<code>sync.WaitGroup</code> 拥有一个内部计数器，当计数器等于 0 时，则 <code>Wait()</code> 方法会立即返回，否则它将阻塞执行 <code>Wait()</code> 方法的 <code>goroutine</code> 直到计数器等于 0 为止。<br>
</p>

<p>
要增加计数器，我们必须使用 <code>Add(int)</code> 方法；要减少它，我们可以使用 <code>Done()</code> （将计数器减一），也可以传递负数给 <code>Add</code> 方法， <code>Done()</code> 方法底层就是通过 <code>Add(-1)</code> 实现的。<br>
</p>

<p>
在以下示例中，我们将启动八个 <code>goroutine</code> ，并等待它们完成：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">wg</span> := &amp;<span style="color: #df005f; font-weight: bold;">sync.WaitGroup</span>{}

<span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := <span style="color: #d75fd7;">0</span>; i &lt; <span style="color: #d75fd7;">0</span>; i ++ {
    wg.<span style="color: #d75fd7; font-weight: bold;">Add</span>(<span style="color: #d75fd7;">1</span>)
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Do something</span>
        wg.<span style="color: #d75fd7; font-weight: bold;">Done</span>()
    } ()
}
wg.<span style="color: #d75fd7; font-weight: bold;">Wait</span>()
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#32487;&#32493;&#24448;&#19979;&#25191;&#34892;...</span>
</pre>
</div>

<p>
每次创建 <code>goroutine</code> 时，我们都会使用 <code>wg.Add(1)</code> 来增加 <code>wg</code> 的内部计数器，也可以在 <code>for</code> 循环之前调用 <code>wg.Add(8)</code> 。<br>
</p>

<p>
于此同时，每个 <code>goroutine</code> 完成时，都会使用 <code>wg.Done()</code> 减少 <code>wg</code> 的内部计数器。<br>
</p>

<p>
<code>main goroutine</code> 会在八个 <code>goroutine</code> 都执行 <code>wg.Done()</code> 将计数器变为 0 后才能继续执行。<br>
</p>
</div>
</div>
<div id="outline-container-orgcecf5d8" class="outline-2">
<h2 id="orgcecf5d8">sync.Map</h2>
<div class="outline-text-2" id="text-orgcecf5d8">
<p>
<code>sync.Map</code> 是一个并发版本的 <code>Go</code> 语言的 <code>map</code> ：<br>
</p>

<ul class="org-ul">
<li>使用 <code>Store(interface {}，interface {})</code> 添加元素。<br></li>
<li>使用 <code>Load(interface {}) interface {}</code> 检索元素。<br></li>
<li>使用 <code>Delete(interface {})</code> 删除元素。<br></li>
<li>使用 <code>LoadOrStore(interface {}，interface {}) (interface {}，bool)</code> 检索或添加之前不存在的元素。如果键之前在 <code>map</code> 中存在，则返回的布尔值为 <code>true</code> 。<br></li>
<li>使用 <code>Range</code> 遍历元素。<br></li>
</ul>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">m</span> := &amp;<span style="color: #df005f; font-weight: bold;">sync.Map</span>{}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#28155;&#21152;&#20803;&#32032;</span>
m.<span style="color: #d75fd7; font-weight: bold;">Store</span>(<span style="color: #d75fd7;">1</span>, <span style="color: #2aa198;">"one"</span>)
m.<span style="color: #d75fd7; font-weight: bold;">Store</span>(<span style="color: #d75fd7;">2</span>, <span style="color: #2aa198;">"two"</span>)

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#33719;&#21462;&#20803;&#32032;1</span>
<span style="color: #8787d7;">value</span>, <span style="color: #8787d7;">contains</span> := m.<span style="color: #d75fd7; font-weight: bold;">Load</span>(<span style="color: #d75fd7;">1</span>)
<span style="color: #268bd2; font-weight: bold;">if</span> contains {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%s\n"</span>, value.(<span style="color: #df005f; font-weight: bold;">string</span>))
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36820;&#22238;&#24050;&#23384;value&#65292;&#21542;&#21017;&#25226;&#25351;&#23450;&#30340;&#38190;&#20540;&#23384;&#20648;&#21040;map&#20013;</span>
<span style="color: #8787d7;">value</span>, <span style="color: #8787d7;">loaded</span> := m.<span style="color: #d75fd7; font-weight: bold;">LoadOrStore</span>(<span style="color: #d75fd7;">3</span>, <span style="color: #2aa198;">"three"</span>)
<span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #d75fd7;">!</span>loaded {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%s\n"</span>, value.(<span style="color: #df005f; font-weight: bold;">string</span>))
}

m.<span style="color: #d75fd7; font-weight: bold;">Delete</span>(<span style="color: #d75fd7;">3</span>)

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36845;&#20195;&#25152;&#26377;&#20803;&#32032;</span>
m.<span style="color: #d75fd7; font-weight: bold;">Range</span>(<span style="color: #268bd2; font-weight: bold;">func</span>(<span style="color: #8787d7;">key</span>, <span style="color: #8787d7;">value</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{}) <span style="color: #df005f; font-weight: bold;">bool</span> {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%d: %s\n"</span>, key.(<span style="color: #df005f; font-weight: bold;">int</span>), value.(<span style="color: #df005f; font-weight: bold;">string</span>))
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">true</span>
})
</pre>
</div>

<p>
输出：<br>
</p>

<pre class="example" id="org5eae77f">
one
three
1: one
2: two
</pre>

<p>
<code>Range</code> 方法接收一个类型为 <code>func(key, value interface{}) bool</code> 的函数参数，如果函数返回了 <code>false</code> ，则停止迭代。有趣的事实是，即使我们在恒定时间后返回 <code>false</code> ，最坏情况下的时间复杂度仍为 <code>O(n)</code> 。<br>
</p>

<p>
我们应该在什么时候使用 <code>sync.Map</code> 而不是在普通的 <code>Map</code> 上使用 <code>sync.Mutex</code> ？<br>
</p>

<ul class="org-ul">
<li>当我们对 <code>map</code> 有频繁的读取和不频繁的写入时<br></li>
<li>当多个 <code>goroutine</code> 读取，写入和覆盖不相交的键时，具体是什么意思呢？例如：我们有一个分片实现，其中包含一组 4 个 <code>goroutine</code> ，每个 <code>goroutine</code> 负责 25% 的键（每个负责的键不冲突），在这种情况下， <code>sync.Map</code> 是首选。<br></li>
</ul>
</div>
</div>
<div id="outline-container-org2139f82" class="outline-2">
<h2 id="org2139f82">sync.Poll</h2>
<div class="outline-text-2" id="text-org2139f82">
<p>
<code>sync.Pool</code> 是一个并发池，负责安全地保存一组对象。它有两个导出方法：<br>
</p>

<ul class="org-ul">
<li><code>Get() interface{}</code> 用来从并发池中取出元素。<br></li>
<li><code>Put(interface{})</code> 将一个对象加入并发池。<br></li>
</ul>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">pool</span> := &amp;<span style="color: #df005f; font-weight: bold;">sync.Pool</span>{}

pool.<span style="color: #d75fd7; font-weight: bold;">Put</span>(<span style="color: #d75fd7; font-weight: bold;">NewConnection</span>(<span style="color: #d75fd7;">1</span>))
pool.<span style="color: #d75fd7; font-weight: bold;">Put</span>(<span style="color: #d75fd7; font-weight: bold;">NewConnection</span>(<span style="color: #d75fd7;">2</span>))
pool.<span style="color: #d75fd7; font-weight: bold;">Put</span>(<span style="color: #d75fd7; font-weight: bold;">NewConnection</span>(<span style="color: #d75fd7;">3</span>))

<span style="color: #8787d7;">connection</span> := pool.<span style="color: #d75fd7; font-weight: bold;">Get</span>().(*<span style="color: #df005f; font-weight: bold;">Connection</span>)
fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%d\n"</span>, connection.id)
connection = pool.<span style="color: #d75fd7; font-weight: bold;">Get</span>().(*<span style="color: #df005f; font-weight: bold;">Connection</span>)
fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%d\n"</span>, connection.id)
connection = pool.<span style="color: #d75fd7; font-weight: bold;">Get</span>().(*<span style="color: #df005f; font-weight: bold;">Connection</span>)
fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%d\n"</span>, connection.id)
</pre>
</div>

<p>
输出：<br>
</p>

<pre class="example" id="org132cdd1">
1
3
2
</pre>

<p>
需要注意的是 <code>Get()</code> 方法会从并发池中随机取出对象，无法保证以固定的顺序获取并发池中存储的对象。<br>
</p>

<p>
还可以为 <code>sync.Pool</code> 指定一个创建者方法：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">pool</span> := &amp;<span style="color: #df005f; font-weight: bold;">sync.Pool</span>{
    <span style="color: #d75fd7;">New</span>: <span style="color: #268bd2; font-weight: bold;">func</span>() <span style="color: #268bd2; font-weight: bold;">interface</span>{} {
        <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7; font-weight: bold;">NewConnection</span>()
    },
}

<span style="color: #8787d7;">connection</span> := pool.<span style="color: #d75fd7; font-weight: bold;">Get</span>().(*<span style="color: #df005f; font-weight: bold;">Connection</span>)
</pre>
</div>

<p>
这样每次调用 <code>Get()</code> 时，将返回由在 <code>pool.New</code> 中指定的函数创建对象（在本例中为指针）。<br>
</p>

<p>
那什么时候使用 <code>sync.Pool</code> ？有两个用例：<br>
</p>

<p>
第一个是当我们必须重用共享的和长期存在的对象（例如，数据库连接）时，第二个是用于优化内存分配。<br>
</p>

<p>
让我们考虑一个写入缓冲区并将结果持久保存到文件中的函数示例。使用 <code>sync.Pool</code> ，我们可以通过在不同的函数调用之间重用同一对象来重用为缓冲区分配的空间。<br>
</p>

<p>
第一步是检索先前分配的缓冲区（如果是第一个调用，则创建一个缓冲区，但这是抽象的）。然后， <code>defer</code> 操作是将缓冲区放回 <code>sync.Pool</code> 中。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">writeFile</span>(<span style="color: #8787d7;">pool</span> *<span style="color: #df005f; font-weight: bold;">sync.Pool</span>, <span style="color: #8787d7;">filename</span> <span style="color: #df005f; font-weight: bold;">string</span>) <span style="color: #df005f; font-weight: bold;">error</span> {
    <span style="color: #8787d7;">buf</span> := pool.<span style="color: #d75fd7; font-weight: bold;">Get</span>().(*<span style="color: #df005f; font-weight: bold;">bytes.Buffer</span>)

    <span style="color: #268bd2; font-weight: bold;">defer</span> pool.<span style="color: #d75fd7; font-weight: bold;">Put</span>(buf)

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Reset &#32531;&#23384;&#21306;&#65292;&#19981;&#28982;&#20250;&#36830;&#25509;&#19978;&#27425;&#35843;&#29992;&#26102;&#20445;&#23384;&#22312;&#32531;&#23384;&#21306;&#37324;&#30340;&#23383;&#31526;&#20018;foo</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#32534;&#31243;foofoo &#20197;&#27492;&#31867;&#25512;</span>
    buf.<span style="color: #d75fd7; font-weight: bold;">Reset</span>()

    buf.<span style="color: #d75fd7; font-weight: bold;">WriteString</span>(<span style="color: #2aa198;">"foo"</span>)

    <span style="color: #268bd2; font-weight: bold;">return</span> ioutil.<span style="color: #d75fd7; font-weight: bold;">WriteFile</span>(filename, buf.<span style="color: #d75fd7; font-weight: bold;">Bytes</span>(), <span style="color: #d75fd7;">0644</span>)
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org6d1dd15" class="outline-2">
<h2 id="org6d1dd15">sync.Once</h2>
<div class="outline-text-2" id="text-org6d1dd15">
<p>
<code>sync.Once</code> 是一个简单而强大的原语，可确保一个函数仅执行一次。在下面的示例中，只有一个 <code>goroutine</code> 会显示输出消息：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">once</span> := &amp;<span style="color: #df005f; font-weight: bold;">sync.Once</span>{}
<span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := <span style="color: #d75fd7;">0</span>; i &lt; <span style="color: #d75fd7;">4</span>; i++ {
    <span style="color: #8787d7;">i</span> := i
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>() {
        once.<span style="color: #d75fd7; font-weight: bold;">Do</span>(<span style="color: #268bd2; font-weight: bold;">func</span>() {
            fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"first %d\n"</span>, i)
        })
    }()
}
</pre>
</div>

<p>
我们使用了 <code>Do(func ())</code> 方法来指定只能被调用一次的部分。<br>
</p>
</div>
</div>
<div id="outline-container-orgdf61913" class="outline-2">
<h2 id="orgdf61913">sync.Cond</h2>
<div class="outline-text-2" id="text-orgdf61913">
<p>
<code>sync.Cond</code> 可能是 <code>sync</code> 包提供的同步原语中最不常用的一个，它用于发出信号（一对一）或广播信号（一对多）到 <code>goroutine</code> 。让我们考虑一个场景，我们必须向一个 <code>goroutine</code> 指示共享切片的第一个元素已更新。创建 <code>sync.Cond</code> 需要 <code>sync.Locker</code> 对象（ <code>sync.Mutex</code> 或 <code>sync.RWMutex</code> ）：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">cond</span> := sync.<span style="color: #d75fd7; font-weight: bold;">NewCond</span>(&amp;<span style="color: #df005f; font-weight: bold;">sync.Mutex</span>{})
</pre>
</div>

<p>
然后，让我们编写负责显示切片的第一个元素的函数：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">printFirstElement</span>(<span style="color: #8787d7;">s</span> []<span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #8787d7;">cond</span> *<span style="color: #df005f; font-weight: bold;">sync.Cond</span>) {
    cond.L.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
    cond.<span style="color: #d75fd7; font-weight: bold;">Wait</span>()
    fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%d\n"</span>, s[<span style="color: #d75fd7;">0</span>])
    cond.L.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
}
</pre>
</div>

<p>
我们可以使用 <code>cond.L</code> 访问内部的互斥锁。一旦获得了锁，我们将调用 <code>cond.Wait()</code> ，这会让当前 <code>goroutine</code> 在收到信号前一直处于阻塞状态。<br>
</p>

<p>
让我们回到 <code>main goroutine</code> 。我们将通过传递共享切片和先前创建的 <code>sync.Cond</code> 来创建 <code>printFirstElement</code> 池。然后我们调用 <code>get()</code> 函数，将结果存储在 <code>s[0]</code> 中并发出信号：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">s</span> := <span style="color: #268bd2;">make</span>([]<span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #d75fd7;">1</span>)
<span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := <span style="color: #d75fd7;">0</span>; i &lt; runtime.<span style="color: #d75fd7; font-weight: bold;">NumCPU</span>(); i++ {
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #d75fd7; font-weight: bold;">printFirstElement</span>(s, cond)
}

<span style="color: #8787d7;">i</span> := <span style="color: #d75fd7; font-weight: bold;">get</span>()
cond.L.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
s[<span style="color: #d75fd7;">0</span>] = i
cond.<span style="color: #d75fd7; font-weight: bold;">Signal</span>()
cond.L.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
</pre>
</div>

<p>
这个信号会解除一个 <code>goroutine</code> 的阻塞状态，解除阻塞的 <code>goroutine</code> 将会显示 <code>s[0]</code> 中存储的值。<br>
</p>

<p>
但是，有的人可能会争辩说我们的代码破坏了 <code>Go</code> 的最基本原则之一：<br>
</p>

<blockquote>
<p>
不要通过共享内存进行通信；而是通过通信共享内存。<br>
</p>
</blockquote>

<p>
确实，在这个示例中，最好使用 <code>channel</code> 来传递 <code>get()</code> 返回的值。但是我们也提到了 <code>sync.Cond</code> 也可以用于广播信号。我们修改一下上面的示例，把 <code>Signal()</code> 调用改为调用 <code>Broadcast()</code> 。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">i</span> := <span style="color: #d75fd7; font-weight: bold;">get</span>()
cond.L.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
s[<span style="color: #d75fd7;">0</span>] = i
cond.<span style="color: #d75fd7; font-weight: bold;">Broadcast</span>()
cond.L.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
</pre>
</div>

<p>
在这种情况下，所有 <code>goroutine</code> 都将被触发。<br>
众所周知，channel里的元素只会由一个goroutine接收到。通过 <code>channel</code> 模拟广播的唯一方法是关闭 <code>channel</code> 。<br>
</p>

<blockquote>
<p>
当一个channel被关闭后，channel中已经发送的数据都被成功接收后，后续的接收操作将不再阻塞，它们会立即返回一个零值。<br>
</p>
</blockquote>

<p>
但是这种方式只能广播一次。因此，尽管存在很大争议，但这无疑是 <code>sync.Cond</code> 的一个有趣的功能。<br>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-02-07 18:02 Mon</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-02-14 Mon 04:31</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
