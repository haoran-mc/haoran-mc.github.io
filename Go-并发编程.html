<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-05-14 Sat 19:55 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Go 并发编程</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">Go 并发编程</h1>
<p>
我们知道，Go 语言部署简单，自带完善的工具链，不仅容易上手，而且执行性能非常好，现在已经被越来越多的人当成主要的编程语言。最重要的是，它天然支持并发，这也是它的最大优势。<br>
</p>

<p>
但是，并发编程入门容易，想要精通却很难，主要有五大问题：<br>
</p>

<ul class="org-ul">
<li>在面对并发难题时，该选择哪个并发原语来解决问题呢？<br></li>
<li>如果多个并发原语都可以解决问题，那么，究竟哪个是最优解呢？比如说是用互斥锁，还是用 Channel。<br></li>
<li>并发编程不像是传统的串行编程，程序的运行存在着很大的不确定性，我们怎么才能让相应的任务按照我们设想的流程运行呢？<br></li>
<li>有时候，按照正常理解的并发方式去实现的程序，结果莫名其妙就 panic 或者死锁了，排查起来非常困难。<br></li>
<li>已知的并发原语都不能解决并发问题，程序写起来异常复杂，而且代码混乱，容易出错，该怎么办呢？<br></li>
</ul>

<ul class="org-ul">
<li><a href="Go-并发编程中的专业名词.html">并发编程中的几个专业名词</a><br></li>
</ul>

<hr>

<ul class="org-ul">
<li><b>基本并发原语</b> ：标准库中的基本并发原语，互斥锁 Mutex、RWMutex、Waitgroup、Cond、Pool、Context 等的实现机制和使用技巧。<br>
<ul class="org-ul">
<li><a href="Go-并发编程-Mutex_如何解决资源并发访问问题.html">Mutex: 如何解决资源并发访问问题？</a> <br></li>
<li><a href="Go-并发编程-Mutex_源码实现.html">Mutex: 源码实现</a> <br></li>
<li><a href="Go-并发编程-Mutex_4种易错场景.html">Mutex: 4 种易错场景</a> <br></li>
<li><a href="Go-并发编程-Mutex_拓展额外功能.html">Mutex: 拓展额外功能</a><br></li>
<li><a href="Go-并发编程-RWMutex_读写锁的实现原理及避坑指南.html">RWMutex: 读写锁的实现原理及避坑指南</a> <br></li>
<li>Cond: 条件变量的实现机制及避坑指南<br></li>
<li>Once: 一个简约而不简单的并发原语<br></li>
<li>map: 如何实现线程安全的 map 类型？<br></li>
<li>Pool: 性能提升大杀器<br></li>
<li>Context: 信息穿透上下文<br></li>
</ul></li>
<li><b>原子操作</b> ：标准库中的原子操作，这是其它并发原语的基础。学会了这部分内容，可以自己创造新的并发原语。<br>
<ul class="org-ul">
<li>atomic: 要保证原子操作，一定要使用这几种方法<br></li>
</ul></li>
<li><b>Channel</b> ：Channel 类型是 Go 语言独特的类型。<br>
<ul class="org-ul">
<li>Channel: 另辟蹊径，解决并发问题<br></li>
<li>Channel: 透过代码看典型的应用模式<br></li>
<li>内存模型：Go 如何保证并发读写的顺序？<br></li>
</ul></li>
<li><b>扩展并发原语</b> ：目前来看，Go 开发组不准备在标准库中扩充并发原语了，但是还有一些并发原语应用得非常广泛。讲解信号量、SingleFlight、循环栅栏、ErrGroup 等，在处理一些并发问题时事半功倍。<br>
<ul class="org-ul">
<li>Semaphore: 一篇文章搞懂信号量<br></li>
<li>SingleFlight 和 CyclicBarrier: 请求合并和循环栅栏该怎么用？<br></li>
</ul></li>
<li><b>分布式并发原语</b> ：分布式并发原语是应对大规模的应用程序中并发问题的并发类型，主要会介绍使用 etcd 实现的一些分布式并发原语，比如 Leader 选举、分布式互斥锁、分布式读写锁、分布式队列等，攻克分布式场景中的并发难题。<br>
<ul class="org-ul">
<li>在分布式环境中，Leader 选举、互斥锁和读写锁该如何实现？<br></li>
<li>在分布式环境中，队列、栅栏和 STM 该如何实现？<br></li>
</ul></li>
</ul>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-05-09 21:05 Mon</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-05-14 Sat 19:55</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
