<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-10-15 Fri 21:08 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>博弈论</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">博弈论</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org49845ef">公平组合游戏</a></li>
<li><a href="#orgfdd61b3">Nim Game</a>
<ul>
<li><a href="#org5479a1b">游戏内容</a></li>
<li><a href="#org6a43275">必胜手段</a></li>
<li><a href="#orge57ee09">推广到 n 堆牌</a></li>
<li><a href="#org297ed18">判断胜者多少种胜法</a></li>
<li><a href="#org840f1a0">证明一定有从非平衡态到平衡态的取法</a></li>
<li><a href="#org9a070c6">证明一定没有从平衡态到平衡态的取法</a></li>
</ul>
</li>
<li><a href="#orgc848da8">有向图游戏的和 Sprague-Grundy 函数</a>
<ul>
<li><a href="#org4615b41">mex 运算</a></li>
<li><a href="#org797b512">sg 函数</a></li>
<li><a href="#orgf8be066">使用sg函数求解nim游戏</a></li>
</ul>
</li>
<li><a href="#org88b0b03">Bash Game</a>
<ul>
<li><a href="#orgaaf9935">游戏内容</a></li>
<li><a href="#org652192b">推广到 n 张牌</a></li>
<li><a href="#org11c3055">限制取石子的数量</a></li>
<li><a href="#org8f1f2b0">继续推广到二维平面</a></li>
<li><a href="#org3897903">一步两步</a></li>
</ul>
</li>
<li><a href="#org60b2a2f">Wythoff Game</a>
<ul>
<li><a href="#org99cd0d5">威佐夫两类问题：</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org49845ef" class="outline-2">
<h2 id="org49845ef">公平组合游戏</h2>
<div class="outline-text-2" id="text-org49845ef">
<p>
公平组合游戏的定义如下：<br>
</p>
<ul class="org-ul">
<li>游戏有两个人参与，二者轮流做出决策，双方均知道游戏的完整信息；<br></li>
<li>任意一个游戏者在某一确定状态可以作出的决策集合只与当前的状态有关，而与游戏者无关；<br></li>
<li>游戏中的同一个状态不可能多次抵达，游戏以玩家无法行动为结束，且游戏一定会在有限步后以非平局结束。<br></li>
</ul>

<p>
大部分的棋类游戏都 不是 公平组合游戏，如国际象棋、中国象棋、围棋、五子棋等（因为双方都不能使用对方的棋子）。<br>
</p>
</div>
</div>
<div id="outline-container-orgfdd61b3" class="outline-2">
<h2 id="orgfdd61b3">Nim Game</h2>
<div class="outline-text-2" id="text-orgfdd61b3">
</div>
<div id="outline-container-org5479a1b" class="outline-3">
<h3 id="org5479a1b">游戏内容</h3>
<div class="outline-text-3" id="text-org5479a1b">
<ul class="org-ul">
<li>两个玩家以及 \(3\) 堆扑克，分别有 \(5, 7, 9\) 张牌<br></li>
<li>游戏双方轮流操作<br></li>
<li>玩家的每次操作是选择其中一堆从中取走任意张牌，不能不取牌<br></li>
<li>最后一次取牌的玩家为获胜方<br></li>
</ul>

<p>
游戏双方 \(A\) 和 \(B\)，看似游戏输赢是随机的，但实则先手取牌的人必赢；后手取牌的人必输。<br>
</p>
</div>
</div>
<div id="outline-container-org6a43275" class="outline-3">
<h3 id="org6a43275">必胜手段</h3>
<div class="outline-text-3" id="text-org6a43275">
<p>
本世纪初，哈佛大学数学系副教授查理士•理昂纳德•包顿（Chales Leonard Bouton）利用数的二进制表示法，解答了这个游戏的一般法则。<br>
</p>

<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">\(2^3 = 8\)</th>
<th scope="col" class="org-right">\(2^2 = 4\)</th>
<th scope="col" class="org-right">\(2^1 = 2\)</th>
<th scope="col" class="org-right">\(2^0 = 1\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">5</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<p>
将每堆牌数化为二进制数，如果每列的"1"的个数是偶数的话，则是平衡点；每列的"1"的个数不是偶数的话，就是非平衡点。<br>
</p>

<p>
操作一次后达到平衡点的玩家必赢，反之必输。<br>
</p>

<p>
在本局游戏中，如果先手玩家 \(A\) 从 \(9\) 堆里拿走 \(7\) 张牌，二进制表示就变为了：<br>
</p>

<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">\(2^3 = 8\)</th>
<th scope="col" class="org-right">\(2^2 = 4\)</th>
<th scope="col" class="org-right">\(2^1 = 2\)</th>
<th scope="col" class="org-right">\(2^0 = 1\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">5</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>

<p>
每列"1"的个数变为偶数，游戏状态变为平衡态，先手玩家 \(A\) 必赢。<br>
</p>

<p>
因为无论 \(B\) 怎么拿牌，一定不能使每列"1"的个数变为偶数，也就是说 \(B\) 一定会将游戏状态变为非平衡态。<br>
</p>

<p>
而无论 \(B\) 怎么拿牌，\(A\) 一定能重新使每列"1"的个数变为偶数，也就是说一次轮流操作中，\(B\) 一定会将游戏状态变为非平衡态；而 \(A\) 一定会将游戏状态重新变为平衡态，最终 \(B\) 将游戏变为非平衡态，而 \(A\) 终结游戏获得胜利。<br>
</p>

<hr>

<ul class="org-ul">
<li><p>
例如 \(A\) 已经从有 \(9\) 张牌的堆中取走 \(7\) 张牌，这时 \(B\) 有很多中选择，假设 \(B\) 从含有 \(5\) 张牌的堆中取走 \(5\) 张牌，游戏状态变为：<br>
</p>

<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">\(2^3 = 8\)</th>
<th scope="col" class="org-right">\(2^2 = 4\)</th>
<th scope="col" class="org-right">\(2^1 = 2\)</th>
<th scope="col" class="org-right">\(2^0 = 1\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">5</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>

<li><p>
这时 \(A\) 从含有 \(7\) 张牌的堆中取走 \(5\) 张，游戏状态变为：<br>
</p>

<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">\(2^3 = 8\)</th>
<th scope="col" class="org-right">\(2^2 = 4\)</th>
<th scope="col" class="org-right">\(2^1 = 2\)</th>
<th scope="col" class="org-right">\(2^0 = 1\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">5</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>

<li><p>
如果接下来 \(B\) 从 \(7\) 堆中选 \(1\) 张牌，为了使游戏状态变为平衡态，\(A\) 从 \(9\) 堆中取走 \(1\) 张牌，这时的游戏状态变为：<br>
</p>

<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">\(2^3 = 8\)</th>
<th scope="col" class="org-right">\(2^2 = 4\)</th>
<th scope="col" class="org-right">\(2^1 = 2\)</th>
<th scope="col" class="org-right">\(2^0 = 1\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">5</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table></li>

<li>容易发现这时 \(B\) 只有两种取法，都是必输的。<br></li>
</ul>
</div>
</div>
<div id="outline-container-orge57ee09" class="outline-3">
<h3 id="orge57ee09">推广到 n 堆牌</h3>
<div class="outline-text-3" id="text-orge57ee09">
<p>
推广到 \(n\) 堆牌，每堆中有 \(m_1, m_2, m_3 \dots m_n\) 张牌。<br>
</p>

<p>
如果 \(m_1 \oplus m_2 \oplus m_3 \oplus \dots \oplus m_n == 0\)，那么这是一个平衡点（先手必败），否则不是一个平衡点（先手必胜）。<br>
</p>
</div>
</div>
<div id="outline-container-org297ed18" class="outline-3">
<h3 id="org297ed18">判断胜者多少种胜法</h3>
<div class="outline-text-3" id="text-org297ed18">
<p>
除了知道谁会赢之外，如何判断必赢的人有多少种必胜的操作方案？<br>
</p>

<p>
令 \(nim\_xor = m_1 \oplus m_2 \oplus m_3 \oplus \dots \oplus m_n\)<br>
</p>

<p>
由上面直到如果 \(nim\_xor\) 不是 \(0\)，则先手的玩家必胜。<br>
</p>

<ul class="org-ul">
<li>定义 \(sum1 = nim \oplus m_1\) ，如果 \(sum1 <= m_1，res += sum1;\)<br></li>
<li>定义 \(sum2 = nim \oplus m_2\) ，如果 \(sum2 <= m_2，res += sum2;\)<br></li>
<li>\(\dots\)<br></li>
<li>定义 \(sumn = nim \oplus m_n\) ，如果 \(sumn <= m_n，res += sumn;\)<br></li>
</ul>

<p>
\(res\) 就是必赢的人有多少种必胜的操作方案。<br>
</p>
</div>
</div>
<div id="outline-container-org840f1a0" class="outline-3">
<h3 id="org840f1a0">证明一定有从非平衡态到平衡态的取法</h3>
<div class="outline-text-3" id="text-org840f1a0">
<p>
有 \(n\) 堆牌，每堆中有 \(m_1, m_2, m_3 \dots m_n\) 张牌，且现在为非平衡态。<br>
</p>

<p>
由于当前为非平衡态，那么 \(m_1 \oplus m_2 \oplus m_3 \oplus \dots \oplus m_n = x\ (x \neq 0)\)<br>
</p>

<p>
设 \(x\) 的二进制表示中最高一位 \(1\) 在第 \(k\) 位，\(m_1, m_2, \dots m_n\) 中必然存在一个 \(m_i\) 的第 \(k\) 位是 \(1\)。<br>
</p>

<p>
我们从 \(m_i\) 中取出 \(m_i - (m_i \oplus x)\) 张牌。由于 \(m_i\) 与 \(x\) 的第 \(k\) 位是 \(1\)，所以无论 \(m_i\) 二进制表示中其余位是什么，\(m_i \oplus x\) 的值一定小于 \(m_i\)，所以 \(m_i - (m_i \oplus x) < m_i\)，所以一定可以取出这个值。<br>
</p>

<p>
取出后这堆还有 \(m_i - (m_i - m_i \oplus x) = m_i \oplus x\) 张牌，原本 \(m_1 \oplus m_2 \oplus m_3 \oplus \dots \oplus m_n = x\ (x \neq 0)\)，\((m_1 \oplus m_2 \oplus m_3 \oplus \dots \oplus m_{i - 1} \oplus m_{i + 1} \dots \oplus m_n) \oplus m_i' = (x \oplus m_i) \oplus m_i' = (x \oplus m_i) \oplus (x \oplus m_i) = 0\)，一定有从非平衡态到平衡态的取法。<br>
</p>
</div>
</div>
<div id="outline-container-org9a070c6" class="outline-3">
<h3 id="org9a070c6">证明一定没有从平衡态到平衡态的取法</h3>
<div class="outline-text-3" id="text-org9a070c6">
<p>
有 \(n\) 堆牌，每堆中有 \(m_1, m_2, m_3 \dots m_n\) 张牌，且现在为平衡态。<br>
</p>

<p>
由于当前为平衡态，那么 \(m_1 \oplus m_2 \oplus m_3 \oplus \dots \oplus m_n = 0\)<br>
</p>

<p>
使用反证法，假设取走 \(m_i\) 一些牌之后仍有 \(m_1 \oplus m_2 \oplus m_3 \oplus \dots \oplus m_{i - 1} \oplus m_i' \oplus m_{i + 1} \dots \oplus m_n = 0\)<br>
</p>

<p>
则 \(m_1 \oplus m_2 \oplus m_3 \oplus \dots \oplus m_n = m_1 \oplus m_2 \oplus m_3 \oplus \dots \oplus m_{i - 1} \oplus m_i' \oplus m_{i + 1} \dots \oplus m_n\)<br>
</p>

<p>
\(\rightarrow m_i = m_i'\)，矛盾，得证。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-orgc848da8" class="outline-2">
<h2 id="orgc848da8">有向图游戏的和 Sprague-Grundy 函数</h2>
<div class="outline-text-2" id="text-orgc848da8">
</div>
<div id="outline-container-org4615b41" class="outline-3">
<h3 id="org4615b41">mex 运算</h3>
<div class="outline-text-3" id="text-org4615b41">
<p>
设 \(S\) 表示一个非负整数，定义 \(mex(S)\) 为求出不属于集合 \(S\) 的最小非负整数的运算，即：\(mex(S) = min(x)\ (x \in N \land x \notin S)\)<br>
</p>
</div>
</div>
<div id="outline-container-org797b512" class="outline-3">
<h3 id="org797b512">sg 函数</h3>
<div class="outline-text-3" id="text-org797b512">
<p>
定义一个 \(sg\) 函数，在一个有向图中，当前结点存储的值是指向的所有结点中未存在的最小非负整数。<br>
</p>

<p>
\(Sprague-Grundy Theorem\) 就是: \(g(G) = g(G1) \oplus g(G2) \oplus \dots \oplus g(Gn)\)，游戏的和的 \(SG\) 值就是它的所有子游戏的SG函数值的异或。<br>
</p>
</div>
</div>
<div id="outline-container-orgf8be066" class="outline-3">
<h3 id="orgf8be066">使用sg函数求解nim游戏</h3>
<div class="outline-text-3" id="text-orgf8be066">
<ol class="org-ol">
<li>求解每堆石子的 \(sg\) 值<br></li>
<li>求所有石子堆 \(sg\) 值的异或<br></li>
</ol>

<p>
\[sg(x1) \oplus sg(x2) \oplus sg(x3) \oplus ... \oplus sg(xn) != 0\ \ 先手必胜\\ sg(x1) \oplus sg(x2) \oplus sg(x3) \oplus ... \oplus sg(xn) != 0\ \ 先手必败\]<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org88b0b03" class="outline-2">
<h2 id="org88b0b03">Bash Game</h2>
<div class="outline-text-2" id="text-org88b0b03">
</div>
<div id="outline-container-orgaaf9935" class="outline-3">
<h3 id="orgaaf9935">游戏内容</h3>
<div class="outline-text-3" id="text-orgaaf9935">
<ul class="org-ul">
<li>两个玩家，\(23\) 张扑克牌<br></li>
<li>游戏双方轮流取牌<br></li>
<li>每人每次取牌仅限于取 \(1\) 张、\(2\) 张或 \(3\) 张<br></li>
<li>扑克牌取光，则游戏结束<br></li>
<li>最后取牌的一方为胜者<br></li>
</ul>

<p>
游戏双方 \(A\) 和 \(B\)，看似游戏输赢是随机的，但实则先手取牌的人必赢；后手取牌的人必输。<br>
</p>

<p>
假设先手取牌的人是 \(A\)，\(A\) 取 \(3\) 张牌后还剩 \(20\) 张牌，是 \(4\) 的倍数；\(B\) 无论取多少张牌，都会打破"\(4\) 的倍数"这一状态，假设取 \(m\) 张牌。<br>
</p>

<p>
这时 \(A\) 取 \((4 - m)\)张牌，就又会恢复到"\(4\) 的倍数"这一平衡的状态。<br>
</p>

<p>
这样当进行 \(8\) 次操作后，牌还剩 \(4\) 张，无论 \(B\) 取几张牌，\(A\) 都可以最后取牌得到胜利。<br>
</p>
</div>
</div>
<div id="outline-container-org652192b" class="outline-3">
<h3 id="org652192b">推广到 n 张牌</h3>
<div class="outline-text-3" id="text-org652192b">
<p>
推广到有 \(n\) 张牌，每次取牌的数量不超过 \(m\) 张<br>
</p>

<p>
有 \(n == k \times (m + 1) + r\)<br>
</p>
<ol class="org-ol">
<li>如果 \(r == 0\)，先手取牌的人会打破平衡态，必输<br></li>
<li>如果 \(r != 0\)，先手取牌的人取r张牌，达到平衡态，必赢<br></li>
</ol>

<p>
<b>N-positiong为胜利</b><br>
</p>

<p>
由此看来，\((m + 1) \times k\) 是必胜点，除了必胜点都是必败点；只要一方达到必胜点，也就达到平衡点，另一方的下一次操作就一定会打破这种平衡态，到达必输点。<br>
定义 \(P-position\) 和 \(N-position\)；\(P(previous)\)、\(N(next)\)，也就是操作一次达到必胜点的人的位置是 \(P-position\)，操作一次脱离必胜点的人的位置是 \(N-position\)。<br>
</p>
<ol class="org-ol">
<li>最终操作结束时的局面是 \(N-position\)<br></li>
<li>能够操作一次达到 \(N-position\) 的位置是 \(P-position\)<br></li>
<li>能够操作一次达到 \(P-position\) 的位置是 \(N-position\)<br></li>
</ol>
</div>
</div>
<div id="outline-container-org11c3055" class="outline-3">
<h3 id="org11c3055">限制取石子的数量</h3>
<div class="outline-text-3" id="text-org11c3055">
<p>
如果设置取石子的数量不是 \([1, m]\) 内的连续数字，而是只能在 \({a_1, a_2, \dots a_k}\)中选<br>
同样使用 \(P-position\) 与 \(N-position\)<br>
例如只能拿 \({1, 4}\) 数量的石头，<br>
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">x</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
<td class="org-right">5</td>
<td class="org-right">6</td>
<td class="org-right">7</td>
<td class="org-right">8</td>
<td class="org-right">9</td>
<td class="org-right">10</td>
<td class="org-right">11</td>
<td class="org-right">12</td>
<td class="org-right">13</td>
<td class="org-left">&#x2026;</td>
</tr>

<tr>
<td class="org-left">pos</td>
<td class="org-right">P</td>
<td class="org-right">N</td>
<td class="org-right">P</td>
<td class="org-right">N</td>
<td class="org-right">N</td>
<td class="org-right">P</td>
<td class="org-right">N</td>
<td class="org-right">P</td>
<td class="org-right">N</td>
<td class="org-right">N</td>
<td class="org-right">P</td>
<td class="org-right">N</td>
<td class="org-right">P</td>
<td class="org-right">N</td>
<td class="org-left">&#x2026;</td>
</tr>
</tbody>
</table>

<p>
发现有周期变化，而且计算过程符合动态规划的思想，可以使用动态规划完成。<br>
</p>
</div>
</div>
<div id="outline-container-org8f1f2b0" class="outline-3">
<h3 id="org8f1f2b0">继续推广到二维平面</h3>
<div class="outline-text-3" id="text-org8f1f2b0">
<p>
棋盘上有一枚棋子位置是 \((x, y)\)，棋盘的左上角位置是 \((0, 0)\)。<br>
这个棋子可以左移也可以上移，可以移动一格或者两格，直到有一方不能移动(棋子已经处于 \((0, 0)\) 的一方为输。<br>
打表发现 \(abs(x - y) % 3 == 0\) 时为必输点。<br>
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #009F9F;">#include</span> <span style="color: #FC9F4E;">&lt;cstdio&gt;</span>
<span style="color: #009F9F;">#include</span> <span style="color: #FC9F4E;">&lt;algorithm&gt;</span>
<span style="color: #BD93F9;">using</span> <span style="color: #BD93F9;">namespace</span> <span style="color: #009F9F;">std</span>;

<span style="color: #AFAFAF;">bool</span> <span style="color: #AFAFAF;">coord</span>[<span style="color: #009F9F;">100</span>][<span style="color: #009F9F;">100</span>] = {<span style="color: #009F9F;">false</span>};
<span style="color: #AFAFAF;">bool</span> <span style="color: #AFAFAF;">rem</span>[<span style="color: #009F9F;">100</span>][<span style="color: #009F9F;">100</span>] = {<span style="color: #009F9F;">false</span>};

<span style="color: #AFAFAF;">void</span> <span style="color: #AFAFAF;">buildCoord</span>(<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">x</span>, <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">y</span>) {
    <span style="color: #BD93F9;">if</span> (rem[x][y] == <span style="color: #009F9F;">true</span>)
        <span style="color: #BD93F9;">return</span> ;
    rem[x][y] = <span style="color: #009F9F;">true</span>;

    <span style="color: #BD93F9;">if</span> (x &gt; <span style="color: #009F9F;">30</span> + <span style="color: #009F9F;">1</span> || y &gt; <span style="color: #009F9F;">30</span> + <span style="color: #009F9F;">1</span>)
        <span style="color: #BD93F9;">return</span> ;

    coord[x + <span style="color: #009F9F;">1</span>][y] = <span style="color: #009F9F;">true</span>;
    coord[x + <span style="color: #009F9F;">2</span>][y] = <span style="color: #009F9F;">true</span>;
    coord[x][y + <span style="color: #009F9F;">1</span>] = <span style="color: #009F9F;">true</span>;
    coord[x][y + <span style="color: #009F9F;">2</span>] = <span style="color: #009F9F;">true</span>;
    buildCoord(x + <span style="color: #009F9F;">3</span>, y);
    buildCoord(x, y + <span style="color: #009F9F;">3</span>);
    buildCoord(x + <span style="color: #009F9F;">1</span>, y + <span style="color: #009F9F;">1</span>);
}

<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">main</span>() {
    buildCoord(<span style="color: #009F9F;">0</span>, <span style="color: #009F9F;">0</span>);
    <span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">i</span> = <span style="color: #009F9F;">0</span>; i &lt; <span style="color: #009F9F;">30</span>; i++) {
        <span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">j</span> = <span style="color: #009F9F;">0</span>; j &lt; <span style="color: #009F9F;">30</span>; j++) 
            printf(<span style="color: #FC9F4E;">"%d "</span>, coord[i][j]);
        printf(<span style="color: #FC9F4E;">"\n"</span>);
    }
    <span style="color: #BD93F9;">return</span> <span style="color: #009F9F;">0</span>;
}
</pre>
</div>

<pre class="example" id="org72b10c5">
0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1
1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1
1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0
0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1
1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1
1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0
0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1
1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1
1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0
0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1
1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1
1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0
0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1
1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1
1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0
0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1
1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1
1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0
0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1
1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1
1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0
0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1
1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1
1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0
</pre>
</div>
</div>
<div id="outline-container-org3897903" class="outline-3">
<h3 id="org3897903">一步两步</h3>
<div class="outline-text-3" id="text-org3897903">
<p>
棋盘一步两步问题<br>
</p>

<p>
<a href="https://ac.nowcoder.com/acm/contest/7412#question">牛客月赛28</a><br>
</p>

<p>
B 牛牛和牛可乐的赌约2<br>
</p>

<pre class="example" id="orgc33261f">
0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1
1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1
1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0
0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1
1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1
1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0
0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1
1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1
1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0
0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1
1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1
1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0
0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1
1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1
1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0
0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1
1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1
1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0
0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1
1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1
1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0
0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1
1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1
1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0
</pre>

<p>
观察得 <code>abs(x - y) % 3 == 0</code> 的点都是 \(0\)。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org60b2a2f" class="outline-2">
<h2 id="org60b2a2f">Wythoff Game</h2>
<div class="outline-text-2" id="text-org60b2a2f">
<p>
有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，规定最后取光者得胜。<br>
</p>

<img src="./images/wythoff.png" />

<p>
仔细分析，就能看出其差值为 \(0, 1, 2, 3, \dots n\);<br>
</p>

<p>
在分析一下规律，我们发现第一个值 = 差值 \(\times 1.618\)；<br>
</p>

<p>
而 \(1.618 = (sqrt(5)+ 1) / 2\) 是黄金分割率，而威佐夫博弈正好是 \(1.618\)，这就是博弈的奇妙之处！<br>
</p>
</div>

<div id="outline-container-org99cd0d5" class="outline-3">
<h3 id="org99cd0d5">威佐夫两类问题：</h3>
<div class="outline-text-3" id="text-org99cd0d5">
<ol class="org-ol">
<li>一个局面，求先手输赢。<br></li>
</ol>

<p>
有了上面的分析，那么这个问题应该不难解决。首先求出差值，差值 * p == 最小值 的话后手赢，否则先手赢(注意这里的p = (sqrt(5)+ 1) / 2)<br>
</p>

<ol class="org-ol">
<li>一个局面，求先手输赢，假设先手赢的话输出他第一次的取法<br></li>
</ol>

<p>
首先讨论在两边同时取的情况，很明显两边同时取的话，不论怎样取他的差值是不变的，那么我们可以根据差值计算出其中的小值，然后加上差值就是大的值<br>
</p>

<p>
能取的条件是求出的最小的值不能大于其中小的一堆的石子数目<br>
</p>

<p>
只在一堆中取的话，可以取任意一堆，那么其差值是不定的，所以我们枚举差值，差值范围是0 到 大的一堆石子数目，然后根据上面的理论判断满足条件的话就是一种合理的取法<br>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2021-10-15 Fri 21:08</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
