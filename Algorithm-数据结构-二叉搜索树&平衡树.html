<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-03-25 Fri 21:11 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>二叉搜索树</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran &lt;haoran.mc@outlook.com&gt;">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="static/MathJax/cdn.bootcdn.net/ajax/libs/mathjax/3.1.2/es5/tex-mml-chtml.min.js"></script>
</head>
<body>
<div id="content">
<h1 class="title">二叉搜索树</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org5499f41">树的概念</a>
<ul>
<li><a href="#org7323d0c">一般意义的树</a></li>
<li><a href="#org0c8983c">树的静态写法</a></li>
</ul>
</li>
<li><a href="#org6519925">二叉树</a>
<ul>
<li><a href="#orgad5af30">二叉树动态实现</a>
<ul>
<li><a href="#orgaf86350">两种特殊的二叉树</a></li>
<li><a href="#org71524c2">二叉树的基本操作</a></li>
<li><a href="#orged9c5fd">二叉树的遍历</a></li>
<li><a href="#orge90811b">重建二叉树</a></li>
</ul>
</li>
<li><a href="#orgfb3a38e">二叉树静态实现</a></li>
<li><a href="#orga6749fa">二叉树的遍历</a>
<ul>
<li><a href="#org95ab96e">先序遍历</a></li>
<li><a href="#org9dd6092">中序遍历</a></li>
<li><a href="#org3a7e04c">后序遍历</a></li>
<li><a href="#org0e53aea">层序遍历</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org380142f">树、森林和二叉树之间的转换</a>
<ul>
<li><a href="#org5b6fba7">树转换为二叉树</a></li>
<li><a href="#orgd4ee376">森林转换为二叉树</a></li>
<li><a href="#org855860f">二叉树转换为树</a></li>
<li><a href="#orgd600042">二叉树转换为森林</a></li>
</ul>
</li>
<li><a href="#org73d9b2e">树的双亲表示法、孩子表示法和孩子兄弟表示法</a>
<ul>
<li><a href="#org4d588be">双亲表示法</a></li>
<li><a href="#org0529a3c">孩子表示法</a></li>
<li><a href="#org98fa9c1">孩子兄弟表示法</a></li>
<li><a href="#orgb277835">森林和二叉树的相互转化</a></li>
</ul>
</li>
<li><a href="#org3b30ab3">二叉搜索树</a></li>
</ul>
</div>
</div>

<div id="outline-container-org5499f41" class="outline-2">
<h2 id="org5499f41">树的概念</h2>
<div class="outline-text-2" id="text-org5499f41">
<ol class="org-ol">
<li>没有结点的树是 <b>空树</b><br></li>
<li>树的 <b>层次</b> 从根结点开始算起，根结点为第一层，根结点子树的根结点为第二层<br></li>
<li>把结点的子树棵数称为   +结点的度  + ，树中结点的最大的度称为树的度(也称为树的宽度)<br></li>
<li>有n个结点的树，边数一定是n-1<br></li>
<li>叶子结点被定义为度为0的结点，当树中只有一个结点时(即根结点)，根结点也算作叶子节点<br></li>
<li><b>结点的深度</b><br></li>
<li><b>结点的高度</b><br></li>
<li>多棵树组合在一起称为森林，森林是若干棵树的集合<br></li>
</ol>
</div>
<div id="outline-container-org7323d0c" class="outline-3">
<h3 id="org7323d0c">一般意义的树</h3>
</div>
<div id="outline-container-org0c8983c" class="outline-3">
<h3 id="org0c8983c">树的静态写法</h3>
<div class="outline-text-3" id="text-org0c8983c">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #268bd2; font-weight: bold;">struct</span> <span style="color: #df005f; font-weight: bold;">Node</span> {
    <span style="color: #df005f; font-weight: bold;">int</span> <span style="color: #8787d7;">data</span>;
    <span style="color: #df005f; font-weight: bold;">vector</span>&lt;<span style="color: #df005f; font-weight: bold;">int</span>&gt; <span style="color: #8787d7;">child</span>;
} <span style="color: #8787d7;">node</span>[maxn];

<span style="color: #df005f; font-weight: bold;">int</span> <span style="color: #8787d7;">index</span> = 0;
<span style="color: #df005f; font-weight: bold;">int</span> <span style="color: #d75fd7; font-weight: bold;">newNode</span>(<span style="color: #df005f; font-weight: bold;">int</span> <span style="color: #8787d7;">value</span>) {
    node[index].data = value;
    node[index].child.clear();
    <span style="color: #268bd2; font-weight: bold;">return</span> index ++ ;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org6519925" class="outline-2">
<h2 id="org6519925">二叉树</h2>
<div class="outline-text-2" id="text-org6519925">
</div>
<div id="outline-container-orgad5af30" class="outline-3">
<h3 id="orgad5af30">二叉树动态实现</h3>
<div class="outline-text-3" id="text-orgad5af30">
</div>
<div id="outline-container-orgaf86350" class="outline-4">
<h4 id="orgaf86350">两种特殊的二叉树</h4>
<div class="outline-text-4" id="text-orgaf86350">
<ul class="org-ul">
<li>满二叉树<br>
<ul class="org-ul">
<li>每一层的结点个数都达到了当层能达到的最大结点数<br></li>
</ul></li>
<li>完全二叉树<br>
<ul class="org-ul">
<li>除了最下面一层之外，其余层的结点个数到达到了当层能达到的最大结点数，且最下面一层只从左至右连续存在若干个结点，而这些连续结点右边的结点全部不存在<br></li>
<li>对于完全二叉树当中的任何一个结点(设编号为x)，其左孩子的编号一定是2x，右孩子的编号一定是2x+1<br>
<ul class="org-ul">
<li>也就是说完全二叉树可以通过建立一个大小为2^k的数组来存储所有结点的信息，其中k为完全二叉树的最大高度，且1号位存放的一定是根结点<br></li>
<li>当然，如果不是完全二叉树，只需要设为结点上限个数加一即可<br></li>
</ul></li>
<li>判断某个结点是否为叶结点的标志：该结点(记下标为index)的左子结点的编号2+index大于结点个数n<br></li>
<li>判断某个结点是否为空结点的标志：该结点下标index大于结点个数n<br></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org71524c2" class="outline-4">
<h4 id="org71524c2">二叉树的基本操作</h4>
<div class="outline-text-4" id="text-org71524c2">
<ul class="org-ul">
<li>二叉树的创建<br></li>
<li>二叉树的查找与插入<br></li>
</ul>
</div>
</div>
<div id="outline-container-orged9c5fd" class="outline-4">
<h4 id="orged9c5fd">二叉树的遍历</h4>
<div class="outline-text-4" id="text-orged9c5fd">
<ul class="org-ul">
<li>先序遍历<br></li>
<li>中序遍历<br></li>
<li>后序遍历<br></li>
<li>层序遍历<br></li>
</ul>
</div>
</div>
<div id="outline-container-orge90811b" class="outline-4">
<h4 id="orge90811b">重建二叉树</h4>
<div class="outline-text-4" id="text-orge90811b">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #008787; background-color: #262626;">/*</span><span style="color: #008787; background-color: #262626;">&#24050;&#30693;&#20808;&#24207;&#24207;&#21015;&#19982;&#20013;&#24207;&#24207;&#21015;&#37325;&#24314;&#20108;&#21449;&#26641;</span><span style="color: #008787; background-color: #262626;">*/</span>
<span style="color: #df005f; font-weight: bold;">node</span>* <span style="color: #d75fd7; font-weight: bold;">rebuild</span>(<span style="color: #df005f; font-weight: bold;">int</span> <span style="color: #8787d7;">preLeft</span>, <span style="color: #df005f; font-weight: bold;">int</span> <span style="color: #8787d7;">preRight</span>, <span style="color: #df005f; font-weight: bold;">int</span> <span style="color: #8787d7;">inLeft</span>, <span style="color: #df005f; font-weight: bold;">int</span> <span style="color: #8787d7;">inRight</span>) {
    <span style="color: #268bd2; font-weight: bold;">if</span> (preLeft &gt; preRight)
        <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">NULL</span>;

    <span style="color: #df005f; font-weight: bold;">Node</span>* <span style="color: #8787d7;">nowRoot</span> = <span style="color: #268bd2; font-weight: bold;">new</span> <span style="color: #df005f; font-weight: bold;">node</span>;             <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#23384;&#25918;&#24403;&#21069;&#20108;&#21449;&#26641;&#30340;&#26681;&#32467;&#28857;</span>
    nowRoot -&gt; data = pre[preLeft];       <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#26032;&#32467;&#28857;&#25968;&#25454;&#22495;&#20026;&#26681;&#32467;&#28857;&#30340;&#20540;</span>
    <span style="color: #df005f; font-weight: bold;">int</span> <span style="color: #8787d7;">k</span>;
    <span style="color: #268bd2; font-weight: bold;">for</span> (k = inLeft; k &lt;= inRight; k++)
        <span style="color: #268bd2; font-weight: bold;">if</span> (in[k] == pre[preLeft])
            <span style="color: #268bd2; font-weight: bold;">break</span>;

    <span style="color: #df005f; font-weight: bold;">int</span> <span style="color: #8787d7;">numLeft</span> = k - inLeft;             <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#24038;&#23376;&#26641;&#30340;&#32467;&#28857;&#20010;&#25968;&#65292;&#19981;&#19968;&#23450;&#31561;&#20110;&#21491;&#23376;&#26641;&#32467;&#28857;&#20010;&#25968;</span>

    <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#24038;&#23376;&#26641;&#30340;&#20808;&#24207;&#21306;&#38388;&#20026;[preLeft + 1, preLeft + numLeft]&#65292;&#20013;&#24207;&#21306;&#38388;&#20026;[inLeft, k - 1]</span>
    <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#36820;&#22238;&#24038;&#23376;&#26641;&#30340;&#26681;&#32467;&#28857;&#22320;&#22336;&#65292;&#36171;&#20540;&#32473;nowRoot&#30340;&#24038;&#25351;&#38024;</span>
    nowRoot -&gt; left = rebuild(preLeft + 1, preLeft + numleft, inLeft, k - 1);

    <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#21491;&#23376;&#26641;&#30340;&#20808;&#24207;&#21306;&#38388;&#20026;[preLeft + numLeft + 1, preRight]&#65292;&#20013;&#24207;&#21306;&#38388;&#20026;[k + 1, inRight]</span>
    <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#36820;&#22238;&#21491;&#23376;&#26641;&#30340;&#26681;&#32467;&#28857;&#22320;&#22336;&#65292;&#36171;&#20540;&#32473;nowRoot&#30340;&#21491;&#25351;&#38024;</span>
    nowRoot -&gt; right = rebuild(preLeft + numLeft + 1, preRight, k + 1, inRight);

    <span style="color: #268bd2; font-weight: bold;">return</span> nowRoot;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgfb3a38e" class="outline-3">
<h3 id="orgfb3a38e">二叉树静态实现</h3>
</div>
<div id="outline-container-orga6749fa" class="outline-3">
<h3 id="orga6749fa">二叉树的遍历</h3>
<div class="outline-text-3" id="text-orga6749fa">
</div>
<div id="outline-container-org95ab96e" class="outline-4">
<h4 id="org95ab96e">先序遍历</h4>
</div>
<div id="outline-container-org9dd6092" class="outline-4">
<h4 id="org9dd6092">中序遍历</h4>
</div>
<div id="outline-container-org3a7e04c" class="outline-4">
<h4 id="org3a7e04c">后序遍历</h4>
</div>
<div id="outline-container-org0e53aea" class="outline-4">
<h4 id="org0e53aea">层序遍历</h4>
</div>
</div>
</div>
<div id="outline-container-org380142f" class="outline-2">
<h2 id="org380142f">树、森林和二叉树之间的转换</h2>
<div class="outline-text-2" id="text-org380142f">
</div>
<div id="outline-container-org5b6fba7" class="outline-3">
<h3 id="org5b6fba7">树转换为二叉树</h3>
<div class="outline-text-3" id="text-org5b6fba7">
<ol class="org-ol">
<li>加线，在所有兄弟结点之间加一条连线。<br></li>
<li>去线，树中的每个结点，只保留它与第一个孩子结点的连线，删除它与其它孩子结点之间的连线。<br></li>
<li>层次调整，以树的根节点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明。（注意第一个孩子是结点的左孩子，兄弟转换过来的孩子是结点的右孩子）<br></li>
</ol>

<img src="./images/树转换为二叉树.webp" />
</div>
</div>
<div id="outline-container-orgd4ee376" class="outline-3">
<h3 id="orgd4ee376">森林转换为二叉树</h3>
<div class="outline-text-3" id="text-orgd4ee376">
<ol class="org-ol">
<li>把每棵树转换为二叉树<br></li>
<li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来<br></li>
</ol>

<img src="./images/森林转换为二叉树.webp" />
</div>
</div>
<div id="outline-container-org855860f" class="outline-3">
<h3 id="org855860f">二叉树转换为树</h3>
<div class="outline-text-3" id="text-org855860f">
<p>
是树转换为二叉树的逆过程。<br>
</p>

<ol class="org-ol">
<li>加线，若某结点X的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点…，都作为结点X的孩子。将结点X与这些右孩子结点用线连接起来。<br></li>
<li>去线，删除原二叉树中所有结点与其右孩子结点的连线。<br></li>
<li>层次调整。<br></li>
</ol>

<img src="./images/二叉树转换为树.webp" />
</div>
</div>
<div id="outline-container-orgd600042" class="outline-3">
<h3 id="orgd600042">二叉树转换为森林</h3>
<div class="outline-text-3" id="text-orgd600042">
<p>
假如一棵二叉树的根节点有右孩子，则这棵二叉树能够转换为森林，否则将转换为一棵树。<br>
</p>

<ol class="org-ol">
<li>从根节点开始，若右孩子存在，则把与右孩子结点的连线删除。再查看分离后的二叉树，若其根节点的右孩子存在，则连线删除&#x2026;&#x2026;直到所有这些根节点与右孩子的连线都删除为止。<br></li>
<li>将每棵分离后的二叉树转换为树。<br></li>
</ol>

<img src="./images/二叉树转换为森林.webp" />
</div>
</div>
</div>
<div id="outline-container-org73d9b2e" class="outline-2">
<h2 id="org73d9b2e">树的双亲表示法、孩子表示法和孩子兄弟表示法</h2>
<div class="outline-text-2" id="text-org73d9b2e">
</div>
<div id="outline-container-org4d588be" class="outline-3">
<h3 id="org4d588be">双亲表示法</h3>
<div class="outline-text-3" id="text-org4d588be">
<p>
取一块连续的内存空间，在存储每个结点的同时，各自都附加一个记录其父结点位置的变量。<br>
</p>

<p>
在树结构中，除了树根外，每个结点都只有一个父结点（又叫“双亲结点”）。<br>
</p>

<p>
代码表示：<br>
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #d75fd7;">#define</span> <span style="color: #8787d7;">tree_size</span> 100<span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#23439;&#23450;&#20041;&#26641;&#20013;&#32467;&#28857;&#30340;&#26368;&#22823;&#25968;&#37327;</span>
<span style="color: #d75fd7;">#define</span> <span style="color: #8787d7;">TElemType</span> <span style="color: #df005f; font-weight: bold;">int</span><span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#23439;&#23450;&#20041;&#26641;&#32467;&#26500;&#20013;&#25968;&#25454;&#31867;&#22411;</span>
<span style="color: #268bd2; font-weight: bold;">typedef</span> <span style="color: #268bd2; font-weight: bold;">struct</span> <span style="color: #df005f; font-weight: bold;">PTNode</span>{
    <span style="color: #df005f; font-weight: bold;">TElemType</span> <span style="color: #8787d7;">data</span>;<span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#26641;&#20013;&#32467;&#28857;&#30340;&#25968;&#25454;&#31867;&#22411;</span>
    <span style="color: #df005f; font-weight: bold;">int</span> <span style="color: #8787d7;">parent</span>;<span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#32467;&#28857;&#30340;&#29238;&#32467;&#28857;&#22312;&#25968;&#32452;&#20013;&#30340;&#20301;&#32622;&#19979;&#26631;</span>
}<span style="color: #df005f; font-weight: bold;">PTNode</span>;
<span style="color: #268bd2; font-weight: bold;">typedef</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    <span style="color: #df005f; font-weight: bold;">PTNode</span> <span style="color: #8787d7;">nodes</span>[tree_size];<span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#23384;&#25918;&#26641;&#20013;&#25152;&#26377;&#32467;&#28857;</span>
    <span style="color: #df005f; font-weight: bold;">int</span> <span style="color: #8787d7;">r</span>,<span style="color: #8787d7;">n</span>;<span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#26681;&#30340;&#20301;&#32622;&#19979;&#26631;&#21644;&#32467;&#28857;&#25968;</span>
}<span style="color: #df005f; font-weight: bold;">PTree</span>;
</pre>
</div>

<p>
例如，使用双亲表示法存储图 1（A）中的树结构时，数组存储结果为（B）：<br>
</p>

<img src="./images/树的双亲表示法.png" style="padding: 10px" />
</div>
</div>
<div id="outline-container-org0529a3c" class="outline-3">
<h3 id="org0529a3c">孩子表示法</h3>
<div class="outline-text-3" id="text-org0529a3c">
<p>
将树中的每个结点的孩子结点排列成一个线性表，用链表存储起来。对于含有 n 个结点的树来说，就会有 n 个单链表，将 n 个单链表的头指针存储在一个线性表中，这样的表示方法就是孩子表示法。<br>
如果结点没有孩子（例如叶子结点），那么它的单链表为空表。<br>
</p>

<p>
代码表示：<br>
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #d75fd7;">#define</span> <span style="color: #8787d7;">TElemType</span> <span style="color: #df005f; font-weight: bold;">int</span>
<span style="color: #d75fd7;">#define</span> <span style="color: #8787d7;">Tree_Size</span> 100
<span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#23401;&#23376;&#34920;&#31034;&#27861;</span>
<span style="color: #268bd2; font-weight: bold;">typedef</span> <span style="color: #268bd2; font-weight: bold;">struct</span> <span style="color: #df005f; font-weight: bold;">CTNode</span>{
    <span style="color: #df005f; font-weight: bold;">int</span> <span style="color: #8787d7;">child</span>;<span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#38142;&#34920;&#20013;&#27599;&#20010;&#32467;&#28857;&#23384;&#20648;&#30340;&#19981;&#26159;&#25968;&#25454;&#26412;&#36523;&#65292;&#32780;&#26159;&#25968;&#25454;&#22312;&#25968;&#32452;&#20013;&#23384;&#20648;&#30340;&#20301;&#32622;&#19979;&#26631;</span>
    <span style="color: #268bd2; font-weight: bold;">struct</span> <span style="color: #df005f; font-weight: bold;">CTNode</span> * <span style="color: #8787d7;">next</span>;
}*<span style="color: #df005f; font-weight: bold;">ChildPtr</span>;
<span style="color: #268bd2; font-weight: bold;">typedef</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    <span style="color: #df005f; font-weight: bold;">TElemType</span> <span style="color: #8787d7;">data</span>;<span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#32467;&#28857;&#30340;&#25968;&#25454;&#31867;&#22411;</span>
    <span style="color: #df005f; font-weight: bold;">ChildPtr</span> <span style="color: #8787d7;">firstchild</span>;<span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#23401;&#23376;&#38142;&#34920;&#30340;&#22836;&#25351;&#38024;</span>
}<span style="color: #df005f; font-weight: bold;">CTBox</span>;
<span style="color: #268bd2; font-weight: bold;">typedef</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{
    <span style="color: #df005f; font-weight: bold;">CTBox</span> <span style="color: #8787d7;">nodes</span>[Tree_Size];<span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#23384;&#20648;&#32467;&#28857;&#30340;&#25968;&#32452;</span>
    <span style="color: #df005f; font-weight: bold;">int</span> <span style="color: #8787d7;">n</span>,<span style="color: #8787d7;">r</span>;<span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#32467;&#28857;&#25968;&#37327;&#21644;&#26641;&#26681;&#30340;&#20301;&#32622;</span>
}<span style="color: #df005f; font-weight: bold;">CTree</span>;
</pre>
</div>

<p>
例如，使用孩子表示法存储图 1 （A），存储效果如图 2：<br>
</p>

<img src="./images/孩子表示法.png" style="padding: 10px" />

<p>
使用孩子表示法存储的树结构，正好和双亲表示法相反，适用于查找某结点的孩子结点，不适用于查找其父结点。可以将两种表示方法合二为一，存储效果如图 3：<br>
</p>

<img src="./images/孩子双亲表示法.png" style="padding: 10px" />
</div>
</div>
<div id="outline-container-org98fa9c1" class="outline-3">
<h3 id="org98fa9c1">孩子兄弟表示法</h3>
<div class="outline-text-3" id="text-org98fa9c1">
<p>
使用链式存储结构存储普通树。链表中每个结点由 3 部分组成：<br>
</p>

<img src="./images/孩子兄弟表示法结点的组成.png" style="padding: 10px" />

<p>
其中孩子指针域，表示指向当前结点的第一个孩子结点，兄弟结点表示指向当前结点的下一个兄弟结点。<br>
</p>

<p>
代码表示：<br>
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #d75fd7;">#define</span> <span style="color: #8787d7;">ElemType</span> <span style="color: #df005f; font-weight: bold;">int</span>
<span style="color: #268bd2; font-weight: bold;">typedef</span> <span style="color: #268bd2; font-weight: bold;">struct</span> <span style="color: #df005f; font-weight: bold;">CSNode</span>{
    <span style="color: #df005f; font-weight: bold;">ElemType</span> <span style="color: #8787d7;">data</span>;
    <span style="color: #268bd2; font-weight: bold;">struct</span> <span style="color: #df005f; font-weight: bold;">CSNode</span> * <span style="color: #8787d7;">firstchild</span>,*<span style="color: #8787d7;">nextsibling</span>;
} <span style="color: #df005f; font-weight: bold;">CSNode</span>, *<span style="color: #df005f; font-weight: bold;">CSTree</span>;
</pre>
</div>

<p>
通过孩子兄弟表示法，普通树转化为了二叉树，所以孩子兄弟表示法又被称为“二叉树表示法”或者“二叉链表表示法”。<br>
</p>

<p>
例如，用孩子兄弟表示法表示图 1 （A）的普通树，存储结果为：<br>
</p>

<img src="./images/孩子兄弟表示法.png" style="padding: 10px" />
</div>
</div>
<div id="outline-container-orgb277835" class="outline-3">
<h3 id="orgb277835">森林和二叉树的相互转化</h3>
<div class="outline-text-3" id="text-orgb277835">
<p>
通过孩子兄弟表示法的学习，对于任意一棵树，都可以找到唯一的一棵二叉树与之对应。<br>
普通树转化成的二叉树，其根结点都没有右孩子，即普通树对应的二叉树肯定没有右子树。<br>
</p>

<p>
而森林是由多棵树组成，为了便于对森林的遍历等操作，需要将森林中的所有树都组合成一颗大的二叉树，转化步骤为：<br>
首先将森林中树各自转化为二叉树；<br>
森林中第一棵二叉树的树根作为转化后二叉树的树根；<br>
其他树的树根作为第一棵树树根的兄弟结点，进行连接；<br>
</p>

<img src="./images/森林转化为二叉树.png" style="padding: 10px" />

<p>
图 6 森林转化成二叉树<br>
</p>

<p>
如图 6 所示，（A）中由三棵普通树组成的森林，首先三棵普通树采用孩子兄弟表示法各自转化成二叉树，如（B）所示；然后由（B）转（C）时，将森林中第一棵树的树根作为转化后的整棵二叉树的树根，其他数的树根作为第一棵树的树根的兄弟结点，如（C）所示。<br>
</p>

<p>
转化成二叉树的森林，做的最多的操作就是查找树中的结点。在遍历转化后的二叉树时，遍历方式有先序遍历、中序遍历和后序遍历。<br>
对森林使用先序和中序遍历的结果和对转化后的二叉树使用先序和中序遍历得到的序列是一样的，而使用后序遍历得到的结果不同。例如图 6（B）中森林采用中序遍历和（C）中二叉树采用中序遍历得到的结果是相同的，遍历序列都为：B C D A F E H J I G。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org3b30ab3" class="outline-2">
<h2 id="org3b30ab3">二叉搜索树</h2>
<div class="outline-text-2" id="text-org3b30ab3">
<p>
每个结点都有一个权值。<br>
</p>

<ul class="org-ul">
<li>当前结点的左子树中的任何一个结点的权值都是 &lt; 当前结点的权值<br></li>
<li>当前结点的右子树中的任何一个结点的权值都是 &gt; 当前结点的权值<br></li>
</ul>

<p>
为了使树上存在相同权值的结点，就在每个结点记录一个 \(cnt\)。<br>
</p>

<img src="./images/二叉搜索树01.png" />

<p>
二叉搜索树的中序遍历的权值是从小到大的，二叉搜索树也就是动态维护一个有序序列。<br>
</p>
</div>
</div>
</div>
</body>
</html>
