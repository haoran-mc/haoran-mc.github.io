<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-11-18 Thu 13:13 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>二叉搜索树</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran &lt;haoran.mc@outlook.com&gt;">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">二叉搜索树</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb5c86fb">树的概念</a>
<ul>
<li><a href="#orgb73ff59">一般意义的树</a></li>
<li><a href="#org5a42b35">树的静态写法</a></li>
</ul>
</li>
<li><a href="#org0250988">二叉树</a>
<ul>
<li><a href="#org4a82706">二叉树动态实现</a>
<ul>
<li><a href="#orgae3305e">两种特殊的二叉树</a></li>
<li><a href="#org2c50db7">二叉树的基本操作</a></li>
<li><a href="#org40729ed">二叉树的遍历</a></li>
<li><a href="#org695e261">重建二叉树</a></li>
</ul>
</li>
<li><a href="#orgc8f7876">二叉树静态实现</a></li>
<li><a href="#org90b8cca">二叉树的遍历</a>
<ul>
<li><a href="#org4ad3a52">先序遍历</a></li>
<li><a href="#org7416951">中序遍历</a></li>
<li><a href="#orgb68f7c4">后序遍历</a></li>
<li><a href="#org68c5d83">层序遍历</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9e0d29b">二叉搜索树</a></li>
<li><a href="#org4aa67d9">插入</a></li>
<li><a href="#org47a6d6b">删除</a></li>
<li><a href="#orgeca68b3">找前驱后继</a></li>
<li><a href="#org455848a">找最大最小值</a></li>
<li><a href="#org38b773e">求某个值的排名</a></li>
<li><a href="#org8657776">求排名是k的数是哪个</a></li>
<li><a href="#org0199946">比某个数大的最小值</a></li>
<li><a href="#org32c36cb">比某个数小的最大值</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgb5c86fb" class="outline-2">
<h2 id="orgb5c86fb">树的概念</h2>
<div class="outline-text-2" id="text-orgb5c86fb">
<ol class="org-ol">
<li>没有结点的树是 <b>空树</b><br></li>
<li>树的 <b>层次</b> 从根结点开始算起，根结点为第一层，根结点子树的根结点为第二层<br></li>
<li>把结点的子树棵数称为   +结点的度  + ，树中结点的最大的度称为树的度(也称为树的宽度)<br></li>
<li>有n个结点的树，边数一定是n-1<br></li>
<li>叶子结点被定义为度为0的结点，当树中只有一个结点时(即根结点)，根结点也算作叶子节点<br></li>
<li><b>结点的深度</b><br></li>
<li><b>结点的高度</b><br></li>
<li>多棵树组合在一起称为森林，森林是若干棵树的集合<br></li>
</ol>
</div>
<div id="outline-container-orgb73ff59" class="outline-3">
<h3 id="orgb73ff59">一般意义的树</h3>
</div>
<div id="outline-container-org5a42b35" class="outline-3">
<h3 id="org5a42b35">树的静态写法</h3>
<div class="outline-text-3" id="text-org5a42b35">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #BD93F9;">struct</span> <span style="color: #AFAFAF;">Node</span> {
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">data</span>;
    <span style="color: #AFAFAF;">vector</span>&lt;<span style="color: #AFAFAF;">int</span>&gt; <span style="color: #AFAFAF;">child</span>;
}<span style="color: #AFAFAF;">node</span>[maxn];

<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">index</span> = <span style="color: #009F9F;">0</span>;
<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">newNode</span>(<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">value</span>) {
    node[index].data = value;
    node[index].child.clear();
    <span style="color: #BD93F9;">return</span> index++;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org0250988" class="outline-2">
<h2 id="org0250988">二叉树</h2>
<div class="outline-text-2" id="text-org0250988">
</div>
<div id="outline-container-org4a82706" class="outline-3">
<h3 id="org4a82706">二叉树动态实现</h3>
<div class="outline-text-3" id="text-org4a82706">
</div>
<div id="outline-container-orgae3305e" class="outline-4">
<h4 id="orgae3305e">两种特殊的二叉树</h4>
<div class="outline-text-4" id="text-orgae3305e">
<ul class="org-ul">
<li>满二叉树<br>
<ul class="org-ul">
<li>每一层的结点个数都达到了当层能达到的最大结点数<br></li>
</ul></li>
<li>完全二叉树<br>
<ul class="org-ul">
<li>除了最下面一层之外，其余层的结点个数到达到了当层能达到的最大结点数，且最下面一层只从左至右连续存在若干个结点，而这些连续结点右边的结点全部不存在<br></li>
<li>对于完全二叉树当中的任何一个结点(设编号为x)，其左孩子的编号一定是2x，右孩子的编号一定是2x+1<br>
<ul class="org-ul">
<li>也就是说完全二叉树可以通过建立一个大小为2^k的数组来存储所有结点的信息，其中k为完全二叉树的最大高度，且1号位存放的一定是根结点<br></li>
<li>当然，如果不是完全二叉树，只需要设为结点上限个数加一即可<br></li>
</ul></li>
<li>判断某个结点是否为叶结点的标志：该结点(记下标为index)的左子结点的编号2+index大于结点个数n<br></li>
<li>判断某个结点是否为空结点的标志：该结点下标index大于结点个数n<br></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org2c50db7" class="outline-4">
<h4 id="org2c50db7">二叉树的基本操作</h4>
<div class="outline-text-4" id="text-org2c50db7">
<ul class="org-ul">
<li>二叉树的创建<br></li>
<li>二叉树的查找与插入<br></li>
</ul>
</div>
</div>
<div id="outline-container-org40729ed" class="outline-4">
<h4 id="org40729ed">二叉树的遍历</h4>
<div class="outline-text-4" id="text-org40729ed">
<ul class="org-ul">
<li>先序遍历<br></li>
<li>中序遍历<br></li>
<li>后序遍历<br></li>
<li>层序遍历<br></li>
</ul>
</div>
</div>
<div id="outline-container-org695e261" class="outline-4">
<h4 id="org695e261">重建二叉树</h4>
<div class="outline-text-4" id="text-org695e261">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #7c7c7c; font-style: italic;">/*</span><span style="color: #7c7c7c; font-style: italic;">&#24050;&#30693;&#20808;&#24207;&#24207;&#21015;&#19982;&#20013;&#24207;&#24207;&#21015;&#37325;&#24314;&#20108;&#21449;&#26641;</span><span style="color: #7c7c7c; font-style: italic;">*/</span>
<span style="color: #AFAFAF;">node</span>* <span style="color: #AFAFAF;">rebuild</span>(<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">preLeft</span>, <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">preRight</span>, <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">inLeft</span>, <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">inRight</span>) {
    <span style="color: #BD93F9;">if</span> (preLeft &gt; preRight)
        <span style="color: #BD93F9;">return</span> <span style="color: #009F9F;">NULL</span>;

    <span style="color: #AFAFAF;">Node</span>* <span style="color: #AFAFAF;">nowRoot</span> = <span style="color: #BD93F9;">new</span> <span style="color: #AFAFAF;">node</span>;             <span style="color: #7c7c7c; font-style: italic;">//</span><span style="color: #7c7c7c; font-style: italic;">&#23384;&#25918;&#24403;&#21069;&#20108;&#21449;&#26641;&#30340;&#26681;&#32467;&#28857;</span>
    nowRoot -&gt; data = pre[preLeft];       <span style="color: #7c7c7c; font-style: italic;">//</span><span style="color: #7c7c7c; font-style: italic;">&#26032;&#32467;&#28857;&#25968;&#25454;&#22495;&#20026;&#26681;&#32467;&#28857;&#30340;&#20540;</span>
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">k</span>;
    <span style="color: #BD93F9;">for</span> (k = inLeft; k &lt;= inRight; k++)
        <span style="color: #BD93F9;">if</span> (in[k] == pre[preLeft])
            <span style="color: #BD93F9;">break</span>;

    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">numLeft</span> = k - inLeft;             <span style="color: #7c7c7c; font-style: italic;">//</span><span style="color: #7c7c7c; font-style: italic;">&#24038;&#23376;&#26641;&#30340;&#32467;&#28857;&#20010;&#25968;&#65292;&#19981;&#19968;&#23450;&#31561;&#20110;&#21491;&#23376;&#26641;&#32467;&#28857;&#20010;&#25968;</span>

    <span style="color: #7c7c7c; font-style: italic;">//</span><span style="color: #7c7c7c; font-style: italic;">&#24038;&#23376;&#26641;&#30340;&#20808;&#24207;&#21306;&#38388;&#20026;[preLeft + 1, preLeft + numLeft]&#65292;&#20013;&#24207;&#21306;&#38388;&#20026;[inLeft, k - 1]</span>
    <span style="color: #7c7c7c; font-style: italic;">//</span><span style="color: #7c7c7c; font-style: italic;">&#36820;&#22238;&#24038;&#23376;&#26641;&#30340;&#26681;&#32467;&#28857;&#22320;&#22336;&#65292;&#36171;&#20540;&#32473;nowRoot&#30340;&#24038;&#25351;&#38024;</span>
    nowRoot -&gt; left = rebuild(preLeft + <span style="color: #009F9F;">1</span>, preLeft + numleft, inLeft, k - <span style="color: #009F9F;">1</span>);

    <span style="color: #7c7c7c; font-style: italic;">//</span><span style="color: #7c7c7c; font-style: italic;">&#21491;&#23376;&#26641;&#30340;&#20808;&#24207;&#21306;&#38388;&#20026;[preLeft + numLeft + 1, preRight]&#65292;&#20013;&#24207;&#21306;&#38388;&#20026;[k + 1, inRight]</span>
    <span style="color: #7c7c7c; font-style: italic;">//</span><span style="color: #7c7c7c; font-style: italic;">&#36820;&#22238;&#21491;&#23376;&#26641;&#30340;&#26681;&#32467;&#28857;&#22320;&#22336;&#65292;&#36171;&#20540;&#32473;nowRoot&#30340;&#21491;&#25351;&#38024;</span>
    nowRoot -&gt; right = rebuild(preLeft + numLeft + <span style="color: #009F9F;">1</span>, preRight, k + <span style="color: #009F9F;">1</span>, inRight);

    <span style="color: #BD93F9;">return</span> nowRoot;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc8f7876" class="outline-3">
<h3 id="orgc8f7876">二叉树静态实现</h3>
</div>
<div id="outline-container-org90b8cca" class="outline-3">
<h3 id="org90b8cca">二叉树的遍历</h3>
<div class="outline-text-3" id="text-org90b8cca">
</div>
<div id="outline-container-org4ad3a52" class="outline-4">
<h4 id="org4ad3a52">先序遍历</h4>
</div>
<div id="outline-container-org7416951" class="outline-4">
<h4 id="org7416951">中序遍历</h4>
</div>
<div id="outline-container-orgb68f7c4" class="outline-4">
<h4 id="orgb68f7c4">后序遍历</h4>
</div>
<div id="outline-container-org68c5d83" class="outline-4">
<h4 id="org68c5d83">层序遍历</h4>
</div>
</div>
</div>
<div id="outline-container-org9e0d29b" class="outline-2">
<h2 id="org9e0d29b">二叉搜索树</h2>
<div class="outline-text-2" id="text-org9e0d29b">
<p>
每个结点都有一个权值。<br>
</p>

<ul class="org-ul">
<li>当前结点的左子树中的任何一个结点的权值都是 &lt; 当前结点的权值<br></li>
<li>当前结点的右子树中的任何一个结点的权值都是 &gt; 当前结点的权值<br></li>
</ul>

<p>
为了使树上存在相同权值的结点，就在每个结点记录一个 \(cnt\)。<br>
</p>

<img src="./images/二叉搜索树01.png" />

<p>
二叉搜索树的中序遍历的权值是从小到大的，二叉搜索树也就是动态维护一个有序序列。<br>
</p>
</div>
</div>
<div id="outline-container-org4aa67d9" class="outline-2">
<h2 id="org4aa67d9">插入</h2>
</div>
<div id="outline-container-org47a6d6b" class="outline-2">
<h2 id="org47a6d6b">删除</h2>
</div>
<div id="outline-container-orgeca68b3" class="outline-2">
<h2 id="orgeca68b3">找前驱后继</h2>
<div class="outline-text-2" id="text-orgeca68b3">
<p>
线索二叉树<br>
</p>
</div>
</div>
<div id="outline-container-org455848a" class="outline-2">
<h2 id="org455848a">找最大最小值</h2>
<div class="outline-text-2" id="text-org455848a">
</div>
</div>
<div id="outline-container-org38b773e" class="outline-2">
<h2 id="org38b773e">求某个值的排名</h2>
</div>
<div id="outline-container-org8657776" class="outline-2">
<h2 id="org8657776">求排名是k的数是哪个</h2>
</div>
<div id="outline-container-org0199946" class="outline-2">
<h2 id="org0199946">比某个数大的最小值</h2>
</div>
<div id="outline-container-org32c36cb" class="outline-2">
<h2 id="org32c36cb">比某个数小的最大值</h2>
</div>
</div>
</body>
</html>
