<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-10-19 Tue 20:19 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>单调队列</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran &lt;haoran.mc@outlook.com&gt;">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">单调队列</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgf6c221a">例题 Sliding Window</a></li>
<li><a href="#org70461e4">AC 代码</a></li>
<li><a href="#orga464997">最大连续子序列和</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgf6c221a" class="outline-2">
<h2 id="orgf6c221a">例题 Sliding Window</h2>
<div class="outline-text-2" id="text-orgf6c221a">
<p>
<a href="http://poj.org/problem?id=2823">题目在这</a><br>
</p>

<p>
一道经典的单调队列题目，本题大意是给出一个长度为 \(n\) 的数组，编程输出每 \(k\) 个连续的数中的最大值和最小值。<br>
</p>

<p>
朴素做法是对每一段 \(i \sim i + k - 1\) 的序列，逐个比较找出最大值（和最小值），时间复杂度是 \(O(n \times k)\)，时间复杂度太高。<br>
</p>

<p>
单调队列：题目求 \(k\) 个连续的数的最大（小）值，用求最大值为例：当一个数进入要查询的范围时，如果这个数比先进队的数要大，显然，前面的数对于后面的窗口而言不再可能是最大值，就把前面较小的数都弹出，然后再将当前数放入队列。<br>
</p>

<p>
所以队列中始终都是单调递增的。<br>
</p>
</div>
</div>
<div id="outline-container-org70461e4" class="outline-2">
<h2 id="org70461e4">AC 代码</h2>
<div class="outline-text-2" id="text-org70461e4">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #009F9F;">#include</span> <span style="color: #FC9F4E;">&lt;cstdio&gt;</span>
<span style="color: #BD93F9;">const</span> <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">maxn</span> = <span style="color: #009F9F;">1e6</span> + <span style="color: #009F9F;">5</span>;
<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">n</span>, <span style="color: #AFAFAF;">k</span>;
<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">a</span>[maxn];
<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">q</span>[maxn];
<span style="color: #009F9F;">#define</span> <span style="color: #AFAFAF;">NEXTLINE</span> puts(<span style="color: #FC9F4E;">""</span>);

<span style="color: #AFAFAF;">void</span> <span style="color: #AFAFAF;">get_mins</span>() {
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">hh</span> = <span style="color: #009F9F;">0</span>, <span style="color: #AFAFAF;">tt</span> = -<span style="color: #009F9F;">1</span>;
    <span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">i</span> = <span style="color: #009F9F;">0</span>; i &lt; n; ++ i) {
        <span style="color: #BD93F9;">if</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span style="color: #009F9F;">1</span>)   <span style="color: #7c7c7c; font-style: italic;">// </span><span style="color: #7c7c7c; font-style: italic;">&#36229;&#20986;&#31383;&#21475;&#33539;&#22260;</span>
            hh ++ ;
        <span style="color: #7c7c7c; font-style: italic;">// </span><span style="color: #7c7c7c; font-style: italic;">&#38431;&#21015;&#20013;&#19968;&#23450;&#26159;&#21333;&#35843;&#36882;&#22686;&#30340;&#65292;&#21069;&#38754;&#30340;&#27604;&#21518;&#38754;&#22823;&#65292;&#37027;&#23601;&#20250;&#21024;&#21435;&#21069;&#38754;&#30340;</span>
        <span style="color: #BD93F9;">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i])
            tt -- ;
        q[ ++ tt] = i;
        <span style="color: #BD93F9;">if</span> (i &gt;= k - <span style="color: #009F9F;">1</span>)
            printf(<span style="color: #FC9F4E;">"%d "</span>, a[q[hh]]);
    }
}

<span style="color: #AFAFAF;">void</span> <span style="color: #AFAFAF;">get_maxs</span>() {
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">hh</span> = <span style="color: #009F9F;">0</span>, <span style="color: #AFAFAF;">tt</span> = -<span style="color: #009F9F;">1</span>;
    <span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">i</span> = <span style="color: #009F9F;">0</span>; i &lt; n; ++ i) {
        <span style="color: #BD93F9;">if</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span style="color: #009F9F;">1</span>)
            hh ++ ;
        <span style="color: #BD93F9;">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i])
            tt -- ;
        q[ ++ tt] = i;
        <span style="color: #BD93F9;">if</span> (i &gt;= k - <span style="color: #009F9F;">1</span>)
            printf(<span style="color: #FC9F4E;">"%d "</span>, a[q[hh]]);
    }
}

<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">main</span>() {
    <span style="color: #BD93F9;">while</span> (~scanf(<span style="color: #FC9F4E;">"%d %d"</span>, &amp;n, &amp;k)) {
        <span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">i</span> = <span style="color: #009F9F;">0</span>; i &lt; n; ++ i)
            scanf(<span style="color: #FC9F4E;">"%d"</span>, &amp;a[i]);
        get_mins();
        NEXTLINE;
        get_maxs();
    }
    <span style="color: #BD93F9;">return</span> <span style="color: #009F9F;">0</span>;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orga464997" class="outline-2">
<h2 id="orga464997">最大连续子序列和</h2>
<div class="outline-text-2" id="text-orga464997">
<p>
给定一个长度为N的整数序列(可能有负数)，从中找出一段长度不超过M的连续子序列，使得所有子序列中所有数的和最大(这里增加了不超过M的条件)<br>
最优选择的策略集合一定是一个"下标位置递增，对应的前缀和的值也递增"的序列，所以可以使用队列保存这个序列<br>
</p>
<ol class="org-ol">
<li>判断队头决策与i的距离是否超过M的范围，若超出则出队<br></li>
<li>此时队头就是右端点为i时，左端点j的最优选择<br></li>
<li>不断删除队尾决策，直到队尾对应的前缀和S小于S[i]，然后把i作为一个新的决策入队<br></li>
</ol>
</div>
</div>
</div>
</body>
</html>
