<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-04-21 Thu 09:12 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CMAKE</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran &lt;haoran.mc@outlook.com&gt;">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">CMAKE</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org8b16814">前言</a></li>
<li><a href="#org05ada02">Cross-platform development</a></li>
<li><a href="#org3d91fa4">语法特性介绍</a></li>
<li><a href="#org031e21c">重要指令和 CMake 常用变量</a>
<ul>
<li><a href="#org9c21a02">重要指令</a></li>
<li><a href="#orgfd62ece">CMake常用变量</a></li>
</ul>
</li>
<li><a href="#orgbd2b94f">CMake 编译工程</a>
<ul>
<li><a href="#orgca94475">两种方式设置编译规则：</a></li>
<li><a href="#org483da9e">编译流程</a></li>
<li><a href="#org8858384">两种构建方式</a>
<ul>
<li><a href="#org8854b5e">内部构建（in-source build）：不推荐使用</a></li>
<li><a href="#org1bf6236">外部构建（out-of-source build）： <code>推荐使用</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgaea5478">[实战]CMake代码实践</a>
<ul>
<li><a href="#org3437445">最小 CMake 工程</a></li>
<li><a href="#org731e81f">多目录工程 - 直接编译</a></li>
<li><a href="#orgc5af852">多目录工程 - 生成库编译</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org8b16814" class="outline-2">
<h2 id="org8b16814">前言</h2>
<div class="outline-text-2" id="text-org8b16814">
<p>
CMake是一个跨平台的安装编译工具，可以用简单的语句来描述所有平台的安装(编译过程)。<br>
</p>

<p>
CMake可以说已经成为大部分C++开源项目标配<br>
</p>
</div>
</div>
<div id="outline-container-org05ada02" class="outline-2">
<h2 id="org05ada02">Cross-platform development</h2>
<div class="outline-text-2" id="text-org05ada02">
<p>
Let’s assume you have some cross-platform project with C++ code shared along different platforms/IDEs. Say you use Visual Studio on Windows, Xcode on OSX and Makefile for Linux:<br>
</p>
<pre class="example">
Build tools:   Visual Studio  Xcode   Makefile
. 									 |          |         |
. 									 |          |         |
. 									 |          |         |
. 									 V          V         V
Build command:    msbuild   xcodebuild   make
. 										 \        |        /
. 											\       |       / 
. 											 \      |      /  
. 												\     |     /   
. 															v          
. 													 binaries
</pre>

<p>
What you will do if you want to add new bar.cpp source file? You have to add it to every tool you use:<br>
</p>
<pre class="example">
. 													 +bar.cpp
. 												 /    |    \  
. 							[add]     /     |     \ 
. 											 /      |      \
. 											/       |       \
. 															v        
Build tools:   Visual Studio  Xcode   Makefile
. 									 |          |         |
. 									 |          |         |
. 									 |          |         |
. 									 V          V         V
Build command:    msbuild   xcodebuild   make
. 										 \        |        /
. 											\       |       / 
. 											 \      |      /  
. 												\     |     /   
. 															v          
. 													 binaries
</pre>

<p>
To keep the environment consistent you have to do the similar update several times. And the most important thing is that you have to do it manually (arrow marked with a red color on the diagram in this case). Of course such approach is error prone and not flexible.<br>
</p>

<p>
CMake solve this design flaw by adding extra step to development process. You can describe your project in CMakeLists.txt file and use CMake to generate tools you currently interested in using cross-platform CMake code:<br>
</p>
<pre class="example">
. 												CMakeLists.txt
. 															|
. 															|
. 															|
. 													 [cmake] 
. 												 /    |    \  
. 												/     |     \ 
. 											 /      |      \
. 											/       |       \
. 															v        
Build tools:   Visual Studio  Xcode   Makefile
. 									 |          |         |
. 									 |          |         |
. 									 |          |         |
. 									 V          V         V
Build command:    msbuild   xcodebuild   make
. 										 \        |        /
. 											\       |       / 
. 											 \      |      /  
. 												\     |     /   
. 															v          
. 													 binaries
</pre>

<p>
Same action - adding new bar.cpp file, will be done in one step now:<br>
</p>
<pre class="example">
. 													 +bar.cpp
. 															|
. 								[add]         |
. 															|
. 												CMakeLists.txt
. 															|
. 															|
. 															|
. 													 [cmake] 
. 												 /    |    \  
. 												/     |     \ 
. 											 /      |      \
. 											/       |       \
. 															v        
Build tools:   Visual Studio  Xcode   Makefile
.										 |          |         |
.										 |          |         |
.										 |          |         |
.										 V          V         V
Build command:    msbuild   xcodebuild   make
. 										 \        |        /
. 											\       |       / 
. 											 \      |      /  
. 												\     |     /   
. 															v          
. 													 binaries
</pre>

<p>
Note that the bottom part of the diagram was not changed. I.e. you still can keep using your favorite tools like Visual Studio/msbuild, Xcode/xcodebuild and Makefile/make!<br>
</p>
</div>
</div>
<div id="outline-container-org3d91fa4" class="outline-2">
<h2 id="org3d91fa4">语法特性介绍</h2>
<div class="outline-text-2" id="text-org3d91fa4">
<ul class="org-ul">
<li>基本语法格式：指令(参数 1 参数 2…)<br>
<ul class="org-ul">
<li>参数使用括弧括起<br></li>
<li>参数之间使用空格或分号分开<br></li>
</ul></li>
<li><p>
指令是大小写无关的，参数和变量是大小写相关的<br>
</p>
<div class="org-src-container">
<pre class="src src-cmake">set(HELLO hello.cpp)
add_executable(hello main.cpp hello.cpp)
ADD_EXECUTABLE(hello main.cpp ${HELLO})
</pre>
</div></li>
<li>变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名<br></li>
</ul>
</div>
</div>
<div id="outline-container-org031e21c" class="outline-2">
<h2 id="org031e21c">重要指令和 CMake 常用变量</h2>
<div class="outline-text-2" id="text-org031e21c">
</div>
<div id="outline-container-org9c21a02" class="outline-3">
<h3 id="org9c21a02">重要指令</h3>
<div class="outline-text-3" id="text-org9c21a02">
<dl class="org-dl">
<dt>cmake_minimum_required</dt><dd>指定CMake的最小版本要求<br></dd>

<dt>语法</dt><dd>cmake_minimum_required(VERSION versionNumber [FATAL_ERROR])<br></dd>
</dl>

<div class="org-src-container">
<pre class="src src-cmake"># CMake最小版本要求为2.8.3
cmake_minimum_required(VERSION 2.8.3)
</pre>
</div>

<ul class="org-ul">
<li>project - 定义工程名称，并可指定工程支持的语言<br></li>
<li id="语法">project(projectname [CXX] [C] [Java])<br></li>
</ul>
<div class="org-src-container">
<pre class="src src-cmake"># 指定工程名为HELLOWORLD
project(HELLOWORLD)
</pre>
</div>

<dl class="org-dl">
<dt>set</dt><dd>显式的定义变量<br></dd>
<dt>语法</dt><dd>set(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])<br></dd>
</dl>
<div class="org-src-container">
<pre class="src src-cmake"># 定义SRC变量，其值为main.cpp hello.cpp
set(SRC sayhello.cpp hello.cpp)
</pre>
</div>

<dl class="org-dl">
<dt>include_directories</dt><dd>向工程添加多个特定的头文件搜索路径  &#x2014;&gt;相当于指定g++编译器的-I参数<br></dd>
<dt>语法</dt><dd>include_directories([AFTER|BEFORE] [SYSTEM] dir1 dir2 …)<br></dd>
</dl>
<div class="org-src-container">
<pre class="src src-cmake"># 将/usr/include/myincludefolder 和 ./include 添加到头文件搜索路径
include_directories(/usr/include/myincludefolder ./include)
</pre>
</div>

<dl class="org-dl">
<dt>link_directories</dt><dd>向工程添加多个特定的库文件搜索路径  &#x2014;&gt;相当于指定g++编译器的-L参数<br></dd>
<dt>语法</dt><dd>link_directories(dir1 dir2 …)<br></dd>
</dl>
<div class="org-src-container">
<pre class="src src-cmake"># 将/usr/lib/mylibfolder 和 ./lib 添加到库文件搜索路径
link_directories(/usr/lib/mylibfolder ./lib)
</pre>
</div>

<dl class="org-dl">
<dt>add_library</dt><dd>生成库文件<br></dd>
<dt>语法</dt><dd>add_library(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 … sourceN)<br></dd>
</dl>
<div class="org-src-container">
<pre class="src src-cmake"># 通过变量 SRC 生成 libhello.so 共享库
add_library(hello SHARED ${SRC})
</pre>
</div>

<dl class="org-dl">
<dt>add_compile_options</dt><dd>添加编译参数<br></dd>
<dt>语法</dt><dd>add_compile_options<br></dd>
</dl>
<div class="org-src-container">
<pre class="src src-cmake"># 添加编译参数 -Wall -std=c++11
add_compile_options(-Wall -std=c++11 -O2)
</pre>
</div>

<dl class="org-dl">
<dt>add_executable</dt><dd>生成可执行文件<br></dd>
<dt>语法</dt><dd>add_library(exename source1 source2 … sourceN)<br></dd>
</dl>
<div class="org-src-container">
<pre class="src src-cmake"># 编译main.cpp生成可执行文件main
add_executable(main main.cpp)
</pre>
</div>

<dl class="org-dl">
<dt>target_link_libraries</dt><dd>为 target 添加需要链接的共享库  &#x2014;&gt;相同于指定g++编译器-l参数<br></dd>
<dt>语法</dt><dd>target_link_libraries(target library1library2…)<br></dd>
</dl>
<div class="org-src-container">
<pre class="src src-cmake"># 将hello动态库文件链接到可执行文件main
target_link_libraries(main hello)
</pre>
</div>

<dl class="org-dl">
<dt>add_subdirectory</dt><dd>向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置<br></dd>
<dt>语法</dt><dd>add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])<br></dd>
</dl>
<div class="org-src-container">
<pre class="src src-cmake"># 添加src子目录，src中需有一个CMakeLists.txt
add_subdirectory(src)
</pre>
</div>

<dl class="org-dl">
<dt>aux_source_directory</dt><dd>发现一个目录下所有的源代码文件并将列表存储在一个变量中，这个指令临时被用来自动构建源文件列表<br></dd>
<dt>语法</dt><dd>aux_source_directory(dir VARIABLE)<br></dd>
</dl>
<div class="org-src-container">
<pre class="src src-cmake"># 定义SRC变量，其值为当前目录下所有的源代码文件
aux_source_directory(. SRC)
# 编译SRC变量所代表的源代码文件，生成main可执行文件
add_executable(main ${SRC})
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfd62ece" class="outline-3">
<h3 id="orgfd62ece">CMake常用变量</h3>
<div class="outline-text-3" id="text-orgfd62ece">
<dl class="org-dl">
<dt><b>CMAKE_C_FLAGS</b></dt><dd>gcc编译选项<br></dd>
<dt><b>CMAKE_CXX_FLAGS</b></dt><dd>g++编译选项<br></dd>
</dl>
<div class="org-src-container">
<pre class="src src-cmake"># 在CMAKE_CXX_FLAGS编译选项后追加-std=c++11
set( CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
</pre>
</div>
<dl class="org-dl">
<dt><b>CMAKE_BUILD_TYPE</b></dt><dd>编译类型(Debug, Release)<br></dd>
</dl>
<div class="org-src-container">
<pre class="src src-cmake"># 设定编译类型为debug，调试时需要选择debug
set(CMAKE_BUILD_TYPE Debug) 
# 设定编译类型为release，发布时需要选择release
set(CMAKE_BUILD_TYPE Release) 
</pre>
</div>
<dl class="org-dl">
<dt><b>CMAKE_C_COMPILER</b></dt><dd>指定C编译器<br></dd>
<dt><b>CMAKE_CXX_COMPILER</b></dt><dd>指定C++编译器<br></dd>
<dt><b>EXECUTABLE_OUTPUT_PATH</b></dt><dd>可执行文件输出的存放路径<br></dd>
<dt><b>LIBRARY_OUTPUT_PATH</b></dt><dd>库文件输出的存放路径<br></dd>
</dl>


<ul class="org-ul">
<li><b>CMAKE_BINARY_DIR</b> 、 <b>PROJECT_BINARY_DIR</b> 、 <b>&lt;projectname&gt;__BINARY_DIR</b><br>
<ol class="org-ol">
<li>这三个变量指代的内容是一致的。<br></li>
<li>如果是 in source build，指的就是工程顶层目录。<br></li>
<li>如果是 out-of-source 编译,指的是工程编译发生的目录。<br></li>
<li>PROJECT_BINARY_DIR 跟其他指令稍有区别，不过现在，你可以理解为他们是一致的。<br></li>
</ol></li>
<li><b>CMAKE_SOURCE_DIR*、*PROJECT_SOURCE_DIR*、*&lt;projectname&gt;__SOURCE_DIR</b><br>
<ol class="org-ol">
<li>这三个变量指代的内容是一致的,不论采用何种编译方式,都是工程顶层目录。<br></li>
<li>也就是在 in source build时,他跟 CMAKE_BINARY_DIR 等变量一致。<br></li>
<li>PROJECT_SOURCE_DIR 跟其他指令稍有区别,现在,你可以理解为他们是一致的。<br></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgbd2b94f" class="outline-2">
<h2 id="orgbd2b94f">CMake 编译工程</h2>
<div class="outline-text-2" id="text-orgbd2b94f">
<p>
CMake目录结构：项目主目录存在一个CMakeLists.txt文件。<br>
</p>
</div>
<div id="outline-container-orgca94475" class="outline-3">
<h3 id="orgca94475">两种方式设置编译规则：</h3>
<div class="outline-text-3" id="text-orgca94475">
<ol class="org-ol">
<li>包含源文件的子文件夹 <b>包含</b> CMakeLists.txt文件，主目录的CMakeLists.txt通过add_subdirectory添加子目录即可<br></li>
<li>包含源文件的子文件夹 <b>未包含</b> CMakeLists.txt文件，子目录编译规则体现在主目录的CMakeLists.txt中<br></li>
</ol>
</div>
</div>
<div id="outline-container-org483da9e" class="outline-3">
<h3 id="org483da9e">编译流程</h3>
<div class="outline-text-3" id="text-org483da9e">
<p>
在 linux 平台下使用 CMake 构建C/C++工程的流程如下:<br>
</p>
<ul class="org-ul">
<li>手动编写 CMakeLists.txt<br></li>
<li>执行命令 cmake PATH生成 Makefile ( PATH 是顶层CMakeLists.txt 所在的目录 )<br></li>
<li><p>
执行命令make进行编译<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">important tips</span>
.          <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#34920;&#31034;&#24403;&#21069;&#30446;&#24405;</span>
./         <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#34920;&#31034;&#24403;&#21069;&#30446;&#24405;</span>

..      <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#34920;&#31034;&#19978;&#32423;&#30446;&#24405;</span>
../     <span style="color: #008787; background-color: #262626;"># </span><span style="color: #008787; background-color: #262626;">&#34920;&#31034;&#19978;&#32423;&#30446;&#24405;</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org8858384" class="outline-3">
<h3 id="org8858384">两种构建方式</h3>
<div class="outline-text-3" id="text-org8858384">
</div>
<div id="outline-container-org8854b5e" class="outline-4">
<h4 id="org8854b5e">内部构建（in-source build）：不推荐使用</h4>
<div class="outline-text-4" id="text-org8854b5e">
<p>
内部构建会在同级目录下产生一大堆中间文件，这些中间文件并不是我们最终所需要的，和工程源文件放在一起会显得杂乱无章。<br>
</p>

<div class="org-src-container">
<pre class="src src-cmake">## 内部构建
# 在当前目录下，编译本目录的CMakeLists.txt，生成Makefile和其他文件
cmake .
# 执行make命令，生成target
make
</pre>
</div>
</div>
</div>
<div id="outline-container-org1bf6236" class="outline-4">
<h4 id="org1bf6236">外部构建（out-of-source build）： <code>推荐使用</code></h4>
<div class="outline-text-4" id="text-org1bf6236">
<p>
将编译输出文件与源文件放到不同目录中<br>
</p>
<div class="org-src-container">
<pre class="src src-cmake">## 外部构建
# 1. 在当前目录下，创建build文件夹
mkdir build 
# 2. 进入到build文件夹
cd build
# 3. 编译上级目录的CMakeLists.txt，生成Makefile和其他文件
cmake ..
# 4. 执行make命令，生成target
make
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgaea5478" class="outline-2">
<h2 id="orgaea5478">[实战]CMake代码实践</h2>
<div class="outline-text-2" id="text-orgaea5478">
<p>
针对第五章写的两个小项目来写对应的CMakeLists.txt。<br>
</p>
</div>
<div id="outline-container-org3437445" class="outline-3">
<h3 id="org3437445">最小 CMake 工程</h3>
<div class="outline-text-3" id="text-org3437445">
<div class="org-src-container">
<pre class="src src-cmake"># Set the minimum version of CMake that can be used
cmake_minimum_required(VERSION 3.0)

# Set the project name
project (HELLO)

# Add an executable
add_executable(hello_cmake main.cpp)
</pre>
</div>
</div>
</div>
<div id="outline-container-org731e81f" class="outline-3">
<h3 id="org731e81f">多目录工程 - 直接编译</h3>
<div class="outline-text-3" id="text-org731e81f">
<div class="org-src-container">
<pre class="src src-cmake"># Set the minimum version of CMake that can be used
cmake_minimum_required(VERSION 3.0)

#project name
project(SWAP)

#head file pat
include_directories( include )

#source directory files to var
add_subdirectory( src DIR_SRCS )

#add executable file  
add_executable(swap_02 ${TEST_MATH})

#add link library  
target_link_libraries(${FS_BUILD_BINARY_PREFIX}sqrt ${LIBRARIES}) 
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc5af852" class="outline-3">
<h3 id="orgc5af852">多目录工程 - 生成库编译</h3>
<div class="outline-text-3" id="text-orgc5af852">
<div class="org-src-container">
<pre class="src src-cmake"># Set the minimum version of CMake that can be used
cmake_minimum_required(VERSION 3.0)

#project name  
project(SWAP_LIBRARY)

#add compile options
add_compile_options("-Wall -std=c++11")

#set CMAKE_BUILD_TYPE
set(CMAKE_BUILD_TYPE Debug) 

# set output binary path  
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)

############################################################
# Create a library
############################################################

#Generate the static library from the library sources
add_library( swap_library STATIC src/Swap.cpp )

target_include_directories( swap_lib PUBLIC ${PROJECT_SOURCE_DIR}/include )

############################################################
# Create an executable
############################################################

# Add an executable with the above sources
add_executable( swap_01 main.cpp )

# link the new swap_01 target with the swap_lib target
target_link_libraries( swap_01 swap_liby )
</pre>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
