<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-02-14 Mon 14:25 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>GOLANG中的锁</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">GOLANG中的锁</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb15762d">什么是锁，为什么使用锁</a></li>
<li><a href="#org4ae564f">常见的锁的种类</a></li>
<li><a href="#org26ee167">Go 中锁的使用和实现分析</a></li>
<li><a href="#orge1a0f92">死锁</a></li>
<li><a href="#orgc0d5145">活锁</a></li>
<li><a href="#orgde3a8e3">饥饿</a></li>
<li><a href="#orgf6f0b2e">参考</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgb15762d" class="outline-2">
<h2 id="orgb15762d">什么是锁，为什么使用锁</h2>
<div class="outline-text-2" id="text-orgb15762d">
<p>
简单来说，锁意味着保护，对资源的保护，这个资源可以是一个变量、一个代码片段、一条记录、一张数据库表等等。<br>
</p>

<p>
之所以使用锁，是防止在并发情况下，多个人对同一资源进行操作，有可能导致的资源不符合预期的修改。<br>
</p>
</div>
</div>
<div id="outline-container-org4ae564f" class="outline-2">
<h2 id="org4ae564f">常见的锁的种类</h2>
<div class="outline-text-2" id="text-org4ae564f">
<p>
锁的种类细分的话非常多，从不同角度看，对锁的定义不一样。<br>
</p>

<p>
我个人认为锁都可以归为以下四类，其他的叫法不同只是因为其实现方式或者应用场景而得名，但本质上还是下面这四大类中的一种。<br>
</p>

<img src="./images/四种锁.png"/>

<p>
其他各种类的锁总结如下，这些锁只是为了高性能，为了各种应用场景在代码实现上做了很多工作，因此而得名。<br>
</p>

<img src="./images/各种锁.png" width="1000px"/>

<pre class="example" id="orgab1701d">
1、自旋锁
			 自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时 才能进入临界区

	 2、阻塞锁
			 可以说是让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间） 时，才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争，
			 进入运行状态。
			 JAVA中，能够进入\退出、阻塞状态或包含阻塞锁的方法有 ，synchronized 关键字（其中的重量锁），
			 ReentrantLock，Object.wait()\notify(),LockSupport.park()/unpart()(j.u.c经常使用)

	 3、可重入锁
			 可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。
			 在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁

	 4、读写锁
			 假设你的程序中涉及到对一些共享资源的读和写操作，且写操作没有读操作那么频繁。在没有写操作的时候，两个线程同时读一个资源没有任何问题，
			 所以应该允许多个线程能在同时读取共享资源。但是如果有一个线程想去写这些共享资源，就不应该再有其它线程对该资源进行读或写。
			 （也就是说：读-读能共存，读-写不能共存，写-写不能共存）。这就需要一个读/写锁来解决这个问题。
			 ReentrantReadWriteLock

	 5、互斥锁
			 所谓互斥锁, 指的是一次最多只能有一个线程持有的锁

	 6、悲观锁
			 悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。
			 传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
			 再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。

	 7、乐观锁
			 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，
			 可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，
			 其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。

	 8、公平锁
	 9、非公平锁

	 10、偏向锁
			 偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。
			 如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会尝试消除它身上的偏向锁，将锁恢复到标准的轻量级锁
			 http://blog.csdn.net/u014411966/article/details/51347100

	 11、对象锁

	 12、线程锁

	 13、锁粗化
			 锁粗化，如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展到整个操作序列的外部，这样就只需要加锁一次就够了。

	 14、锁消除
			 锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除主要判定依据来源于逃逸分析的数据支持

	 15、轻量级锁

	 16、锁膨胀
			 偏向锁----&gt;轻量级锁-----&gt;重量级锁

	 17、信号量
			 Semaphore
</pre>
</div>
</div>
<div id="outline-container-org26ee167" class="outline-2">
<h2 id="org26ee167">Go 中锁的使用和实现分析</h2>
<div class="outline-text-2" id="text-org26ee167">
<p>
Go 的代码库为开发人员提供了下面两种锁：<br>
</p>

<ol class="org-ol">
<li>互斥锁 <code>sync.Mutex</code><br></li>
<li>读写锁 <code>sync.RWMutex</code><br></li>
</ol>

<p>
第一个互斥锁指的是在Go编程中，同一资源的锁定对各个协程是相互排斥的，当其中一个协程获取到该锁时，其它协程只能等待，直到这个获取锁的协程释放锁之后，其它的协程才能获取。<br>
</p>

<p>
第二个读写锁依赖于互斥锁的实现，这个指的是当多个协程对某一个资源都是只读操作，那么多个协程可以获取该资源的读锁，并且互相不影响，但当有协程要修改该资源时就必须获取写锁，如果获取写锁时，已经有其它协程获取了读写或者写锁，那么此次获取失败，也就是说读写互斥，读读共享，写写互斥。<br>
</p>

<p>
Go中关于锁的接口定义如下：，该接口的实现就是上面的两个锁种类，篇幅有限，这篇文章主要是分析一下互斥锁的使用和实现，因为RWMutex也是基于Mutex的，大家可以参考文章自行学习一下。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Locker</span> <span style="color: #268bd2; font-weight: bold;">interface</span> {
    <span style="color: #d75fd7; font-weight: bold;">Lock</span>()
    <span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
}

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Mutex</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    state <span style="color: #df005f; font-weight: bold;">int32</span> <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#21021;&#22987;&#20540;&#40664;&#35748;&#20026;0</span>
    sema  <span style="color: #df005f; font-weight: bold;">uint32</span> <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#21021;&#22987;&#20540;&#40664;&#35748;&#20026;0</span>
}
</pre>
</div>

<p>
Mutex 使用也非常的简单，声明一个 Mutex 变量就可以直接调用 Lock 和 Unlock 方法了，如下代码实例，但使用的过程中有一些注意点，如下：<br>
</p>

<ol class="org-ol">
<li>同一个协程不能连续多次调用Lock,否则发生死锁<br></li>
<li>锁资源时尽量缩小资源的范围，以免引起其它协程超长时间等待<br></li>
<li>mutex传递给外部的时候需要传指针，不然就是实例的拷贝，会引起锁失败<br></li>
<li>善用defer确保在函数内释放了锁<br></li>
<li>使用-race在运行时检测数据竞争问题，go test -race &#x2026;.，go build -race &#x2026;.<br></li>
<li>善用静态工具检查锁的使用问题<br></li>
<li>使用go-deadlock检测死锁，和指定锁超时的等待问题(自己百度工具用法)<br></li>
<li>能用channel的场景别使用成了lock<br></li>
</ol>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">lock</span> <span style="color: #df005f; font-weight: bold;">sync.Mutex</span>

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">MutexStudy</span>(){
    <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#33719;&#21462;&#38145;</span>
    lock.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
    <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#19994;&#21153;&#36923;&#36753;&#25805;&#20316;</span>
    time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(<span style="color: #d75fd7;">1</span> * time.Second)
    <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#37322;&#25918;&#38145;</span>
    <span style="color: #268bd2; font-weight: bold;">defer</span> lock.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
}
</pre>
</div>

<p>
我们了解了 Mutex 的使用和注意事项，那么具体原理是怎么实现的呢？运用到了那些技术，下面一起分析一下Mutex的实现原理。<br>
</p>

<p>
Mutex实现中有两种模式， <b>1：正常模式，2：饥饿模式</b> ，前者指的是当一个协程获取到锁时，后面的协程会排队(FIFO),释放锁时会唤醒最早排队的协程，这个协程会和正在CPU上运行的协程竞争锁，但是大概率会失败，为什么呢？因为你是刚被唤醒的，还没有获得CPU的使用权，而CPU正在执行的协程肯定比你有优势，如果这个被唤醒的协程竞争失败，并且超过了1ms，那么就会退回到后者(饥饿模式)，这种模式下，该协程在下次获取锁时直接得到,不存在竞争关系，本质是为了防止协程等待锁的时间太长。<br>
</p>
</div>
</div>
<div id="outline-container-orge1a0f92" class="outline-2">
<h2 id="orge1a0f92">死锁</h2>
<div class="outline-text-2" id="text-orge1a0f92">
<p>
死锁是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。<br>
</p>

<p>
死锁发生的条件有如下几种：<br>
</p>

<ol class="org-ol">
<li>互斥条件：线程对资源的访问是排他性的，如果一个线程对占用了某资源，那么其他线程必须处于等待状态，直到该资源被释放。<br></li>
<li>请求和保持条件：线程 T1 至少已经保持了一个资源 R1 占用，但又提出使用另一个资源 R2 请求，而此时，资源 R2 被其他线程 T2 占用，于是该线程 T1 也必须等待，但又对自己保持的资源 R1 不释放。<br></li>
<li>不剥夺条件：线程已获得的资源，在未使用完之前，不能被其他线程剥夺，只能在使用完以后由自己释放。<br></li>
<li>环路等待条件：在死锁发生时，必然存在一个“进程 - 资源环形链”，即：{p0,p1,p2,&#x2026;pn}，进程 p0（或线程）等待 p1 占用的资源，p1 等待 p2 占用的资源，pn 等待 p0 占用的资源。<br></li>
</ol>

<p>
最直观的理解是，p0 等待 p1 占用的资源，而 p1 而在等待 p0 占用的资源，于是两个进程就相互等待。<br>
</p>

<p>
死锁解决办法：<br>
</p>

<ul class="org-ul">
<li>如果并发查询多个表，约定访问顺序；<br></li>
<li>在同一个事务中，尽可能做到一次锁定获取所需要的资源；<br></li>
<li>对于容易产生死锁的业务场景，尝试升级锁颗粒度，使用表级锁；<br></li>
<li>采用分布式事务锁或者使用乐观锁。<br></li>
</ul>

<p>
死锁程序是所有并发进程彼此等待的程序，在这种情况下，如果没有外界的干预，这个程序将永远无法恢复。<br>
</p>
</div>
</div>
<div id="outline-container-orgc0d5145" class="outline-2">
<h2 id="orgc0d5145">活锁</h2>
<div class="outline-text-2" id="text-orgc0d5145">
<p>
活锁是另一种形式的活跃性问题，该问题尽管不会阻塞线程，但也不能继续执行，因为线程将不断重复同样的操作，而且总会失败。<br>
</p>

<p>
例如线程 1 可以使用资源，但它很礼貌，让其他线程先使用资源，线程 2 也可以使用资源，但它同样很绅士，也让其他线程先使用资源。就这样你让我，我让你，最后两个线程都无法使用资源。<br>
</p>

<p>
活锁通常发生在处理事务消息中，如果不能成功处理某个消息，那么消息处理机制将回滚事务，并将它重新放到队列的开头。这样，错误的事务被一直回滚重复执行，这种形式的活锁通常是由过度的错误恢复代码造成的，因为它错误地将不可修复的错误认为是可修复的错误。<br>
</p>

<p>
当多个相互协作的线程都对彼此进行相应而修改自己的状态，并使得任何一个线程都无法继续执行时，就导致了活锁。这就像两个过于礼貌的人在路上相遇，他们彼此让路，然后在另一条路上相遇，然后他们就一直这样避让下去。<br>
</p>

<p>
要解决这种活锁问题，需要在重试机制中引入随机性。例如在网络上发送数据包，如果检测到冲突，都要停止并在一段时间后重发，如果都在 1 秒后重发，还是会冲突，所以引入随机性可以解决该类问题。<br>
</p>
</div>
</div>
<div id="outline-container-orgde3a8e3" class="outline-2">
<h2 id="orgde3a8e3">饥饿</h2>
<div class="outline-text-2" id="text-orgde3a8e3">
<p>
饥饿是指一个可运行的进程尽管能继续执行，但被调度器无限期地忽视，而不能被调度执行的情况。<br>
</p>

<p>
与死锁不同的是，饥饿锁在一段时间内，优先级低的线程最终还是会执行的，比如高优先级的线程执行完之后释放了资源。<br>
</p>

<p>
活锁与饥饿是无关的，因为在活锁中，所有并发进程都是相同的，并且没有完成工作。更广泛地说，饥饿通常意味着有一个或多个贪婪的并发进程，它们不公平地阻止一个或多个并发进程，以尽可能有效地完成工作，或者阻止全部并发进程。<br>
</p>

<p>
下面的示例程序中包含了一个贪婪的 goroutine 和一个平和的 goroutine：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> main

<span style="color: #268bd2; font-weight: bold;">import</span> (
    <span style="color: #2aa198;">"fmt"</span>
    <span style="color: #2aa198;">"runtime"</span>
    <span style="color: #2aa198;">"sync"</span>
    <span style="color: #2aa198;">"time"</span>
)

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    runtime.<span style="color: #d75fd7; font-weight: bold;">GOMAXPROCS</span>(<span style="color: #d75fd7;">3</span>)
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">wg</span> <span style="color: #df005f; font-weight: bold;">sync.WaitGroup</span>
    <span style="color: #268bd2; font-weight: bold;">const</span> <span style="color: #d75fd7;">runtime</span> = <span style="color: #d75fd7;">1</span> * time.Second
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">sharedLock</span> <span style="color: #df005f; font-weight: bold;">sync.Mutex</span>

    <span style="color: #8787d7;">greedyWorker</span> := <span style="color: #268bd2; font-weight: bold;">func</span>() {
        <span style="color: #268bd2; font-weight: bold;">defer</span> wg.<span style="color: #d75fd7; font-weight: bold;">Done</span>()
        <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">count</span> <span style="color: #df005f; font-weight: bold;">int</span>
        <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">begin</span> := time.<span style="color: #d75fd7; font-weight: bold;">Now</span>(); time.<span style="color: #d75fd7; font-weight: bold;">Since</span>(begin) &lt;= runtime; {
            sharedLock.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
            time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(<span style="color: #d75fd7;">3</span> * time.Nanosecond)
            sharedLock.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
            count ++
        }
        fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"Greedy worker was able to execute %v work loops\n"</span>, count)
    }

    <span style="color: #8787d7;">politeWorker</span> := <span style="color: #268bd2; font-weight: bold;">func</span>() {
        <span style="color: #268bd2; font-weight: bold;">defer</span> wg.<span style="color: #d75fd7; font-weight: bold;">Done</span>()
        <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">count</span> <span style="color: #df005f; font-weight: bold;">int</span>
        <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">begin</span> := time.<span style="color: #d75fd7; font-weight: bold;">Now</span>(); time.<span style="color: #d75fd7; font-weight: bold;">Since</span>(begin) &lt;= runtime; {
            sharedLock.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
            time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(<span style="color: #d75fd7;">1</span> * time.Nanosecond)
            sharedLock.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()

            sharedLock.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
            time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(<span style="color: #d75fd7;">1</span> * time.Nanosecond)
            sharedLock.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()

            sharedLock.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
            time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(<span style="color: #d75fd7;">1</span> * time.Nanosecond)
            sharedLock.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()

            count ++
        }
        fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"Polite worker was able to execute %v work loops\n"</span>, count)
    }

    wg.<span style="color: #d75fd7; font-weight: bold;">Add</span>(<span style="color: #d75fd7;">2</span>)
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #d75fd7; font-weight: bold;">greedyWorker</span>()
    <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #d75fd7; font-weight: bold;">politeWorker</span>()
    wg.<span style="color: #d75fd7; font-weight: bold;">Wait</span>()
}
</pre>
</div>

<p>
输出如下：<br>
</p>

<pre class="example" id="orgfb3034b">
Polite worker was able to execute 448594 work loops
Greedy worker was able to execute 791732 work loops
</pre>

<p>
贪婪的 worker 会贪婪地抢占共享锁，以完成整个工作循环，而平和的 worker 则试图只在需要时锁定。两种 worker 都做同样多的模拟工作（sleeping 时间为 3ns），可以看到，在同样的时间里，贪婪的 worker 工作量几乎是平和的 worker 工作量的两倍！<br>
</p>

<p>
假设两种 worker 都有同样大小的临界区，而不是认为贪婪的 worker 的算法更有效（或调用 Lock 和 Unlock 的时候，它们也不是缓慢的），我们得出这样的结论，贪婪的 worker 不必要地扩大其持有共享锁上的临界区，井阻止（通过饥饿）平和的 worker 的 goroutine 高效工作。<br>
</p>

<blockquote>
<p>
值得一提的是，前面的代码示例也可以作为进行同步内存访问的性能分支示例。 因为同步访问内存的代价很高，所以扩大我们的锁定范围可能会产生额外的代价。 另一方面，正如我们所看到的那样，我们冒着令其他并发进程挨饿的风险。<br>
</p>

<p>
如果你利用内存访问同步，你必须在性能粗粒度同步和公平性细粒度同步之间找到平衡点。 当开始调试应用程序时，我强烈建议你将内存访问同步仅限于程序的关键部分; 如果同步成为性能问题，则可以扩大范围。 除此之外，其他的解决方式可能会更难以操作。<br>
</p>
</blockquote>

<p>
因此，饥饿可能会导致程序无效或不正确。 前面的例子表明了执行效率是如何被降低的，如果你有一个非常贪婪的并发进程，以至于完全阻止另一个并发进程完成工作，那么你的问题就大了。<br>
</p>

<p>
我们还需要考虑来自程序之外导致的饥饿问题。请记住，饥饿还可以产生于于CPU，内存，文件句柄和数据库连接：任何必须共享的资源都是饥饿的候选对象。<br>
</p>
</div>
</div>
<div id="outline-container-orgf6f0b2e" class="outline-2">
<h2 id="orgf6f0b2e">参考</h2>
<div class="outline-text-2" id="text-orgf6f0b2e">
<p>
本文主要参考了这篇文章：<a href="https://www.cnblogs.com/sy270321/p/12185702.html">https://www.cnblogs.com/sy270321/p/12185702.html</a> <br>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-02-14 01:02 Mon</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-02-14 Mon 14:25</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
