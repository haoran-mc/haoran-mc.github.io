<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-03-24 Thu 16:21 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>值类型与引用类型、内建函数MAKE()与NEW()的区别</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">值类型与引用类型、内建函数MAKE()与NEW()的区别</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org89cfcb5">值类型与引用类型</a></li>
<li><a href="#orgdb5eeea">new 与 make 区别</a>
<ul>
<li><a href="#orga164a63">var</a></li>
<li><a href="#orge37ae80">new</a></li>
<li><a href="#org87d99f8">make</a></li>
</ul>
</li>
<li><a href="#orge9efbb8">小结</a></li>
</ul>
</div>
</div>

<div id="outline-container-org89cfcb5" class="outline-2">
<h2 id="org89cfcb5">值类型与引用类型</h2>
<div class="outline-text-2" id="text-org89cfcb5">
<p>
golang 中分为值类型和引用类型。<br>
</p>

<ul class="org-ul">
<li>值类型分别有：int系列、float系列、bool、string、数组和结构体<br></li>
<li>引用类型有：指针、切片slice、管道channel、接口interface、map、函数等<br></li>
</ul>

<p>
<b>值类型：</b><br>
</p>
<ul class="org-ul">
<li>特点是：变量直接存储值，内存通常在栈中分配<br></li>
<li>当使用等于号 <code>=</code> 将一个变量的值赋值给另一个变量时，实际上是在那内存中进行拷贝<br></li>
</ul>

<p>
<b>引用类型：</b><br>
</p>
<ul class="org-ul">
<li>特点是：变量存储的是一个地址，这个地址对应的空间里才是真正存储的值，内存通常在堆中分配<br></li>
<li>当使用赋值语句时，修改的时变量中存储的地址值<br></li>
</ul>
</div>
</div>
<div id="outline-container-orgdb5eeea" class="outline-2">
<h2 id="orgdb5eeea">new 与 make 区别</h2>
<div class="outline-text-2" id="text-orgdb5eeea">
</div>
<div id="outline-container-orga164a63" class="outline-3">
<h3 id="orga164a63">var</h3>
<div class="outline-text-3" id="text-orga164a63">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">num</span> <span style="color: #df005f; font-weight: bold;">int</span>
<span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">str</span> <span style="color: #df005f; font-weight: bold;">tring</span>
</pre>
</div>

<p>
变量的声明可以通过 <code>var</code> 关键字，然后就可以在程序中使用。当不指定变量的默认值时，这些变量的默认值是他们的零值，比如 <code>int</code> 类型的零值是 0， <code>string</code> 类型的零值是 ""，引用类型的零值是 nil。<br>
</p>

<p>
对于上面两个值类型的两个变量，声明后可以直接使用，那换成引用类型呢？<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> main

<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">p</span> *<span style="color: #df005f; font-weight: bold;">int</span>
    *p = 10
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(*p)
}
</pre>
</div>

<pre class="example">
panic: runtime error: invalid memory address or nil pointer dereference
</pre>

<p>
运行的时候会 panic。从提示中可以看出，对于引用类型的变量，我们不光要声明它，还要为它分配内容空间。<br>
</p>

<p>
对于值类型，声明之后不需要再分配空间，是因为编译器已经默认帮我们分配好了。<br>
</p>

<p>
要分配内存，就需要用到 new 和 make。<br>
</p>
</div>
</div>
<div id="outline-container-orge37ae80" class="outline-3">
<h3 id="orge37ae80">new</h3>
<div class="outline-text-3" id="text-orge37ae80">
<p>
对于上面出现的问题如何解决呢？既然知道了没有为其分配内存，那么我们就使用 <code>new</code> 分配一个吧。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> main

<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">p</span> *<span style="color: #df005f; font-weight: bold;">int</span>
    p = <span style="color: #268bd2;">new</span>(<span style="color: #df005f; font-weight: bold;">int</span>)
    *p = 10
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(*p)
}
</pre>
</div>

<p>
现在再运行程序，会打印 10，程序运行成功。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">The new built-in function allocates memory. The first argument is a type,</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">not a value, and the value returned is a pointer to a newly</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">allocated zero value of that type.</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #268bd2;">new</span>(<span style="color: #df005f; font-weight: bold;">Type</span>) *<span style="color: #df005f; font-weight: bold;">Type</span>
</pre>
</div>

<p>
内置的 <code>new</code> 函数只接受一个参数，这个参数是一个类型，分配好内存后 <b>返回一个指向该类型内存地址的指针</b> 。同时把分配的内存置为该类型的零值。<br>
</p>

<p>
再看一个例子：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> main

<span style="color: #268bd2; font-weight: bold;">import</span> (
    <span style="color: #2aa198;">"fmt"</span>
    <span style="color: #2aa198;">"sync"</span>
)

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Money</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    lock <span style="color: #df005f; font-weight: bold;">sync.Mutex</span>
    spending <span style="color: #df005f; font-weight: bold;">int</span>
    remain <span style="color: #df005f; font-weight: bold;">int</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">m</span> := <span style="color: #268bd2;">new</span>(<span style="color: #df005f; font-weight: bold;">Money</span>)

    m.spending = 0
    m.remain   = 10

    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(m)

    m.lock.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
    m.spending = 1
    m.remain  -= m.spending
    m.lock.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()

    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(m)
}
</pre>
</div>

<p>
在这个例子里，Money 类型中的 lock 字段并没有初始化，可以直接拿来用，不会有无效内存引用异常，因为它已经被零值了。<br>
</p>
</div>
</div>
<div id="outline-container-org87d99f8" class="outline-3">
<h3 id="org87d99f8">make</h3>
<div class="outline-text-3" id="text-org87d99f8">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">The make built-in function allocates and initializes an object of type</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">slice, map, or chan (only). Like new, the first argument is a type, not a</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">value. Unlike new, make's return type is the same as the type of its</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">argument, not a pointer to it. The specification of the result depends on</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">the type:</span>
<span style="color: #008787; background-color: #262626;">//  </span><span style="color: #008787; background-color: #262626;">Slice: The size specifies the length. The capacity of the slice is</span>
<span style="color: #008787; background-color: #262626;">//  </span><span style="color: #008787; background-color: #262626;">equal to its length. A second integer argument may be provided to</span>
<span style="color: #008787; background-color: #262626;">//  </span><span style="color: #008787; background-color: #262626;">specify a different capacity; it must be no smaller than the</span>
<span style="color: #008787; background-color: #262626;">//  </span><span style="color: #008787; background-color: #262626;">length. For example, make([]int, 0, 10) allocates an underlying array</span>
<span style="color: #008787; background-color: #262626;">//  </span><span style="color: #008787; background-color: #262626;">of size 10 and returns a slice of length 0 and capacity 10 that is</span>
<span style="color: #008787; background-color: #262626;">//  </span><span style="color: #008787; background-color: #262626;">backed by this underlying array.</span>
<span style="color: #008787; background-color: #262626;">//  </span><span style="color: #008787; background-color: #262626;">Map: An empty map is allocated with enough space to hold the</span>
<span style="color: #008787; background-color: #262626;">//  </span><span style="color: #008787; background-color: #262626;">specified number of elements. The size may be omitted, in which case</span>
<span style="color: #008787; background-color: #262626;">//  </span><span style="color: #008787; background-color: #262626;">a small starting size is allocated.</span>
<span style="color: #008787; background-color: #262626;">//  </span><span style="color: #008787; background-color: #262626;">Channel: The channel's buffer is initialized with the specified</span>
<span style="color: #008787; background-color: #262626;">//  </span><span style="color: #008787; background-color: #262626;">buffer capacity. If zero, or the size is omitted, the channel is</span>
<span style="color: #008787; background-color: #262626;">//  </span><span style="color: #008787; background-color: #262626;">unbuffered.</span>
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #268bd2;">make</span>(<span style="color: #8787d7;">t</span> <span style="color: #df005f; font-weight: bold;">Type</span>, <span style="color: #8787d7;">size</span> ...<span style="color: #df005f; font-weight: bold;">IntegerType</span>) <span style="color: #df005f; font-weight: bold;">Type</span>
</pre>
</div>

<p>
<code>make</code> 也是用于内存分配的，但是和 <code>new</code> 不同，它只用于 <code>chan</code> 、 <code>map</code> 以及切片的内存创建，而且它返回的类型就是这三个类型本身，而不是它们的指针类型。因为这三种类型就是引用类型的，所以就没有必要返回它们的指针了。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-orge9efbb8" class="outline-2">
<h2 id="orge9efbb8">小结</h2>
<div class="outline-text-2" id="text-orge9efbb8">
<p>
<code>new</code> 与 <code>make</code> 二者都是内存的分配（堆上），但是 <code>make</code> 只用于 slice、map 以及 channel 的初始化（非零值）；而 <code>new</code> 用于类型的内存分配，并且内存置为零。<br>
</p>

<p>
其实 <code>new</code> 不常用，在实际的编码中，通常都是采用短语句声明以及结构体的字面量达到我们的目的，比如：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #8787d7;">num</span> := 0
<span style="color: #8787d7;">m</span> := <span style="color: #df005f; font-weight: bold;">Money</span>{}
</pre>
</div>

<p>
这样更简洁，而且不会涉及到指针这种比较麻烦的操作，但是 <code>make</code> 函数是无可替代的，在使用 slice、map 以及 channel 的时候，还是要使用 <code>make</code> 进行初始化，然后才能对它们操作。<br>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-02-03 18:02 Thu</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-03-24 Thu 16:21</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
