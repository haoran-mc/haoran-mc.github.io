<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2023-01-28 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>控制脚本</title>
<meta name="author" content="Haoran Liu" />
<meta name="description" content="Copyright © 2023, Haoran Liu, all rights reserved." />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="static/css/org.css"/>
</head>
<body>
<div id="content" class="content">
<h1 class="title">控制脚本</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org60fa908">处理信号</a>
<ul>
<li><a href="#org6bf38b8">生成信号</a></li>
<li><a href="#orgaae826d">捕获信号</a></li>
</ul>
</li>
<li><a href="#orgd3edfba">后台模式运行脚本</a></li>
<li><a href="#org37cef7d">非控制台下运行脚本</a></li>
<li><a href="#orgc61a22b">作业控制</a>
<ul>
<li><a href="#org41f5a30">查看作业</a></li>
<li><a href="#org24f3ee0">重启停止的作业</a></li>
<li><a href="#orgedde966">杀死作业</a></li>
</ul>
</li>
<li><a href="#orgb1125f8">调整谦让度</a>
<ul>
<li><a href="#org8da6251">nice 命令</a></li>
<li><a href="#orgc932d55">renice 命令</a></li>
</ul>
</li>
<li><a href="#orga6ec09f">定时运行作业</a>
<ul>
<li><a href="#orgfba1da4">用 at 命令来计划执行作业</a></li>
<li><a href="#org61dda68">用 corn 命令来计划执行作业</a>
<ul>
<li><a href="#org8c34757">crontab</a></li>
<li><a href="#org3ae88eb">使用预配置的 cron 脚本目录</a></li>
<li><a href="#orgf543fdd">小技巧：如何设置一个在每个月的最后一天执行的命令？</a></li>
<li><a href="#orgd6919e8">anacron 程序</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org60fa908" class="outline-2">
<h2 id="org60fa908">处理信号</h2>
<div class="outline-text-2" id="text-org60fa908">
<p>
最常见的 Linux 系统信号：<br>
</p>

<table>


<colgroup>
<col  class="org-right">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">信号</th>
<th scope="col" class="org-left">值</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">SIGHUP</td>
<td class="org-left">挂起进程</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">SIGINT</td>
<td class="org-left">终止进程</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">SIGQUIT</td>
<td class="org-left">停止进程</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-left">SIGKILL</td>
<td class="org-left">无条件终止进程</td>
</tr>

<tr>
<td class="org-right">15</td>
<td class="org-left">SIGTERM</td>
<td class="org-left">尽可能终止进程</td>
</tr>

<tr>
<td class="org-right">17</td>
<td class="org-left">SIGSTOP</td>
<td class="org-left">无条件停止进程，但不是终止进程</td>
</tr>

<tr>
<td class="org-right">18</td>
<td class="org-left">SIGTSTP</td>
<td class="org-left">停止或暂停进程，但不终止进程</td>
</tr>

<tr>
<td class="org-right">19</td>
<td class="org-left">SIGCONT</td>
<td class="org-left">继续运行停止的进程</td>
</tr>
</tbody>
</table>


<p>
默认情况下，bash shell 会忽略收到的任何 SITQUIT(3) 和 IGTERM(5) 信号（正因为这样，交互式 shell 才不会被意外终止）。但是 bash shell 会处理收到的 SIGHUP(1) 和 SIGINT(2) 信号。<br>
</p>
</div>
<div id="outline-container-org6bf38b8" class="outline-3">
<h3 id="org6bf38b8">生成信号</h3>
<div class="outline-text-3" id="text-org6bf38b8">
<ul class="org-ul">
<li>ctrl c 中断进程<br></li>
<li>ctrl z 暂停进程<br></li>
</ul>
</div>
</div>
<div id="outline-container-orgaae826d" class="outline-3">
<h3 id="orgaae826d">捕获信号</h3>
<div class="outline-text-3" id="text-orgaae826d">
<p>
trap 命令<br>
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #ff2afc; font-weight: bold;">trap</span> <span style="color: #7984D1;">"echo ' trap ctrl c'"</span> SIGINT
<span style="color: #ff2afc; font-weight: bold;">trap</span> <span style="color: #7984D1;">"echo ' modify message'"</span> SIGINT
<span style="color: #546A90;"># </span><span style="color: #546A90;">&#37325;&#26032;&#35774;&#32622;&#20250;&#26356;&#25913;&#21629;&#20196;</span>

<span style="color: #546A90;"># </span><span style="color: #546A90;">&#21024;&#38500;&#25429;&#33719;</span>
<span style="color: #ff2afc; font-weight: bold;">trap</span> &#8211;- SIGINT
<span style="color: #546A90;"># </span><span style="color: #546A90;">&#24674;&#22797;&#20449;&#21495;&#30340;&#40664;&#35748;&#21151;&#33021;</span>
<span style="color: #ff2afc; font-weight: bold;">trap</span> - SIGINT
</pre>
</div>

<p>
当运行脚本时， ctrl-c 将会被捕获。<br>
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #546A90;"># </span><span style="color: #546A90;">&#25429;&#33719;&#33050;&#26412;&#36864;&#20986;</span>
<span style="color: #ff2afc; font-weight: bold;">trap</span> <span style="color: #7984D1;">"echo Goodbye..."</span> EXIT
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd3edfba" class="outline-2">
<h2 id="orgd3edfba">后台模式运行脚本</h2>
<div class="outline-text-2" id="text-orgd3edfba">
<p>
命令后加 <code>&amp;</code> 。<br>
</p>
</div>
</div>
<div id="outline-container-org37cef7d" class="outline-2">
<h2 id="org37cef7d">非控制台下运行脚本</h2>
<div class="outline-text-2" id="text-org37cef7d">
<p>
<code>nohup</code> ，即使退出终端会话，该脚本仍会一直在后台运行直到结束。<br>
</p>

<p>
nohup 命令会解除终端与进程的关联，进程也就不再同 STDOUT 和 STDERR 联系在一起。为了保存该命令产生的输出，nohup 命令会自动将 STDOUT 和 STDERR 的消息重定向到一个名为 nohup.out 的文件中。<br>
</p>
</div>
</div>
<div id="outline-container-orgc61a22b" class="outline-2">
<h2 id="orgc61a22b">作业控制</h2>
<div class="outline-text-2" id="text-orgc61a22b">
</div>
<div id="outline-container-org41f5a30" class="outline-3">
<h3 id="org41f5a30">查看作业</h3>
<div class="outline-text-3" id="text-org41f5a30">
<pre class="example" id="org326c807">
jobs

-l 查看作业的 PID
-n 只列出上次 shell 发出的通知后改变了状态的作业
-p 只列出作业的 PID
-r 只列出运行中的作业
-s 只列出已停止的作业

[1]+ ...   带➕的作业是默认作业
[2]- ...   带➖的作业是下一个默认作业
</pre>
</div>
</div>
<div id="outline-container-org24f3ee0" class="outline-3">
<h3 id="org24f3ee0">重启停止的作业</h3>
<div class="outline-text-3" id="text-org24f3ee0">
<ul class="org-ul">
<li>bg 作业号<br></li>
<li>fg 作业号<br></li>
</ul>
</div>
</div>
<div id="outline-container-orgedde966" class="outline-3">
<h3 id="orgedde966">杀死作业</h3>
<div class="outline-text-3" id="text-orgedde966">
<p>
kill -9 进程号<br>
</p>
</div>
</div>
</div>
<div id="outline-container-orgb1125f8" class="outline-2">
<h2 id="orgb1125f8">调整谦让度</h2>
<div class="outline-text-2" id="text-orgb1125f8">
<p>
调度优先级是个整数值，从 -20（最高优先级）到 -19（最低优先级）。默认情况下，bash shell 以优先级 0 来启动所有进程。<br>
</p>
</div>
<div id="outline-container-org8da6251" class="outline-3">
<h3 id="org8da6251">nice 命令</h3>
<div class="outline-text-3" id="text-org8da6251">
<p>
nice 命令允许你设置命令启动时的调度优先级。<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">nice -n 10 ./test.sh &gt; test.out &amp;
</pre>
</div>

<p>
必须将 nice 命令和要启动的命令放在同一行中，而且 nice 命令只会让脚本以更低的优先级运行。<br>
</p>
</div>
</div>
<div id="outline-container-orgc932d55" class="outline-3">
<h3 id="orgc932d55">renice 命令</h3>
<div class="outline-text-3" id="text-orgc932d55">
<p>
指定已运行进程的 PID 来改变它的优先级。<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">renice -n 10 -p 5505
ps -p 5505 -o pid,ppid,ni,cmd
</pre>
</div>

<p>
限制：<br>
</p>

<ul class="org-ul">
<li>只能对属于你的进程执行 renice<br></li>
<li>只能降低进程的优先级<br></li>
<li>root 用户可以通过 renice 来任意调整进程的优先级<br></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga6ec09f" class="outline-2">
<h2 id="orga6ec09f">定时运行作业</h2>
<div class="outline-text-2" id="text-orga6ec09f">
</div>
<div id="outline-container-orgfba1da4" class="outline-3">
<h3 id="orgfba1da4">用 at 命令来计划执行作业</h3>
<div class="outline-text-3" id="text-orgfba1da4">
<pre class="example" id="org41ca026">
at [-f filename] time

-q 指定不同的队列字母
-M 屏蔽作业产生的输出信息
</pre>

<p>
时间格式网上查。<br>
</p>

<p>
at 命令默认利用 sendmail 应用程序来发送输出，如果系统中没有安装 sendmail，需要提前在脚本中对 STDOUT 和 STDERR 进行重定向。<br>
</p>

<ul class="org-ul">
<li>atq 命令查看正在等待的作业<br></li>
<li>atrm 命令来删除等待中的作业，只要指定 atq 命令显示的作业号就好了<br></li>
</ul>
</div>
</div>
<div id="outline-container-org61dda68" class="outline-3">
<h3 id="org61dda68">用 corn 命令来计划执行作业</h3>
<div class="outline-text-3" id="text-org61dda68">
</div>
<div id="outline-container-org8c34757" class="outline-4">
<h4 id="org8c34757">crontab</h4>
<div class="outline-text-4" id="text-org8c34757">
<p>
Linux 提供了 crontab 命令来处理 cron 时间表。<br>
</p>

<pre class="example" id="org17c8db3">
crontab

-l 列出已有的 cron 时间表
-e 添加 cron 时间表条目
</pre>
</div>
</div>
<div id="outline-container-org3ae88eb" class="outline-4">
<h4 id="org3ae88eb">使用预配置的 cron 脚本目录</h4>
<div class="outline-text-4" id="text-org3ae88eb">
<div class="org-src-container">
<pre class="src src-shell">ls /etc/cron.*ly
</pre>
</div>

<p>
将脚本复制在 <code>/etc/cron.daily</code> 目录，cron 就会每天执行它。<br>
</p>
</div>
</div>
<div id="outline-container-orgf543fdd" class="outline-4">
<h4 id="orgf543fdd">小技巧：如何设置一个在每个月的最后一天执行的命令？</h4>
<div class="outline-text-4" id="text-orgf543fdd">
<p>
常用的方法是加一条使用 date 命令的 if-then 语句来检查明天的日期是不是 01：<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">00 12 * * * if [<span style="color: #ff2afc; font-weight: bold;">`date +%d -d tomorrow`</span> = 01 ] ; <span style="color: #ff2afc; font-weight: bold;">then</span> ; command
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd6919e8" class="outline-4">
<h4 id="orgd6919e8">anacron 程序</h4>
<div class="outline-text-4" id="text-orgd6919e8">
<p>
如果 anacron 知道某个作业因为关机错过了执行时间，它会尽快运行该作业。<br>
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2023-01-26 00:01 Thu</p>
<p class="author">Author: Haoran Liu</p>
<p class="date">Created: 2023-01-28</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
