<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2023-02-03 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>时间与日期</title>
<meta name="author" content="L.M.haoran" />
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved." />
<meta name="generator" content="Org Mode" />
<link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
           <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
           <script type="module" src="static/js/main.js" defer></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">时间与日期</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org0e83042">time 包</a></li>
<li><a href="#orga1c77ca">Location</a>
<ul>
<li><a href="#org43fce76">Local 是如何做到表示本地时区的？</a></li>
<li><a href="#orgc2fae08">获得特定时区的实例</a></li>
<li><a href="#org871c480">总结</a></li>
</ul>
</li>
<li><a href="#org47423fe">Time</a>
<ul>
<li><a href="#orged0fdee">常用函数或方法</a>
<ul>
<li><a href="#org9ba08fe">零值的判断</a></li>
<li><a href="#org3359c81">与 Unix 时间戳的转换</a></li>
<li><a href="#org736e8a8">格式化和解析</a>
<ul>
<li><a href="#orge5e623b">解析</a></li>
<li><a href="#org26cece2">为什么是 2006-01-02 15:04:05</a></li>
<li><a href="#org1b46f99">格式化</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8a927bc">Duration</a></li>
<li><a href="#org3f47b7a">Timer 和 Ticker</a>
<ul>
<li><a href="#org764fac6">Timer</a>
<ul>
<li><a href="#org1d81bb1">内部源码</a></li>
<li><a href="#orgb25dd97">相关函数与方法</a></li>
</ul>
</li>
<li><a href="#org74fe38a">Ticker 相关函数与方法</a></li>
</ul>
</li>
<li><a href="#org30b2d6f">Weekday 和 Month</a></li>
<li><a href="#orgaf35c1f">简单点，常用方法：</a></li>
</ul>
</div>
</div>

<div id="outline-container-org0e83042" class="outline-2">
<h2 id="org0e83042">time 包</h2>
<div class="outline-text-2" id="text-org0e83042">
<p>
Go 语言通过标准库 time 包处理日期和时间相关的问题。<br>
</p>

<p>
time 包提供了时间的显示和计量用的功能。日历的计算采用的是公历。提供的主要类型如下：<br>
</p>
</div>
</div>
<div id="outline-container-orga1c77ca" class="outline-2">
<h2 id="orga1c77ca">Location</h2>
<div class="outline-text-2" id="text-orga1c77ca">
<p>
代表一个地区，并表示该地区所在的时区（可能多个）。Location 通常代表地理位置的偏移，比如 CEST 和 CET 表示中欧。<br>
</p>

<p>
不同国家（有时甚至是同一个国家内的不同地区）使用不同的时区。对于要输入和输出时间的程序来说，必须对系统所处的时区加以考虑。Go 语言使用 Location 来表示地区相关的时区，一个 Location 可能表示多个时区。<br>
</p>

<p>
time 包提供了 Location 的两个实例：Local 和 UTC。Local 代表当前系统本地时区；UTC 代表通用协调时间，也就是零时区。time 包默认（为显示提供时区）使用 UTC 时区。<br>
</p>
</div>
<div id="outline-container-org43fce76" class="outline-3">
<h3 id="org43fce76">Local 是如何做到表示本地时区的？</h3>
<div class="outline-text-3" id="text-org43fce76">
<p>
时区信息既浩繁又多变，Unix 系统以标准格式存于文件中，这些文件位于 /usr/share/zoneinfo，而本地时区可以通过 /etc/localtime 获取，这是一个符号链接，指向 /usr/share/zoneinfo 中某一个时区。比如我本地电脑指向的是：/usr/share/zoneinfo/Asia/Shanghai。<br>
</p>

<p>
因此，在初始化 Local 时，通过读取 /etc/localtime 可以获取到系统本地时区。<br>
</p>

<p>
当然，如果设置了环境变量 TZ，则会优先使用它。<br>
</p>

<p>
相关代码：<br>
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #83a598;">tz</span>, <span style="color: #83a598;">ok</span> := syscall.<span style="color: #b8bb26;">Getenv</span>(<span style="color: #b8bb26;">"TZ"</span>)
<span style="color: #fb4934;">switch</span> {
<span style="color: #fb4934;">case</span> <span style="color: #ebdbb2; font-weight: bold;">!</span>ok:
    <span style="color: #83a598;">z</span>, <span style="color: #83a598;">err</span> := <span style="color: #b8bb26;">loadZoneFile</span>(<span style="color: #b8bb26;">""</span>, <span style="color: #b8bb26;">"/etc/localtime"</span>)
    <span style="color: #fb4934;">if</span> err == <span style="color: #d3869b;">nil</span> {
        localLoc = *z
        localLoc.name = <span style="color: #b8bb26;">"Local"</span>
        <span style="color: #fb4934;">return</span>
    }
<span style="color: #fb4934;">case</span> tz != <span style="color: #b8bb26;">""</span> &amp;&amp; tz != <span style="color: #b8bb26;">"UTC"</span>:
    <span style="color: #fb4934;">if</span> <span style="color: #83a598;">z</span>, <span style="color: #83a598;">err</span> := <span style="color: #b8bb26;">loadLocation</span>(tz); err == <span style="color: #d3869b;">nil</span> {
        localLoc = *z
        <span style="color: #fb4934;">return</span>
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc2fae08" class="outline-3">
<h3 id="orgc2fae08">获得特定时区的实例</h3>
<div class="outline-text-3" id="text-orgc2fae08">
<p>
函数 LoadLocation 可以根据名称获取特定时区的实例。函数声明如下：<br>
</p>

<p>
func LoadLocation(name string) (*Location, error)<br>
</p>

<p>
如果 name 是 “” 或 “UTC”，返回 UTC；如果 name 是 “Local”，返回 Local；否则 name 应该是 IANA 时区数据库里有记录的地点名（该数据库记录了地点和对应的时区），如 “America/New_York”。<br>
</p>

<p>
LoadLocation 函数需要的时区数据库可能不是所有系统都提供，特别是非 Unix 系统。此时 LoadLocation 会查找环境变量 ZONEINFO 指定目录或解压该变量指定的 zip 文件（如果有该环境变量）；然后查找 Unix 系统的惯例时区数据安装位置，最后查找 $GOROOT/lib/time/zoneinfo.zip。<br>
</p>

<p>
可以在 Unix 系统下的 /usr/share/zoneinfo 中找到所有的名称。<br>
</p>
</div>
</div>
<div id="outline-container-org871c480" class="outline-3">
<h3 id="org871c480">总结</h3>
<div class="outline-text-3" id="text-org871c480">
<p>
通常，我们使用 time.Local 即可，偶尔可能会需要使用 UTC。在解析时间时，心中一定记得有时区这么回事。当你发现时间出现莫名的情况时，很可能是因为时区的问题，特别是当时间相差 8 小时时。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org47423fe" class="outline-2">
<h2 id="org47423fe">Time</h2>
<div class="outline-text-2" id="text-org47423fe">
<p>
代表一个纳秒精度的时间点，是公历时间。<br>
</p>

<p>
程序中使用 Time 类型值来保存和传递时间，而不是指针，就是说，表示时间的变量和字段，应为 time.Time 类型，而不是 *time.Time 类型。一个 Time 类型值可以被多个 go 协程同时使用。时间点可以使用 Before、After 和 Equal 方法进行比较。Sub 方法让两个时间点相减，生成一个 Deration 类型值（代表时间段）。Add 方法给一个时间点加上一个时间段，生成一个新的 Time 类型时间点。<br>
</p>

<p>
Time 零值代表时间点 January 1, year 1, 00:00:00 000000000 UTC。因为本时间点一般不会出现在使用中，IsZero 方法提供了检验时间是否是显式格式化的一个简单途径。<br>
</p>

<p>
没一个 Time 都具有一个地点信息（即对应地点的时区信息），当计算时间的表示格式时，如 Format、Hour 和 Year 等方法，都会考虑该信息。Local、UTC 和 In 方法返回一个指定时区（但指向同一时间点）的 Time。修改地点 / 时区信息只是会改变其表示；不会修改被表示的时间点，因此也不会影响其计算。<br>
</p>

<p>
通过 <code>==</code> 比较 Time 时，Location 信息也会参与比较，因此 Time 不应该作为 map 的 key。<br>
</p>
</div>
<div id="outline-container-orged0fdee" class="outline-3">
<h3 id="orged0fdee">常用函数或方法</h3>
<div class="outline-text-3" id="text-orged0fdee">
</div>
<div id="outline-container-org9ba08fe" class="outline-4">
<h4 id="org9ba08fe">零值的判断</h4>
<div class="outline-text-4" id="text-org9ba08fe">
<p>
Time 的零值是 sec 和 nsec 都是 0，表示 1 年 1 月 1 日。<br>
</p>

<dl class="org-dl">
<dt>Time.IsZero</dt><dd>判断 Time 表示的时间是否是 0 值。<br></dd>
</dl>
</div>
</div>
<div id="outline-container-org3359c81" class="outline-4">
<h4 id="org3359c81">与 Unix 时间戳的转换</h4>
<div class="outline-text-4" id="text-org3359c81">
<dl class="org-dl">
<dt>time.Unix(sec, nsec int 64)</dt><dd>通过 Unix 时间戳生成 <code>time.Time</code> 实例。<br></dd>
<dt>time.Time.Unix()</dt><dd>得到 Unix 时间戳。<br></dd>
<dt>time.Time.UnixNano()</dt><dd>得到 Unix 时间戳的纳秒表示。<br></dd>
</dl>
</div>
</div>
<div id="outline-container-org736e8a8" class="outline-4">
<h4 id="org736e8a8">格式化和解析</h4>
<div class="outline-text-4" id="text-org736e8a8">
<ul class="org-ul">
<li>time.Parse<br></li>
<li>time.ParseInLocation<br></li>
<li>time.Time.Format<br></li>
</ul>
</div>
<div id="outline-container-orge5e623b" class="outline-5">
<h5 id="orge5e623b">解析</h5>
<div class="outline-text-5" id="text-orge5e623b">
<p>
对于解析，要特别注意时区问题，否则很容易出 bug。比如：<br>
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #83a598;">t</span>, <span style="color: #83a598;">_</span> := time.<span style="color: #b8bb26;">Parse</span>(<span style="color: #b8bb26;">"2006-01-02 15:04:05"</span>, <span style="color: #b8bb26;">"2016-06-13 09:14:00"</span>)
fmt.<span style="color: #b8bb26;">Println</span>(time.<span style="color: #b8bb26;">Now</span>().<span style="color: #b8bb26;">Sub</span>(t).<span style="color: #b8bb26;">Hours</span>())
</pre>
</div>

<p>
2016-06-13 09:14:00 这个时间可能是参数传递过来的。这段代码的结果跟预期的不一样。<br>
</p>

<p>
原因是 time.Now() 的时区是 time.Local，而 time.Parse 解析出来的时区却是 time.UTC（可以通过 Time.Location() 函数知道是哪个时区）。在中国，它们相差 8 小时。<br>
</p>

<p>
所以，一般的，我们应该总是使用 time.ParseInLocation 来解析时间，并给第三个参数传递 time.Local。<br>
</p>
</div>
</div>
<div id="outline-container-org26cece2" class="outline-5">
<h5 id="org26cece2">为什么是 2006-01-02 15:04:05</h5>
<div class="outline-text-5" id="text-org26cece2">
<p>
可能你已经注意到：2006-01-02 15:04:05 这个字符串了。没错，这是固定写法，类似于其他语言中 Y-m-d H:i:s 等。为什么采用这种形式？又为什么是这个时间点而不是其他时间点？<br>
</p>

<ul class="org-ul">
<li>官方说，使用具体的时间，比使用 Y-m-d H:i:s 更容易理解和记忆；这么一说还真是 ~<br></li>
<li>而选择这个时间点，也是出于好记的考虑，官方的例子：Mon Jan 2 15:04:05 MST 2006，另一种形式 01/02 03:04:05PM '06 -0700，对应是 1、2、3、4、5、6、7；常见的格式：2006-01-02 15:04:05，很好记：2006 年 1 月 2 日 3 点 4 分 5 秒 ~<br></li>
</ul>
</div>
</div>
<div id="outline-container-org1b46f99" class="outline-5">
<h5 id="org1b46f99">格式化</h5>
<div class="outline-text-5" id="text-org1b46f99">
<p>
时间格式化输出，使用 Format 方法，layout 参数和 Parse 的一样。Time.String() 方法使用了 2006-01-02 15:04:05.999999999 -0700 MST 这种 layout。<br>
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org8a927bc" class="outline-2">
<h2 id="org8a927bc">Duration</h2>
<div class="outline-text-2" id="text-org8a927bc">
<p>
代表两个时间点之间经过的时间，以纳秒为单位。可表示的最长时间段大约 290 年，也就是说如果两个时间点相差超过 290 年，会返回 290 年，也就是 minDuration(-1 &lt;&lt; 63) 或 maxDuration(1 &lt;&lt; 63 - 1)。<br>
</p>

<p>
类型定义：type Duration int64。<br>
</p>

<p>
将 Duration 类型直接输出时，因为实现了 fmt.Stringer 接口，会输出人类友好的可读形式，如：72h3m0.5s。<br>
</p>
</div>
</div>
<div id="outline-container-org3f47b7a" class="outline-2">
<h2 id="org3f47b7a">Timer 和 Ticker</h2>
<div class="outline-text-2" id="text-org3f47b7a">
<p>
定时器相关类型，定时器是进程规划自己在未来某一时刻接获通知的一种机制。<br>
</p>

<p>
Timer（到达指定时间触发且只触发一次）和 Ticker（间隔特定时间触发）。<br>
</p>
</div>
<div id="outline-container-org764fac6" class="outline-3">
<h3 id="org764fac6">Timer</h3>
<div class="outline-text-3" id="text-org764fac6">
</div>
<div id="outline-container-org1d81bb1" class="outline-4">
<h4 id="org1d81bb1">内部源码</h4>
</div>
<div id="outline-container-orgb25dd97" class="outline-4">
<h4 id="orgb25dd97">相关函数与方法</h4>
</div>
</div>
<div id="outline-container-org74fe38a" class="outline-3">
<h3 id="org74fe38a">Ticker 相关函数与方法</h3>
</div>
</div>
<div id="outline-container-org30b2d6f" class="outline-2">
<h2 id="org30b2d6f">Weekday 和 Month</h2>
<div class="outline-text-2" id="text-org30b2d6f">
<p>
这两个类型的原始类型都是 int，定义它们，语义更明确，同时，实现 fmt.Stringer 接口，方便输出。<br>
</p>
</div>
</div>

<div id="outline-container-orgaf35c1f" class="outline-2">
<h2 id="orgaf35c1f">简单点，常用方法：</h2>
<div class="outline-text-2" id="text-orgaf35c1f">
<dl class="org-dl">
<dt>time.Now()</dt><dd>获取当前时间<br></dd>
<dt>time.Parse(layout, value string)(Time, error)</dt><dd>解析一个格式化时间字符串并返回代表的时间，layout 定义参考时间<br></dd>
<dt>time.ParseInLocation(layout, value string, loc *Location) (Time, error)</dt><dd>使用模板在对应时区转化为time.time类型 ，layout定义参考时间，value字符串，Location 设置loc<br></dd>
<dt>time.Unix(sec int64,nsec int64) Time</dt><dd>时间戳转换本地时间 sec 秒 nsec 纳秒<br></dd>
<dt>t.Location() *Location</dt><dd>返回某时间的地点和时区信息<br></dd>
<dt>t.Unix()</dt><dd>时间转换时间戳<br></dd>
<dt>t.Date() (year int, month Month, day int)</dt><dd>返回时间点 t 对应的年月日<br></dd>
<dt>t.Clock() (hour,min,sec int)</dt><dd>返回t对应的那一天的时，分，秒<br></dd>
<dt>t.Year() int</dt><dd>返回 t 时间的对应年份<br></dd>
<dt>t.Month() Month</dt><dd>返回时间点 t 对应的第几个月<br></dd>
<dt>t.YearDay() int</dt><dd>返回时间点 t 对应的第几天<br></dd>
<dt>t.Day() int</dt><dd>返回时间点 t 对应那一月的第几天<br></dd>
<dt>t.Weekday()</dt><dd>时间点 t 对应的那一周的周几<br></dd>
<dt>t.Hour() int</dt><dd>返回 t 对应的那一天的第几个小时 [1 - 23]<br></dd>
<dt>t.Minute() int</dt><dd>返回对应那一小时的第几分钟 [0, 59]<br></dd>
<dt>t.Second() int</dt><dd>返回 t 对应的那一分钟的第几秒 [0, 59]<br></dd>
<dt>t.Format(layout string)</dt><dd>格式化时间输出<br></dd>
<dt>t.String() string</dt><dd>返回特定格式化时间 2006-01-02 15:04:05.999999999 -0700 MST<br></dd>
</dl>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2021-11-04 17:11 Thu</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2023-02-03</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
