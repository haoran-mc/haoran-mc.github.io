<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-09-29 三 22:54 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>VECTOR</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">VECTOR</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org40a842b">vector的定义</a></li>
<li><a href="#org6c106f6">vector容器内元素的访问</a></li>
<li><a href="#orgd3a670c">vector常用函数</a>
<ul>
<li><a href="#org5e97fec">push_back</a></li>
<li><a href="#org5f83b84">pop_back</a></li>
<li><a href="#orgc0dfaee">size</a></li>
<li><a href="#org4a04f83">clear</a></li>
<li><a href="#org0bcbb29">insert</a></li>
<li><a href="#org9b4e1e7">erase</a></li>
<li><a href="#org8795054">reserve</a></li>
<li><a href="#org2830b48">resize</a></li>
<li><a href="#org9a956d7">begin</a></li>
<li><a href="#orgb03168e">end</a></li>
<li><a href="#org8740523">rbegin</a></li>
<li><a href="#orga200a16">rend</a></li>
<li><a href="#org9dfef45">front</a></li>
<li><a href="#orgb606025">back</a></li>
<li><a href="#org5d62a5c">unique</a></li>
</ul>
</li>
<li><a href="#orge756090">vector与结构体</a></li>
<li><a href="#orgcd270a4">vec2 = vec1</a></li>
</ul>
</div>
</div>

<div id="outline-container-org40a842b" class="outline-2">
<h2 id="org40a842b">vector的定义</h2>
<div class="outline-text-2" id="text-org40a842b">
<p>
vector翻译为映射，可以将任何基本类型(包括STL容器)映射到任何基本类型(包括STL容器)
</p>
<div class="org-src-container">
<pre class="src src-C++">vector&lt;T&gt; vec1;                 /+创建了vec1+/
vector&lt;T&gt; vec2(vec1);           /+创建的vec2中包含vec1中所有副本+/
vector&lt;T&gt; vec2 = vec1;          /+创建的vec2中包含vec1中所有副本+/
vector&lt;T&gt; vec3(n, val);         /+创建的vec3中包含了n个重复的元素，每个元素的值都是val+/
vector&lt;T&gt; vec4(n);              /+创建的vec4中包含了n个重复地执行了值初始化的对象+/
vector&lt;T&gt; vec5{a, b, c ...};    /+创建的vec5中包含了初始化个树的对象，每个元素被赋予相应的初始值+/
vector&lt;T&gt; vec5 = {a, b, c ...}; /+创建的vec5中包含了初始化个树的对象，每个元素被赋予相应的初始值+/
</pre>
</div>
</div>
</div>
<div id="outline-container-org6c106f6" class="outline-2">
<h2 id="org6c106f6">vector容器内元素的访问</h2>
<div class="outline-text-2" id="text-org6c106f6">
<ul class="org-ul">
<li>下标访问</li>
<li>迭代器访问</li>
</ul>
</div>
</div>
<div id="outline-container-orgd3a670c" class="outline-2">
<h2 id="orgd3a670c">vector常用函数</h2>
<div class="outline-text-2" id="text-orgd3a670c">
</div>
<div id="outline-container-org5e97fec" class="outline-3">
<h3 id="org5e97fec">push_back</h3>
<div class="outline-text-3" id="text-org5e97fec">
<ul class="org-ul">
<li>push_back(x)</li>
<li>时间复杂度O(1)</li>
</ul>
</div>
</div>
<div id="outline-container-org5f83b84" class="outline-3">
<h3 id="org5f83b84">pop_back</h3>
<div class="outline-text-3" id="text-org5f83b84">
<ul class="org-ul">
<li>pop_back()</li>
<li>时间复杂度O(1)</li>
</ul>
</div>
</div>
<div id="outline-container-orgc0dfaee" class="outline-3">
<h3 id="orgc0dfaee">size</h3>
<div class="outline-text-3" id="text-orgc0dfaee">
<ul class="org-ul">
<li>vi.size()</li>
<li><p>
时间复杂度O(1)
</p>
<div class="org-src-container">
<pre class="src src-C++">#include &lt;cstdio&gt;
#include &lt;vector&gt;
using namespace std;
int main() {
	vector&lt;int&gt; vec;
	vec.push_back(1);
	vec.push_back(2);
	vec.push_back(3);
	vec.push_back(4);
	vec.push_back(5);
	vec.push_back(6);
	printf("%d\n", (int)vec.size());
	//输出6
	return 0;
}
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org4a04f83" class="outline-3">
<h3 id="org4a04f83">clear</h3>
<div class="outline-text-3" id="text-org4a04f83">
<ul class="org-ul">
<li>vi.clear()</li>
<li><p>
时间复杂度O(N)
</p>
<div class="org-src-container">
<pre class="src src-C++">#include &lt;cstdio&gt;
#include &lt;vector&gt;
using namespace std;
int main() {
	vector&lt;int&gt; vec;
	int n;
	scanf("%d", &amp;n);
	while (n--) {
		int num;
		scanf("%d", &amp;num);
		vec.push_back(num);
	}
	for (auto it = vec.begin(); it != vec.end(); it++) {
		if (*it == 0) {
			vec.erase(it);
			it--;
		}
		else if (*it == 7) {
			vec.clear();
			break;
		}

		else
			printf("%d ", *it);
	}
	printf("\n%d\n", (int)(vec.end() - vec.begin()));
	return 0;
}
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org0bcbb29" class="outline-3">
<h3 id="org0bcbb29">insert</h3>
<div class="outline-text-3" id="text-org0bcbb29">
<ul class="org-ul">
<li>insert(it, x)</li>
<li>时间复杂度O(N)</li>
</ul>
</div>
</div>
<div id="outline-container-org9b4e1e7" class="outline-3">
<h3 id="org9b4e1e7">erase</h3>
<div class="outline-text-3" id="text-org9b4e1e7">
<ul class="org-ul">
<li>vi.erase(vi.begin() + 3);</li>
<li>时间复杂度O(N)</li>
<li>vi.erase(vi.begin(), vi.end());</li>
<li><p>
时间复杂度O(N)
</p>
<div class="org-src-container">
<pre class="src src-C++">//输入10 1 0 2 3 4 5 6 7 8 9
#include &lt;cstdio&gt;
#include &lt;vector&gt;
using namespace std;
int main() {
	vector&lt;int&gt; vec;
	int n;
	scanf("%d", &amp;n);
	while (n--) {
		int num;
		scanf("%d", &amp;num);
		vec.push_back(num);
	}
	for (auto it = vec.begin(); it != vec.end(); it++) {
		if (*it == 0) {
			vec.erase(it);
			//别忘了it--
			it--;
		}
		else if (*it == 7) {
			vec.clear();
			break;
		}

		else
			printf("%d ", *it);
	}
	printf("\n%d\n", (int)(vec.end() - vec.begin()));
	return 0;
}
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org8795054" class="outline-3">
<h3 id="org8795054">reserve</h3>
<div class="outline-text-3" id="text-org8795054">
<ul class="org-ul">
<li><a id="org84adad2"></a></li>
<li><p>
<a href="#org640ac3b">1</a>
</p>

<p>
vector容器有size与capacity两个概念，可以通过size()与capacity()方法分别获得vector的size与capacity值。相应的，vector提供了两个方法分别对size和capacity擦作，resize方法和reserve方法
</p>

<p>
capacity是vector的最大使用空间(虽然说vector是变长数组，但在某个时间点下，数组是有大小的；当这个数组满了之后，如果继续添加元素，vector就会动态开辟内存空间，新开辟空间的大小是capacity/2，所以说vector是变长数组)，而size是当前vector的使用大小
</p>
<div class="org-src-container">
<pre class="src src-C++">...
void push_back(_Ty&amp;&amp; _Val)
...
if (this-&gt;_Mylast == this-&gt;_Myend)
_Reserve(1);
...

void _Reserve(size_type _Count) {	// ensure room for _Count new elements, grow exponentially
	size_type _Size = size();
	if (max_size() - _Count &lt; _Size)
		_Xlen();
	else if ((_Size += _Count) &lt;= capacity())
		;
	else
		reserve(_Grow_to(_Size));
}

size_type _Grow_to(size_type _Count) const {	// grow by 50% or at least to _Count
	size_type _Capacity = capacity();

	_Capacity = max_size() - _Capacity / 2 &lt; _Capacity
		? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
	if (_Capacity &lt; _Count)
		_Capacity = _Count;
	return (_Capacity);
}
</pre>
</div>

<ol class="org-ol">
<li>reserve方法被用来重新分配vector的容量大小</li>
<li>只有当所申请的容量大小大于vector的当前容量size时，才会重新为vector分配空间</li>
<li>reserve方法对于vector的size没有任何影响</li>

<li>resize方法可以改变vector中元素的个数，但不会改变vector的容量</li>
<li>如果resize指定修改的vector的大小n小于当前vector尺寸，那么resize会删除vector中多于n的元素，使vector的大小变为n</li>
<li>如果resize指定修改的vector的大小n大于当前vector尺寸但小于vector的容量，会在vector后面插入适量的元素，使得vector的大小满足n，如果指定了初始化值，则会把新插入的元素初始化为指定的元素值</li>
<li>如果resize指定修改的vector的大小n大于vector的当前容量，会为vector重新分配内存空间</li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org2830b48" class="outline-3">
<h3 id="org2830b48">resize</h3>
<div class="outline-text-3" id="text-org2830b48">
<ul class="org-ul">
<li><a id="org640ac3b"></a></li>
<li><a href="#org84adad2">1</a></li>
</ul>
</div>
</div>
<div id="outline-container-org9a956d7" class="outline-3">
<h3 id="org9a956d7">begin</h3>
</div>
<div id="outline-container-orgb03168e" class="outline-3">
<h3 id="orgb03168e">end</h3>
</div>
<div id="outline-container-org8740523" class="outline-3">
<h3 id="org8740523">rbegin</h3>
<div class="outline-text-3" id="text-org8740523">
<p>
反向迭代器
</p>
</div>
</div>
<div id="outline-container-orga200a16" class="outline-3">
<h3 id="orga200a16">rend</h3>
</div>
<div id="outline-container-org9dfef45" class="outline-3">
<h3 id="org9dfef45">front</h3>
</div>
<div id="outline-container-orgb606025" class="outline-3">
<h3 id="orgb606025">back</h3>
</div>
<div id="outline-container-org5d62a5c" class="outline-3">
<h3 id="org5d62a5c">unique</h3>
<div class="outline-text-3" id="text-org5d62a5c">
<div class="org-src-container">
<pre class="src src-C++">#include &lt;iostream&gt;
#include &lt;cassert&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iterator&gt;
using namespace std;
int main() {
	cout &lt;&lt; "Illustrating the generic unique algorithm." &lt;&lt; endl;
	const int N = 11;
	int array1[N] = {1, 2, 0, 3, 3, 0, 7, 7, 7, 0, 8};
	vector&lt;int&gt; vec;
	for (int i = 0; i &lt; N; ++i)
		vec.push_back(array1[i]);

	vector&lt;int&gt;::iterator new_end;
	/*"删除"相邻的重复元素*/
	new_end=unique(vec.begin(),vec.end());
	assert(vec.size() == N);

	/*删除(真正的删除)重复的元素*/
	vec.erase(new_end,vec.end());
	copy(vec.begin(), vec.end(), ostream_iterator&lt;int&gt;(cout," "));
	cout &lt;&lt; endl;
	return 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orge756090" class="outline-2">
<h2 id="orge756090">vector与结构体</h2>
<div class="outline-text-2" id="text-orge756090">
<div class="org-src-container">
<pre class="src src-C++">struct Node {
	int A;
	int B;
	int C;
};
vector&lt;Node&gt; node;

Node x;
scanf("%d", &amp;x.A);
scanf("%d", &amp;x.B);
scanf("%d", &amp;x.C);
node.push_back(x);
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcd270a4" class="outline-2">
<h2 id="orgcd270a4">vec2 = vec1</h2>
<div class="outline-text-2" id="text-orgcd270a4">
<div class="org-src-container">
<pre class="src src-C++">#include &lt;cstdio&gt;
#include &lt;vector&gt;
using namespace std;
int main() {
	vector&lt;int&gt; vec1;
	vector&lt;int&gt; vec2;
	for (int i = 0; i &lt; 25; i++)
		vec1.push_back(i);

	vec2 = vec1;    /* vec可以直接等于!!! */
	for (auto it = vec2.begin(); it != vec2.end(); it++)
		printf("%d ", *it);

	printf("\n");
	return 0;
}
</pre>
</div>
</div>
</div>
</div>
</body>
</html>
