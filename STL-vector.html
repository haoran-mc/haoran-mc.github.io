<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-09-23 四 15:49 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>VECTOR</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">

                <link rel="stylesheet" href="css/style.css" type="text/css"  />
                <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
                <script type="module" src="js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">VECTOR</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org0adf259">vector的定义</a></li>
<li><a href="#org49c6acb">vector容器内元素的访问</a></li>
<li><a href="#org7c43704">vector常用函数</a>
<ul>
<li><a href="#orgf61bd6f">push_back</a></li>
<li><a href="#org11c7989">pop_back</a></li>
<li><a href="#orgcd6ab0a">size</a></li>
<li><a href="#org5b85a90">clear</a></li>
<li><a href="#orgcd4f43e">insert</a></li>
<li><a href="#org0febbca">erase</a></li>
<li><a href="#org2ff66f4">reserve</a></li>
<li><a href="#org4a33e88">resize</a></li>
<li><a href="#orgcb59e0b">begin</a></li>
<li><a href="#orgf74009c">end</a></li>
<li><a href="#orgc1230bd">rbegin</a></li>
<li><a href="#org980c2fa">rend</a></li>
<li><a href="#orgcf75dac">front</a></li>
<li><a href="#org9f42a98">back</a></li>
<li><a href="#org1ce7c80">unique</a></li>
</ul>
</li>
<li><a href="#org01daaed">vector与结构体</a></li>
<li><a href="#org614208a">vec2 = vec1</a></li>
</ul>
</div>
</div>

<div id="outline-container-org0adf259" class="outline-2">
<h2 id="org0adf259">vector的定义</h2>
<div class="outline-text-2" id="text-org0adf259">
<p>
vector翻译为映射，可以将任何基本类型(包括STL容器)映射到任何基本类型(包括STL容器)
</p>
<div class="org-src-container">
<pre class="src src-C++">vector&lt;T&gt; vec1;                 /+创建了vec1+/
vector&lt;T&gt; vec2(vec1);           /+创建的vec2中包含vec1中所有副本+/
vector&lt;T&gt; vec2 = vec1;          /+创建的vec2中包含vec1中所有副本+/
vector&lt;T&gt; vec3(n, val);         /+创建的vec3中包含了n个重复的元素，每个元素的值都是val+/
vector&lt;T&gt; vec4(n);              /+创建的vec4中包含了n个重复地执行了值初始化的对象+/
vector&lt;T&gt; vec5{a, b, c ...};    /+创建的vec5中包含了初始化个树的对象，每个元素被赋予相应的初始值+/
vector&lt;T&gt; vec5 = {a, b, c ...}; /+创建的vec5中包含了初始化个树的对象，每个元素被赋予相应的初始值+/
</pre>
</div>
</div>
</div>
<div id="outline-container-org49c6acb" class="outline-2">
<h2 id="org49c6acb">vector容器内元素的访问</h2>
<div class="outline-text-2" id="text-org49c6acb">
<ul class="org-ul">
<li>下标访问</li>
<li>迭代器访问</li>
</ul>
</div>
</div>
<div id="outline-container-org7c43704" class="outline-2">
<h2 id="org7c43704">vector常用函数</h2>
<div class="outline-text-2" id="text-org7c43704">
</div>
<div id="outline-container-orgf61bd6f" class="outline-3">
<h3 id="orgf61bd6f">push_back</h3>
<div class="outline-text-3" id="text-orgf61bd6f">
<ul class="org-ul">
<li>push_back(x)</li>
<li>时间复杂度O(1)</li>
</ul>
</div>
</div>
<div id="outline-container-org11c7989" class="outline-3">
<h3 id="org11c7989">pop_back</h3>
<div class="outline-text-3" id="text-org11c7989">
<ul class="org-ul">
<li>pop_back()</li>
<li>时间复杂度O(1)</li>
</ul>
</div>
</div>
<div id="outline-container-orgcd6ab0a" class="outline-3">
<h3 id="orgcd6ab0a">size</h3>
<div class="outline-text-3" id="text-orgcd6ab0a">
<ul class="org-ul">
<li>vi.size()</li>
<li><p>
时间复杂度O(1)
</p>
<div class="org-src-container">
<pre class="src src-C++">#include &lt;cstdio&gt;
#include &lt;vector&gt;
using namespace std;
int main() {
  vector&lt;int&gt; vec;
  vec.push_back(1);
  vec.push_back(2);
  vec.push_back(3);
  vec.push_back(4);
  vec.push_back(5);
  vec.push_back(6);
  printf("%d\n", (int)vec.size());
  //输出6
  return 0;
}
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org5b85a90" class="outline-3">
<h3 id="org5b85a90">clear</h3>
<div class="outline-text-3" id="text-org5b85a90">
<ul class="org-ul">
<li>vi.clear()</li>
<li><p>
时间复杂度O(N)
</p>
<div class="org-src-container">
<pre class="src src-C++">#include &lt;cstdio&gt;
#include &lt;vector&gt;
using namespace std;
int main() {
  vector&lt;int&gt; vec;
  int n;
  scanf("%d", &amp;n);
  while (n--) {
    int num;
    scanf("%d", &amp;num);
    vec.push_back(num);
  }
  for (auto it = vec.begin(); it != vec.end(); it++) {
    if (*it == 0) {
      vec.erase(it);
      it--;
    }
    else if (*it == 7) {
      vec.clear();
      break;
    }

    else
      printf("%d ", *it);
  }
  printf("\n%d\n", (int)(vec.end() - vec.begin()));
  return 0;
}
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgcd4f43e" class="outline-3">
<h3 id="orgcd4f43e">insert</h3>
<div class="outline-text-3" id="text-orgcd4f43e">
<ul class="org-ul">
<li>insert(it, x)</li>
<li>时间复杂度O(N)</li>
</ul>
</div>
</div>
<div id="outline-container-org0febbca" class="outline-3">
<h3 id="org0febbca">erase</h3>
<div class="outline-text-3" id="text-org0febbca">
<ul class="org-ul">
<li>vi.erase(vi.begin() + 3);</li>
<li>时间复杂度O(N)</li>
<li>vi.erase(vi.begin(), vi.end());</li>
<li><p>
时间复杂度O(N)
</p>
<div class="org-src-container">
<pre class="src src-C++">//输入10 1 0 2 3 4 5 6 7 8 9
#include &lt;cstdio&gt;
#include &lt;vector&gt;
using namespace std;
int main() {
  vector&lt;int&gt; vec;
  int n;
  scanf("%d", &amp;n);
  while (n--) {
    int num;
    scanf("%d", &amp;num);
    vec.push_back(num);
  }
  for (auto it = vec.begin(); it != vec.end(); it++) {
    if (*it == 0) {
      vec.erase(it);
      //别忘了it--
      it--;
    }
    else if (*it == 7) {
      vec.clear();
      break;
    }

    else
      printf("%d ", *it);
  }
  printf("\n%d\n", (int)(vec.end() - vec.begin()));
  return 0;
}
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org2ff66f4" class="outline-3">
<h3 id="org2ff66f4">reserve</h3>
<div class="outline-text-3" id="text-org2ff66f4">
<ul class="org-ul">
<li><a id="org8f77b0c"></a></li>
<li><p>
<a href="#org0c30de9">1</a>
</p>

<p>
vector容器有size与capacity两个概念，可以通过size()与capacity()方法分别获得vector的size与capacity值。相应的，vector提供了两个方法分别对size和capacity擦作，resize方法和reserve方法
</p>

<p>
capacity是vector的最大使用空间(虽然说vector是变长数组，但在某个时间点下，数组是有大小的；当这个数组满了之后，如果继续添加元素，vector就会动态开辟内存空间，新开辟空间的大小是capacity/2，所以说vector是变长数组)，而size是当前vector的使用大小
</p>
<div class="org-src-container">
<pre class="src src-C++">...
void push_back(_Ty&amp;&amp; _Val)
...
if (this-&gt;_Mylast == this-&gt;_Myend)
_Reserve(1);
...

void _Reserve(size_type _Count) {	// ensure room for _Count new elements, grow exponentially
  size_type _Size = size();
  if (max_size() - _Count &lt; _Size)
    _Xlen();
  else if ((_Size += _Count) &lt;= capacity())
    ;
  else
    reserve(_Grow_to(_Size));
}

size_type _Grow_to(size_type _Count) const {	// grow by 50% or at least to _Count
  size_type _Capacity = capacity();

  _Capacity = max_size() - _Capacity / 2 &lt; _Capacity
    ? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
  if (_Capacity &lt; _Count)
    _Capacity = _Count;
  return (_Capacity);
}
</pre>
</div>

<ol class="org-ol">
<li>reserve方法被用来重新分配vector的容量大小</li>
<li>只有当所申请的容量大小大于vector的当前容量size时，才会重新为vector分配空间</li>
<li>reserve方法对于vector的size没有任何影响</li>

<li>resize方法可以改变vector中元素的个数，但不会改变vector的容量</li>
<li>如果resize指定修改的vector的大小n小于当前vector尺寸，那么resize会删除vector中多于n的元素，使vector的大小变为n</li>
<li>如果resize指定修改的vector的大小n大于当前vector尺寸但小于vector的容量，会在vector后面插入适量的元素，使得vector的大小满足n，如果指定了初始化值，则会把新插入的元素初始化为指定的元素值</li>
<li>如果resize指定修改的vector的大小n大于vector的当前容量，会为vector重新分配内存空间</li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org4a33e88" class="outline-3">
<h3 id="org4a33e88">resize</h3>
<div class="outline-text-3" id="text-org4a33e88">
<ul class="org-ul">
<li><a id="org0c30de9"></a></li>
<li><a href="#org8f77b0c">1</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgcb59e0b" class="outline-3">
<h3 id="orgcb59e0b">begin</h3>
</div>
<div id="outline-container-orgf74009c" class="outline-3">
<h3 id="orgf74009c">end</h3>
</div>
<div id="outline-container-orgc1230bd" class="outline-3">
<h3 id="orgc1230bd">rbegin</h3>
<div class="outline-text-3" id="text-orgc1230bd">
<p>
反向迭代器
</p>
</div>
</div>
<div id="outline-container-org980c2fa" class="outline-3">
<h3 id="org980c2fa">rend</h3>
</div>
<div id="outline-container-orgcf75dac" class="outline-3">
<h3 id="orgcf75dac">front</h3>
</div>
<div id="outline-container-org9f42a98" class="outline-3">
<h3 id="org9f42a98">back</h3>
</div>
<div id="outline-container-org1ce7c80" class="outline-3">
<h3 id="org1ce7c80">unique</h3>
<div class="outline-text-3" id="text-org1ce7c80">
<div class="org-src-container">
<pre class="src src-C++">#include &lt;iostream&gt;
#include &lt;cassert&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iterator&gt;
using namespace std;
int main() {
  cout &lt;&lt; "Illustrating the generic unique algorithm." &lt;&lt; endl;
  const int N = 11;
  int array1[N] = {1, 2, 0, 3, 3, 0, 7, 7, 7, 0, 8};
  vector&lt;int&gt; vec;
  for (int i = 0; i &lt; N; ++i)
    vec.push_back(array1[i]);

  vector&lt;int&gt;::iterator new_end;
  /*"删除"相邻的重复元素*/
  new_end=unique(vec.begin(),vec.end());
  assert(vec.size() == N);

  /*删除(真正的删除)重复的元素*/
  vec.erase(new_end,vec.end());
  copy(vec.begin(), vec.end(), ostream_iterator&lt;int&gt;(cout," "));
  cout &lt;&lt; endl;
  return 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org01daaed" class="outline-2">
<h2 id="org01daaed">vector与结构体</h2>
<div class="outline-text-2" id="text-org01daaed">
<div class="org-src-container">
<pre class="src src-C++">struct Node {
  int A;
  int B;
  int C;
};
vector&lt;Node&gt; node;

Node x;
scanf("%d", &amp;x.A);
scanf("%d", &amp;x.B);
scanf("%d", &amp;x.C);
node.push_back(x);
</pre>
</div>
</div>
</div>
<div id="outline-container-org614208a" class="outline-2">
<h2 id="org614208a">vec2 = vec1</h2>
<div class="outline-text-2" id="text-org614208a">
<div class="org-src-container">
<pre class="src src-C++">#include &lt;cstdio&gt;
#include &lt;vector&gt;
using namespace std;
int main() {
  vector&lt;int&gt; vec1;
  vector&lt;int&gt; vec2;
  for (int i = 0; i &lt; 25; i++)
    vec1.push_back(i);

  vec2 = vec1;    /* vec可以直接等于!!! */
  for (auto it = vec2.begin(); it != vec2.end(); it++)
    printf("%d ", *it);

  printf("\n");
  return 0;
}
</pre>
</div>
</div>
</div>
</div>
</body>
</html>
