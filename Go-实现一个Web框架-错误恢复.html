<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-12-25 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>错误恢复</title>
<meta name="author" content="L.M.haoran" />
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved." />
<meta name="generator" content="Org Mode" />
<link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
           <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
           <script type="module" src="static/js/main.js" defer></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">错误恢复</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org64644cf">panic</a></li>
<li><a href="#orgdd54d4f">defer</a></li>
<li><a href="#org7f1921e">recover</a></li>
<li><a href="#orgbf189e3">gee 的错误处理机制</a></li>
<li><a href="#org324a58b">使用 demo</a></li>
<li><a href="#orgc552e75">参考</a></li>
</ul>
</div>
</div>

<div id="outline-container-org64644cf" class="outline-2">
<h2 id="org64644cf">panic</h2>
<div class="outline-text-2" id="text-org64644cf">
<p>
go 语言中，比较常见的错误处理方法是返回 error，由调用者决定后续如何处理。但是如果是无法恢复的错误，可以手动触发 panic，当然如果在程序运行过程中出现了类似于数组越界的错误，panic 也会被触发。panic 会中止当前执行的程序，退出。<br>
</p>

<p>
下面是主动触发的例子：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">hello.go</span>
<span style="color: #e45649;">func</span> <span style="color: #a626a4;">main</span>() {
    fmt.<span style="color: #a626a4;">Println</span>(<span style="color: #50a14f;">"before panic"</span>)
    <span style="color: #a626a4;">panic</span>(<span style="color: #50a14f;">"crash"</span>)
    fmt.<span style="color: #a626a4;">Println</span>(<span style="color: #50a14f;">"after panic"</span>)
}
</pre>
</div>

<pre class="example" id="org1a0ffa1">
$ go run hello.go

before panic
panic: crash

goroutine 1 [running]:
main.main()
        ~/go_demo/hello/hello.go:7 +0x95
exit status 2
</pre>

<p>
下面是数组越界触发的 panic<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">hello.go</span>
<span style="color: #e45649;">func</span> <span style="color: #a626a4;">main</span>() {
    <span style="color: #6a1868;">arr</span> := []<span style="color: #986801;">int</span>{1, 2, 3}
    fmt.<span style="color: #a626a4;">Println</span>(arr[4])
}
</pre>
</div>

<pre class="example" id="org00052b7">
$ go run hello.go
panic: runtime error: index out of range [4] with length 3
</pre>
</div>
</div>
<div id="outline-container-orgdd54d4f" class="outline-2">
<h2 id="orgdd54d4f">defer</h2>
<div class="outline-text-2" id="text-orgdd54d4f">
<p>
panic 会导致程序被中止，但是在退出前，会先处理完当前协程上已经defer 的任务，执行完成后再退出。效果类似于 java 语言的 <code>try...catch</code> 。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">hello.go</span>
<span style="color: #e45649;">func</span> <span style="color: #a626a4;">main</span>() {
    <span style="color: #e45649;">defer</span> <span style="color: #e45649;">func</span>() {
        fmt.<span style="color: #a626a4;">Println</span>(<span style="color: #50a14f;">"defer func"</span>)
    }()

    <span style="color: #6a1868;">arr</span> := []<span style="color: #986801;">int</span>{1, 2, 3}
    fmt.<span style="color: #a626a4;">Println</span>(arr[4])
}
</pre>
</div>

<pre class="example" id="org6cda7e3">
$ go run hello.go
defer func
panic: runtime error: index out of range [4] with length 3
</pre>

<p>
可以 defer 多个任务，在同一个函数中 defer 多个任务，会逆序执行。即先执行最后 defer 的任务。<br>
</p>

<p>
在这里，defer 的任务执行完成之后，panic 还会继续被抛出，导致程序非正常结束。<br>
</p>
</div>
</div>
<div id="outline-container-org7f1921e" class="outline-2">
<h2 id="org7f1921e">recover</h2>
<div class="outline-text-2" id="text-org7f1921e">
<p>
go 语言还提供了 recover 函数，可以避免因为 panic 发生而导致整个程序终止，recover 函数只在 defer 中生效。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">hello.go</span>
<span style="color: #e45649;">func</span> <span style="color: #a626a4;">test_recover</span>() {
    <span style="color: #e45649;">defer</span> <span style="color: #e45649;">func</span>() {
        fmt.<span style="color: #a626a4;">Println</span>(<span style="color: #50a14f;">"defer func"</span>)
        <span style="color: #e45649;">if</span> <span style="color: #6a1868;">err</span> := <span style="color: #a626a4;">recover</span>(); err != <span style="color: #b751b6;">nil</span> {
            fmt.<span style="color: #a626a4;">Println</span>(<span style="color: #50a14f;">"recover success"</span>)
        }
    }()

    <span style="color: #6a1868;">arr</span> := []<span style="color: #986801;">int</span>{1, 2, 3}
    fmt.<span style="color: #a626a4;">Println</span>(arr[4])
    fmt.<span style="color: #a626a4;">Println</span>(<span style="color: #50a14f;">"after panic"</span>)
}

<span style="color: #e45649;">func</span> <span style="color: #a626a4;">main</span>() {
    <span style="color: #a626a4;">test_recover</span>()
    fmt.<span style="color: #a626a4;">Println</span>(<span style="color: #50a14f;">"after recover"</span>)
}
</pre>
</div>

<pre class="example" id="org404525e">
$ go run hello.go
defer func
recover success
after recover
</pre>

<p>
我们可以看到，recover 捕获了 panic，程序正常结束。test_recover() 中的 after panic 没有打印，这是正确的，当 panic 被触发时，控制权就被交给了 defer 。就像在 java 中， <code>try</code> 代码块中发生了异常，控制权交给了 <code>catch</code> ，接下来执行 catch 代码块中的代码。而在 main() 中打印了 after recover，说明程序已经恢复正常，继续往下执行直到结束。<br>
</p>
</div>
</div>
<div id="outline-container-orgbf189e3" class="outline-2">
<h2 id="orgbf189e3">gee 的错误处理机制</h2>
<div class="outline-text-2" id="text-orgbf189e3">
<p>
对一个 Web 框架而言，错误处理机制是非常必要的。可能是框架本身没有完备的测试，导致在某些情况下出现空指针异常等情况。也有可能用户不正确的参数，触发了某些异常，例如数组越界，空指针等。如果因为这些原因导致系统宕机，必然是不可接受的。<br>
</p>

<p>
我们在第六天实现的框架并没有加入异常处理机制，如果代码中存在会触发 panic 的 BUG，很容易宕掉。<br>
</p>

<p>
例如下面的代码：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #e45649;">func</span> <span style="color: #a626a4;">main</span>() {
    <span style="color: #6a1868;">r</span> := gee.<span style="color: #a626a4;">New</span>()
    r.<span style="color: #a626a4;">GET</span>(<span style="color: #50a14f;">"/panic"</span>, <span style="color: #e45649;">func</span>(<span style="color: #6a1868;">c</span> *<span style="color: #986801;">gee.Context</span>) {
        <span style="color: #6a1868;">names</span> := []<span style="color: #986801;">string</span>{<span style="color: #50a14f;">"geektutu"</span>}
        c.<span style="color: #a626a4;">String</span>(http.StatusOK, names[100])
    })
    r.<span style="color: #a626a4;">Run</span>(<span style="color: #50a14f;">":9999"</span>)
}
</pre>
</div>

<p>
在上面的代码中，我们为 gee 注册了路由 <code>/panic</code> ，而这个路由的处理函数内部存在数组越界 <code>names[100]</code> ，如果访问 localhost:9999/panic，Web 服务就会宕掉。<br>
</p>

<p>
今天，我们将在 gee 中添加一个非常简单的错误处理机制，即在此类错误发生时，向用户返回 Internal Server Error，并且在日志中打印必要的错误信息，方便进行错误定位。<br>
</p>

<p>
我们之前实现了中间件机制，错误处理也可以作为一个中间件，增强 gee 框架的能力。<br>
</p>

<p>
新增文件 gee/recovery.go，在这个文件中实现中间件 Recovery。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #e45649;">func</span> <span style="color: #a626a4;">Recovery</span>() <span style="color: #986801;">HandlerFunc</span> {
    <span style="color: #e45649;">return</span> <span style="color: #e45649;">func</span>(<span style="color: #6a1868;">c</span> *<span style="color: #986801;">Context</span>) {
        <span style="color: #e45649;">defer</span> <span style="color: #e45649;">func</span>() {
            <span style="color: #e45649;">if</span> <span style="color: #6a1868;">err</span> := <span style="color: #a626a4;">recover</span>(); err != <span style="color: #b751b6;">nil</span> {
                <span style="color: #6a1868;">message</span> := fmt.<span style="color: #a626a4;">Sprintf</span>(<span style="color: #50a14f;">"%s"</span>, err)
                log.<span style="color: #a626a4;">Printf</span>(<span style="color: #50a14f;">"%s\n\n"</span>, <span style="color: #a626a4;">trace</span>(message))
                c.<span style="color: #a626a4;">Fail</span>(http.StatusInternalServerError, <span style="color: #50a14f;">"Internal Server Error"</span>)
            }
        }()
        c.<span style="color: #a626a4;">Next</span>()
    }
}
</pre>
</div>

<p>
Recovery 的实现非常简单，使用 defer 挂载上错误恢复的函数，在这个函数中调用 *recover()*，捕获 panic，并且将堆栈信息打印在日志中，向用户返回 Internal Server Error。<br>
</p>

<p>
你可能注意到，这里有一个 trace() 函数，这个函数是用来获取触发 panic 的堆栈信息，完整代码如下：<br>
</p>

<blockquote>
<p>
gee/recovery.go<br>
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #e45649;">package</span> gee

<span style="color: #e45649;">import</span> (
    <span style="color: #50a14f;">"fmt"</span>
    <span style="color: #50a14f;">"log"</span>
    <span style="color: #50a14f;">"net/http"</span>
    <span style="color: #50a14f;">"runtime"</span>
    <span style="color: #50a14f;">"strings"</span>
)

<span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">print stack trace for debug</span>
<span style="color: #e45649;">func</span> <span style="color: #a626a4;">trace</span>(<span style="color: #6a1868;">message</span> <span style="color: #986801;">string</span>) <span style="color: #986801;">string</span> {
    <span style="color: #e45649;">var</span> <span style="color: #6a1868;">pcs</span> [32]<span style="color: #986801;">uintptr</span>
    <span style="color: #6a1868;">n</span> := runtime.<span style="color: #a626a4;">Callers</span>(3, pcs[:]) <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">skip first 3 caller</span>

    <span style="color: #e45649;">var</span> <span style="color: #6a1868;">str</span> <span style="color: #986801;">strings.Builder</span>
    str.<span style="color: #a626a4;">WriteString</span>(message + <span style="color: #50a14f;">"\nTraceback:"</span>)
    <span style="color: #e45649;">for</span> <span style="color: #6a1868;">_</span>, <span style="color: #6a1868;">pc</span> := <span style="color: #e45649;">range</span> pcs[:n] {
        <span style="color: #6a1868;">fn</span> := runtime.<span style="color: #a626a4;">FuncForPC</span>(pc)
        <span style="color: #6a1868;">file</span>, <span style="color: #6a1868;">line</span> := fn.<span style="color: #a626a4;">FileLine</span>(pc)
        str.<span style="color: #a626a4;">WriteString</span>(fmt.<span style="color: #a626a4;">Sprintf</span>(<span style="color: #50a14f;">"\n\t%s:%d"</span>, file, line))
    }
    <span style="color: #e45649;">return</span> str.<span style="color: #a626a4;">String</span>()
}

<span style="color: #e45649;">func</span> <span style="color: #a626a4;">Recovery</span>() <span style="color: #986801;">HandlerFunc</span> {
    <span style="color: #e45649;">return</span> <span style="color: #e45649;">func</span>(<span style="color: #6a1868;">c</span> *<span style="color: #986801;">Context</span>) {
        <span style="color: #e45649;">defer</span> <span style="color: #e45649;">func</span>() {
            <span style="color: #e45649;">if</span> <span style="color: #6a1868;">err</span> := <span style="color: #a626a4;">recover</span>(); err != <span style="color: #b751b6;">nil</span> {
                <span style="color: #6a1868;">message</span> := fmt.<span style="color: #a626a4;">Sprintf</span>(<span style="color: #50a14f;">"%s"</span>, err)
                log.<span style="color: #a626a4;">Printf</span>(<span style="color: #50a14f;">"%s\n\n"</span>, <span style="color: #a626a4;">trace</span>(message))
                c.<span style="color: #a626a4;">Fail</span>(http.StatusInternalServerError, <span style="color: #50a14f;">"Internal Server Error"</span>)
            }
        }()

        c.<span style="color: #a626a4;">Next</span>()
    }
}
</pre>
</div>

<p>
在 trace() 中，调用了 <code>runtime.Callers(3, pcs[:])</code> ，Callers 用来返回调用栈的程序计数器, 第 0 个 Caller 是 Callers 本身，第 1 个是上一层 trace，第 2 个是再上一层的 defer func。因此，为了日志简洁一点，我们跳过了前 3 个 Caller。<br>
</p>

<p>
接下来，通过 <code>runtime.FuncForPC(pc)</code> 获取对应的函数，在通过 <code>fn.FileLine(pc)</code> 获取到调用该函数的文件名和行号，打印在日志中。<br>
</p>

<p>
至此，gee 框架的错误处理机制就完成了。<br>
</p>
</div>
</div>
<div id="outline-container-org324a58b" class="outline-2">
<h2 id="org324a58b">使用 demo</h2>
<div class="outline-text-2" id="text-org324a58b">
<blockquote>
<p>
main.go<br>
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #e45649;">package</span> main

<span style="color: #e45649;">import</span> (
    <span style="color: #50a14f;">"net/http"</span>

    <span style="color: #50a14f;">"gee"</span>
)

<span style="color: #e45649;">func</span> <span style="color: #a626a4;">main</span>() {
    <span style="color: #6a1868;">r</span> := gee.<span style="color: #a626a4;">Default</span>()
    r.<span style="color: #a626a4;">GET</span>(<span style="color: #50a14f;">"/"</span>, <span style="color: #e45649;">func</span>(<span style="color: #6a1868;">c</span> *<span style="color: #986801;">gee.Context</span>) {
        c.<span style="color: #a626a4;">String</span>(http.StatusOK, <span style="color: #50a14f;">"hello gee\n"</span>)
    })
    <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">index out of range for testing Recovery()</span>
    r.<span style="color: #a626a4;">GET</span>(<span style="color: #50a14f;">"/panic"</span>, <span style="color: #e45649;">func</span>(<span style="color: #6a1868;">c</span> *<span style="color: #986801;">gee.Context</span>) {
        <span style="color: #6a1868;">names</span> := []<span style="color: #986801;">string</span>{<span style="color: #50a14f;">"haoran"</span>}
        c.<span style="color: #a626a4;">String</span>(http.StatusOK, names[100])
    })

    r.<span style="color: #a626a4;">Run</span>(<span style="color: #50a14f;">":9999"</span>)
}
</pre>
</div>

<p>
接下来进行测试，先访问主页，访问一个有BUG的 /panic，服务正常返回。接下来我们再一次成功访问了主页，说明服务完全运转正常。<br>
</p>

<pre class="example" id="org8ba45ab">
$ curl "http://localhost:9999"
Hello Geektutu
$ curl "http://localhost:9999/panic"
{"message":"Internal Server Error"}
$ curl "http://localhost:9999"
Hello Geektutu
</pre>

<p>
我们可以在后台日志中看到如下内容，引发错误的原因和堆栈信息都被打印了出来，通过日志，我们可以很容易地知道，在 main.go:47 的地方出现了 index out of range 错误。<br>
</p>

<pre class="example" id="org1cdac1b">
2022/12/25 00:19:06 runtime error: index out of range [100] with length 1
Traceback:
        /usr/local/go/src/runtime/panic.go:884
        /usr/local/go/src/runtime/panic.go:113
        /Users/haoran/haoran/gr/go_pkgs/go_web/main.go:17
        /Users/haoran/haoran/gr/go_pkgs/go_web/gee/context.go:41
        /Users/haoran/haoran/gr/go_pkgs/go_web/gee/recovery.go:21
        /Users/haoran/haoran/gr/go_pkgs/go_web/gee/context.go:41
        /Users/haoran/haoran/gr/go_pkgs/go_web/gee/logger.go:15
        /Users/haoran/haoran/gr/go_pkgs/go_web/gee/context.go:41
        /Users/haoran/haoran/gr/go_pkgs/go_web/gee/router.go:101
        /Users/haoran/haoran/gr/go_pkgs/go_web/gee/gee.go:98
        /usr/local/go/src/net/http/server.go:2948
        /usr/local/go/src/net/http/server.go:1992
        /usr/local/go/src/runtime/asm_amd64.s:1595
</pre>
</div>
</div>
<div id="outline-container-orgc552e75" class="outline-2">
<h2 id="orgc552e75">参考</h2>
<div class="outline-text-2" id="text-orgc552e75">
<ul class="org-ul">
<li><a href="https://golang.org/pkg/runtime/">Package runtime - golang.org</a><br></li>
<li><a href="https://stackoverflow.com/questions/35212985/is-it-possible-get-information-about-caller-function-in-golang">Is it possible get information about caller function in Golang? - StackOverflow</a><br></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-12-25</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
