<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-09-24 五 21:33 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>无穷大的设定</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="css/style.css" type="text/css"  />
                <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
                <script type="module" src="js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">无穷大的设定</h1>
<pre class="example" id="org99b14e5">
int型变量的取值范围：[-2^31, 2^31 - 1]  -&gt;  [-2147483648, 2147483647]
0x7fffffff = 2147483647
           = (2^31 - 1)
           = (1 &lt;&lt; 31) - 1

0x3fffffff = 1073741823
           = (2^30 - 1)
           = (1 &lt;&lt; 30) - 1
0x3f3f3f3f = 1061109567
</pre>

<p>
在写编程题目时常常需要用到无穷大，比如在求图的最短路径时，就需要先将源点到各点的最短距离设置为无穷大在十进制表示下，0x7fffffff = 2147483647，恰好等于int型变量的上界，所以在一些情况下用0x7fffffff表示无穷大是一个很好的选择
</p>
<ul class="org-ul">
<li>这些情况包括但不限于数的比较，min(num, 0x7fffffff)，一开始设置num是0x7fffffff，用这个式子判断是否num已改变</li>
</ul>
<p>
但是对于很多情况，设置无穷大为0x7fffffff并不能满足我们的需求，因为对于无穷大，加上一个数应该还是无穷大。而在计算机中，0x7fffffff加上一个数后会溢出，就不再是无穷大，还可能是负数。
</p>

<p>
这时候我们需要换个数来表示无穷大，我们这次选择0x3fffffff，这个数用十进制表示是(1 &lt;&lt; 30) - 1，因为一般场合下程序中的数据都是小于1e9的，而0x3fffffff = 1073741823 &gt; 1e9。那么这个数不仅满足了比程序中的任何数都大，而且0x3fffffff + 0x3fffffff = (1 &lt;&lt; 31) - 2小于int型的边界(1 &lt;&lt; 31) - 1 = 2147483647，同时满足了无穷大加上一个数还是无穷大
</p>

<p>
除了用0x3fffffff表示无穷大之外，我们还经常能看到用0x3f3f3f3f表示无穷大。其实和0x3fffffff一样，因为一般场合下的数据都是小于1e9的，而0x3f3f3f3f = 1061109567 &gt; 1e9。同样0x3f3f3f3f + 0x3f3f3f3f = 2122219134 &lt; int型的边界(1 &lt;&lt; 31) - 1 = 2147483647，也满足无穷大加上一个无穷大还是无穷大。不仅如此，如果要对一个数组全部赋值无穷大时，如果觉得使用循环麻烦，可以使用memset结合0x3f3f3f3f将数组全部赋值为无穷大，我们知道memset是按字节赋值的，它能够对数组清零(因为0的每个字节都是0)，或者全部赋值-1(因为-1在计算机中的表示形式为111&#x2026;,每个字节都是11111111)，由于0x3f3f3f3f的每个字节都是0x3f！所以要把一段内存全部设置为无穷大时，我们只需要memset(arr, 0x3f, sizeof(arr))
</p>

<p>
对于上述三种对无穷大的定义，除了第一种需要根据题目要求判断是否需要有无穷大加上一个数的操作来选择之外，选择哪种定义取决于个人喜好
</p>

<div class="org-src-container">
<pre class="src src-C++">#define INF1 0x7fffffff
#define INE2 0x3fffffff
#define INF3 0x3f3f3f3f
const int INF4 = 0x7fffffff;
const int INF5 = 0x3fffffff;
const int INF6 = 0x3f3f3f3f;
</pre>
</div>










<p>
ill Inf = (1LL &lt;&lt; 63) - 1;
</p>





<p>
编程中无穷大常量的设定技巧
</p>

<p>
如果问题中各数据的范围明确，那么无穷大的设定不是问题，在不明确的情况下，很多程序员都取0x7fffffff作为无穷大，因为这是32-bit int的最大值。如果这个无穷大只用于一般的比较（比如求最小值时min变量的初值），那么0x7fffffff确实是一个完美的选择，但是在更多的情况 下，0x7fffffff并不是一个好的选择。
</p>

<p>
很多时候我们并不只是单纯拿无穷大来作比较，而是会运算后再做比较，例如在大部分最短路径算法中都会使用的松弛操作：
if (d[u]+w[u]\[v]&lt;d[v]) d[v]=d[u]+w[u]\[v];
我们知道如果u,v之间没有边，那么w[u]\[v]=INF，如果我们的INF取0x7fffffff，那么d[u]+w[u]\[v]会溢出而变成负数， 我们的松弛操作便出错了，更一般的说，0x7fffffff不能满足“无穷大加一个有穷的数依然是无穷大”，它变成了一个很小的负数。除了要满足加上一个常数依然是无穷大之外，我们的常量还应该满足“无穷大加无穷大依然是无穷大”，至少两个无穷大相加不应该出现灾难性的错误，这一点上0x7fffffff依然不能满足我们。
</p>

<p>
所以我们需要一个更好的家伙来顶替0x7fffffff，最严谨的办法当然是对无穷大进行特别处理而不是找一个很大很大的常量来代替它（或者说模拟 它），但是这样会让我们的编程过程变得很麻烦。在我读过的代码中，最精巧的无穷大常量取值是0x3f3f3f3f，我不知道是谁最先开始使用这个精妙的常 量来做无穷大，不过我的确是从一位不认识的ACMer(ID:Staginner)的博客上学到的，他/她的很多代码中都使用了这个常量，于是我自己也尝试了一下，发现非常好用，而当我对这个常量做更深入的分析时，就发现它真的是非常精巧了。
</p>

<p>
0x3f3f3f3f的十进制是1061109567，也就是10^9级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。另一方面，由于一般的数据都不会大于10^9，所以当我们把无穷大加上一个数据时，它并不会溢出（这就满足了“无穷大加一个有穷的数依然是无穷 大”），事实上0x3f3f3f3f+0x3f3f3f3f=2122219134，这非常大但却没有超过32-bit int的表示范围，所以0x3f3f3f3f还满足了我们“无穷大加无穷大还是无穷大”的需求。最后，0x3f3f3f3f还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用 memset(a,0,sizeof(a))这样的代码来实现（方便而高效），但是当我们想将某个数组全部赋值为无穷大时（例如解决图论问题时邻接矩阵的 初始化），就不能使用memset函数而得自己写循环了（写这些不重要的代码真的很痛苦），我们知道这是因为memset是按字节操作的，它能够对数组清 零是因为0的每个字节都是0，现在好了，如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！所 以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))。
</p>

<p>
所以在通常的场合下，0x3f3f3f3f真的是一个非常棒的选择
</p>
</div>
</body>
</html>
