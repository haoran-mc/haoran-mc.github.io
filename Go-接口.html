<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-07-06 Wed 01:27 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>GO语言-接口</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">GO语言-接口</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org4def9b4">接口类型</a></li>
<li><a href="#orgdb05dbd">为什么要使用接口</a></li>
<li><a href="#orgfb77904">接口的定义</a></li>
<li><a href="#orgb458c7d">实现接口的条件</a></li>
<li><a href="#org9bacf39">接口类型变量</a></li>
<li><a href="#orgdad2605">值接收者和指针接收者实现接口</a>
<ul>
<li><a href="#orgc034802">值接收者实现接口</a></li>
<li><a href="#org7fe231c">指针接收者实现接口</a></li>
<li><a href="#org1b8e0c5">测试题</a></li>
</ul>
</li>
<li><a href="#org4769342">类型与接口的关系</a>
<ul>
<li><a href="#orgd969f31">一个类型实现多个接口</a></li>
<li><a href="#org831d333">多个类型实现同一接口</a></li>
</ul>
</li>
<li><a href="#org098c61f">接口嵌套</a></li>
<li><a href="#org505d3c6">空接口</a>
<ul>
<li><a href="#org6d929d7">空接口的定义</a></li>
<li><a href="#org527864c">空接口的应用</a></li>
</ul>
</li>
<li><a href="#org1aaa483">类型断言</a>
<ul>
<li><a href="#orgc93c011">接口值</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org4def9b4" class="outline-2">
<h2 id="org4def9b4">接口类型</h2>
<div class="outline-text-2" id="text-org4def9b4">
<p>
在 Go 语言中接口 <code>interface</code> 是一种类型，一种抽象的类型。<br>
</p>

<p>
<span class="underline">接口 <code>interface</code> 是一组 method 的集合</span> ，是 duck-type programming 的一种体现。接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，我们就称它为洗衣机，不关心属性（数据），只关心行为（方法）。<br>
</p>

<p>
<span class="underline">请牢记接口（interface）是一种类型。</span><br>
</p>
</div>
</div>
<div id="outline-container-orgdb05dbd" class="outline-2">
<h2 id="orgdb05dbd">为什么要使用接口</h2>
<div class="outline-text-2" id="text-orgdb05dbd">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> main

<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Cat</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">cat</span> <span style="color: #df005f; font-weight: bold;">Cat</span>) <span style="color: #d75fd7; font-weight: bold;">Say</span>() <span style="color: #df005f; font-weight: bold;">string</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #2aa198;">"&#21941;&#21941;&#21941;"</span>
}

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Dog</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">dog</span> <span style="color: #df005f; font-weight: bold;">Dog</span>) <span style="color: #d75fd7; font-weight: bold;">Say</span>() <span style="color: #df005f; font-weight: bold;">string</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #2aa198;">"&#27754;&#27754;&#27754;"</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">cat</span> := <span style="color: #df005f; font-weight: bold;">Cat</span>{}
    <span style="color: #8787d7;">dog</span> := <span style="color: #df005f; font-weight: bold;">Dog</span>{}
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"&#29483;: "</span>, cat.<span style="color: #d75fd7; font-weight: bold;">Say</span>())
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"&#29399;: "</span>, dog.<span style="color: #d75fd7; font-weight: bold;">Say</span>())
}
</pre>
</div>

<p>
上面的代码中定义了猫和狗，然后它们都会叫，会发现 <code>main</code> 函数中明显有重复的代码，如果我们后续再加上别的动物，我们的代码还会一直重复下去。那我们能不能把它们当成"能叫的动物"来处理呢？<br>
</p>
</div>
</div>
<div id="outline-container-orgfb77904" class="outline-2">
<h2 id="orgfb77904">接口的定义</h2>
<div class="outline-text-2" id="text-orgfb77904">
<p>
Go 语言提倡面向接口编程。<br>
</p>

<p>
每个接口由数个方法组成，接口的定义格式如下：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">&#25509;&#21475;&#31867;&#22411;&#21517;</span> <span style="color: #268bd2; font-weight: bold;">interface</span> {
    <span style="color: #d75fd7; font-weight: bold;">&#26041;&#27861;&#21517;1</span>(<span style="color: #df005f; font-weight: bold;">&#21442;&#25968;&#21015;&#34920;1</span>) <span style="color: #df005f; font-weight: bold;">&#36820;&#22238;&#20540;&#21015;&#34920;1</span>
    <span style="color: #d75fd7; font-weight: bold;">&#26041;&#27861;&#21517;2</span>(<span style="color: #df005f; font-weight: bold;">&#21442;&#25968;&#21015;&#34920;2</span>) <span style="color: #df005f; font-weight: bold;">&#36820;&#22238;&#20540;&#21015;&#34920;2</span>
    <span style="color: #d75fd7; font-weight: bold;">&#26041;&#27861;&#21517;3</span>(<span style="color: #df005f; font-weight: bold;">&#21442;&#25968;&#21015;&#34920;3</span>) <span style="color: #df005f; font-weight: bold;">&#36820;&#22238;&#20540;&#21015;&#34920;3</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">...</span>
}
</pre>
</div>

<dl class="org-dl">
<dt>接口名</dt><dd>使用 type 将接口定义为自定义的类型名，（按照约定，只包含一个方法的）Go 语言接口在命名时，接口的名字由方法名加 [e]r 后缀组成，例如 Printer、Reader、Writer、Logger、Converter 等等。还有一些不常用的方式（当后缀 er 不合适时），比如 Recoverable，此时接口名以 able 结尾，或者以 I 开头（像 .NET 或 Java 中那样）。<br></dd>
<dt>方法名</dt><dd>当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。<br></dd>
<dt>参数列表、返回值列表</dt><dd><span class="underline">参数列表和返回值列表中的参数变量名可以省略。</span><br></dd>
</dl>

<p>
举个例子：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #268bd2; font-weight: bold;">interface</span> {
    <span style="color: #d75fd7; font-weight: bold;">Write</span>([]<span style="color: #df005f; font-weight: bold;">byte</span>) <span style="color: #df005f; font-weight: bold;">error</span>
}
</pre>
</div>

<p>
当你看到这个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的 <code>Write</code> 方法来做一些事情。<br>
</p>
</div>
</div>
<div id="outline-container-orgb458c7d" class="outline-2">
<h2 id="orgb458c7d">实现接口的条件</h2>
<div class="outline-text-2" id="text-orgb458c7d">
<p>
一个 <b>对象</b> （也就是 <code>struct</code> 结构体）只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个需要实现的方法列表。<br>
</p>

<p>
我们来定义一个 <code>Sayer</code> 接口：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Sayer &#25509;&#21475;</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Sayer</span> <span style="color: #268bd2; font-weight: bold;">interface</span> {
    <span style="color: #d75fd7; font-weight: bold;">Say</span>()
}
</pre>
</div>

<p>
定义 <code>dog</code> 和 <code>cat</code> 两个结构体：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Dog</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {}
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Cat</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {}
</pre>
</div>

<p>
因为 <code>Sayer</code> 接口里只有一个 <code>say</code> 方法，所以我们只需要给 <code>dog</code> 和 <code>cat</code> 分别实现 <code>say</code> 方法就可以实现 <code>Sayer</code> 接口了。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Cat &#23454;&#29616;&#20102; Sayer &#25509;&#21475;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">cat</span> <span style="color: #df005f; font-weight: bold;">Cat</span>) <span style="color: #d75fd7; font-weight: bold;">Say</span>() {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"&#21941;&#21941;&#21941;"</span>)
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Dog &#23454;&#29616;&#20102; Sayer &#25509;&#21475;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">dog</span> <span style="color: #df005f; font-weight: bold;">Dog</span>) <span style="color: #d75fd7; font-weight: bold;">Say</span>() {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"&#27754;&#27754;&#27754;"</span>)
}
</pre>
</div>

<p>
接口的实现就是这么简单，只要实现了接口中的所有方法，就实现了这个接口。<br>
</p>
</div>
</div>
<div id="outline-container-org9bacf39" class="outline-2">
<h2 id="org9bacf39">接口类型变量</h2>
<div class="outline-text-2" id="text-org9bacf39">
<p>
那么实现了接口有什么用呢？<br>
</p>

<p>
<span class="underline">接口类型变量能够存储所有实现了该接口的实例。例如上面的实例中， <code>Sayer</code> 类型的变量能够存储 <code>Dog</code> 和 <code>Cat</code> 类型的变量。</span><br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">sayer</span> <span style="color: #df005f; font-weight: bold;">Sayer</span>   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22768;&#26126;&#19968;&#20010; Sayer &#31867;&#22411;&#30340;&#21464;&#37327; sayer</span>
    <span style="color: #8787d7;">cat</span> := <span style="color: #df005f; font-weight: bold;">Cat</span>{}      <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#23454;&#20363;&#21270;&#19968;&#20010; Cat</span>
    <span style="color: #8787d7;">dog</span> := <span style="color: #df005f; font-weight: bold;">Dog</span>{}      <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#23454;&#20363;&#21270;&#19968;&#20010; Dog</span>
    sayer = cat       <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21487;&#20197;&#25226; Cat &#23454;&#20363;&#30452;&#25509;&#36171;&#20540;&#32473; sayer</span>
    sayer.<span style="color: #d75fd7; font-weight: bold;">Say</span>()       <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21941;&#21941;&#21941;</span>
    sayer = dog       <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21487;&#20197;&#25226; Dog&#23454;&#20363;&#30452;&#25509;&#36171;&#20540;&#32473; sayer</span>
    sayer.<span style="color: #d75fd7; font-weight: bold;">Say</span>()       <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#27754;&#27754;&#27754;</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgdad2605" class="outline-2">
<h2 id="orgdad2605">值接收者和指针接收者实现接口</h2>
<div class="outline-text-2" id="text-orgdad2605">
<p>
使用值接收者实现接口和使用指针接收者实现接口有什么区别呢？<br>
</p>

<p>
创建一个 <code>Mover</code> 接口和一个 <code>Dog</code> 结构体。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Mover</span> <span style="color: #268bd2; font-weight: bold;">interface</span> {
    <span style="color: #d75fd7; font-weight: bold;">Move</span>()
}

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Dog</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {}
</pre>
</div>
</div>
<div id="outline-container-orgc034802" class="outline-3">
<h3 id="orgc034802">值接收者实现接口</h3>
<div class="outline-text-3" id="text-orgc034802">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">dog</span> <span style="color: #df005f; font-weight: bold;">Dog</span>) <span style="color: #d75fd7; font-weight: bold;">Move</span>() {
    funt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"&#29399;&#20250;&#21160;"</span>)
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">mover</span> <span style="color: #df005f; font-weight: bold;">Mover</span>
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">dog1</span> = <span style="color: #df005f; font-weight: bold;">Dog</span>{}   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">dog1 &#26159; Dog &#31867;&#22411;</span>
    mover = dog1       <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">mover &#21487;&#20197;&#25509;&#25910; Dog &#31867;&#22411;</span>
    mover.<span style="color: #d75fd7; font-weight: bold;">Move</span>()

    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">dog2</span> = &amp;<span style="color: #df005f; font-weight: bold;">Dog</span>{}  <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">dog2 &#26159; *Dog &#31867;&#22411;</span>
    mover = dog2       <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">mover &#21487;&#20197;&#25509;&#25910; *Dog &#31867;&#22411;</span>
    mover.<span style="color: #d75fd7; font-weight: bold;">Move</span>()
}
</pre>
</div>

<p>
从上面的代码可以发现，使用值接收者实现接口之后，不管是 <code>Dog</code> 结构体还是结构体指针 <code>*Dog</code> 类型的变量都可以赋值给该接口变量。因为 Go 语言中有对指针类型变量求值的语法糖， <code>Dog</code> 指针内部会自动求值。<br>
</p>
</div>
</div>
<div id="outline-container-org7fe231c" class="outline-3">
<h3 id="org7fe231c">指针接收者实现接口</h3>
<div class="outline-text-3" id="text-org7fe231c">
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">dog</span> *<span style="color: #df005f; font-weight: bold;">Dog</span>) <span style="color: #d75fd7; font-weight: bold;">Move</span>() {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"&#29399;&#20250;&#21160;"</span>)
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">mover</span> <span style="color: #df005f; font-weight: bold;">Mover</span>
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">dog1</span> = <span style="color: #df005f; font-weight: bold;">Dog</span>{}   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">dog1 &#26159; Dog &#31867;&#22411;</span>
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">mover = dog1    // &#36825;&#21477;&#38169;&#35823;&#65292;mover &#19981;&#21487;&#20197;&#25509;&#25910; Dog &#31867;&#22411;&#65292;&#22240;&#20026; dog1 &#27809;&#26377;&#23454;&#29616;&#25509;&#21475;&#20013;&#30340;&#25152;&#26377;&#26041;&#27861;</span>

    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">dog2</span> = &amp;<span style="color: #df005f; font-weight: bold;">Dog</span>{}
    mover = dog2
    mover.<span style="color: #d75fd7; font-weight: bold;">Move</span>()
}
</pre>
</div>

<p>
此时实现 <code>Mover</code> 接口的是 <code>*Dog</code> 类型，所以不能给 <code>mover</code> 传入 <code>Dog</code> 类型的 <code>dog1</code> ，此时 <code>mover</code> 只能存储 <code>*Dog</code> 类型的值。<br>
</p>
</div>
</div>
<div id="outline-container-org1b8e0c5" class="outline-3">
<h3 id="org1b8e0c5">测试题</h3>
<div class="outline-text-3" id="text-org1b8e0c5">
<p>
观察下面这段代码，回答这段代码能否通过编译？<br>
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">People</span> <span style="color: #268bd2; font-weight: bold;">interface</span> {
    <span style="color: #d75fd7; font-weight: bold;">Speak</span>(<span style="color: #df005f; font-weight: bold;">string</span>) <span style="color: #df005f; font-weight: bold;">string</span>
}

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Student</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">str</span> *<span style="color: #df005f; font-weight: bold;">Student</span>) <span style="color: #d75fd7; font-weight: bold;">Speak</span>(<span style="color: #8787d7;">think</span> <span style="color: #df005f; font-weight: bold;">string</span>) (<span style="color: #8787d7;">talk</span> <span style="color: #df005f; font-weight: bold;">string</span>) {
    <span style="color: #268bd2; font-weight: bold;">if</span> think == <span style="color: #2aa198;">"&#30005;&#24433;"</span> {
        talk = <span style="color: #2aa198;">"&#25105;&#20204;&#21435;&#30475;&#30005;&#24433;&#21543;"</span>
    } <span style="color: #268bd2; font-weight: bold;">else</span> {
        talk = <span style="color: #2aa198;">"&#22909;&#26080;&#32842;"</span>
    }
    <span style="color: #268bd2; font-weight: bold;">return</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">peo</span> <span style="color: #df005f; font-weight: bold;">People</span> = <span style="color: #df005f; font-weight: bold;">Student</span>{}
    <span style="color: #8787d7;">think</span> := <span style="color: #2aa198;">"&#21507;&#39277;"</span>
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(peo.<span style="color: #d75fd7; font-weight: bold;">Speak</span>(think))
}
</pre>
</div>

<p>
那这段呢？这两份代码有什么差别？<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">People</span> <span style="color: #268bd2; font-weight: bold;">interface</span> {
    <span style="color: #d75fd7; font-weight: bold;">Speak</span>(<span style="color: #df005f; font-weight: bold;">string</span>) <span style="color: #df005f; font-weight: bold;">string</span>
}

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Student</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">str</span> *<span style="color: #df005f; font-weight: bold;">Student</span>) <span style="color: #d75fd7; font-weight: bold;">Speak</span>(<span style="color: #8787d7;">think</span> <span style="color: #df005f; font-weight: bold;">string</span>) (<span style="color: #8787d7;">talk</span> <span style="color: #df005f; font-weight: bold;">string</span>) {
    <span style="color: #268bd2; font-weight: bold;">if</span> think == <span style="color: #2aa198;">"&#30005;&#24433;"</span> {
        talk = <span style="color: #2aa198;">"&#25105;&#20204;&#21435;&#30475;&#30005;&#24433;&#21543;"</span>
    } <span style="color: #268bd2; font-weight: bold;">else</span> {
        talk = <span style="color: #2aa198;">"&#22909;&#26080;&#32842;"</span>
    }
    <span style="color: #268bd2; font-weight: bold;">return</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">peo</span> <span style="color: #df005f; font-weight: bold;">People</span> = &amp;<span style="color: #df005f; font-weight: bold;">Student</span>{}
    <span style="color: #8787d7;">think</span> := <span style="color: #2aa198;">"&#21507;&#39277;"</span>
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(peo.<span style="color: #d75fd7; font-weight: bold;">Speak</span>(think))
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org4769342" class="outline-2">
<h2 id="org4769342">类型与接口的关系</h2>
<div class="outline-text-2" id="text-org4769342">
</div>
<div id="outline-container-orgd969f31" class="outline-3">
<h3 id="orgd969f31">一个类型实现多个接口</h3>
<div class="outline-text-3" id="text-orgd969f31">
<p>
一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Sayer</span> <span style="color: #268bd2; font-weight: bold;">interface</span> {
    <span style="color: #d75fd7; font-weight: bold;">Say</span>()
}

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Runner</span> <span style="color: #268bd2; font-weight: bold;">interface</span> {
    <span style="color: #d75fd7; font-weight: bold;">Run</span>()
}
</pre>
</div>

<p>
<code>Dog</code> 既可以实现 <code>Sayer</code> 接口，也可以实现 <code>Runner</code> 接口。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Dog</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    name <span style="color: #df005f; font-weight: bold;">string</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">dog</span> <span style="color: #df005f; font-weight: bold;">Dog</span>) <span style="color: #d75fd7; font-weight: bold;">Say</span>() {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%s: &#27754;&#27754;&#27754;\n"</span>, dog.name)
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">dog</span> <span style="color: #df005f; font-weight: bold;">Dog</span>) <span style="color: #d75fd7; font-weight: bold;">Run</span>() {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%s: &#36305;&#36305;&#36305;\n"</span>, dog.name)
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">sayer</span> <span style="color: #df005f; font-weight: bold;">Sayer</span>
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">runner</span> <span style="color: #df005f; font-weight: bold;">Runner</span>

    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">dog</span> = <span style="color: #df005f; font-weight: bold;">Dog</span>{<span style="color: #d75fd7;">name</span>: <span style="color: #2aa198;">"&#26106;&#36130;"</span>}
    sayer = dog
    runner = dog
    sayer.<span style="color: #d75fd7; font-weight: bold;">Say</span>()
    runner.<span style="color: #d75fd7; font-weight: bold;">Run</span>()
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org831d333" class="outline-3">
<h3 id="org831d333">多个类型实现同一接口</h3>
<div class="outline-text-3" id="text-org831d333">
<p>
Go 语言中不同的类型还可以实现同一接口，首先定义一个 <code>Runner</code> 接口，它要求必须有一个 <code>Run</code> 方法。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Runner</span> <span style="color: #268bd2; font-weight: bold;">interface</span> {
    <span style="color: #d75fd7; font-weight: bold;">Run</span>()
}
</pre>
</div>

<p>
狗可以跑，汽车也能跑：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Dog</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    name <span style="color: #df005f; font-weight: bold;">string</span>
}

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Car</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    brand <span style="color: #df005f; font-weight: bold;">string</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">dog</span> <span style="color: #df005f; font-weight: bold;">Dog</span>) <span style="color: #d75fd7; font-weight: bold;">Run</span>() {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%s: &#36305;&#36305;&#36305;\n"</span>, dog.name)
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">car</span> <span style="color: #df005f; font-weight: bold;">Car</span>) <span style="color: #d75fd7; font-weight: bold;">Run</span>() {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"%s&#26102;&#36895;: 50km/h\n"</span>, car.brand)
}
</pre>
</div>

<p>
这个时候我们在代码中就可以把狗和汽车当成一个会跑的物体来处理了，不再关注它们具体是什么，只需要调用它们的 <code>Run</code> 方法就可以了。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">runner</span> <span style="color: #df005f; font-weight: bold;">Runner</span>
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">dog</span> = <span style="color: #df005f; font-weight: bold;">Dog</span>{<span style="color: #d75fd7;">name</span>: <span style="color: #2aa198;">"&#26106;&#36130;"</span>}
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">car</span> = <span style="color: #df005f; font-weight: bold;">Car</span>{<span style="color: #d75fd7;">brand</span>: <span style="color: #2aa198;">"&#20445;&#26102;&#25463;"</span>}
    runner = dog
    runner.<span style="color: #d75fd7; font-weight: bold;">move</span>()
    runner = car
    runner.<span style="color: #d75fd7; font-weight: bold;">move</span>()
}
</pre>
</div>

<p>
并且一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者机构体来实现。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">WashingMaching &#27927;&#34915;&#26426;</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">WashingMachine</span> <span style="color: #268bd2; font-weight: bold;">interface</span> {
    <span style="color: #d75fd7; font-weight: bold;">Wash</span>()
    <span style="color: #d75fd7; font-weight: bold;">Dry</span>()
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Dryer &#29993;&#24178;&#22120;</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Dryer</span> <span style="color: #268bd2; font-weight: bold;">struct</span>{}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">dryer</span> <span style="color: #df005f; font-weight: bold;">Dryer</span>) <span style="color: #d75fd7; font-weight: bold;">Dry</span>() {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"&#29993;&#24178;"</span>)
}

<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#28023;&#23572;&#27927;&#34915;&#26426;</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Haier</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    Dryer   <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#23884;&#20837;&#29993;&#24178;&#22120;</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">haier</span> <span style="color: #df005f; font-weight: bold;">Haier</span>) <span style="color: #d75fd7; font-weight: bold;">Wash</span>() {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"&#27927;&#34915;"</span>)
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org098c61f" class="outline-2">
<h2 id="org098c61f">接口嵌套</h2>
<div class="outline-text-2" id="text-org098c61f">
<p>
接口与接口之间可以通过嵌套创造出新的接口。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Sayer</span> <span style="color: #268bd2; font-weight: bold;">interface</span> {
    <span style="color: #d75fd7; font-weight: bold;">Say</span>()
}

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Runner</span> <span style="color: #268bd2; font-weight: bold;">interface</span> {
    <span style="color: #d75fd7; font-weight: bold;">Run</span>()
}

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Animal</span> <span style="color: #268bd2; font-weight: bold;">interface</span> {
    Sayer
    Runner
}
</pre>
</div>

<p>
嵌套得到的接口与普通接口一样使用：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Cat</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    name <span style="color: #df005f; font-weight: bold;">string</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">cat</span> <span style="color: #df005f; font-weight: bold;">Cat</span>) <span style="color: #d75fd7; font-weight: bold;">Say</span>() {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"&#29483;: &#21941;&#21941;&#21941;"</span>)
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">cat</span> <span style="color: #df005f; font-weight: bold;">Cat</span>) <span style="color: #d75fd7; font-weight: bold;">Run</span>() {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"&#29483;: &#36305;&#36305;&#36305;"</span>)
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">animal</span> <span style="color: #df005f; font-weight: bold;">Animal</span>
    cat = <span style="color: #df005f; font-weight: bold;">Cat</span>{<span style="color: #d75fd7;">name</span>: <span style="color: #2aa198;">"&#33457;&#33457;"</span>}
    cat.<span style="color: #d75fd7; font-weight: bold;">Say</span>()
    cat.<span style="color: #d75fd7; font-weight: bold;">Move</span>()
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org505d3c6" class="outline-2">
<h2 id="org505d3c6">空接口</h2>
<div class="outline-text-2" id="text-org505d3c6">
</div>
<div id="outline-container-org6d929d7" class="outline-3">
<h3 id="org6d929d7">空接口的定义</h3>
<div class="outline-text-3" id="text-org6d929d7">
<p>
空接口是指没有定义任何方法的接口，因此任何类型都实现了空接口。<br>
</p>

<p>
空接口类型的变量可以存储任意类型的变量。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">intf</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{}
    <span style="color: #8787d7;">s</span> := <span style="color: #2aa198;">"Hello, world!"</span>
    intf = s
    fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"type: %T value: %v\n"</span>, intf, intf)

    <span style="color: #8787d7;">i</span> := 100
    intf = i
    fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"type: %T value: %v\n"</span>, intf, intf)

    <span style="color: #8787d7;">b</span> := <span style="color: #d75fd7;">true</span> 
    intf = b
    fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"type: %T value: %v\n"</span>, intf, intf)
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org527864c" class="outline-3">
<h3 id="org527864c">空接口的应用</h3>
<div class="outline-text-3" id="text-org527864c">
<ol class="org-ol">
<li><p>
使用空接口实现可以接收任意类型的函数参数。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">show</span>(<span style="color: #8787d7;">inft</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{}) {
    fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"type: %T value: %V\n"</span>)
}
</pre>
</div></li>

<li><p>
使用空接口实现可以保存任意值的字典。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">studentInfo</span> = <span style="color: #268bd2;">make</span>(<span style="color: #268bd2; font-weight: bold;">map</span>[<span style="color: #df005f; font-weight: bold;">string</span>]<span style="color: #268bd2; font-weight: bold;">interface</span>{})
studentInfo[<span style="color: #2aa198;">"name"</span>] = <span style="color: #2aa198;">"xiaoming"</span>
studentInfo[<span style="color: #2aa198;">"age"</span>] = 21
studentInfo[<span style="color: #2aa198;">"married"</span>] = <span style="color: #d75fd7;">false</span>
fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(studentInfo)
</pre>
</div></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org1aaa483" class="outline-2">
<h2 id="org1aaa483">类型断言</h2>
<div class="outline-text-2" id="text-org1aaa483">
<p>
空接口可以存储任意类型的值，那我们如何获取其存储的具体数据呢？<br>
</p>
</div>
<div id="outline-container-orgc93c011" class="outline-3">
<h3 id="orgc93c011">接口值</h3>
<div class="outline-text-3" id="text-orgc93c011">
<p>
一个接口的值是由一个具体类型和具体类型的值两部分组成的，这两部分分别称为 <b>接口的动态类型</b> 和 <b>动态值</b> 。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">w</span> <span style="color: #df005f; font-weight: bold;">io.Weiter</span>
w = os.Stdout
w = <span style="color: #268bd2;">new</span>(<span style="color: #df005f; font-weight: bold;">bytes.Buffer</span>)
w = <span style="color: #d75fd7;">nil</span>
</pre>
</div>

<img src="./images/接口断言.png"/>

<p>
想要判断空接口中的值，就可以使用类型断言：<br>
</p>

<div class="org-src-container">
<pre class="src src-go">intf.(<span style="color: #df005f; font-weight: bold;">T</span>)
</pre>
</div>

<p>
其中：<br>
</p>
<dl class="org-dl">
<dt>intf</dt><dd>表示类型为 <code>interface{}</code> 的变量<br></dd>
<dt>T</dt><dd>表示断言 intf 可能是的类型<br></dd>
</dl>

<p>
该语法返回两个参数，第一个参数是 <code>intf</code> 转化为 <code>T</code> 类型后的变量，第二个值是一个布尔值，若为 <code>true</code> 则表示断言成功，为 <code>false</code> 则表示断言失败。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">intf</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{}
    intf = <span style="color: #2aa198;">"Hello, world!"</span>
    <span style="color: #8787d7;">v</span>, <span style="color: #8787d7;">ok</span> := intf.(<span style="color: #df005f; font-weight: bold;">string</span>)
    <span style="color: #268bd2; font-weight: bold;">if</span> ok {
        fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(v)
    } <span style="color: #268bd2; font-weight: bold;">else</span> {
        fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"&#31867;&#22411;&#26029;&#35328;&#22833;&#36133;"</span>)
    }
}
</pre>
</div>

<p>
或者使用 switch：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">justifyType</span>(<span style="color: #8787d7;">intf</span> <span style="color: #268bd2; font-weight: bold;">interface</span>{}) {
    <span style="color: #268bd2; font-weight: bold;">switch</span> <span style="color: #8787d7;">v</span> := intf.(<span style="color: #268bd2; font-weight: bold;">type</span>) {
    <span style="color: #268bd2; font-weight: bold;">case</span> <span style="color: #df005f; font-weight: bold;">string</span>:
        fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"intf is a string&#65292;value is %v\n"</span>, v)
    <span style="color: #268bd2; font-weight: bold;">case</span> <span style="color: #df005f; font-weight: bold;">int</span>:
        fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"intf is a int is %v\n"</span>, v)
    <span style="color: #268bd2; font-weight: bold;">case</span> <span style="color: #df005f; font-weight: bold;">bool</span>:
        fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"intf is a bool is %v\n"</span>, v)
    <span style="color: #268bd2; font-weight: bold;">default</span>:
        fmt.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"unsupport type&#65281;"</span>)
    }
}
</pre>
</div>

<p>
因为空接口可以存储任意类型值的特点，所以空接口在 Go 语言中的使用十分广泛。<br>
</p>

<p>
关于接口需要注意的是，只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。不要为了接口而写接口，那样只会增加不必要的抽象，导致不必要的运行时损耗。<br>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-02-06 23:02 Sun</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-07-06 Wed 01:27</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
