<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-06-29 Wed 14:30 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Go 并发编程 - COND: 条件变量的实现机制及避坑指南</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">Go 并发编程 - COND: 条件变量的实现机制及避坑指南</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org6e37ae2">引言</a></li>
<li><a href="#org0f12849">Go 标准库的 Cond</a></li>
<li><a href="#org52071aa">Cond 的基本用法</a></li>
<li><a href="#org89514c0">Cond 的实现原理</a></li>
<li><a href="#org60238c5">使用 Cond 的 2 个常见错误</a></li>
<li><a href="#orgabcb9c3">知名项目中 Cond 的使用</a></li>
<li><a href="#orgd749984">总结</a></li>
</ul>
</div>
</div>

<div id="outline-container-org6e37ae2" class="outline-2">
<h2 id="org6e37ae2">引言</h2>
<div class="outline-text-2" id="text-org6e37ae2">
<p>
如何实现一个限定容量的队列（queue），当队列满或者空的时候，利用等待/通知机制实现阻塞或者唤醒。<br>
</p>

<p>
在 Go 中，也可以实现一个类似的限定容量的队列，而且实现起来也比较简单，只要用条件变量（Cond）并发原语就可以。Cond 并发原语相对来说不是那么常用，但是在特定的场景使用会事半功倍，比如你需要在唤醒一个或者所有的等待者做一些检查操作的时候。<br>
</p>
</div>
</div>
<div id="outline-container-org0f12849" class="outline-2">
<h2 id="org0f12849">Go 标准库的 Cond</h2>
<div class="outline-text-2" id="text-org0f12849">
<p>
Go 标准库提供 Cond 原语的目的是，为等待 / 通知场景下的并发问题提供支持。Cond 通常应用于等待某个条件的一组 goroutine，等条件变为 true 的时候，其中一个 goroutine 或者所有的 goroutine 都会被唤醒执行。<br>
</p>

<p>
顾名思义，Cond 是和某个条件相关，这个条件需要一组 goroutine 协作共同完成，在条件还没有满足的时候，所有等待这个条件的 goroutine 都会被阻塞住，只有这一组 goroutine 通过协作达到了这个条件，等待的 goroutine 才可能继续进行下去。<br>
</p>

<p>
那这里等待的条件是什么呢？等待的条件，可以是某个变量达到了某个阈值或者某个时间点，也可以是一组变量分别都达到了某个阈值，还可以是某个对象的状态满足了特定的条件。总结来讲，等待的条件是一种可以用来计算结果是 true 还是 false 的条件。<br>
</p>

<p>
从开发实践上，我们真正使用 Cond 的场景比较少，因为一旦遇到需要使用 Cond 的场景，我们更多地会使用 Channel 的方式（后面会展开 Channel 的用法）去实现，因为那才是更地道的 Go 语言的写法，甚至 Go 的开发者有个“把 Cond 从标准库移除”的提议（<a href="https://github.com/golang/go/issues/21165">issue 21165</a>）。而有的开发者认为，Cond 是唯一难以掌握的 Go 并发原语。至于其中原因，先卖个关子，到这一讲的后半部分再解释。<br>
</p>
</div>
</div>
<div id="outline-container-org52071aa" class="outline-2">
<h2 id="org52071aa">Cond 的基本用法</h2>
<div class="outline-text-2" id="text-org52071aa">
<p>
标准库中的 Cond 并发原语初始化的时候，需要关联一个 Locker 接口的实例，一般我们使用 Mutex 或者 RWMutex。<br>
</p>

<p>
先看一下 Cond 的实现：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Cond</span>
    <span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">NeWCond</span>(<span style="color: #8787d7;">l</span> <span style="color: #df005f; font-weight: bold;">Locker</span>) *<span style="color: #df005f; font-weight: bold;">Cond</span>
    <span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">Cond</span>) <span style="color: #d75fd7; font-weight: bold;">Broadcast</span>()
    <span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">Cond</span>) <span style="color: #d75fd7; font-weight: bold;">Signal</span>()
    <span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">Cond</span>) <span style="color: #d75fd7; font-weight: bold;">Wait</span>()
</pre>
</div>

<p>
首先，Cond 关联的 Locker 实例可以通过 c.L 访问，它内部维护着一个先入先出的等待队列。<br>
</p>

<p>
然后，我们分别看下它的三个方法 Broadcast、Signal 和 Wait 方法。<br>
</p>

<p>
<b>Signal 方法</b> ，允许调用者 Caller 唤醒一个等待此 Cond 的 goroutine。如果此时没有等待的 goroutine，显然无需通知 waiter；如果 Cond 等待队列中有一个或者多个等待的 goroutine，则需要从等待队列中移除第一个 goroutine 并把它唤醒。在其他编程语言中，比如 Java 语言中，Signal 方法也被叫做 notify 方法。<br>
</p>

<p>
调用 Signal 方法时，不强求你一定要持有 c.L 的锁。<br>
</p>

<p>
<b>Broadcast 方法</b> ，允许调用者 Caller 唤醒所有等待此 Cond 的 goroutine。如果此时没有等待的 goroutine，显然无需通知 waiter；如果 Cond 等待队列中有一个或者多个等待的 goroutine，则清空所有等待的 goroutine，并全部唤醒。在其他编程语言中，比如 Java 语言中，Broadcast 方法也被叫做 notifyAll 方法。<br>
</p>

<p>
同样地，调用 Broadcast 方法时，也不强求你一定持有 c.L 的锁。<br>
</p>

<p>
<b>Wait 方法</b> ，会把调用者 Caller 放入 Cond 的等待队列中并阻塞，直到被 Signal 或者 Broadcast 的方法从等待队列中移除并唤醒。<br>
</p>

<p>
调用 Wait 方法时必须要持有 c.L 的锁。<br>
</p>

<p>
Go 实现的 sync.Cond 的方法名是 Wait、Signal 和 Broadcast，这是计算机科学中条件变量的<a href="https://en.wikipedia.org/wiki/Monitor_(synchronization)#Condition_variables_2">通用方法名</a>。比如，C 语言中对应的方法名是 pthread_cond_wait、pthread_cond_signal 和 pthread_cond_broadcast。<br>
</p>

<p>
知道了 Cond 提供的三个方法后，我们再通过一个百米赛跑开始时的例子，来学习下 <b>Cond 的使用方法</b> 。10 个运动员进入赛场之后需要先做拉伸活动活动筋骨，向观众和粉丝招手致敬，在自己的赛道上做好准备；等所有的运动员都准备好之后，裁判员才会打响发令枪。<br>
</p>

<p>
每个运动员做好准备之后，将 ready 加一，表明自己做好准备了，同时调用 Broadcast 方法通知裁判员。因为裁判员只有一个，所以这里可以直接替换成 Signal 方法调用。调用 Broadcast 方法的时候，我们并没有请求 c.L 锁，只是在更改等待变量的时候才使用到了锁。<br>
</p>

<p>
裁判员会等待运动员都准备好（第 22 行）。虽然每个运动员准备好之后都唤醒了裁判员，但是裁判员被唤醒之后需要检查等待条件是否满足（ <b>运动员都准备好了</b> ）。可以看到，裁判员被唤醒之后一定要检查等待条件，如果条件不满足还是要继续等待。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">c</span> := sync.<span style="color: #d75fd7; font-weight: bold;">NewCond</span>(&amp;<span style="color: #df005f; font-weight: bold;">sync.Mutex</span>{})
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">ready</span> <span style="color: #df005f; font-weight: bold;">int</span>

    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := 0; i &lt; 10; i++ {
        <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>(<span style="color: #8787d7;">i</span> <span style="color: #df005f; font-weight: bold;">int</span>) {
            time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(time.<span style="color: #d75fd7; font-weight: bold;">Duration</span>(rand.<span style="color: #d75fd7; font-weight: bold;">Int63n</span>(10)) * time.Second)

            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21152;&#38145;&#26356;&#25913;&#31561;&#24453;&#26465;&#20214;</span>
            c.L.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
            ready++
            c.L.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()

            log.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"&#36816;&#21160;&#21592;#%d &#24050;&#20934;&#22791;&#23601;&#32490;\n"</span>, i)
            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#24191;&#25773;&#21796;&#37266;&#25152;&#26377;&#30340;&#31561;&#24453;&#32773;</span>
            c.<span style="color: #d75fd7; font-weight: bold;">Broadcast</span>()
        }(i)
    }

    c.L.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
    <span style="color: #268bd2; font-weight: bold;">for</span> ready != 10 {
        c.<span style="color: #d75fd7; font-weight: bold;">Wait</span>()
        log.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"&#35009;&#21028;&#21592;&#34987;&#21796;&#37266;&#19968;&#27425;"</span>)
    }
    c.L.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()

    <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#25152;&#26377;&#30340;&#36816;&#21160;&#21592;&#26159;&#21542;&#23601;&#32490;</span>
    log.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"&#25152;&#26377;&#36816;&#21160;&#21592;&#37117;&#20934;&#22791;&#23601;&#32490;&#12290;&#27604;&#36187;&#24320;&#22987;&#65292;3&#65292;2&#65292;1, ......"</span>)
}   
</pre>
</div>

<p>
你看，Cond 的使用其实没那么简单。它的复杂在于：一，这段代码有时候需要加锁，有时候可以不加；二，Wait 唤醒后需要检查条件；三，条件变量的更改，其实是需要原子操作或者互斥锁保护的。所以，有的开发者会认为，Cond 是唯一难以掌握的 Go 并发原语。<br>
</p>
</div>
</div>
<div id="outline-container-org89514c0" class="outline-2">
<h2 id="org89514c0">Cond 的实现原理</h2>
<div class="outline-text-2" id="text-org89514c0">
<p>
其实，Cond 的实现非常简单，或者说复杂的逻辑已经被 Locker 或者 runtime 的等待队列实现了。我们直接看看 Cond 的源码吧。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Cond</span> <span style="color: #268bd2; font-weight: bold;">struct</span> {
    noCopy <span style="color: #df005f; font-weight: bold;">noCopy</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#24403;&#35266;&#23519;&#25110;&#32773;&#20462;&#25913;&#31561;&#24453;&#26465;&#20214;&#30340;&#26102;&#20505;&#38656;&#35201;&#21152;&#38145;</span>
    L <span style="color: #df005f; font-weight: bold;">Locker</span>

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#31561;&#24453;&#38431;&#21015;</span>
    notify  <span style="color: #df005f; font-weight: bold;">notifyList</span>
    checker <span style="color: #df005f; font-weight: bold;">copyChecker</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">NewCond</span>(<span style="color: #8787d7;">l</span> <span style="color: #df005f; font-weight: bold;">Locker</span>) *<span style="color: #df005f; font-weight: bold;">Cond</span> {
    <span style="color: #268bd2; font-weight: bold;">return</span> &amp;<span style="color: #df005f; font-weight: bold;">Cond</span>{<span style="color: #d75fd7;">L</span>: l}
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">Cond</span>) <span style="color: #d75fd7; font-weight: bold;">Wait</span>() {
    c.checker.<span style="color: #d75fd7; font-weight: bold;">check</span>()
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22686;&#21152;&#21040;&#31561;&#24453;&#38431;&#21015;&#20013;</span>
    <span style="color: #8787d7;">t</span> := <span style="color: #d75fd7; font-weight: bold;">runtime_notifyListAdd</span>(&amp;c.notify)
    c.L.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#38459;&#22622;&#20241;&#30496;&#30452;&#21040;&#34987;&#21796;&#37266;</span>
    <span style="color: #d75fd7; font-weight: bold;">runtime_notifyListWait</span>(&amp;c.notify, t)
    c.L.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">Cond</span>) <span style="color: #d75fd7; font-weight: bold;">Signal</span>() {
    c.checker.<span style="color: #d75fd7; font-weight: bold;">check</span>()
    <span style="color: #d75fd7; font-weight: bold;">runtime_notifyListNotifyOne</span>(&amp;c.notify)
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">Cond</span>) <span style="color: #d75fd7; font-weight: bold;">Broadcast</span>() {
    c.checker.<span style="color: #d75fd7; font-weight: bold;">check</span>()
    <span style="color: #d75fd7; font-weight: bold;">runtime_notifyListNotifyAll</span>(&amp;c.notify&#65289;
}
</pre>
</div>

<p>
runtime_notifyListXXX 是运行时实现的方法，实现了一个等待 / 通知的队列。如果你想深入学习这部分，可以再去看看 runtime/sema.go 代码中。<br>
</p>

<p>
copyChecker 是一个辅助结构，可以在运行时检查 Cond 是否被复制使用。<br>
</p>

<p>
Signal 和 Broadcast 只涉及到 notifyList 数据结构，不涉及到锁。<br>
</p>

<p>
Wait 把调用者加入到等待队列时会释放锁，在被唤醒之后还会请求锁。在阻塞休眠期间，调用者是不持有锁的，这样能让其他 goroutine 有机会检查或者更新等待变量。<br>
</p>

<p>
我们继续看看使用 Cond 常见的两个错误，一个是调用 Wait 的时候没有加锁，另一个是没有检查条件是否满足程序就继续执行了。<br>
</p>
</div>
</div>
<div id="outline-container-org60238c5" class="outline-2">
<h2 id="org60238c5">使用 Cond 的 2 个常见错误</h2>
<div class="outline-text-2" id="text-org60238c5">
<p>
我们先看 Cond 最常见的使用错误，也就是调用 Wait 的时候没有加锁。<br>
</p>

<p>
以前面百米赛跑的程序为例，在调用 cond.Wait 时，把前后的 Lock/Unlock 注释掉，如下面的代码中的第 20 行和第 25 行：<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">c</span> := sync.<span style="color: #d75fd7; font-weight: bold;">NewCond</span>(&amp;<span style="color: #df005f; font-weight: bold;">sync.Mutex</span>{})
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">ready</span> <span style="color: #df005f; font-weight: bold;">int</span>

    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := 0; i &lt; 10; i++ {
        <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>(<span style="color: #8787d7;">i</span> <span style="color: #df005f; font-weight: bold;">int</span>) {
            time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(time.<span style="color: #d75fd7; font-weight: bold;">Duration</span>(rand.<span style="color: #d75fd7; font-weight: bold;">Int63n</span>(10)) * time.Second)

            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21152;&#38145;&#26356;&#25913;&#31561;&#24453;&#26465;&#20214;</span>
            c.L.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
            ready++
            c.L.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()

            log.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"&#36816;&#21160;&#21592;#%d &#24050;&#20934;&#22791;&#23601;&#32490;\n"</span>, i)
            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#24191;&#25773;&#21796;&#37266;&#25152;&#26377;&#30340;&#31561;&#24453;&#32773;</span>
            c.<span style="color: #d75fd7; font-weight: bold;">Broadcast</span>()
        }(i)
    }

    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">c.L.Lock()</span>
    <span style="color: #268bd2; font-weight: bold;">for</span> ready != 10 {
        c.<span style="color: #d75fd7; font-weight: bold;">Wait</span>()
        log.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"&#35009;&#21028;&#21592;&#34987;&#21796;&#37266;&#19968;&#27425;"</span>)
    }
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">c.L.Unlock()</span>

    <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#25152;&#26377;&#30340;&#36816;&#21160;&#21592;&#26159;&#21542;&#23601;&#32490;</span>
    log.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"&#25152;&#26377;&#36816;&#21160;&#21592;&#37117;&#20934;&#22791;&#23601;&#32490;&#12290;&#27604;&#36187;&#24320;&#22987;&#65292;3&#65292;2&#65292;1, ......"</span>)
}
</pre>
</div>

<p>
再运行程序，就会报释放未加锁的 panic：<br>
</p>

<p>
出现这个问题的原因在于，cond.Wait 方法的实现是，把当前调用者加入到 notify 队列之中后会释放锁（如果不释放锁，其他 Wait 的调用者就没有机会加入到 notify 队列中了），然后一直等待；等调用者被唤醒之后，又会去争抢这把锁。如果调用 Wait 之前不加锁的话，就有可能 Unlock 一个未加锁的 Locker。所以切记， <b>调用 cond.Wait 方法之前一定要加锁</b> 。<br>
</p>

<p>
使用 Cond 的另一个常见错误是，只调用了一次 Wait，没有检查等待条件是否满足，结果条件没满足，程序就继续执行了。出现这个问题的原因在于，误以为 Cond 的使用，就像 WaitGroup 那样调用一下 Wait 方法等待那么简单。比如下面的代码中，把第 21 行和第 24 行注释掉：<br>
</p>

<div class="org-src-container">
<pre class="src src-go">
<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">c</span> := sync.<span style="color: #d75fd7; font-weight: bold;">NewCond</span>(&amp;<span style="color: #df005f; font-weight: bold;">sync.Mutex</span>{})
    <span style="color: #268bd2; font-weight: bold;">var</span> <span style="color: #8787d7;">ready</span> <span style="color: #df005f; font-weight: bold;">int</span>

    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">i</span> := 0; i &lt; 10; i++ {
        <span style="color: #268bd2; font-weight: bold;">go</span> <span style="color: #268bd2; font-weight: bold;">func</span>(<span style="color: #8787d7;">i</span> <span style="color: #df005f; font-weight: bold;">int</span>) {
            time.<span style="color: #d75fd7; font-weight: bold;">Sleep</span>(time.<span style="color: #d75fd7; font-weight: bold;">Duration</span>(rand.<span style="color: #d75fd7; font-weight: bold;">Int63n</span>(10)) * time.Second)

            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21152;&#38145;&#26356;&#25913;&#31561;&#24453;&#26465;&#20214;</span>
            c.L.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
            ready++
            c.L.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()

            log.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"&#36816;&#21160;&#21592;#%d &#24050;&#20934;&#22791;&#23601;&#32490;\n"</span>, i)
            <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#24191;&#25773;&#21796;&#37266;&#25152;&#26377;&#30340;&#31561;&#24453;&#32773;</span>
            c.<span style="color: #d75fd7; font-weight: bold;">Broadcast</span>()
        }(i)
    }

    c.L.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">for ready != 10 {</span>
    c.<span style="color: #d75fd7; font-weight: bold;">Wait</span>()
    log.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"&#35009;&#21028;&#21592;&#34987;&#21796;&#37266;&#19968;&#27425;"</span>)
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">}</span>
    c.L.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()

    <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#25152;&#26377;&#30340;&#36816;&#21160;&#21592;&#26159;&#21542;&#23601;&#32490;</span>
    log.<span style="color: #d75fd7; font-weight: bold;">Println</span>(<span style="color: #2aa198;">"&#25152;&#26377;&#36816;&#21160;&#21592;&#37117;&#20934;&#22791;&#23601;&#32490;&#12290;&#27604;&#36187;&#24320;&#22987;&#65292;3&#65292;2&#65292;1, ......"</span>)
}
</pre>
</div>

<p>
运行这个程序，你会发现，可能只有几个运动员准备好之后程序就运行完了，而不是我们期望的所有运动员都准备好才进行下一步。原因在于，每一个运动员准备好之后都会唤醒所有的等待者，也就是这里的裁判员，比如第一个运动员准备好后就唤醒了裁判员，结果这个裁判员傻傻地没做任何检查，以为所有的运动员都准备好了，就继续执行了。<br>
</p>

<p>
所以，一定要记住，waiter goroutine 被唤醒不等于等待条件被满足，只是有 goroutine 把它唤醒了而已，等待条件有可能已经满足了，也有可能不满足，我们需要进一步检查。你也可以理解为，等待者被唤醒，只是得到了一次检查的机会而已。<br>
</p>

<p>
到这里，我们小结下。如果你想在使用 Cond 的时候避免犯错，只要时刻记住调用 cond.Wait 方法之前一定要加锁，以及 waiter goroutine 被唤醒不等于等待条件被满足这两个知识点。<br>
</p>
</div>
</div>
<div id="outline-container-orgabcb9c3" class="outline-2">
<h2 id="orgabcb9c3">知名项目中 Cond 的使用</h2>
<div class="outline-text-2" id="text-orgabcb9c3">
<p>
Cond 在实际项目中被使用的机会比较少，原因总结起来有两个。<br>
</p>

<p>
第一，同样的场景我们会使用其他的并发原语来替代。Go 特有的 Channel 类型，有一个应用很广泛的模式就是通知机制，这个模式使用起来也特别简单。所以很多情况下，我们会使用 Channel 而不是 Cond 实现 wait/notify 机制。<br>
</p>

<p>
第二，对于简单的 wait/notify 场景，比如等待一组 goroutine 完成之后继续执行余下的代码，我们会使用 WaitGroup 来实现。因为 WaitGroup 的使用方法更简单，而且不容易出错。比如，上面百米赛跑的问题，就可以很方便地使用 WaitGroup 来实现。<br>
</p>

<p>
所以，我在这一讲开头提到，Cond 的使用场景很少。先前的标准库内部有几个地方使用了 Cond，比如 io/pipe.go 等，后来都被其他的并发原语（比如 Channel）替换了，sync.Cond 的路越走越窄。但是，还是有一批忠实的“粉丝”坚持在使用 Cond，原因在于 Cond 有三点特性是 Channel 无法替代的：<br>
</p>

<ul class="org-ul">
<li>Cond 和一个 Locker 关联，可以利用这个 Locker 对相关的依赖条件更改提供保护；<br></li>
<li>Cond 可以同时支持 Signal 和 Broadcast 方法，而 Channel 只能同时支持其中一种；<br></li>
<li>Cond 的 Broadcast 方法可以被重复调用。等待条件再次变成不满足的状态后，我们又可以调用 Broadcast 再次唤醒等待的 goroutine。这也是 Channel 不能支持的，Channel 被 close 掉了之后不支持再 open；<br></li>
</ul>

<p>
Kubernetes 项目中定义了优先级队列 <a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/scheduler/internal/queue/scheduling_queue.go">PriorityQueue</a> 这样一个数据结构，用来实现 Pod 的调用。它内部有三个 Pod 的队列，即 activeQ、podBackoffQ 和 unschedulableQ，其中 activeQ 就是用来调度的活跃队列（heap）。<br>
</p>

<p>
Pop 方法调用的时候，如果这个队列为空，并且这个队列没有 Close 的话，会调用 Cond 的 Wait 方法等待。<br>
</p>

<p>
你可以看到，调用 Wait 方法的时候，调用者是持有锁的，并且被唤醒的时候检查等待条件（队列是否为空）。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20174;&#38431;&#21015;&#20013;&#21462;&#20986;&#19968;&#20010;&#20803;&#32032;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">p</span> *<span style="color: #df005f; font-weight: bold;">PriorityQueue</span>) <span style="color: #d75fd7; font-weight: bold;">Pop</span>() (*<span style="color: #df005f; font-weight: bold;">framework.QueuedPodInfo</span>, <span style="color: #df005f; font-weight: bold;">error</span>) {
    p.lock.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
    <span style="color: #268bd2; font-weight: bold;">defer</span> p.lock.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
    <span style="color: #268bd2; font-weight: bold;">for</span> p.activeQ.<span style="color: #d75fd7; font-weight: bold;">Len</span>() == 0 { <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22914;&#26524;&#38431;&#21015;&#20026;&#31354;</span>
        <span style="color: #268bd2; font-weight: bold;">if</span> p.closed {
            <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">nil</span>, fmt.<span style="color: #d75fd7; font-weight: bold;">Errorf</span>(queueClosed)
        }
        p.cond.<span style="color: #d75fd7; font-weight: bold;">Wait</span>() <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#31561;&#24453;&#65292;&#30452;&#21040;&#34987;&#21796;&#37266;</span>
    }
    ......
        <span style="color: #268bd2; font-weight: bold;">return</span> pInfo, err
}   
</pre>
</div>

<p>
当 activeQ 增加新的元素时，会调用条件变量的 Boradcast 方法，通知被 Pop 阻塞的调用者。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#22686;&#21152;&#20803;&#32032;&#21040;&#38431;&#21015;&#20013;</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">p</span> *<span style="color: #df005f; font-weight: bold;">PriorityQueue</span>) <span style="color: #d75fd7; font-weight: bold;">Add</span>(<span style="color: #8787d7;">pod</span> *<span style="color: #df005f; font-weight: bold;">v1.Pod</span>) <span style="color: #df005f; font-weight: bold;">error</span> {
    p.lock.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
    <span style="color: #268bd2; font-weight: bold;">defer</span> p.lock.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
    <span style="color: #8787d7;">pInfo</span> := p.<span style="color: #d75fd7; font-weight: bold;">newQueuedPodInfo</span>(pod)
    <span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #8787d7;">err</span> := p.activeQ.<span style="color: #d75fd7; font-weight: bold;">Add</span>(pInfo); err != <span style="color: #d75fd7;">nil</span> {<span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#22686;&#21152;&#20803;&#32032;&#21040;&#38431;&#21015;&#20013;</span>
        klog.<span style="color: #d75fd7; font-weight: bold;">Errorf</span>(<span style="color: #2aa198;">"Error adding pod %v to the scheduling queue: %v"</span>, <span style="color: #d75fd7; font-weight: bold;">nsNameForPod</span>(pod), err)
        <span style="color: #268bd2; font-weight: bold;">return</span> err
    }
    ......
        p.cond.<span style="color: #d75fd7; font-weight: bold;">Broadcast</span>() <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#36890;&#30693;&#20854;&#23427;&#31561;&#24453;&#30340;goroutine&#65292;&#38431;&#21015;&#20013;&#26377;&#20803;&#32032;&#20102;</span>

    <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">nil</span>
}
</pre>
</div>

<p>
这个优先级队列被关闭的时候，也会调用 Broadcast 方法，避免被 Pop 阻塞的调用者永远 hang 住。<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">p</span> *<span style="color: #df005f; font-weight: bold;">PriorityQueue</span>) <span style="color: #d75fd7; font-weight: bold;">Close</span>() {
    p.lock.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
    <span style="color: #268bd2; font-weight: bold;">defer</span> p.lock.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
    <span style="color: #268bd2;">close</span>(p.stop)
    p.closed = <span style="color: #d75fd7;">true</span>
    p.cond.<span style="color: #d75fd7; font-weight: bold;">Broadcast</span>() <span style="color: #008787; background-color: #262626;">//</span><span style="color: #008787; background-color: #262626;">&#20851;&#38381;&#26102;&#36890;&#30693;&#31561;&#24453;&#30340;goroutine&#65292;&#36991;&#20813;&#23427;&#20204;&#27704;&#36828;&#31561;&#24453;</span>
}
</pre>
</div>

<p>
可以思考一下，这里为什么使用 Cond 这个并发原语，能不能换成 Channel 实现呢？<br>
</p>
</div>
</div>
<div id="outline-container-orgd749984" class="outline-2">
<h2 id="orgd749984">总结</h2>
<div class="outline-text-2" id="text-orgd749984">
<p>
Cond 是为等待 / 通知场景下的并发问题提供支持的。它提供了条件变量的三个基本方法 Signal、Broadcast 和 Wait，为并发的 goroutine 提供等待 / 通知机制。<br>
</p>

<p>
在实践中，处理等待 / 通知的场景时，我们常常会使用 Channel 替换 Cond，因为 Channel 类型使用起来更简洁，而且不容易出错。但是对于需要重复调用 Broadcast 的场景，比如上面 Kubernetes 的例子，每次往队列中成功增加了元素后就需要调用 Broadcast 通知所有的等待者，使用 Cond 就再合适不过了。<br>
</p>

<p>
使用 Cond 之所以容易出错，就是 Wait 调用需要加锁，以及被唤醒后一定要检查条件是否真的已经满足。你需要牢记这两点。<br>
</p>

<p>
虽然我们讲到的百米赛跑的例子，也可以通过 WaitGroup 来实现，但是本质上 WaitGroup 和 Cond 是有区别的：WaitGroup 是主 goroutine 等待确定数量的子 goroutine 完成任务；而 Cond 是等待某个条件满足，这个条件的修改可以被任意多的 goroutine 更新，而且 Cond 的 Wait 不关心也不知道其他 goroutine 的数量，只关心等待条件。而且 Cond 还有单个通知的机制，也就是 Signal 方法。<br>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-06-29 Wed 14:30</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
