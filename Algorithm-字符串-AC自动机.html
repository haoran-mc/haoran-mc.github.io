<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-11-08 Mon 08:32 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>AC自动机</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2021, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">AC自动机</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb904c43">简介</a></li>
<li><a href="#org98569e2">失配指针</a></li>
<li><a href="#org7e8ffed">构建指针</a></li>
<li><a href="#org00de0f1">代码实现</a></li>
<li><a href="#orgf4e2182">Trie 图</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgb904c43" class="outline-2">
<h2 id="orgb904c43">简介</h2>
<div class="outline-text-2" id="text-orgb904c43">
<p>
AC自动机是以 <a href="Algorithm-字符串-字典树.html">Trie</a> 的结构为基础，结合 <a href="Algorithm-字符串-前缀函数与KMP算法.html">KMP</a> 的思想建立的。<br>
</p>

<p>
简单来说，建立一个AC自动机有两个步骤：<br>
</p>
<ol class="org-ol">
<li>创建一个字典树<br></li>
<li>对字典树上所有的结点构造失配指针<br></li>
</ol>
</div>
</div>
<div id="outline-container-org98569e2" class="outline-2">
<h2 id="org98569e2">失配指针</h2>
<div class="outline-text-2" id="text-org98569e2">
<p>
AC自动机利用一个 \(fail\) 指针来辅助多模式串的匹配。<br>
</p>

<p>
状态 \(u\) 的 \(fail\) 指针指向另一个状态 \(v\)，状态 \(u, v\) 都要是字典树中被标记过的节点，且 \(v\) 是 \(u\) 的最长后缀，这里简单对比一下这里的 \(fail\) 指针与 \(KMP\) 中的 \(next\) 指针：<br>
</p>

<ol class="org-ol">
<li>共同点：两者同样是在失配的时候用于跳转的指针。<br></li>
<li>不同点：\(next\) 指针求的是最长相同前后缀，而 \(fail\) 指针指向所有模式串的前缀中匹配当前状态的最长后缀。<br></li>
</ol>

<p>
因为 KMP 只对一个模式串做匹配，而AC自动机要对多个模式串做匹配，所以 fail 指针指向的结点对应着另一个模式串，这个模式串是前一个模式串的最长后缀。<br>
</p>
</div>
</div>
<div id="outline-container-org7e8ffed" class="outline-2">
<h2 id="org7e8ffed">构建指针</h2>
<div class="outline-text-2" id="text-org7e8ffed">
<p>
考虑字典树中当前的结点 \(u\)，\(u\) 的父结点是 \(p\)，\(p\) 通过字符 \(c\) 的边指向 \(u\)，即 \(trie[p, c] = u\)，假设深度小于 \(u\) 的所有结点的 \(fail\) 指针都已求得。<br>
</p>

<ol class="org-ol">
<li>如果 \(trie[fail[p], c]\) 存在：则让 \(u\) 的 \(fail\) 指针指向 \(trie[fail[p], c]\)。<br></li>
<li>如果 \(trie[fail[p], c]\) 不存在：那么我们继续找到 \(trie[fail[fail[p]], c]\)，如果还不存在，继续寻找 \(trie[fail[fail[fail[p]]], c]\)，直到存在这样的一个 \(c\) 或者 \(fail\) 跳到根结点。<br></li>
<li>如果 \(fail\) 跳到了根结点，那就让这个 \(u\) 的 \(fail\) 指针指向根结点，表示没有出现过当前这个子串的后缀。<br></li>
</ol>

<br/><img src="./images/AC自动机01.png" width=550px />

<p>
假设我们按上图开始求结点 \(9\) 的失配指针：<br>
</p>

<p>
在这里，当前结点 \(u = 9\) 的父结点就是 \(p = 8\)，\(p\) 通过字符 <code>e</code> 的边指向 \(u\)，即 \(trie[p, c] = u\)，且深度小于 \(u\) 的所有结点的 \(fail\) 指针都已求得。<br>
</p>

<ol class="org-ol">
<li>如果 \(trie[fail[p], c] = trie[fail[8], 'e'] = trie[1, 'e']\) 存在：则让 \(u\) 的 \(fail\) 指针指向 \(trie[fail[p], c] = trie[1, 'e']\)，显然这里存在，那么有 \(fail[9] = trie[1, 'e'] = 2\)；<br></li>
<li>我们假设结点 \(1\) 到结点 \(2\) 上的字符不是 <code>e</code> ，也就是 \(trie[fail[p], c] = trie[fail[8], 'e'] = trie[1, 'e']\) 不存在：继续寻找 \(trie[fail[fail[p]], c] = trie[fail[1], 'e'] = trie[0, 'e']\)，发现还是没有，且现在 \(fail\) 已经在根结点处了，所以进入下一步 \(3\)；<br></li>
<li>如果 \(fail\) 跳到了根结点，那就让这个 \(u\) 的 \(fail\) 指针指向根结点；<br></li>
</ol>
</div>
</div>
<div id="outline-container-org00de0f1" class="outline-2">
<h2 id="org00de0f1">代码实现</h2>
<div class="outline-text-2" id="text-org00de0f1">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #7c7c7c; font-style: italic;">// </span><span style="color: #7c7c7c; font-style: italic;">fail &#25351;&#38024;&#26500;&#24314;&#36807;&#31243;</span>
<span style="color: #AFAFAF;">void</span> <span style="color: #AFAFAF;">build</span>() {
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">hh</span> = <span style="color: #009F9F;">0</span>, <span style="color: #AFAFAF;">tt</span> = -<span style="color: #009F9F;">1</span>;
    <span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">i</span> = <span style="color: #009F9F;">0</span>; i &lt; <span style="color: #009F9F;">26</span>; ++ i)
        <span style="color: #BD93F9;">if</span> (tr[<span style="color: #009F9F;">0</span>][i]) {
            ne[tr[<span style="color: #009F9F;">0</span>][i]] = <span style="color: #009F9F;">0</span>;
            q[ ++ tt] = tr[<span style="color: #009F9F;">0</span>][i];
        }
    <span style="color: #BD93F9;">while</span> (hh &lt;= tt) {
        <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">t</span> = q[hh ++ ];
        <span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">i</span> = <span style="color: #009F9F;">0</span>; i &lt; <span style="color: #009F9F;">26</span>; ++ i) {
            <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">c</span> = tr[t][i];
            <span style="color: #BD93F9;">if</span> (!c)
                <span style="color: #BD93F9;">continue</span>;
            <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">j</span> = ne[t];
            <span style="color: #BD93F9;">while</span> (j &amp;&amp; !tr[j][i])
                j = ne[j];
            <span style="color: #BD93F9;">if</span> (tr[j][i])
                j = tr[j][i];
            ne[c] = j;
            q[ ++ tt] = c;
        }
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf4e2182" class="outline-2">
<h2 id="orgf4e2182">Trie 图</h2>
<div class="outline-text-2" id="text-orgf4e2182">
<p>
如果数据叼钻，AC自动机中的第 \(2\) 步可能会跳很多次，Trie图是AC自动机在这步进行的优化。<br>
</p>

<ul class="org-ul">
<li>如果 \(trie[fail[p], c]\) 不存在：那么我们直接 \(trie[p, c] = trie[fail[p], c]\)<br></li>
</ul>

<img src="./images/AC自动机02.png" width=550px />

<p>
这样，我们在匹配时也同样不需要 \(fail\) 指针一直跳，相当于少了一层循环，时间复杂度是 \(O(n)\) （AC自动机的时间复杂度也是线性的），优化了一些，代码也更短。<br>
</p>

<p>
代码：<br>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #AFAFAF;">void</span> <span style="color: #AFAFAF;">build</span>() {
    <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">hh</span> = <span style="color: #009F9F;">0</span>, <span style="color: #AFAFAF;">tt</span> = -<span style="color: #009F9F;">1</span>;
    <span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">i</span> = <span style="color: #009F9F;">0</span>; i &lt; <span style="color: #009F9F;">26</span>; ++ i)
        <span style="color: #BD93F9;">if</span> (tr[<span style="color: #009F9F;">0</span>][i]) {
            ne[tr[<span style="color: #009F9F;">0</span>][i]] = <span style="color: #009F9F;">0</span>;
            q[ ++ tt] = tr[<span style="color: #009F9F;">0</span>][i];
        }
    <span style="color: #BD93F9;">while</span> (hh &lt;= tt) {
        <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">t</span> = q[hh ++ ];
        <span style="color: #BD93F9;">for</span> (<span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">i</span> = <span style="color: #009F9F;">0</span>; i &lt; <span style="color: #009F9F;">26</span>; ++ i) {
            <span style="color: #AFAFAF;">int</span> <span style="color: #AFAFAF;">c</span> = tr[t][i];
            <span style="color: #BD93F9;">if</span> (!c) {
                tr[t][i] = tr[ne[t]][i];
            }
            <span style="color: #BD93F9;">else</span> {
                ne[c] = tr[ne[t]][i];
                q[ ++ tt] = c;
            }
        }
    }
}
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2021-11-03 22:11 Wed</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2021-11-08 Mon 08:32</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
