<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-07-16 Sat 16:25 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>五种IO模型</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">五种IO模型</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org4053e70">概念说明</a>
<ul>
<li><a href="#org4b1ef1b">Socket</a></li>
<li><a href="#org6ff998c">Socket 缓冲区</a></li>
<li><a href="#orgfceb947">用户空间、内核空间、系统调用</a></li>
<li><a href="#org0f57213">阻塞与非阻塞</a></li>
<li><a href="#org63554a1">同步与异步</a></li>
</ul>
</li>
<li><a href="#org3305299">五种 IO 模型</a>
<ul>
<li><a href="#orgab001cf">TCP 发送数据的流程</a></li>
<li><a href="#org8fb56ef">阻塞 IO | 非阻塞 IO</a>
<ul>
<li><a href="#org2476e40">阻塞 IO 模型</a></li>
<li><a href="#org08cd6fe">非阻塞 IO 模型</a></li>
</ul>
</li>
<li><a href="#org6553497">IO 复用模型</a></li>
<li><a href="#orga37c35e">信号驱动 IO 模型</a></li>
<li><a href="#org9d8b40e">异步 IO 模型</a></li>
<li><a href="#org07120cc">总结</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org4053e70" class="outline-2">
<h2 id="org4053e70">概念说明</h2>
<div class="outline-text-2" id="text-org4053e70">
</div>
<div id="outline-container-org4b1ef1b" class="outline-3">
<h3 id="org4b1ef1b">Socket</h3>
<div class="outline-text-3" id="text-org4b1ef1b">
<p>
Socket 中文翻译为套接字，是计算机网络中进程间进行双向通信的端点的抽象。一个 Socket 代表了网络通信的一端，是由操作系统提供的进程间通信机制。<br>
</p>

<ul class="org-ul">
<li>在操作系统中，通常会为应用程序提供一组应用程序接口，称为 Socket 接口（Socket API）。应用程序可以通过 Socket 接口，来使用网络 Socket，以进行数据的传输；<br></li>
<li>一个 Socket 由IP地址和端口组成，即：Socket 地址 = IP地址 : 端口号；<br></li>
<li>在同一台计算机上，TCP 协议与 UDP 协议可以同时使用相同的端口（Port），而互不干扰；<br></li>
<li>要想实现网络通信，至少需要一对 Socket，其中一个运行在客户端，称之为 Client Socket；另一个运行在服务器端，称之为 Server Socket；<br></li>
<li>Socket 之间的连接过程可以分为三个步骤：（1）服务器监听；（2）客户端连接；（3）连接确认；<br></li>
</ul>
</div>
</div>
<div id="outline-container-org6ff998c" class="outline-3">
<h3 id="org6ff998c">Socket 缓冲区</h3>
<div class="outline-text-3" id="text-org6ff998c">
<p>
每个 Socket 被创建后，都会在内核中分配两个缓冲区：输入缓冲区和输出缓冲区。<br>
</p>

<ul class="org-ul">
<li>通过 Socket 发送数据并不会立即向网络中传输数据，而是先将数据写入到输出缓冲区中，再由 TCP 协议将数据从输出缓冲区发送到目标主机；<br></li>
<li>通过 Socket 接收数据也是如此，也是从输入缓冲区中读取数据，而不是直接从网络中读取；<br></li>
</ul>
</div>
</div>
<div id="outline-container-orgfceb947" class="outline-3">
<h3 id="orgfceb947">用户空间、内核空间、系统调用</h3>
<div class="outline-text-3" id="text-orgfceb947">
<p>
操作系统的进程空间可以分为用户空间（User Space）和内核空间（Kernel Space），它们需要不同的执行权限。<br>
</p>

<ul class="org-ul">
<li>大多数系统交互式操作需要在内核空间中运行，比如设备 IO 操作。<br></li>
<li>我们的应用程序运行在用户空间，是不具备系统级的直接操作权限的。如果应用程序想要访问系统核心功能，必须通过系统调用（System Call）来完成。比如调用recv()函数，会将输入缓冲区中的内容拷贝到用户缓冲区。<br></li>
<li>系统调用运行在内核空间，是操作系统为应用程序提供的接口。<br></li>
</ul>

<div class="div-center">
	<img src="./images/用户空间、内核空间、系统调用.webp" />
</div>

<p>
下面列举了一些 Linux 操作系统中的系统调用接口（部分函数后面章节会用到）：<br>
</p>

<dl class="org-dl">
<dt>socketcall</dt><dd>socket 系统调用<br></dd>
<dt>socket</dt><dd>建立 socket<br></dd>
<dt>bind 绑定</dt><dd>socket 到端口<br></dd>
<dt>connect</dt><dd>连接远程主机<br></dd>
<dt>accept</dt><dd>响应 socket 连接请求<br></dd>
<dt>send</dt><dd>通过 socket 发送信息<br></dd>
<dt>sendto</dt><dd>发送 UDP 信息<br></dd>
<dt>recv</dt><dd>通过 socket 接收信息<br></dd>
<dt>recvfrom</dt><dd>接收 UDP 信息<br></dd>
<dt>listen</dt><dd>监听 socket 端口<br></dd>
<dt>select</dt><dd>对多路同步 IO 进行轮询<br></dd>
<dt>shutdown</dt><dd>关闭 socket 上的连接<br></dd>
<dt>sigaction</dt><dd>设置对指定信号的处理方法<br></dd>
</dl>
</div>
</div>
<div id="outline-container-org0f57213" class="outline-3">
<h3 id="org0f57213">阻塞与非阻塞</h3>
<div class="outline-text-3" id="text-org0f57213">
<p>
阻塞与非阻塞，用于描述调用者在等待返回结果时的状态。<br>
</p>

<ul class="org-ul">
<li>阻塞：调用者发起请求后，会一直等待返回结果，这期间当前线程会被挂起（阻塞）；<br></li>
<li>非阻塞：调用者发起请求后，会立刻返回，当前线程也不会阻塞。该调用不会立刻得到结果，调用者需要定时轮询查看处理状态；<br></li>
</ul>
</div>
</div>
<div id="outline-container-org63554a1" class="outline-3">
<h3 id="org63554a1">同步与异步</h3>
<div class="outline-text-3" id="text-org63554a1">
<p>
而同步与异步，用于描述调用结果的返回机制（或者叫通信机制）。<br>
</p>

<ul class="org-ul">
<li>同步：调用者发起请求后，会一直等待返回结果，即由调用者主动等待这个调用结果；<br></li>
<li>异步：调用者发起请求后，会立刻返回，但不会立刻得到这个结果，而是由被调者在执行结束后主动通知（如 Callback）调用者；<br></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3305299" class="outline-2">
<h2 id="org3305299">五种 IO 模型</h2>
<div class="outline-text-2" id="text-org3305299">
</div>
<div id="outline-container-orgab001cf" class="outline-3">
<h3 id="orgab001cf">TCP 发送数据的流程</h3>
<div class="outline-text-3" id="text-orgab001cf">
<p>
当 A 向 B 发送一条消息，简单来说会经过如下流程：<br>
</p>

<p>
第一步：应用 A 把消息发送到 TCP 发送缓冲区；<br>
第二步：TCP 发送缓冲区再把消息发送出去，经过网络传递后，消息会发送到 B 服务器的 TCP 接收缓冲区；<br>
第三步：B 再从 TCP 接收缓冲区去读取属于自己的数据；<br>
</p>

<div class="div-center">
	<img src="./images/TCP发送数据的流程.png" />
</div>
</div>
</div>
<div id="outline-container-org8fb56ef" class="outline-3">
<h3 id="org8fb56ef">阻塞 IO | 非阻塞 IO</h3>
<div class="outline-text-3" id="text-org8fb56ef">
<p>
关注上图中的第三步，也就是应用 B 从 TCP 缓冲区中读取数据。<br>
</p>

<div class="div-center">
	<img src="./images/应用B从TCP接收缓冲区读取消息.png" />
</div>

<p>
应用之间发送消息是间断性的，我们根据在 TCP 缓冲区还没接收到属于应用 B 的数据时，B 此时是继续等待直到接收到数据还是立即返回等有数据时再处理的状态来判断 IO 的模型是阻塞 IO 还是 非阻塞 IO。<br>
</p>

<p>
同理，可以将这个问题应用到第一步。<br>
</p>
</div>
<div id="outline-container-org2476e40" class="outline-4">
<h4 id="org2476e40">阻塞 IO 模型</h4>
<div class="outline-text-4" id="text-org2476e40">
<p>
当应用 B 发起读取数据申请时，如果内核数据还没有准备好，应用 B 会一直处于等待数据状态，直到内核把数据准备好了交给应用 B 才结束。<br>
</p>
</div>
</div>
<div id="outline-container-org08cd6fe" class="outline-4">
<h4 id="org08cd6fe">非阻塞 IO 模型</h4>
<div class="outline-text-4" id="text-org08cd6fe">
<p>
当应用 B 发起读取数据请求时，如果内核数据还没有准备好会立刻告诉应用 B，不会让 B 等待。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org6553497" class="outline-3">
<h3 id="org6553497">IO 复用模型</h3>
<div class="outline-text-3" id="text-org6553497">
<p>
继续看应用 B 从 TCP 缓冲区中读取数据这个环节，如果在并发的环境下，可能会有 N 个人向 B 发消息，这种情况下我们的应用就必须创建多个线程来读取数据，每个线程都会自己调用 recvfrom 读取数据：<br>
</p>

<div class="div-center">
	<img src="./images/多线程读取数据.png" />
</div>

<p>
并发情况下服务器很可能一瞬间收到几十上百万的请求，这种情况下应用 B 就需要创建几十上百万的线程去读取数据，同时又因为应用线程是不知道什么时候会有数据读取，为了保证消息能及时读取到，那么这些线程自己必须不断地向内核发送 recvfrom 请求来读取数据。<br>
</p>

<p>
这么多的线程不断调用 recvfrom 请求数据，很明显这种方式太浪费资源了，线程是我们操作系统的宝贵资源，大量的线程用来去读取数据了，那么就意味着能做其他事情的线程就少了。<br>
</p>

<p>
所以就有人提出能否由一个线程监控多个网络请求（也就是 fd 文件描述符），这样就可以只需要一个或几个线程就可以完成数据状态询问的操作，当有数据准备就绪之后再分配对应的线程去读取数据，这么做就可以节省出大量的线程资源出来，这就是 IO 复用模型的思路。<br>
</p>

<div class="div-center">
	<img src="./images/IO复用.png" />
</div>

<p>
IO 复用模型的思路就是系统提供了一种可以同时监控多个 fd 的操作，也就是我们常说的 select、poll、epoll 函数。<br>
</p>
</div>
</div>
<div id="outline-container-orga37c35e" class="outline-3">
<h3 id="orga37c35e">信号驱动 IO 模型</h3>
<div class="outline-text-3" id="text-orga37c35e">
<p>
复用 IO 模型的无脑轮询显得有点暴力，大部分情况下的轮询都是无效的，为了改善这种情况，衍生出了信号驱动 IO 模型，不是我总去询问数据是否准备就绪，而是等你数据好了就通知我。<br>
</p>

<p>
信号驱动 IO 是在调用 sigaction 时建立一个 SIGIO 的信号联系，当内核数据准备好之后再通过 SIGIO 信号通知线程数据准备好后的可读状态，当线程收到可读状态的信号后，此时再向内核发起 recvfrom 读取数据的请求。<br>
</p>

<p>
因为信号驱动 IO 模型下应用线程在发出信号监控后即可返回，不会阻塞，所以这样的方式下，一个应用线程可以同时监控多个 fd。<br>
</p>

<div class="div-center">
	<img src="./images/信号驱动IO模型.png" />
</div>
</div>
</div>
<div id="outline-container-org9d8b40e" class="outline-3">
<h3 id="org9d8b40e">异步 IO 模型</h3>
<div class="outline-text-3" id="text-org9d8b40e">
<p>
通过观察发现，不管是 IO 复用还是信号驱动，我们要读取一个数据总是要发起两个阶段的请求，第一次发送 select 请求，询问数据状态是否准备好，第二次发送 recvfrom 请求读取数据。<br>
</p>

<p>
那么我们可不可以发送一个请求，然后就不管了，当数据到达的时候让内核去帮我将数据复制到用户空间？<br>
</p>

<p>
而这种模式就是异步 IO 模型。<br>
</p>

<div class="div-center">
	<img src="./images/异步IO模型.png" />
</div>
</div>
</div>
<div id="outline-container-org07120cc" class="outline-3">
<h3 id="org07120cc">总结</h3>
<div class="outline-text-3" id="text-org07120cc">
<p>
从上述五种 IO 模型可以看出，应用进程对内核发起 IO 系统调用后，内核会经过两个阶段来完成数据的传输：<br>
</p>

<p>
第一阶段：等待数据。即应用进程发起 IO 系统调用后，会一直等待数据；当有数据传入服务器，会将数据放入内核空间，此时数据准备好。<br>
第二阶段：将数据从内核空间复制到用户空间，并返回给应用程序成功标识。<br>
</p>

<p>
前四种模型的第二阶段是相同的，都是处于阻塞状态，其主要区别在第一阶段。而异步 IO 模型则不同，应用进程在这两个阶段是完全不阻塞的。<br>
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">IO</th>
<th scope="col" class="org-left">模型</th>
<th scope="col" class="org-left">第一阶段</th>
<th scope="col" class="org-left">第二阶段</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">阻塞式IO</td>
<td class="org-left">阻塞</td>
<td class="org-left">阻塞</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">非阻塞式IO</td>
<td class="org-left">非阻塞</td>
<td class="org-left">阻塞</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">IO多路程复用</td>
<td class="org-left">阻塞（Select）</td>
<td class="org-left">阻塞</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">信号驱动式IO</td>
<td class="org-left">异步</td>
<td class="org-left">阻塞</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">异步IO</td>
<td class="org-left">异步</td>
<td class="org-left">异步</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-07-16 Sat 16:25</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
