<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-02-18 Fri 18:08 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>HTTP包的内存泄漏</title>
<meta name="generator" content="Org mode">
<meta name="author" content="L.M.haoran">
<meta name="description" content="Copyright © 2022, L.M.haoran, all rights reserved."
>

                <link rel="stylesheet" href="static/css/org.css" type="text/css"  />
                <script type="module" src="static/js/main.js" defer></script>
                <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="content">
<h1 class="title">HTTP包的内存泄漏</h1>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">package</span> main

<span style="color: #268bd2; font-weight: bold;">import</span> (
    <span style="color: #2aa198;">"fmt"</span>
    <span style="color: #2aa198;">"io/ioutil"</span>
    <span style="color: #2aa198;">"net/http"</span>
    <span style="color: #2aa198;">"runtime"</span>
)

<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">main</span>() {
    <span style="color: #8787d7;">num</span> := <span style="color: #d75fd7;">6</span>
    <span style="color: #268bd2; font-weight: bold;">for</span> <span style="color: #8787d7;">index</span> := <span style="color: #d75fd7;">0</span>; index &lt; num; index++ {
        <span style="color: #8787d7;">resp</span>, <span style="color: #8787d7;">_</span> := http.<span style="color: #d75fd7; font-weight: bold;">Get</span>(<span style="color: #2aa198;">"https://www.baidu.com"</span>)
        _, _ = ioutil.<span style="color: #d75fd7; font-weight: bold;">ReadAll</span>(resp.Body)
    }
    fmt.<span style="color: #d75fd7; font-weight: bold;">Printf</span>(<span style="color: #2aa198;">"&#27492;&#26102; goroutine &#20010;&#25968;= %d\n"</span>, runtime.<span style="color: #d75fd7; font-weight: bold;">NumGoroutine</span>())
}
</pre>
</div>

<p>
上面这道题在不执行 <code>resp.Body.Close()</code> 的情况下，泄漏了吗？如果泄漏，泄漏了多少个 goroutine?<br>
</p>

<p>
不进行 <code>resp.Body.Close()</code> ，泄漏是一定的。但是泄漏的 goroutine 个数就让我迷糊了。由于执行了 6 遍，每次泄漏一个读和写 goroutine，就是 12 个 goroutine，加上 main 函数本身也是一个 goroutine，所以答案是 13.<br>
</p>

<p>
然而执行程序，发现答案是 3，出入有点大，为什么呢？<br>
</p>

<p>
我们直接看源码。golang 的 http 包。<br>
</p>

<div class="org-src-container">
<pre class="src src-go">http.<span style="color: #d75fd7; font-weight: bold;">Get</span>()

-- DefaultClient.Get
----<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">Client</span>) <span style="color: #d75fd7; font-weight: bold;">do</span>(<span style="color: #8787d7;">req</span> *<span style="color: #df005f; font-weight: bold;">Request</span>)
------<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">send</span>(<span style="color: #8787d7;">ireq</span> *<span style="color: #df005f; font-weight: bold;">Request</span>, <span style="color: #8787d7;">rt</span> <span style="color: #df005f; font-weight: bold;">RoundTripper</span>, <span style="color: #8787d7;">deadline</span> <span style="color: #df005f; font-weight: bold;">time.Time</span>)
-------- resp, didTimeout, err = <span style="color: #d75fd7; font-weight: bold;">send</span>(req, c.<span style="color: #d75fd7; font-weight: bold;">transport</span>(), deadline) 
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20197;&#19978;&#20195;&#30721;&#22312; go/1.12.7/libexec/src/net/http/client:174 </span>

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">c</span> *<span style="color: #df005f; font-weight: bold;">Client</span>) <span style="color: #d75fd7; font-weight: bold;">transport</span>() <span style="color: #df005f; font-weight: bold;">RoundTripper</span> {
    <span style="color: #268bd2; font-weight: bold;">if</span> c.Transport != <span style="color: #d75fd7;">nil</span> {
        <span style="color: #268bd2; font-weight: bold;">return</span> c.Transport
    }
    <span style="color: #268bd2; font-weight: bold;">return</span> DefaultTransport
}
</pre>
</div>

<ul class="org-ul">
<li>说明 <code>http.Get</code> 默认使用 <code>DefaultTransport</code> 管理连接。<br></li>
</ul>

<p>
DefaultTransport 是干嘛的呢？<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">It establishes network connections as needed</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">and caches them for reuse by subsequent calls.</span>
</pre>
</div>

<ul class="org-ul">
<li><code>DefaultTransport</code> 的作用是根据需要建立网络连接并缓存它们以供后续调用重用。<br></li>
</ul>

<p>
那么 <code>DefaultTransport</code> 什么时候会建立连接呢？<br>
</p>

<p>
接着上面的代码堆栈往下翻<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">send</span>(<span style="color: #8787d7;">ireq</span> *<span style="color: #df005f; font-weight: bold;">Request</span>, <span style="color: #8787d7;">rt</span> <span style="color: #df005f; font-weight: bold;">RoundTripper</span>, <span style="color: #8787d7;">deadline</span> <span style="color: #df005f; font-weight: bold;">time.Time</span>) 
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">--resp, err = rt.RoundTrip(req) // &#20197;&#19978;&#20195;&#30721;&#22312; go/1.12.7/libexec/src/net/http/client:250</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">t</span> *<span style="color: #df005f; font-weight: bold;">Transport</span>) <span style="color: #d75fd7; font-weight: bold;">RoundTrip</span>(<span style="color: #8787d7;">req</span> *<span style="color: #df005f; font-weight: bold;">http.Request</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">t</span> *<span style="color: #df005f; font-weight: bold;">Transport</span>) <span style="color: #d75fd7; font-weight: bold;">roundTrip</span>(<span style="color: #8787d7;">req</span> *<span style="color: #df005f; font-weight: bold;">Request</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">t</span> *<span style="color: #df005f; font-weight: bold;">Transport</span>) <span style="color: #d75fd7; font-weight: bold;">getConn</span>(<span style="color: #8787d7;">treq</span> *<span style="color: #df005f; font-weight: bold;">transportRequest</span>, <span style="color: #8787d7;">cm</span> <span style="color: #df005f; font-weight: bold;">connectMethod</span>)
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">t</span> *<span style="color: #df005f; font-weight: bold;">Transport</span>) <span style="color: #d75fd7; font-weight: bold;">dialConn</span>(<span style="color: #8787d7;">ctx</span> <span style="color: #df005f; font-weight: bold;">context.Context</span>, <span style="color: #8787d7;">cm</span> <span style="color: #df005f; font-weight: bold;">connectMethod</span>) (*<span style="color: #df005f; font-weight: bold;">persistConn</span>, <span style="color: #df005f; font-weight: bold;">error</span>) {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">...</span>
    <span style="color: #268bd2; font-weight: bold;">go</span> pconn.<span style="color: #d75fd7; font-weight: bold;">readLoop</span>()  <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21551;&#21160;&#19968;&#20010;&#35835;goroutine</span>
    <span style="color: #268bd2; font-weight: bold;">go</span> pconn.<span style="color: #d75fd7; font-weight: bold;">writeLoop</span>() <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#21551;&#21160;&#19968;&#20010;&#20889;goroutine</span>
    <span style="color: #268bd2; font-weight: bold;">return</span> pconn, <span style="color: #d75fd7;">nil</span>
}
</pre>
</div>

<ul class="org-ul">
<li>一次建立连接，就会启动一个读 goroutine 和写 goroutine。这就是为什么一次 <code>http.Get()</code> 会泄漏两个 goroutine 的来源。<br></li>
<li>泄漏的来源知道了，也知道是因为没有执行 close。<br></li>
</ul>

<p>
<b>那为什么不执行 close 会泄漏呢？</b><br>
</p>

<p>
回到刚刚启动的读 goroutine 的 <code>readLoop()</code> 代码里<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">pc</span> *<span style="color: #df005f; font-weight: bold;">persistConn</span>) <span style="color: #d75fd7; font-weight: bold;">readLoop</span>() {
    <span style="color: #8787d7;">alive</span> := <span style="color: #d75fd7;">true</span>
    <span style="color: #268bd2; font-weight: bold;">for</span> alive {
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">...</span>
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">Before looping back to the top of this function and peeking on</span>
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">the bufio.Reader, wait for the caller goroutine to finish</span>
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">reading the response body. (or for cancelation or death)</span>
        <span style="color: #268bd2; font-weight: bold;">select</span> {
        <span style="color: #268bd2; font-weight: bold;">case</span> <span style="color: #8787d7;">bodyEOF</span> := &lt;-waitForBodyRead:
            pc.t.<span style="color: #d75fd7; font-weight: bold;">setReqCanceler</span>(rc.req, <span style="color: #d75fd7;">nil</span>) <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">before pc might return to idle pool</span>
            alive = alive &amp;&amp;
                bodyEOF &amp;&amp;
                <span style="color: #d75fd7;">!</span>pc.sawEOF &amp;&amp;
                pc.<span style="color: #d75fd7; font-weight: bold;">wroteRequest</span>() &amp;&amp;
                <span style="color: #d75fd7; font-weight: bold;">tryPutIdleConn</span>(trace)
            <span style="color: #268bd2; font-weight: bold;">if</span> bodyEOF {
                eofc &lt;- <span style="color: #268bd2; font-weight: bold;">struct</span>{}{}
            }
        <span style="color: #268bd2; font-weight: bold;">case</span> &lt;-rc.req.Cancel:
            alive = <span style="color: #d75fd7;">false</span>
            pc.t.<span style="color: #d75fd7; font-weight: bold;">CancelRequest</span>(rc.req)
        <span style="color: #268bd2; font-weight: bold;">case</span> &lt;-rc.req.<span style="color: #d75fd7; font-weight: bold;">Context</span>().<span style="color: #d75fd7; font-weight: bold;">Done</span>():
            alive = <span style="color: #d75fd7;">false</span>
            pc.t.<span style="color: #d75fd7; font-weight: bold;">cancelRequest</span>(rc.req, rc.req.<span style="color: #d75fd7; font-weight: bold;">Context</span>().<span style="color: #d75fd7; font-weight: bold;">Err</span>())
        <span style="color: #268bd2; font-weight: bold;">case</span> &lt;-pc.closech:
            alive = <span style="color: #d75fd7;">false</span>
        }
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">...</span>
    }
}
</pre>
</div>

<p>
其中第一个 body 被读取完或关闭这个 case:<br>
</p>

<pre class="example" id="org669f426">
alive = alive &amp;&amp;
    bodyEOF &amp;&amp;
    !pc.sawEOF &amp;&amp;
    pc.wroteRequest() &amp;&amp;
    tryPutIdleConn(trace)
</pre>

<p>
bodyEOF 来源于到一个通道 waitForBodyRead，这个字段的 true 和 false 直接决定了 alive 变量的值（alive = true 那读 goroutine 继续活着，循环，否则退出 goroutine）。<br>
</p>

<p>
<b>那么这个通道的值是从哪里过来的呢？</b><br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">go/1.12.7/libexec/src/net/http/transport.go: 1758</span>
<span style="color: #8787d7;">body</span> := &amp;<span style="color: #df005f; font-weight: bold;">bodyEOFSignal</span>{
    <span style="color: #d75fd7;">body</span>: resp.Body,
    <span style="color: #d75fd7;">earlyCloseFn</span>: <span style="color: #268bd2; font-weight: bold;">func</span>() <span style="color: #df005f; font-weight: bold;">error</span> {
        waitForBodyRead &lt;- <span style="color: #d75fd7;">false</span>
        &lt;-eofc <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">will be closed by deferred call at the end of the function</span>
        <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">nil</span>

    },
    <span style="color: #d75fd7;">fn</span>: <span style="color: #268bd2; font-weight: bold;">func</span>(<span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>) <span style="color: #df005f; font-weight: bold;">error</span> {
        <span style="color: #8787d7;">isEOF</span> := err == io.EOF
        waitForBodyRead &lt;- isEOF
        <span style="color: #268bd2; font-weight: bold;">if</span> isEOF {
            &lt;-eofc <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">see comment above eofc declaration</span>
        } <span style="color: #268bd2; font-weight: bold;">else</span> <span style="color: #268bd2; font-weight: bold;">if</span> err != <span style="color: #d75fd7;">nil</span> {
            <span style="color: #268bd2; font-weight: bold;">if</span> <span style="color: #8787d7;">cerr</span> := pc.<span style="color: #d75fd7; font-weight: bold;">canceled</span>(); cerr != <span style="color: #d75fd7;">nil</span> {
                <span style="color: #268bd2; font-weight: bold;">return</span> cerr
            }
        }
        <span style="color: #268bd2; font-weight: bold;">return</span> err
    },
}
</pre>
</div>

<ul class="org-ul">
<li>如果执行 earlyCloseFn ，waitForBodyRead 通道输入的是 false，alive 也会是 false，那 readLoop() 这个 goroutine 就会退出。<br></li>
<li>如果执行 fn ，其中包括正常情况下 body 读完数据抛出 io.EOF 时的 case，waitForBodyRead 通道输入的是 true，那 alive 会是 true，那么 readLoop() 这个 goroutine 就不会退出，同时还顺便执行了 tryPutIdleConn(trace) 。<br></li>
</ul>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">tryPutIdleConn adds pconn to the list of idle persistent connections awaiting</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">a new request.</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">If pconn is no longer needed or not in a good state, tryPutIdleConn returns</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">an error explaining why it wasn't registered.</span>
<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">tryPutIdleConn does not close pconn. Use putOrCloseIdleConn instead for that.</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">t</span> *<span style="color: #df005f; font-weight: bold;">Transport</span>) <span style="color: #d75fd7; font-weight: bold;">tryPutIdleConn</span>(<span style="color: #8787d7;">pconn</span> *<span style="color: #df005f; font-weight: bold;">persistConn</span>) <span style="color: #df005f; font-weight: bold;">error</span>
</pre>
</div>

<ul class="org-ul">
<li>tryPutIdleConn 将 pconn 添加到等待新请求的空闲持久连接列表中，也就是之前说的连接会复用。<br></li>
</ul>

<p>
那么问题又来了，什么时候会执行这个 <code>fn</code> 和 <code>earlyCloseFn</code> 呢？<br>
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">es</span> *<span style="color: #df005f; font-weight: bold;">bodyEOFSignal</span>) <span style="color: #d75fd7; font-weight: bold;">Close</span>() <span style="color: #df005f; font-weight: bold;">error</span> {
    es.mu.<span style="color: #d75fd7; font-weight: bold;">Lock</span>()
    <span style="color: #268bd2; font-weight: bold;">defer</span> es.mu.<span style="color: #d75fd7; font-weight: bold;">Unlock</span>()
    <span style="color: #268bd2; font-weight: bold;">if</span> es.closed {
        <span style="color: #268bd2; font-weight: bold;">return</span> <span style="color: #d75fd7;">nil</span>
    }
    es.closed = <span style="color: #d75fd7;">true</span>
    <span style="color: #268bd2; font-weight: bold;">if</span> es.earlyCloseFn != <span style="color: #d75fd7;">nil</span> &amp;&amp; es.rerr != io.EOF {
        <span style="color: #268bd2; font-weight: bold;">return</span> es.<span style="color: #d75fd7; font-weight: bold;">earlyCloseFn</span>() <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#20851;&#38381;&#26102;&#25191;&#34892; earlyCloseFn</span>
    }
    <span style="color: #8787d7;">err</span> := es.body.<span style="color: #d75fd7; font-weight: bold;">Close</span>()
    <span style="color: #268bd2; font-weight: bold;">return</span> es.<span style="color: #d75fd7; font-weight: bold;">condfn</span>(err)
}
</pre>
</div>

<ul class="org-ul">
<li>上面这个其实就是我们比较收悉的 resp.Body.Close() ,在里面会执行 earlyCloseFn，也就是此时 readLoop() 里的 waitForBodyRead 通道输入的是 false，alive 也会是 false，那 readLoop() 这个 goroutine 就会退出，goroutine 不会泄露。<br></li>
</ul>

<div class="org-src-container">
<pre class="src src-go">b, err = ioutil.<span style="color: #d75fd7; font-weight: bold;">ReadAll</span>(resp.Body)
--<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">ReadAll</span>(<span style="color: #8787d7;">r</span> <span style="color: #df005f; font-weight: bold;">io.Reader</span>) 
----<span style="color: #268bd2; font-weight: bold;">func</span> <span style="color: #d75fd7; font-weight: bold;">readAll</span>(<span style="color: #8787d7;">r</span> <span style="color: #df005f; font-weight: bold;">io.Reader</span>, <span style="color: #8787d7;">capacity</span> <span style="color: #df005f; font-weight: bold;">int64</span>) 
------<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">Buffer</span>) <span style="color: #d75fd7; font-weight: bold;">ReadFrom</span>(<span style="color: #8787d7;">r</span> <span style="color: #df005f; font-weight: bold;">io.Reader</span>)


<span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">go/1.12.7/libexec/src/bytes/buffer.go:207</span>
<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">b</span> *<span style="color: #df005f; font-weight: bold;">Buffer</span>) <span style="color: #d75fd7; font-weight: bold;">ReadFrom</span>(<span style="color: #8787d7;">r</span> <span style="color: #df005f; font-weight: bold;">io.Reader</span>) (<span style="color: #8787d7;">n</span> <span style="color: #df005f; font-weight: bold;">int64</span>, <span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>) {
    <span style="color: #268bd2; font-weight: bold;">for</span> {
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">...</span>
        <span style="color: #8787d7;">m</span>, <span style="color: #8787d7;">e</span> := r.<span style="color: #d75fd7; font-weight: bold;">Read</span>(b.buf[i:<span style="color: #268bd2;">cap</span>(b.buf)])  <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#30475;&#36825;&#37324;&#65292;&#26159;body&#22312;&#25191;&#34892;read&#26041;&#27861;</span>
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">...</span>
    }
}
</pre>
</div>

<ul class="org-ul">
<li>这个 <code>read</code> ，其实就是 <code>bodyEOFSignal</code> 里的<br></li>
</ul>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">es</span> *<span style="color: #df005f; font-weight: bold;">bodyEOFSignal</span>) <span style="color: #d75fd7; font-weight: bold;">Read</span>(<span style="color: #8787d7;">p</span> []<span style="color: #df005f; font-weight: bold;">byte</span>) (<span style="color: #8787d7;">n</span> <span style="color: #df005f; font-weight: bold;">int</span>, <span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>) {
    <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">...</span>
    n, err = es.body.<span style="color: #d75fd7; font-weight: bold;">Read</span>(p)
    <span style="color: #268bd2; font-weight: bold;">if</span> err != <span style="color: #d75fd7;">nil</span> {
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">... </span>
        <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36825;&#37324;&#20250;&#26377;&#19968;&#20010;io.EOF&#30340;&#25253;&#38169;&#65292;&#24847;&#24605;&#26159;&#35835;&#23436;&#20102;</span>
        err = es.<span style="color: #d75fd7; font-weight: bold;">condfn</span>(err)
    }
    <span style="color: #268bd2; font-weight: bold;">return</span>
}

<span style="color: #268bd2; font-weight: bold;">func</span> (<span style="color: #8787d7;">es</span> *<span style="color: #df005f; font-weight: bold;">bodyEOFSignal</span>) <span style="color: #d75fd7; font-weight: bold;">condfn</span>(<span style="color: #8787d7;">err</span> <span style="color: #df005f; font-weight: bold;">error</span>) <span style="color: #df005f; font-weight: bold;">error</span> {
    <span style="color: #268bd2; font-weight: bold;">if</span> es.fn == <span style="color: #d75fd7;">nil</span> {
        <span style="color: #268bd2; font-weight: bold;">return</span> err
    }
    err = es.<span style="color: #d75fd7; font-weight: bold;">fn</span>(err)  <span style="color: #008787; background-color: #262626;">// </span><span style="color: #008787; background-color: #262626;">&#36825;&#20102;&#25191;&#34892;&#20102; fn</span>
    es.fn = <span style="color: #d75fd7;">nil</span>
    <span style="color: #268bd2; font-weight: bold;">return</span> err
}
</pre>
</div>

<ul class="org-ul">
<li>上面这个其实就是我们比较收悉的读取 body 里的内容。 ioutil.ReadAll() ，在读完 body 的内容时会执行 fn，也就是此时 readLoop() 里的 waitForBodyRead 通道输入的是 true，alive 也会是 true，那 readLoop() 这个 goroutine 就不会退出，goroutine 会泄露，然后执行 tryPutIdleConn(trace) 把连接放回池子里复用。<br></li>
</ul>

<p>
<b>总结：</b><br>
</p>

<ul class="org-ul">
<li>所以结论呼之欲出了，虽然执行了 6 次循环，而且每次都没有执行 Body.Close() ，就是因为执行了 ioutil.ReadAll() 把内容都读出来了，连接得以复用，因此只泄漏了一个读 goroutine 和一个写 goroutine，最后加上 main goroutine，所以答案就是 3 个 goroutine。<br></li>
<li>从另外一个角度说，正常情况下我们的代码都会执行 ioutil.ReadAll()，但如果此时忘了 resp.Body.Close()，确实会导致泄漏。但如果你调用的域名一直是同一个的话，那么只会泄漏一个 读 goroutine 和一个写 goroutine，这就是为什么代码明明不规范但却看不到明显内存泄漏的原因。<br></li>
<li>那么问题又来了，为什么上面要特意强调是同一个域名呢？改天，回头，以后有空再说吧。<br></li>
</ul>





<div class="reference">
	<ul style="list-style: none;">
		<li><a href="https://juejin.cn/post/6896993332019822605" target="_blank">http/net源码阅读，goroutine泄漏个数分析详</a></li>
	</ul>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-02-18 16:02 Fri</p>
<p class="author">Author: L.M.haoran</p>
<p class="date">Created: 2022-02-18 Fri 18:08</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
